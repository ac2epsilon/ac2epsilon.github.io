SCALA 3 Book
============

== Властивості Scala 3

Ім'я _Scala_ походить від _scalable_, маштабований, і виправдовуючи це ім'я, мова Scala використовується для підсилення завантажених веб сайтів та аналізу величезних обсягів даних. Цей розіділ знайомить вас з властивостями, що роблять Scala такою маштабованою мовою. Ці властивості поділені на три розділи:

* Високорівневі мовні властивості
* Низькорівневі мовні властивості
* Властивості екосистеми Scala

=== Високорівневі властивості

Дивлячись на Scala з уявного пташиного політу, ви можете зробити наступні зауваження щодо цієї мови:

* Це мова програмування високого рівня
* Вона має стислий та читаємий синтаксис
* Вона статично типізована (але відчувається як динамічно типізована)
* Вона має виразну систему типів
* Це функціо
нальна (FP) мова програмування
* Вона також є об'єктно орієнтовною (OOP) мовою програмування
* Вона підтримує поєднання FP та OOP
* Контекстуальні абстракції провадять ясний шлях для _виводу термів_
* Все виконується на JVM (або в браузері) 
* Забезпечена безшовна взаємодія з Java кодом
* Використовується для застосувань сервер-сайду (включаючи мікросервіси), застосувань біг-дейта, але також може застосовуватись в браузері через Scala.js.

Наступні розділи дають швидкий огляд ціх властивостей.

==== Мова високого рівня

Scala має бути визнана як мова високого рівня, щонайменьше через два аспекти. По перше, як Java та багато іншіх сучасних мов програмування, ви не маєте справу з низькорівневими концепціями, як вказівники та керування пам'яттю.

По друге, за допомогою лямбд та функцій вищого гатунку ви пишете ваш код на дуже високому рівні. Як здверджує прикизка функціональної мови, ви кажете _що_ ви бажаєте, а не _як_ цього досягти. Тобто ви не пишете імперативний код як наступний:
[source,scala]
----
def double(ints: List[Int]): List[Int] = {
  val buffer = new ListBuffer[Int]()
  for (i <- ints) {
      buffer += i * 2
  }
  buffer.toList
}
val newNumbers = double(oldNumbers)
----
Цей код інструктує компілятор що робити, крок за кроком. Замість цього ми пишемо на вищому рівні, функціональний код, використовуючи функції вищого гатунку та лямбди, як нижче, для отримання того самого результату: 
[source,scala]
----
val newNumbers = oldNumbers.map(_ * 2)
----
Як ви можете бачити, цей код значно більш стислий, простіший для читання та простіший для підтримки.

==== Стислий синтаксис

Scala має стислий, читабельний синтаксис. Наприклад, змінні створюються стисло, та їх тип зрозумілий:
[source,scala]
----
val nums = List(1,2,3)
val p = Person("Martin", "Odersky")
----
Функції вищого гатунку та лямбди створені для стислого коду, що можливо прочитати: 
[source,scala]
----
nums.map(i => i * 2)   // довга форма
nums.map(_ * 2)        // коротка форма

nums.filter(i => i > 1)
nums.filter(_ > 1)
----
Трейти, класи та методи визначені в стислому і прозорому синтаксисі: 
[source,scala]
----
trait Animal:
  def speak(): Unit

trait HasTail:
  def wagTail(): Unit

class Dog extends Animal, HasTail:
  def speak() = println("Woof")
  def wagTail() = println("⎞⎜⎛  ⎞⎜⎛")
----
Досліди показали, що час, який розробник витрачає на _читання_ коду до _написання_ коду складає щонайменьше 1/10, так що написання стислого та читабельного коду так важливе.

==== Відчуття динамічності

Scala є статично типізованою мовою, але завдячуючи її можливостям по виведенню типів, вона відчувається як динамічна. Всі ці вирази виглядають як динамічно-типізована мова, як Python або Ruby, але все це Scala: 
[source,scala]
----
val s = "Hello"
val p = Person("Al", "Pacino")
val sum = ints.reduceLeft(_ + _)
val y = for i <- nums yield i * 2
val z = nums.filter(_ > 100)
            .filter(_ < 10_000)
            .map(_ * 2)
----
Як стверджує Heather Miller, Scala визначено сильно, статично типізована мова, та ви можете отримати всі переваги статичних типів: 

* Коректність: ви відловлюєте більшість помилок під час компіляції
* Чудова підтримка IDE: 
** Надійне завершення коду
** Відловлення помилок під час компіляції означає перехоплення помилок по мірі набору
** Простий та надійний рефакторинг
* Ви можете впевнено рефакторити свій код
* Декларації типів методів  кажуть читачеві, що робить метод, та служить в якості документації
* Маштабованість та підтримуваність: типи допомагають переконатись в коректності між довільно великими застосуваннями та командами розробників
* Сильна типізація, в комбінації з чудовим виведенням, дозволяє механізми, як контекстуальна абстракція, що дозволяє вам уникати шаблонного коду. Часто цей шаблонний код може бути виведений компілятором, базуючись на визначенні типів та певному контексті.

==== Виразна система типів

Система типів Scala примушуе, під час компіляції, щоб абстракції використовувались в безпечний та узгоджений спосіб. Зокрема, система типів підтримує: 

* Виведені типи
* Дженерік класи
* Анотації варіантності
* Верхні і нижні межі типів
* Поліморфні методи
* Типи перетину
* Юніон типи
* Типові лямбди
* Примірники `given` та `using` класи
* Методи розширення
* Класи типів
* Мультиверсальне порівняння
* Прозорі псевдоніми типів
* Відкриті класи
* Класи порівнянь
* Типи залежної функції
* Типи поліморфної функції
* Межі контексту
* Функції контексту
* Внутрішні класи та абстрактні члени класів як члени об'єктів

В комбінації ці властивості провадять потужний базис для безпечного використання абстракцій програмування, та для типо-безпечного розширення програм.

==== Функціональна мова програмування

Scala є функціональною мовою програмування. Це означає: 

* Функції є значеннями, і можуть передаватись як будь-які значення
* Пряма підтримка функцій вищого гатунку
* Вбудовані лямбда
* Все в Scala э виразом, що повертає значення
* Синтаксично просте використання незмінних змінних, і їх використання заохочується
* Наявне різноманіття класів для незмінних колекцій в стандартній бібліотеці
* Ці класи колекцій ідуть з десятками функціональних методів: вони не змінюють колекцію, та замість цього повертають оновлену копію даних

==== Об'єктно-орієнтовна мова

Scala є об'єктно-орієнтовною мовою програмування (OOP). Кожне значення є примірником класу і кожний "оператор" є методом.

В Scala всі типи походять від кореневого класу `Any`, чиї безпосередні діти є `AnyVal` (_типи-значення_, такі як `Int` або `Boolean`), та `AnyRef` (_типи-посилання_, як в Java). Це означає, що різниця між примітивними типами, та боксованими типами (як `int` vs `Integer`), відсутня в Scala. Боксування та розбоксування повністю прозорі для користувача.

==== Підтримка змішування FP/OOP

Основою Scala є змішування функціонального програмування та об'єктно-орієнтовного програмування в прописній істині:

* Функції для логіки
* Об'єкти для модульності

Як стверджував Martin Odersky, "Scala була розроблена, щоб показати, що злиття функціонального та об'єктно-орієнтовного програмування є можливим та практичним".

==== Вивід термів, зроблене зрозумілішим

Слідуючи за Haskell, Scala була другою за популярністю мовою, що мала деяку форму _імплісітів_. В Scala 3 ці концепції були повністю переосмислені, і реалізовані більш зрозуміло.

Головна ідея є _вивід термів_: маючи тип, компілятор синтезує "канонічний" терм, що має такий тип. В Scala контекстний параметр прямо веде до виведеного терму аргументу, що також може бути записаний явно. 

Випадки застосування цієї концепції включають реалізацію класів типу, встановлення контексту, ін'єкція залежностей, вираження спроможностей, обчислення нових типів, та налагодження відносин між ними.

Scala 3 робить цей процесс більш прозорим, ніж будь-коли до цього. Читайте про контекстуальні абстракції в референсній документації.

==== Клієнт та сервер

Scala код виконується на Java Virtual Machine (JVM), так що ви отримуєте всі її переваги: 

* Безпеку
* Продуктивність
* Керування пам'ятю
* Портабельність та незалежність від платформи
* Здатність використовувати богатства існуючих бібліотек Java та JVM

На додаток до виконання на JVM, Scala також робить в браузері, за допомогою Scala.js (та бібліотек з відкритим кодом для інтеграції з популярними бібліотеками JavaScript), та нативними виконавчими файлами, що можуть бути побудовані з допомогою Scala Native та GraalVM.

==== Безшовна інтеграція з Java

Ви можете використовувати класи та бібліотеки Java в ваших Scala застосуваннях, та ви можете використовувати код Scala в ваших Java застосуваннях. Що до другого твердження, великі бібліотеки, як Akka та Play Framework, написані на Scala, та можуть бути використані в Java застосуваннях.

Відносно першого твердження, Java класи та бібліотеки використовуються в застосуваннях Scala кожний день. Наприклад, в Scala ви можете читати файли за допомогою Java `BufferedReader` та `FileReader`: 
[source,scala]
----
import java.io.*
val br = BufferedReader(FileReader(filename))
// читати файл через `br` ...
----
Використання Java коду в Scala є загалом безшовним.

Java колекції також можуть бути використані в Scala, та якщо ви бажаєте використати багаті класи колекцій Scala з ними, ви можете конвертувати їх в парі рядків кода: 
[source,scala]
----
import scala.jdk.CollectionConverters.*
val scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq
----

==== Багатство бібліотек

Як ви побачите в третій частині цієї сторінки, Scala бібліотеки та фреймворки, як ці, були написані, щоб підсилити завантажені веб сайти, і робити з велетенськими базами даних: 

1. Play Framework - це легковажна, безстанова, дружня до розробника, дружня до веб архітектура для створення високо-маштабованих застосувань
2. Lagom - фреймворк мікросервісів, що допомагає роз'єднати ваш застарілий моноліт, та побудувати, протестувати, та розгорнути цілі системи реактивних мікросервісів
3. Apache Spark - уніфікований аналітичний рушій для обробки великих обсягів даних, з вбудованими модулями для стримінгу, SQL, машинним навчанням та обробкою графів

Список Awesome Scala показує десятки додаткових інструментів з відкритим кодом, що створені розробниками для побудови Scala застосувань.

На додаток до серверного програмування, Scala.js є сильно-типізованою заміною для написання JavaScript, з бібліотеками з відкритим кодом третіх сторін, що включають інструменти для інтергації з бібліотекою Facebook React, jQuery, тощо. 

=== Низькорівневі властивості мови

В той час, коли попередній розділ розповідав про високо-рівневі можливості Scala, цікаво зауважити, що на вищому рівні ви можете зробити ті самі зауваження щодо обох, Scala 2 та Scala 3. Десятиріччя тому Scala розпочинала з міцного фундаменту бажаних властивостей, і, як ви побачите в цьому розділі, ці переваги були покращені в Scala 3.

На "рівні моря" з погляду на деталі - тобто, на можливості мови, які програмісти використовують щодня - Scala 3 має значні переваги над Scala 3: 

* Здатність створювати алгебраїчні типи даних (ADT) більш стисло, за допомогою енумерацій
* Навіть ще більш стислий та читабельний синтаксис: 
** "Тихий" синтаксис керівних структур, що простіше читається
** Опціональні дужки
*** Менше символів в коді створює меньше візуального галасу, що легше читається
** Ключове слово `new` загалом більше не потрібне при створенні примірників класів
** Формальності об'єкта-пакунка були відкинуті на користь простіших визначень "вищого рівня"
* Зрозуміліша граматика
** Декілька різних використань ключового слова `implicit` були видалені; ці використання замінені на більш очевидні ключові слова, як `given`, `using`, `extension`, фокусуючись на призначенні замість механізмів (дивіться розділ Given)
** Методи розширення замінюють імплісіт-класи з яснішим та простішим механізмом
** Додавання модифікатора `open` до класів робить явними наміри розробника зробити клас відкритим для модифікацій, таким чином обмежуючи ad-hoc розширення кодової бази
** Мультиверсальна еквівалентність відкидає безглуздзі порівняння за допомогою `==` та `!=` (тобто, порівняння `Person` та `Planet`)
** Макроси реалізовані значно простіше
** Юніони та перетини пропонують гнучкий шлях моделювання типів
** Параметри трейтів замінюють та спрощують ранні ініціалізатори
** Прозорі псевдоніми типів замінюють більшість використань класів-значень, при цьому гарантуючи відсутність боксування
** Твердження експорту провадять простий та узагальнений спосіб вираження агрегації, що може замінити попередній паттерн фасаду наслідування об'єктів пакунку від класів
** Процедурний синтаксис був відкинутий, та синтаксис `varargs` був змінений, обоє щоб зробити мову більш узгодженою
** Анотація `@infix` робить очевидним, як ви бажаєте застосувати метод
** Анотація методу `@targetName` визначає альтернативне ім'я для методу, покращуючи взаємодію з Java, та провадячи псевдоніми для символічних операторів

Демонстрація всіх цих можливостей прямо тут заняла б багато місця, але слідуючи за посиланнями ви можете побачити можливості в дії. Всі ці можливості обговорюються на сторінках _Нове, змінене та відкинуте_ в оглядовій документації.

=== Екосистема Scala

Scala має вируючу екосистему, з бібліотеками та фреймворками для кожної потреби. Список _Awesome Scala_ провадить перелік сотен доступних розробникам проектів з відкритим кодом, та Scaladex провадить пошук Scala бібліотек. Деякі з самих помітних перелічені нижче. 

==== Веб розробка

* _Play Framework_ слідує за моделлю Ruby on Rails, щоб стати легковажною, безстановою, розробник-дружньою, веб-дружньою архітектурою для високо маштабованих застосувань
* _Scalatra_ є маленьким, високопродуктивним, асинхронним веб фреймворком, натхненим Sinatra
* _Finatra_ є Scala сервісами, побудованими на TwitterServer та Finagle
* _Scala.js_ - це сильно типізована заміна для JavaScript, що провадить безпечніший шлях для побудови надійнішого фронт-енду веб застосувань
* _ScalaJs-React_ підіймає бібліотеку Facebook React до Scala.js, та намагається зробити її настільки безпечною та Scala-дружньою, як це можливо
* _Lagom_ - фреймворк мікросервісів, що допомагає декомпозиції існуючих монолітів, та побудові, тестуванню, та розгортанню цілих систем реактивних мікросервісів

==== HTTP(S) бібліотеки

* akka-http
* Finch
* Http4s
* Sttp

==== JSON бібліотеки

* Argonaut
* Circe
* Json4s
* Play-JSON
* ScalaPB (серіалізіція)

==== Наукові обчислення та обробка даних

* Algebird
* Spire
* Squants

==== Big data

* Apache Spark
* Apache Flink

==== AI, машинне навчання

* BigDL (Distributed Deep Learning Framework) для Apache Spark
* TensorFlow Scala

==== Функціональне (та реактивне) програмування 

* Cats
* Zio
* fs2
* monix

==== Інструменти побудови 

* sbt
* Gradle
* Mill

=== Підсумок

Як показує ця сторінка, Scala має багато неймовірних властивостей мови на вищому рівні, на рівні щоденного програмування, та через екосистему розробників.

== Чому Scala 3?

Існує багато переваг використання Scala, зокрема Scala 3. Важко перелічити всі переваги Scala, але топ-10 може виглядати так: 

1. Scala обіймає злиття функціонального програмування (FP), та об'єктно-орієнтовного програмування (OOP)
2. Scala статично типізована, але часто відчувається як динамічно типізована мова
3. Синтаксис Scala стислий, але все ще зрозумілий; на нього часто посилаються як на _виразний_.
4. _Імплісіти_ в Scala 2 були визначальною можливыстю, і вони були покращені та спрощені в Scala 3
5. Scala безшовно інтегрується з Java, так що ви можете створювати змішані проекти на Scala та Java, та код Scala може легко використовувати тисячі існуючих Java бібліотек
6. Scala може використовуватись на сервері, але також в браузері, за допомогою Scala.js
7. Стандартна бібліотека Scala має десятки пре-побудованих, функціональних методів, щоб зберігти ваш час, та значно зменшити потребу писати власні `for` цикли та алгоритми
8. "Кращі практики" вбудовані в Scala, що надає перевагу незмінності, анонімних функцій, функцій вищого гатунку, порівняння шаблонів, класів, що не розширюються по замовчанню, та інше
9. Екосистема Scala пропонує найбільш сучасні FP бібліоеки в світі
10. Сильна система типів

=== 1) Злиття FP/OOP

Більше ніж будь-яка інша мова, Scala підтримує злиття парадігм FP та OOP. Як стверджував Мартін Одерскі, основа Scala в злитті функціонального та об'єктно-орієнтовного програмування в типовому оточенні: 

* Функції для логіки
* Об'єкти для модульності

Можливо, один з кращих прикладів модульності є класи в стандартній бібліотеці. Наприклад, `List` визначений як клас - технічно це абстрактний клас - і новий примірник створюється так: 
[source,scala]
----
val x = List(1, 2, 3)
----
Однак, для програміста виглядає так, що простий `List` насправді побудований як комбінація декількох спеціалізованих типів, включаючи трейти з назвами `Iterable`, `Seq` та `LinearSeq`. Ці типи подібним чином скомпоновані з інших, меньших, модульних одиниць коду.

На додаток до побудови типів як `List` з послідовності модульних трейтів, `List` API також складається з десятків інших методів, багато з яких є функціями вищого гатунку: 
[source,scala]
----
val xs = List(1, 2, 3, 4, 5)

xs.map(_ + 1)         // List(2, 3, 4, 5, 6)
xs.filter(_ < 3)      // List(1, 2)
xs.find(_ > 3)        // Some(4)
xs.takeWhile(_ < 3)   // List(1, 2)
----
В ціх прикладах значення в списку не може бути модифіковане, клас `List` є незмінним. Так що ці методи повертають нові значення, як показано в коментарях.

=== 2) Динамічне відчуття

_Вивід типів_ Scala часто робить відчуття мови динамічно типізованим, навіть хоча вона статично типізована. Це так для декларацій змінних: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3,4,5)
val stuff = ("fish", 42, 1_234.5)
----
Це також вірно, коли анонімна функція передається до функції вищого гатунку: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
list.filter(_ < 4)
    .map(_ * 2)
----
та при визначенні методів: 
[source,scala]
----
def add(a: Int, b: Int) = a + b
----
Це все ще більше вірно в Scala 3, як при використанні юніон типів: 
[source,scala]
----
// параметр юніон типу
def help(id: Username | Password) =
  val user = id match
    case Username(name) => lookupName(name)
    case Password(hash) => lookupPassword(hash)
  // тут код ...

// значення юніон типу
val b: Password | Username = if (true) name else password
----

=== 3) Стислий синтаксис

Scala - мова без церемоній, "стисла, але читабельна". Наприклад, декларація змінних стисла: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3)
----
Створення типів, як трейти, класи та енумерації, є стислим: 
[source,scala]
----
trait Tail:
  def wagTail(): Unit
  def stopTail(): Unit

enum Topping:
  case Cheese, Pepperoni, Sausage, Mushrooms, Onions

class Dog extends Animal, Tail, Legs, RubberyNose

case class Person(
  firstName: String,
  lastName: String,
  age: Int
)
----
Функції вищого гатунку також стислі: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
----

Всі ці вирази, і багато інших, є стислими, та при цьому все ще зрозумілі: ми називаємо це _виразність_.

=== 4) Імплісіти, спрощені

Імплісіти в Scala 2 були головною знаковою відмінністю дизайну. Вони репрезентували фундаментальний шлях абстрагуватись від контексту, з уніфікованою парадігмою, що служить багатому різноманіттю випадків. Серед них: 

* Реалізація класів типу
* Встановлення контексту
* Ін'єкція залежностей
* Вираз можливостей

З тих пір багато мов прийняли подібні концепції, всі з яких є варіантами головної ідеї _виводу термів_: маючи тип, компілятор синтезує "канонічний" терм, що має цей тип.

Хоча імплісіти були визначальною властивістю в Scala 2, їх дизайн був суттєво покращений в Scala 3: 

* Існує єдиний спосіб визначити `given` значення
* Існує єдиний спосіб ввести імплісіт параметри та аргументи
* Існує окремий шлях імпортувати `given`, що не дозволяє їм загубитись в морі звичайних імпортів
* Існує єдиний спосіб визначити імплісіт конверсію, яка зрозуміло помічена як така, і не потребує спеціального синтаксису

Переваги таких змін наступні: 

* Новий дизайн уникає взаємодії можливостей, та робить мову більш узгодженою
* Це робить імплісіти простішими для вивчання, та складнішими для невірного використання
* Це гарно підвищує прозорість 95% Scala програм, що використовують імплісіти
* Існує потенціал робити вивід термів в принциповий спосіб, що також доступний та дружній

Ці властивості детально описані в інших розділах. Дивіться вступ до Контекстуальної абстракції, та розділ про `given` та `using`.

=== 5) Безшовна Java інтеграція

Інтеграція Scala/Java є безшовною в багатьох сенсах. Наприклад: 

* Ви можете використовувати всі тисячі Java бібліотек в ваших Scala проектах
* Scala `String` в основі є Java `String`, з додатковими можливостями
* Scala безшовно використовує класи дати та часу в пакунку _java.time_.

Ви також можете використовувати Java колекції в Scala, і, щоб надати їм більше функціональності, Scala включає методи, так що ви можете трансформувати їх в Scala колекції.

Хоча майже кожна взаємодія є безшовною, глава _Взаємодія з Java_ демонструє, як використовувати деякі можливості разом, включаючи використання: 

* Java колекції в Scala
* Java `Optional` в Scala
* Java інтерфейси в Scala
* Scala колекції в Java
* Scala `Option` в Java
* Scala трейти в Java
* Scala методи, що закидають виключення, в Java
* Scala `varargs` параметри в Java

Дивіться відповідну главу для додаткової інформації по цім темам.

=== 6) Клієнт і сервер

Scala може бути використана з боку сервера за допомогою несамовитих фреймворків та мікросервісів: 

* _Play Framework_ дозволяє вам будувати високо маштабовані серверні застосування та мікросервіси
* _Akka Actors_ дозволяють використовувати модель акторів, щоб значно спростити розподілені та конкурентні софтверні застосування

Scala також може бути використана в браузері завдяки проекту Scala.js, що є типо-безпечною заміною JavaScript. Екосистема Scala.js має десятки бібліотек, що дозволяють використовувати React, Angular, jQuery, та багато інших бібліотек JavaScript та Scala в браузері.

На додаток до ціх інструментів проект Scala Native "є оптимізуючим ahead-of-time компілятором і легковажним керованим рантаймом, розробленим спеціально для Scala". Він дозволяє будувати бінарні застосування за допомогою звичайного коду Scala, а також дозволяє використовувати низькорівневі примітиви.

=== 7) Методи стандартної бібліотеки

Тепер вам рідко потрібно власноруч писати цикли `for`, тому що десятки функціональних методів в стандартній бібліотеці Scala одночасно зберігає ваш час, та допомагає робити код більш узгодженим між різними застосуваннями.

Наступні приклади демонструють деякі з вбудованих методів колекцій, і є багато ще інших. Хоча всі вони використовують клас `List`, ті самі методи методи роблять з іншими класами колекцій, як `Seq`, `LazyList`, `Set`, `Map`, `Array`, `ArrayBuffer`.

Ось деяки приклади: 
[source,scala]
----
List.range(1, 3)                          // List(1, 2)
List.range(start = 1, end = 6, step = 2)  // List(1, 3, 5)
List.fill(3)("foo")                       // List(foo, foo, foo)
List.tabulate(3)(n => n * n)              // List(0, 1, 4)
List.tabulate(4)(n => n * n)              // List(0, 1, 4, 9)

val a = List(10, 20, 30, 40, 10)          // List(10, 20, 30, 40, 10)
a.distinct                                // List(10, 20, 30, 40)
a.drop(2)                                 // List(30, 40, 10)
a.dropRight(2)                            // List(10, 20, 30)
a.dropWhile(_ < 25)                       // List(30, 40, 10)
a.filter(_ < 25)                          // List(10, 20, 10)
a.filter(_ > 100)                         // List()
a.find(_ > 20)                            // Some(30)
a.head                                    // 10
a.headOption                              // Some(10)
a.init                                    // List(10, 20, 30, 40)
a.intersect(List(19,20,21))               // List(20)
a.last                                    // 10
a.lastOption                              // Some(10)
a.map(_ * 2)                              // List(20, 40, 60, 80, 20)
a.slice(2, 4)                             // List(30, 40)
a.tail                                    // List(20, 30, 40, 10)
a.take(3)                                 // List(10, 20, 30)
a.takeRight(2)                            // List(40, 10)
a.takeWhile(_ < 30)                       // List(10, 20)
a.filter(_ < 30).map(_ * 10)              // List(100, 200, 100)

val fruits = List("apple", "pear")
fruits.map(_.toUpperCase)                 // List(APPLE, PEAR)
fruits.flatMap(_.toUpperCase)             // List(A, P, P, L, E, P, E, A, R)

val nums = List(10, 5, 8, 1, 7)
nums.sorted                               // List(1, 5, 7, 8, 10)
nums.sortWith(_ < _)                      // List(1, 5, 7, 8, 10)
nums.sortWith(_ > _)                      // List(10, 8, 7, 5, 1)
----

=== 8) Вбудовані кращі практики

Ідіоми Scala заохочують кращі практики в декілька способів. Для незмінності вас заохочують створювати незмінні `val` декларації: 
[source,scala]
----
val a = 1   // незмінна змінна
----
Вас також заохочують використовувати класи незмінних колекцій, як `List` та `Map`: 
[source,scala]
----
val b = List(1,2,3)       // List незмінний
val c = Map(1 -> "one")   // Map незмінний
----
Кейс класи загалом призначені для використання в доменному моделюванні, і їх параметри незмінні: 
[source,scala]
----
case class Person(name: String)
val p = Person("Michael Scott")
p.name           // Michael Scott
p.name = "Joe"   // помилка компілятора (переприсвоєння val)
----
Як показано в попередньому розділі, класи колекцій Scala підтримують функції вищого гатунку, і ви можете передавати до них методи (не показані) та анонімні функції: 
[source,scala]
----
a.dropWhile(_ < 25)
a.filter(_ < 25)
a.takeWhile(_ < 30)
a.filter(_ < 30).map(_ * 10)
nums.sortWith(_ < _)
nums.sortWith(_ > _)
----
Вирази `match` дозволяють використовувати порівняння шаблонів, і вони насправді є виразами, що повертають значення: 
[source,scala]
----
val numAsString = i match
  case 1 | 3 | 5 | 7 | 9 => "odd"
  case 2 | 4 | 6 | 8 | 10 => "even"
  case _ => "too big"
----
Оскільки вони повертають значення, вони часто використовуються як тіло функції: 
[source,scala]
----
def isTruthy(a: Matchable) = a match
  case 0 | "" => false
  case _ => true
----

=== 9) Бібліотеки екосистеми

Бібліотеки Scala для функціонального програмування (FP), як Cats та Zio, знаходяться на передньому фланзі бібліотек FP спільноти. Всі ці штампи, як високо-продуктивний, безпека типів, конкурентний, асинхронний, ресурсо-безпечний, тестовний, функціональний, модуларний, бінарно-сумісний, ефективний, та більше, що можна сказати про ці бібліотеки.

Ви можете перегорнути сотні бібліотек, але, на щастя, всі вони перелічені в одному місці: для деталей дивіться _Awesome Scala_.

=== 10) Сильна система типів

Scala має сильну систему типів, і вона була навіть ще більше покращена в Scala 3. Цілі Scala 3 були визначені на ранній стадії, і ті, що мають відношення до системи типів, включають: 

* Спрощення
* Уникнення неузгодженостей
* Безпека
* Ергономіка
* Продуктивність

_Спрощення_ досягається через десятки змінених та відкинутих можливостей. Наприклад, зміна від перевантаженого ключового слова `implicit` в Scala 2, до термів `given` та `using` в Scala 3, що робить мову більш зрозумілою, особливо для розробників-початківців.

_Уникнення неузгодженостей_ пов'язане з десятками відкинутих можливостей, змінених можливостей та доданих можливостей в Scala 3. Деякі з найбільш важливих можливостей в цій категорії: 

* Перетини типів
* Юніон типи
* Типи імплісіт функції
* Типи залежної функції
* Параметри трейтів
* Дженерік тапли

_Безпека_ пов'язана з новими та зміненими властивостями:  

* Мультіверсальна еквівалентність
* Обмеження імплісіт конверсій
* null-безпечність
* Безпечна ініціалізація

Гарні приклади _ергономіки_ є енумерації та методи розширення, що були додані в Scala 3 в дуже зрозумілий спосіб: 
[source,scala]
----
// енумерація
enum Color:
  case Red, Green, Blue

// методи розширення
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius
----
_Продуктивність_ відноситься до декількох речей. Одна з них є прозорі типи. В Scala 2 було декілька спроб вирішити питання дотримання практики Domain-driven design (DDD) надавати значенням більш осмислені типи. Ці спроби включають: 

* Псевдоніми типів
* Класи-значення
* Кейс класи

Нажаль, всі з ціх підходів мають свої вади, як описано в `Opaque Types SIP`. Навпаки, ціллю прозорих типів є, як описано в цьому SIP, щоб "операції на ціх типах-огортках не створювали додаткового навантаження під час виконання, при цьому провадячи безпеку типів рід час компіляції".

Більше щодо деталей системи типів дивіться відповідні посилання.

=== Інші значні властивості

Scala має багато гарних властивостей, та вибір Топ-10 може бути суб'єктиним. Декілька досліджень показали, що різні групи розробників люблять різні властивості. Маємо надію, що ви знайдете інші потужні можливості Scala по мірі використання мови.

== Смак Scala

Ця глава провадить карколомний тур по основним можливостям мови програмування Scala 3. Після цього початкового туру залишок книги провадить більше деталей по цім можливостям, та нарешті Референсна документація надає _значно_ быльше деталей.

На протязі цієї книги ми рекомендуємо експериментувати з прикладами на _Scastie_, або _Scala REPL_, які ми скоро побачимо.

== Hello, Wold!

Приклад "Hello, World!" на Scala 3 виглядає таким чином. Спочатку покладіть наступний код в файл _Hello.scala_: 
[source,scala]
----
 @main def hello = println("Hello, world!")
----
В цьому коді `hello` є метод. Він визначається за допомогою `def`, і задекларований як `main` за допомогою анотації `@main`. Він друкує _"Hello, world!"_ в стандартний вивід (STDOUT), використовуючи метод `println`.

Далі скомпілюйте код в `scalac`: 
[source,bash]
----
$ scalac Hello.scala
----
  Прим.перекл. Станом на 01 січня 2022 року компілятор та ланчер Scala 3 мали назву `scala3-compiler` та `scala3`, відповідно. Майте це на увазі, Scala 2 видасть помилку вже на першій декларації `@main`.

Якщо ви прийшли в Scala з Java, `scalac` такий саме, як `javac`, так що ця команда створить декілька файлів: 
[source,bash]
----
$ ls -1
Hello$package$.class
Hello$package.class
Hello$package.tasty
Hello.scala
hello.class
hello.tasty
----
Як і в Java, файли `.class` є файлами байткоду, і вони готові для виконання в JVM. 

Тепер ви можете виконати метод `hello` в команді ланчера `scala`: 
[source,bash]
----
$ scala hello
Hello, world!
----
Вважаючи, що все робить, прийміть поздоровлення. Ви тільки що скомпілювали та виконали ваше перше застосування на Scala.
  
  Більше інформації щодо _sbt_ та інших інструментів, що спрощують розробку на Scala, можна знайти в главі _Інструменти Scala_.

== REPL

Scala REPL (“Read-Evaluate-Print-Loop”) є інтерпретатором командного рядка, який ви використовуєте для перевірки вашого Scala коду. Ви запускаєте вашу REPL сессію, виконуючи команду `scala` в командному рядку операційної системи. Ви маєте побачити запрошення. подібне до наступного: 
[source,bash]
----
$ scala
Welcome to Scala 3.0.0 (OpenJDK 64-Bit Server VM, Java 11.0.9).
Type in expressions for evaluation.
Or try :help.

scala> _
----
REPL є інтерпретатором командного рядка, так що він очікує, доки ви введете будь-що. Тепер ви можете вводити вирази Scala, щоб побачити як вони роблять: 
[source,scala]
----
scala> 1 + 1
val res0: Int = 2

scala> 2 + 2
val res1: Int = 4
----
Як стверджує результат, якщо ви не присвоєте результат до змінної, REPL створить змінні з іменами `res1`, `res2`, тощо. Ви можете  використовувати ці имена в наступних виразах: 
[source,scala]
----
scala> val x = res0 * 10
val x: Int = 20
----
Зауважте, що REPL також відображужє результат обчислення ваших виразів.

Ви можете виконувати в REPL всі типи експериментів. Цей приклад показує, як створити та потім виконати метод `sum`: 
[source,scala]
----
scala> def sum(a: Int, b: Int): Int = a + b
def sum(a: Int, b: Int): Int

scala> sum(2, 2)
val res2: Int = 4
----
Якщо ви обираєте онлайн плейграунд, ви також можете використовувати http://scastie.scala-lang.org.

Якщо ви обираєте, замість підказки консолі, писати код в текстовому редакторі, ви можете використовувати _worksheet_.

== Змінні і типи даних

Цей розділ провадить погляд на змінні та типи даних Scala.

=== Два типи змінних

Коли ви створюєте нову змінну в Scala, ви декларуєте, чи буде змінна незмінною аба змінною: 

*Тип*  *Опис*
`val`   Створює _незмінну_ змінну, як `final` в Java. Ви завжди маєте створювати змінні за допомогою `val`, крім наявності причини створити змінну змінну.
`var`   створює _мінливу_ змінну, і має створюватись, тільки коли значення повинне змінюватись у часі.

Наступні приклади показують, як створювати змінні `val` та `var`: 
[source,scala]
----
// незмінна
val a = 0

// змінна
var b = 1
----
В застосуванні `val` не може бути переприсвоєна. Ви отримаєте помилку компілятора, якщо спробуєте зробити переприсвоєння: 
[source,scala]
----
val msg = "Hello, world"
msg = "Aloha"   // помилка; це не буде компілюватись
----
І навпаки, `var` мможе бути переприсвоєна: 
[source,scala]
----
var msg = "Hello, world"
msg = "Aloha"   // це скомпілюється, var може переприсвоюватись
----

=== Декларування типів змінних

Коли ви створюєте змінну, ви можете явно декларувати її тип, або дати компілятору вивести тип самостійно: 
[source,scala]
----
val x: Int = 1   // явний тип
val x = 1        // компілятор виводить тип неявно
----
Друга форма має назву _вивід типу_, і це чудовий спосіб підтримувати код стислим. Компілятор Scala загалом може вивести тип даних, як можна бачити з результатів роботи прикладів в REPL: 
[source,scala]
----
scala> val x = 1
val x: Int = 1

scala> val s = "a string"
val s: String = a string

scala> val nums = List(1, 2, 3)
val nums: List[Int] = List(1, 2, 3)
----
Ви завжди можете явно декларувати тип змінної, якщо бажаєте, але в простих випадках в цьому немає потреби: 
[source,scala]
----
val x: Int = 1
val s: String = "a string"
val p: Person = Person("Richard")
----
Зауважте, що при такому підході код виглядає більш галасливим, ніж потрібно. 

=== Вбудовані типи даних

Scala іде зі стандартними числовими типами, як ви можете очікувать, і вони є повноцінні примірники класів. в Scala будь-що є об'єктом.

Ці приклади показують, як декларувати змінні числових типів: 
[source,scala]
----
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
----
Оскільки `Int` та `Double` є числовими типами по замовчанню, ви зазвичай створюєте їх без явного декларування типу даних: 
[source,scala]
----
val i = 123   //  Int
val j = 1.0   //  Double
----
Також в своєму коді ви можете додати символи `L`, `D`, `F` (та їх прописні еквіваленти) до чисел, щоб вказати що це значення `Long`, `Double` або `Float`: 
[source,scala]
----
val x = 1_000L   // val x: Long = 1000
val y = 2.2D     // val y: Double = 2.2
val z = 3.3F     // val z: Float = 3.3
----
Якщо нам треба дійсно великі числа, використовуйте типи `BigInt` та `BigDecimal`: 
[source,scala]
----
var a = BigInt(1_234_567_890_987_654_321L)
var b = BigDecimal(123_456.789)
----
В той час, як `Double` та `Float` округлюють десяткові числа,`BigDecimal` використовують точну арифметику.

Scala також має типи даних `String` та `Char`: 
[source,scala]
----
val name = "Bill"   // String
val c = 'a'         // Char
----

==== Рядки

Рядки Scala подібні до рядків Java, але мають дві додаткові функції: 

* Вони підтримують інтерполяцію рядків
* Легко створювати багаторядкові рядки

===== Інтерполяція рядків

Інтерполяція рядків провадить дуже наочний шлях для використання змінних в рядках. Наприклад, візьмемо наступні три рядка: 
[source,scala]
----
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
----
Ви можете скомпонувати ці змінні в один рядок таким чином: 
[source,scala]
----
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"
----
Просто поставьте перед рядком літеру `s`, та покладіть символ `$` перед ім'ям іменами ваших змінних всередині рядка.

Щоб вбудувати в рядок довільний вираз, заточіть його в фігурні дужки: 
[source,scala]
----
println(s"2 + 2 = ${2 + 2}")   // друкує "2 + 2 = 4"

val x = -1
println(s"x.abs = ${x.abs}")   // друкує "x.abs = 1"
----
Літера `s` перед рядком є лише одним можливим інтерполятором. Якщо замість `s` ви поставите `f`, ви отримаєте `printf`-подібний синтаксис в рядку. Більше того, інтерполятор є лише спеціальним методом, і ви можете визначати власні. Наприклад, деякі бібліотеки баз даних визначають дуже потужний інтерполятор `sql`.

===== Багаторядкові рядки

Багаторядкові рядки створюються оточенням рядка в потрійні подвійні лапки: 
[source,scala]
----
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
----
  Додактові деталі щодо інтерполяції рядків та багаторядкові рядки дивіться главу _Перший погляд на типи_.

=== Керівні структури

Scala має керівні структури, які ви можете знайти в інших мовах, але також має потужні вирази `for` та `match`: 

* `if/else`
* `for` цикли та вирази
* `match` вирази 
* `while` цикли
* `try/catch`

Ці структури продемонстровані в наступних прикладах.

==== if/else

В Scala керівіна структура `if/else` виглядає подібно до інших мов: 
[source,scala]
----
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
----
Зауважте, що це насправді _вираз - не твердження_. Це означає, що це повертає значення, так що ви можете присвоїти його змінній: 
[source,scala]
----
val x = if a < b then a else b
----
Як ви побачите в цій книжці, в Scala _всі_ контрольні структури можуть використовуватись як вирази.

  Вираз повертає результат, тоді як твердження - ні. Твердження типово використовуються для своїх побічних ефектів, таких, як використання `println` для друку на консолі.

==== for цикли  та вирази

Ключове слово `for` використовується для створення `for` циклу. Приклад показує, як надрукувати всі елементи в `List`: 
[source,scala]
----
val ints = List(1, 2, 3, 4, 5)

for i <- ints do println(i)
----
Код `i <- ints` відомий як _генератор_, а код після `do` складає _тіло_ циклу.

Старий синтаксис для цієї структури виглядав так: 
[source,scala]
----
for (i <- ints) println(i)
----

==== Охоронці

Ви можете також використовувати один або більше `if` в своєму циклі `for`. Це відоме як _охоронці_. Приклад друкує всі числа в `ints`, що більше ніж 2: 
[source,scala]
----
for
  i <- ints
  if i > 2
do
  println(i)
----
Ви можете використовувати декілька генераторів та охоронців. Цей цикл ітерує по числах від 1 до 3, і для кожного ітерує по символах від `a` до `c`. Однак ми також маємо два охоронці, так що друкується тільки рядок, коли `i` дорівнює 2, а `j` - символу `b`: 
[source,scala]
----
for
  i <- 1 to 3
  j <- 'a' to 'c'
  if i == 2
  if j == 'b'
do
  println(s"i = $i, j = $j")   // друкує: "i = 2, j = b"
----

==== for вирази

Ключове слово `for` має ще більші можливості: якщо ви, замість `do` використати `yeld`, ви створите _вираз_ `for`, що обчислює та видає результати.

Декілька прикладів демонструють це. Використовуючи той самий список `ints`, що і в попередньому прикладі, цей код генерує новий список, де кожне значення елементу в новому списку є подвоєне значення в оригінальному списку: 
[source,scala]
----
scala> val doubles = for i <- ints yield i * 2
val doubles: List[Int] = List(2, 4, 6, 8, 10)
----
Синтаксис керівних структур Scala гнучкий, і той самий вираз `for` може бути записаний різними шляхами, за вашим вподобанням: 
[source,scala]
----
val doubles = for i <- ints yield i * 2 // стиль, показаний вище
val doubles = for (i <- ints) yield i * 2
val doubles = for (i <- ints) yield (i * 2)
val doubles = for { i <- ints } yield (i * 2)
----
Наступний приклад показує, як капіталізувати кожний рядок зі списку: 
[source,scala]
----
val names = List("chris", "ed", "maurice")
val capNames = for name <- names yield name.capitalize
----
Нарешті, цей `for` вираз ітерує по списку рядків, та повертає довжину кожного рядка, але тільки якщо ця довжина більше чотирьох: 
[source,scala]
----
val fruits = List("apple", "banana", "lime", "orange")

val fruitLengths = for
  f <- fruits
  if f.length > 4
yield
  // тут може бути більше рядків
  f.length

// fruitLengths: List[Int] = List(5, 6, 6)
----
Цикли та вирази `for` розглядаються більш детально в розділі _Керівні структури_ та в референсній документації.

==== `match` вирази

Scala має вираз `match`, який в простіший формі використання подібний до Java `switch`: 
[source,scala]
----
val i = 1

// далі в коді ...
i match
  case 1 => println("one")
  case 2 => println("two")
  case _ => println("other")
----
Однак, насправді `match` є виразом, що означає, що він повертає результат на основі порівняння шаблонів, що може бути прикріплене до змінної: 
[source,scala]
----
val result = i match
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
----
`match` не обмежений робити з цілими значеннями, він може використовуватись з любими типами даних: 
[source,scala]
--------
val p = Person("Fred")

// далі в коді
p match
  case Person(name) if name == "Fred" =>
    println(s"$name says, Yubba dubba doo")

  case Person(name) if name == "Bam Bam" =>
    println(s"$name says, Bam bam!")

  case _ => println("Watch the Flintstones!")
--------
Фактично, вираз `match` може бути використаний для перевірки змінної по багатьом різним типам шаблонів. Приклад показує, (а) як використовувати вираз `match` в якості тіла метода, та (б) як порівнювати різні типи: 
[source,scala]
----
// getClassAsString - метод, що приймає любий тип
def getClassAsString(x: Matchable): String = x match
  case s: String => s"'$s' is a String"
  case i: Int => "Int"
  case d: Double => "Double"
  case l: List[_] => "List"
  case _ => "Unknown"

// приклади
getClassAsString(1)             // Int
getClassAsString("hello")       // 'hello' типу String
getClassAsString(List(1, 2, 3)) // List
----
Метод `getClassAsString` приймає як параметр значення типу `Matchable`, що може бути любим типом, що підтримує порівняння шаблонів (деякі типи не підтримують порівняння, бо це може зламати енкапсуляцію).

Є ще _дуже багато_ чого стосовно порівнянь шаблонів в Scala. Шаблони можуть бути вкладені, результати шаблонів можуть бути захоплені, і саме порівняння може визначатись власним кодом. Дивіться приклади порівнянь в главі Структури керування.

==== try/catch/finally

Керівна структура `try/catch/finally` в Scala дозволяє вам перехоплювати виключення. Це подібне до Java, але синтаксис узгоджений з виразами `match`: 
[source,scala]
----
try
  writeTextToFile(text)
catch
  case ioe: IOException => println("Got an IOException.")
  case nfe: NumberFormatException => println("Got a NumberFormatException.")
finally
  println("Clean up your resources here.")
----

==== `while` цикли

Scala також має конструкцію циклу `while`. Його одно-рядковий синтаксис виглядає так: 
[source,scala]
----
while x >= 0 do x = f(x)
----
Scala 2 має дещо інший синтаксис: умова була оточена дужками, та не було ключового слова `do`: 
[source,scala]
----
while (x >= 0) { x = f(x) }
----
Scala 3 все ще підтримує синтаксис Scala 2 в цілях сумісності.

Багато-рядковий синтаксис циклу `while` має наступний вигляд: 
[source,scala]
----
var x = 1

while
  x < 3
do
  println(x)
  x += 1
----

==== Власні керівні структури

Завдяки таким можливостям, як `by-name` параметри, інфіксна нотація, гнучки інтерфейси, опціональні дужки, методи розширення та функції вищого гатунку, ви можете створити ваш власний код, що робитиме як керівна структура. Ви найдете більше про це в _Керівні структури_.


== Доменне моделювання

Scala підтримує обоє, функціональне програмування (FP) та об'єктно-орієнтовне програмування (OOP), так само, як і суміш обох парадигм. Цей розділ провадить швидкий огляд моделювання даних в OOP та FP.

=== Доменне моделювання OOP

Коли ви пишете код в OOP стилі, ваші два основні інструменти для енкапсуляції - це _трейти_ та _класи_.

==== Трейти

Трейти Scala можуть використовуватись як прості інтерфейси, але вони також можуть містити абстрактні і конкретизовані методи і поля, і вони можуть мати параметри, так само, як класи. Вони провадять вам гарний спосіб організувати поведінку в малі, модулярні юніти. Пізніше, коли ви побажаєте створити конкретизовані реалізації атрибутів та поведінок, класи та об'єкти можуть розширювати трейти по мірі необхідності, міксуючи так багато трейтів, як потрібно, щоб отримати бажану поведінку.

В якості приклада, як використовувати трейти як інтерфейси - ось три трейти, що визначають гарно організовану і модульну поведінку для тварин, як собаки та кішки: 
[source,scala]
----
trait Speaker:
  def speak(): String  // абстрактне, без тіла

trait TailWagger:
  def startTail(): Unit = println("tail is wagging")
  def stopTail(): Unit = println("tail is stopped")

trait Runner:
  def startRunning(): Unit = println("I’m running")
  def stopRunning(): Unit = println("Stopped running")
----
Маючи ці трейти, ось клас `Dog`, що розширює всі ці трейти, та також провадить поведінку абстрактного метода `speak`: 
[source,scala]
----
class Dog(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Woof!"
----
Зверніть увагу, як клас розширює трейти за допомогою ключового слова `extends`.

Подібно до цього, ось клас `Cat`, що реалізує ті самі трейти, та переписує два конкретизованих методів, який він наслідує: 
[source,scala]
----
class Cat(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Meow"
  override def startRunning(): Unit = println("Yeah ... I don’t run")
  override def stopRunning(): Unit = println("No need to stop")
----
Ось приклад, як ці класи можуть бути використані: 
[source,scala]
----
val d = Dog("Rover")
println(d.speak())      // "Woof!"

val c = Cat("Morris")
println(c.speak())   // "Meow"
c.startRunning()     // "Yeah ... I don’t run"
c.stopRunning()      // "No need to stop"
----
Якщо цей код має сенс - добре, ви знайомі з трейтами в якості інтерфейсів. Якщо ні - не турбуйтесь, ми пояснимо краще в главі _Доменне модулювання_.

==== Класи 

Scala _класи_ використовуються в OOP стилі програмування. Ось приклад класа, що модулює "персону". В OOP поля типово змінні, так що `firstName` та `lastName` декларовані як `var`: 
[source,scala]
----
class Person(var firstName: String, var lastName: String):
  def printFullName() = println(s"$firstName $lastName")

val p = Person("John", "Stephens")
println(p.firstName)   // "John"
p.lastName = "Legend"
p.printFullName()      // "John Legend"
----
Зауважте, що декларація класу створює конструктор: 
[source,scala]
----
// тут використовується конструктор
val p = Person("John", "Stephens")
----
Конструктори та інші пов'язані з класами теми розкриті в главі _Доменне моделювання_.

=== Доменне моделювання в FP

Коли ви пишете код в FP стилі, ви будете використовувати такі конструкції: 

* Енумерації для визначення ADT
* Кейс класи
* Трейти

==== Енумерації

Конструкція `enum` є чудовим шляхом моделювати алгебраїчні типи даних (ATD) в Scala 3. Наприклад, піцца має три головні атрибути: 

* Розмір коржа
* Товщина коржа
* Приправи (опції)

Це стисло моделюється таким чином: 
[source,scala]
----
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions
----
Як тільки ви маєте енумерейшин, ви можете використовувати його як трейт, клас або об'єкт: 
[source,scala]
----
import CrustSize.*
val currentCrustSize = Small

// енумерація в `match` виразі
currentCrustSize match
  case Small => println("Small crust size")
  case Medium => println("Medium crust size")
  case Large => println("Large crust size")

// енумерація в `if` твердженні
if currentCrustSize == Small then println("Small crust size")
----
Ось інший приклад того, як створити і використовувати ADT в Scala: 
[source,scala]
----
enum Nat:
  case Zero
  case Succ(pred: Nat)
----
Енумерейшини розкриваються в деталях в розділі _Доменне моделювання_ цієї книжки, а також в референсній документації.

==== Кейс класи

В Scala `case` класи дозволяють моделювати концепції з незмінними структурами даних. Кейс клас має всю функціональність звичайного класу, та також додаткові вбудовані можливості, що робить їх корисними для функціонального програмування. Коли компілятор бачить ключове слово `case` перед `class`, це має наступні ефекти та переваги: 

* Конструктор кейс класа має параметри - публічні `val` по замовчанню, так що поля незмінні, та для кожного параметру генерується метод аксессора
* Генерується метод `upapply`, що дозволяє використовувати кейс класи в `match` додатковими шляхами
* В класі генерується метод `copy`. Це провадить шлях створювати оновленні копії об'єктів, не змінюючи оригінальний об'єкт
* Генеруються методи `equals` та `hashCode` для реалізації структурної еквівалентності
* Генерується дефолтний метод `toString`, корисний для дебагінгу

Ви _можете_ вручну додати всі ці методи до класу власноруч, але завдяки тому, що вони так загально використовуються в функціональному програмуванні, використання `case` класів виглядає значно зручнішим.

Цей код демонструє декілька можливостей `case` класів: 
[source,scala]
----
// визначення case class
case class Person(name: String, vocation: String)

// створення примірника case class
val p = Person("Reginald Kenneth Dwight", "Singer")

// гарний метод toString
p // : Person = Person(Reginald Kenneth Dwight,Singer)

// доступ до незмінних полів
p.name         // "Reginald Kenneth Dwight"
p.name = "Joe" // error: can’t reassign a val field

// створення зміненої копії
val p2 = p.copy(name = "Elton John")
p2  // : Person = Person(Elton John,Singer)
----
Дивіться _Доменне модулювання_ для значно більших деталей щодо кейс класів.

=== Методи в Scala

Scala класи, кейс класи, трейти, енумерації, об'єкти - всі можуть мати методи. Синтаксис простого метода може виглядати таким чином: 
[source,scala]
----
def methodName(param1: Type1, param2: Type2): ReturnType =
  // тіло метода
----
Ось декілька прикладів: 
[source,scala]
----
def sum(a: Int, b: Int): Int = a + b
def concatenate(s1: String, s2: String): String = s1 + s2
----
Вам не треба вказувати тип результату методів, тому за бажанням ви можете записати ті самі методи таким чином: 
[source,scala]
----
def sum(a: Int, b: Int) = a + b
def concatenate(s1: String, s2: String) = s1 + s2
----
Ось як ви виклиаєте ці методи: 
[source,scala]
----
val x = sum(1, 2)
val y = concatenate("foo", "bar")
----
Ось приклад багато-рядкового методу: 
[source,scala]
----
def getStackTraceAsString(t: Throwable): String =
  val sw = new StringWriter
  t.printStackTrace(new PrintWriter(sw))
  sw.toString
----
Параметри методыв можуть мати дефолтні значення по замовчанню. В наступному прикладі параметр `timeout` має дефолтне значення `5000`: 
[source,scala]
----
def makeConnection(url: String, timeout: Int = 5000): Unit =
  println(s"url=$url, timeout=$timeout")
----
Оскільки надане дефолтне значення для `timeout`, метод можна викликати в два способи: 
[source,scala]
----
makeConnection("https://localhost")         // url=http://localhost, timeout=5000
makeConnection("https://localhost", 2500)   // url=http://localhost, timeout=2500
----
Scala також підтримує _іменовані параметри_ при виклику методів, так що за бажанням ви можете викликати цей метод таким чином: 
[source,scala]
----
makeConnection(
  url = "https://localhost",
  timeout = 2500
)
----
Іменовані параметри зокрема корисні, коли декілька параметрів метода мають однаковий тип. З першого погляду на цей метод ви можете тільки здогадуватись, які з параметрів  встановлені в `true` або `false`: 
[source,scala]
----
engage(true, true, true, false)
----
Без допомоги IDE цей код важко читати, але наступний код значно очевидніший: 
[source,scala]
----
engage(
  speedIsSet = true,
  directionIsSet = true,
  picardSaidMakeItSo = true,
  turnedOffParkingBrake = false
)
----

=== Методи розширення

_Методи розширення_ дозволяють вам додавати нові методи до зачинених класів. Наприклад, якщо ви бажаєте додати два методи з назвами `hello` та `aloha` до класу `String`, задекларуйте їх як методи розширення: 
[source,scala]
----
extension (s: String)
  def hello: String = s"Hello, ${s.capitalize}!"
  def aloha: String = s"Aloha, ${s.capitalize}!"

"world".hello    // "Hello, World!"
"friend".aloha   // "Aloha, Friend!"
----
Ключове слово `extension` декларує, що ви маєте намір визначити один або більше методів розширення на параметрі, що стоїть в дужках. Як показано в прикладі, параметр `s` типу `String` потім може бути використаний в тілі методів розширення.

Наступний приклад показує, як додати метод `makeInt` до класу `String`. Тут `makeInt` приймає параметр на ім'я `radix`. Код не враховує можливої помилки перетворення рядок-в-ціле, але, оминаючи ці деталі, приклади показують, як це робить: 
[source,scala]
----
extension (s: String)
  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)

"1".makeInt(2)      // Int = 1
"10".makeInt(2)     // Int = 2
"100".makeInt(2)    // Int = 4
----

==== Дивіться також

Методи Scala можуть бути значно потужніші: вони можуь приймати параметри типів та контекстні параметри. Вони детально описані в розділі _Доменне моделювання_.

=== Функції першого класу

Scala має більшість можливостей, які ви очікуєте від функціональної мови програмування, включаючи: 

* Лямбди (анонимні функції)
* Функції вищого гатунку (HOFs)
* Незмінні колекції в стандартній бібліотеці

Лябмди, також відомі як _анонімні функції_, є багатою частиною того, що дозволяє робити ваш код стислим і розумілим.

Метод `map` класу `List` є типовим прикладом функції вищого гатунку - функції, що приймає іншу функцію в якості параметра.

Ці два приклади еквівалентні, і показують, як помножити кожне число в списку на 2, передаючи лямбду в метод `map`: 
[source,scala]
----
val a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)
val b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)
----
Ці приклади також еквівалентні до наступного коду, що використовує метод `double` замість лямбди: 
[source,scala]
----
def double(i: Int): Int = i * 2

val a = List(1, 2, 3).map(i => double(i))   // List(2,4,6)
val b = List(1, 2, 3).map(double)           // List(2,4,6)
----
  Якщо ви не бачили метод `map` до цього, він застосовує надану функцію до кожного елемента списку, видаючи новий список з отриманими результатами.

Передача лямбда до функцій вищого гатунку на класах колекцій (як `List`), є частиною досвіду Scala, дещо, що ви робитимете кожен день.

=== Незмінні колекції

Коли ви робите з незмінними колекціями, `List`, `Vector`, незмінними класами `Map` та `Set`, важливо знати, що ці функції не змінюють колекцію, на якій вони викликаються. Замість цього вони повертають нову колекцію з оновленнями. Як результат, досить загальним є зчеплювати їх разом в "гнучкому" стилі, для вирішення проблем.

Наприклад, цей приклад показує, як фільтрувати колекцію двічі, та потім помножити кожний елемент в тому, що залишилось: 
[source,scala]
----
// приклад списку
val nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)

// методи можуть бути зціплені
val x = nums.filter(_ > 3)
            .filter(_ < 7)
            .map(_ * 10)

// result: x == List(40, 50, 60)
----
На додаток до функцій вищого гатунку, які використовуються в стандартній бібліотеці, ви також можете створити власні.

=== Об'єкти-синглтони

В Scala ключове слово `object` створює об'єкт-синглтон. Інакше кажучи, `object` визначає клас, що має рівно один примірник.

Об'єкти мають декілька застосувань: 

* Вони використовуються для створення колекцій допоміжних методів-утіліт
* _Об'єкт-компанйон_ - це об'єкт , що має те саме ім'я, що і клас, з яким він поділяє один файл. В такій ситуації клас також називається _класом-компанйоном_
* Вони використовуються для реалізації трейтів, щоб створити _модулі_

==== Допоміжні методи-утіліти

Оскільки `object` є синглтоном, його методи можуть бути досяжними, як методи `static` в Java класі. Наприклад, цей об'єкт `StringUtils` містить невелику колекцію методів, пов'язаних з рядками: 
[source,scala]
----
object StringUtils:
  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty
  def leftTrim(s: String): String = s.replaceAll("^\\s+", "")
  def rightTrim(s: String): String = s.replaceAll("\\s+$", "")
----
Оскільки `StringUtils` є синглтоном, його методи можуть бути викликані на об'єкті: 
[source,scala]
----
val x = StringUtils.isNullOrEmpty("")    // true
val x = StringUtils.isNullOrEmpty("a")   // false
----

==== Об'єкти-компанйони

Компанйон-клас або компанйон-об'єкт можуть отримувати доступ до приватних членів свого компанйона. Використовуйте компанйон-об'єкт для методів, що не є специфічними для примірників компанйон-класа.

Цей приклад демонструє, як метод `area` в компанйон класі має доступ до приватного метода `calculateArea` в компанйон-об'єкті: 
[source,scala]
----
import scala.math.*

class Circle(radius: Double):
  import Circle.*
  def area: Double = calculateArea(radius)

object Circle:
  private def calculateArea(radius: Double): Double =
    Pi * pow(radius, 2.0)

val circle1 = Circle(5.0)
circle1.area   // Double = 78.53981633974483
----

==== Створення модулів з трейтів

Об'єкти також можуть використовуватись для реалізації трейтів, щоб створити модулі. Цей прийом бере два трейти, і комбінує їх, щоб створити конкретний `object`: 
[source,scala]
----
trait AddService:
  def add(a: Int, b: Int) = a + b

trait MultiplyService:
  def multiply(a: Int, b: Int) = a * b

// реалізація трейтів в якості об'єкта
object MathService extends AddService, MultiplyService

// використання об'єкту
import MathService.*
println(add(1,1))        // 2
println(multiply(2,2))   // 4
----

=== Колекції

Бібліотека Scala має багатий набір класів колекцій, і ці класи мають багатий набір методів. Класи колекцій доступні в змінній та незмінній формі.

==== Створення списків

Щоб дати вам відчути смак того, як це робить, ось деякі приклади, що використовують клас `List`, що є незмінним класом зв'язаного списку. Ці приклади показують різні шляхи створити заповнений `List`: 
[source,scala]
----
val a = List(1, 2, 3)           // a: List[Int] = List(1, 2, 3)

// Диапазони
val b = (1 to 5).toList         // b: List[Int] = List(1, 2, 3, 4, 5)
val c = (1 to 10 by 2).toList   // c: List[Int] = List(1, 3, 5, 7, 9)
val e = (1 until 5).toList      // e: List[Int] = List(1, 2, 3, 4)
val f = List.range(1, 5)        // f: List[Int] = List(1, 2, 3, 4)
val g = List.range(1, 10, 3)    // g: List[Int] = List(1, 4, 7)
----

==== Методи списків

Коли ви вже маєте заповнений список, наступні приклади показують деяки з етодів, які ви можете викликати на ньому. Зауважте, що всі вони є функціональними, тобто всі вони не змінюють колекцію, на якій викликаються. Замість цього вони повертають нову колекцію з оновленими елементами. Результати кожної такої операції показані в коментарях: 
[source,scala]
----
// деякий список
val a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)

a.drop(2)                             // List(30, 40, 10)
a.dropWhile(_ < 25)                   // List(30, 40, 10)
a.filter(_ < 25)                      // List(10, 20, 10)
a.slice(2,4)                          // List(30, 40)
a.tail                                // List(20, 30, 40, 10)
a.take(3)                             // List(10, 20, 30)
a.takeWhile(_ < 30)                   // List(10, 20)

// flatten
val a = List(List(1,2), List(3,4))
a.flatten                             // List(1, 2, 3, 4)

// map, flatMap
val nums = List("one", "two")
nums.map(_.toUpperCase)               // List("ONE", "TWO")
nums.flatMap(_.toUpperCase)           // List('O', 'N', 'E', 'T', 'W', 'O')
----
Ці приклади показують, як методи `foldLeft` та `reduceLeft` використовуються для підсумку значень в послідовності цілих: 
[source,scala]
----
val firstTen = (1 to 10).toList    // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

firstTen.reduceLeft(_ + _)         // 55
firstTen.foldLeft(100)(_ + _)      // 155 (100 is a “seed” value)
----
Є багато інших методів, доступних для класів колекцій в Scala, і вони описані в главі _Колекції_, та в документації по API.

=== Тапли

_Тапли_ в Scala є типом, що дозволяє вам просто покласти колекцію різних типів в той самий контейнер. Наприклад, ми маємо такий кейс клас `Person`: 
[source,scala]
----
case class Person(name: String)
----
Ось як ми створюємо тапл, що містить значення `Int`, `String` та власний тип `Person`: 
[source,scala]
----
val t = (11, "eleven", Person("Eleven"))
----
Як тільки ми маємо тапл, ви можете отримати значення через прикріплення їх до змінних, або отримати їх за порядковими номерами: 
[source,scala]
----
t(0)   // 11
t(1)   // "eleven"
t(2)   // Person("Eleven")
----
Ви також можете використати підхід _екстрактора_, щоб призначити поля тапла до імен змінних: 
[source,scala]
----
val (num, str, person) = t

// val num: Int = 11
// val str: String = eleven
// val person: Person = Person(Eleven)
----
Тапли гарні для тих випадків, коли ви бажаєте покласти колекцію гетерогенних типів в малу колекціє-подібну структуру. Дивіться референсну документацію щодо деталей по таплам.

=== Контекстуальні абстракції

За певних обставин ви можете уникнути деяких параметрів у викликах методів, які можна вважати повторюваннями.

Такі параметри називаються _контекстуальними параметрами_, оскільки вони виводяться компілятором з контексту, що оточує виклик методу.

Наприклад, розглянемо програму, що сортує список адрес за двома критеріями: назва міста, та потім назва вулиці.
[source,scala]
----
val addresses: List[Address] = ...

addresses.sortBy(address => (address.city, address.street))
----
Метод `sortBy` приймає функцію, що для кожної адреси повертає значення, по якому треба порівнювати адреси один з одним. В цьому випадку ми передаємо функцію, що повертає пару, яка містить назву міста та назву вулиці.

Зауважте, що ми тольки вказуємо, _що_ треба порівняти, але не _як_ виконувати порівняння. Як алгоритм сортування знає, як порівнюються пари `String`?

Насправді, метод `sortBy` приймає другий параметр, параметр `context`, який виводиться компілятором. Він не з'являється в попередньому прикладі, бо він надається компілятором.

Цей другий параметр реалізує _як_ порівнювати. Зручно уникати його, оскільки ми загалом знаємо, що `String` порівнюються в алфавітному порядку. 

Однак, також завжди можливо передати параметр явно: 
[source,scala]
----
addresses.sortBy(address => (address.city, address.street))(using Ordering.Tuple2(Ordering.String, Ordering.String))
----
В цьому випадку примірник `Ordering.Tuple2(Ordering.String, Ordering.String)` є саме той, що інакше буде виведений компілятором. Інакше кажучи, обоє приклади спродукують ту саму програму.

_Контекстуальні абстракції_ використовуються, щоб уникнути повторюваного коду. Вони допомагають розробникам писати частини коду, що є розширювані і стислі в той самий час.

Для додаткових деталей дивіться главу Контекстуальні абстракції в цій книзі, та також референсну документацію.

=== Визначння вищого рівня

В Scala 3 всі типи визначень можуть бути записані на "верхньому рівні" ваших файлів з кодом. Наприклад, ви можете створити файл з назвою `MyCoolApp.scala` і покласти в нього такий зміст: 
[source,scala]
----
import scala.collection.mutable.ArrayBuffer

enum Topping:
  case Cheese, Pepperoni, Mushrooms

import Topping.*
class Pizza:
  val toppings = ArrayBuffer[Topping]()

val p = Pizza()

extension (s: String)
  def capitalizeAllWords = s.split(" ").map(_.capitalize).mkString(" ")

val hwUpper = "hello, world".capitalizeAllWords

type Money = BigDecimal

// інші визначення ...

@main def myApp =
  p.toppings += Cheese
  println("show me the code".capitalizeAllWords)
----
Як показано, немає потреби класти ці визначення в `package`, `class`, або іншу конструкцію.

==== Заміна для об'єктів пакунку

Якщо ви знайомі зі Scala 2, цей підхід замінює _об'єкти пакунків_. Але хоча це значно простіше в використанні, вони роблять подібним чином: коли ви кладете визначення в пакунок на ім'я `foo`, ви можете потім отримати доступ до визначення в усіх пакунках під пакунком `foo`, як в пакунку `foo.bar` в прикладі нижче: 
[source,scala]
----
package foo {
  def double(i: Int) = i * 2
}

package foo {
  package bar {
    @main def fooBarMain =
      println(s"${double(1)}")   // це робить
  }
}
----
Фігурні дужки використані в цьому прикладі щоб зробити наголос на вкладенні пакунків: 

Переваги цього підходу в тому, що ви можете покласти визначення в пакунок на ім'я `com.acme.myapp`, та потім посилатись на них з `com.acme.myapp.model` та `com.acme.myapp.controller`.

=== Підсумок

В попередніх розділах ви побачили: 

* Як використовувати Scala REPL
* Як створювати змінні `val` та `var`
* Деякі загальні типи даних
* Керівні структури
* Як моделювати реальний світ в стилі OOP та FP
* Як створювати та використовувати методи
* Як використовувати лямбди (анонімні функції) та функції вищого гатунку
* Як використовувати об'єкти для різних цілей
* Вступ до контекстуальних абстракцій

Ми також згадали, що якщо ви бажаєте замість REPL використовувати плейграунд в браузері, ви можете використовувати `Scastie.scala-lang.org` або `ScalaFiddle.io`.

=== Перший погляд на типи 