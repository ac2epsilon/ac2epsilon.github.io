SCALA 3 Book
============

== Властивості Scala 3

Ім'я _Scala_ походить від _scalable_, маштабований, і виправдовуючи це ім'я, мова Scala використовується для підсилення завантажених веб сайтів та аналізу величезних обсягів даних. Цей розіділ знайомить вас з властивостями, що роблять Scala такою маштабованою мовою. Ці властивості поділені на три розділи:

* Високорівневі мовні властивості
* Низькорівневі мовні властивості
* Властивості екосистеми Scala

=== Високорівневі властивості

Дивлячись на Scala з уявного пташиного політу, ви можете зробити наступні зауваження щодо цієї мови:

* Це мова програмування високого рівня
* Вона має стислий та читаємий синтаксис
* Вона статично типізована (але відчувається як динамічно типізована)
* Вона має виразну систему типів
* Це функціо
нальна (FP) мова програмування
* Вона також є об'єктно орієнтовною (OOP) мовою програмування
* Вона підтримує поєднання FP та OOP
* Контекстуальні абстракції провадять ясний шлях для _виводу термів_
* Все виконується на JVM (або в браузері) 
* Забезпечена безшовна взаємодія з Java кодом
* Використовується для застосувань сервер-сайду (включаючи мікросервіси), застосувань біг-дейта, але також може застосовуватись в браузері через Scala.js.

Наступні розділи дають швидкий огляд ціх властивостей.

==== Мова високого рівня

Scala має бути визнана як мова високого рівня, щонайменьше через два аспекти. По перше, як Java та багато іншіх сучасних мов програмування, ви не маєте справу з низькорівневими концепціями, як вказівники та керування пам'яттю.

По друге, за допомогою лямбд та функцій вищого гатунку ви пишете ваш код на дуже високому рівні. Як здверджує прикизка функціональної мови, ви кажете _що_ ви бажаєте, а не _як_ цього досягти. Тобто ви не пишете імперативний код як наступний:
[source,scala]
----
def double(ints: List[Int]): List[Int] = {
  val buffer = new ListBuffer[Int]()
  for (i <- ints) {
      buffer += i * 2
  }
  buffer.toList
}
val newNumbers = double(oldNumbers)
----
Цей код інструктує компілятор що робити, крок за кроком. Замість цього ми пишемо на вищому рівні, функціональний код, використовуючи функції вищого гатунку та лямбди, як нижче, для отримання того самого результату: 
[source,scala]
----
val newNumbers = oldNumbers.map(_ * 2)
----
Як ви можете бачити, цей код значно більш стислий, простіший для читання та простіший для підтримки.

==== Стислий синтаксис

Scala має стислий, читабельний синтаксис. Наприклад, змінні створюються стисло, та їх тип зрозумілий:
[source,scala]
----
val nums = List(1,2,3)
val p = Person("Martin", "Odersky")
----
Функції вищого гатунку та лямбди створені для стислого коду, що можливо прочитати: 
[source,scala]
----
nums.map(i => i * 2)   // довга форма
nums.map(_ * 2)        // коротка форма

nums.filter(i => i > 1)
nums.filter(_ > 1)
----
Трейти, класи та методи визначені в стислому і прозорому синтаксисі: 
[source,scala]
----
trait Animal:
  def speak(): Unit

trait HasTail:
  def wagTail(): Unit

class Dog extends Animal, HasTail:
  def speak() = println("Woof")
  def wagTail() = println("⎞⎜⎛  ⎞⎜⎛")
----
Досліди показали, що час, який розробник витрачає на _читання_ коду до _написання_ коду складає щонайменьше 1/10, так що написання стислого та читабельного коду так важливе.

==== Відчуття динамічності

Scala є статично типізованою мовою, але завдячуючи її можливостям по виведенню типів, вона відчувається як динамічна. Всі ці вирази виглядають як динамічно-типізована мова, як Python або Ruby, але все це Scala: 
[source,scala]
----
val s = "Hello"
val p = Person("Al", "Pacino")
val sum = ints.reduceLeft(_ + _)
val y = for i <- nums yield i * 2
val z = nums.filter(_ > 100)
            .filter(_ < 10_000)
            .map(_ * 2)
----
Як стверджує Heather Miller, Scala визначено сильно, статично типізована мова, та ви можете отримати всі переваги статичних типів: 

* Коректність: ви відловлюєте більшість помилок під час компіляції
* Чудова підтримка IDE: 
** Надійне завершення коду
** Відловлення помилок під час компіляції означає перехоплення помилок по мірі набору
** Простий та надійний рефакторинг
* Ви можете впевнено рефакторити свій код
* Декларації типів методів  кажуть читачеві, що робить метод, та служить в якості документації
* Маштабованість та підтримуваність: типи допомагають переконатись в коректності між довільно великими застосуваннями та командами розробників
* Сильна типізація, в комбінації з чудовим виведенням, дозволяє механізми, як контекстуальна абстракція, що дозволяє вам уникати шаблонного коду. Часто цей шаблонний код може бути виведений компілятором, базуючись на визначенні типів та певному контексті.

==== Виразна система типів

Система типів Scala примушуе, під час компіляції, щоб абстракції використовувались в безпечний та узгоджений спосіб. Зокрема, система типів підтримує: 

* Виведені типи
* Дженерік класи
* Анотації варіантності
* Верхні і нижні межі типів
* Поліморфні методи
* Типи перетину
* Юніон типи
* Типові лямбди
* Примірники `given` та `using` класи
* Методи розширення
* Класи типів
* Мультиверсальне порівняння
* Прозорі псевдоніми типів
* Відкриті класи
* Класи порівнянь
* Типи залежної функції
* Типи поліморфної функції
* Межі контексту
* Функції контексту
* Внутрішні класи та абстрактні члени класів як члени об'єктів

В комбінації ці властивості провадять потужний базис для безпечного використання абстракцій програмування, та для типо-безпечного розширення програм.

==== Функціональна мова програмування

Scala є функціональною мовою програмування. Це означає: 

* Функції є значеннями, і можуть передаватись як будь-які значення
* Пряма підтримка функцій вищого гатунку
* Вбудовані лямбда
* Все в Scala э виразом, що повертає значення
* Синтаксично просте використання незмінних змінних, і їх використання заохочується
* Наявне різноманіття класів для незмінних колекцій в стандартній бібліотеці
* Ці класи колекцій ідуть з десятками функціональних методів: вони не змінюють колекцію, та замість цього повертають оновлену копію даних

==== Об'єктно-орієнтовна мова

Scala є об'єктно-орієнтовною мовою програмування (OOP). Кожне значення є примірником класу і кожний "оператор" є методом.

В Scala всі типи походять від кореневого класу `Any`, чиї безпосередні діти є `AnyVal` (_типи-значення_, такі як `Int` або `Boolean`), та `AnyRef` (_типи-посилання_, як в Java). Це означає, що різниця між примітивними типами, та боксованими типами (як `int` vs `Integer`), відсутня в Scala. Боксування та розбоксування повністю прозорі для користувача.

==== Підтримка змішування FP/OOP

Основою Scala є змішування функціонального програмування та об'єктно-орієнтовного програмування в прописній істині:

* Функції для логіки
* Об'єкти для модульності

Як стверджував Martin Odersky, "Scala була розроблена, щоб показати, що злиття функціонального та об'єктно-орієнтовного програмування є можливим та практичним".

==== Вивід термів, зроблене зрозумілішим

Слідуючи за Haskell, Scala була другою за популярністю мовою, що мала деяку форму _імплісітів_. В Scala 3 ці концепції були повністю переосмислені, і реалізовані більш зрозуміло.

Головна ідея є _вивід термів_: маючи тип, компілятор синтезує "канонічний" терм, що має такий тип. В Scala контекстний параметр прямо веде до виведеного терму аргументу, що також може бути записаний явно. 

Випадки застосування цієї концепції включають реалізацію класів типу, встановлення контексту, ін'єкція залежностей, вираження спроможностей, обчислення нових типів, та налагодження відносин між ними.

Scala 3 робить цей процесс більш прозорим, ніж будь-коли до цього. Читайте про контекстуальні абстракції в референсній документації.

==== Клієнт та сервер

Scala код виконується на Java Virtual Machine (JVM), так що ви отримуєте всі її переваги: 

* Безпеку
* Продуктивність
* Керування пам'ятю
* Портабельність та незалежність від платформи
* Здатність використовувати богатства існуючих бібліотек Java та JVM

На додаток до виконання на JVM, Scala також робить в браузері, за допомогою Scala.js (та бібліотек з відкритим кодом для інтеграції з популярними бібліотеками JavaScript), та нативними виконавчими файлами, що можуть бути побудовані з допомогою Scala Native та GraalVM.

==== Безшовна інтеграція з Java

Ви можете використовувати класи та бібліотеки Java в ваших Scala застосуваннях, та ви можете використовувати код Scala в ваших Java застосуваннях. Що до другого твердження, великі бібліотеки, як Akka та Play Framework, написані на Scala, та можуть бути використані в Java застосуваннях.

Відносно першого твердження, Java класи та бібліотеки використовуються в застосуваннях Scala кожний день. Наприклад, в Scala ви можете читати файли за допомогою Java `BufferedReader` та `FileReader`: 
[source,scala]
----
import java.io.*
val br = BufferedReader(FileReader(filename))
// читати файл через `br` ...
----
Використання Java коду в Scala є загалом безшовним.

Java колекції також можуть бути використані в Scala, та якщо ви бажаєте використати багаті класи колекцій Scala з ними, ви можете конвертувати їх в парі рядків кода: 
[source,scala]
----
import scala.jdk.CollectionConverters.*
val scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq
----

==== Багатство бібліотек

Як ви побачите в третій частині цієї сторінки, Scala бібліотеки та фреймворки, як ці, були написані, щоб підсилити завантажені веб сайти, і робити з велетенськими базами даних: 

1. Play Framework - це легковажна, безстанова, дружня до розробника, дружня до веб архітектура для створення високо-маштабованих застосувань
2. Lagom - фреймворк мікросервісів, що допомагає роз'єднати ваш застарілий моноліт, та побудувати, протестувати, та розгорнути цілі системи реактивних мікросервісів
3. Apache Spark - уніфікований аналітичний рушій для обробки великих обсягів даних, з вбудованими модулями для стримінгу, SQL, машинним навчанням та обробкою графів

Список Awesome Scala показує десятки додаткових інструментів з відкритим кодом, що створені розробниками для побудови Scala застосувань.

На додаток до серверного програмування, Scala.js є сильно-типізованою заміною для написання JavaScript, з бібліотеками з відкритим кодом третіх сторін, що включають інструменти для інтергації з бібліотекою Facebook React, jQuery, тощо. 

=== Низькорівневі властивості мови

В той час, коли попередній розділ розповідав про високо-рівневі можливості Scala, цікаво зауважити, що на вищому рівні ви можете зробити ті самі зауваження щодо обох, Scala 2 та Scala 3. Десятиріччя тому Scala розпочинала з міцного фундаменту бажаних властивостей, і, як ви побачите в цьому розділі, ці переваги були покращені в Scala 3.

На "рівні моря" з погляду на деталі - тобто, на можливості мови, які програмісти використовують щодня - Scala 3 має значні переваги над Scala 3: 

* Здатність створювати алгебраїчні типи даних (ADT) більш стисло, за допомогою енумерацій
* Навіть ще більш стислий та читабельний синтаксис: 
** "Тихий" синтаксис керівних структур, що простіше читається
** Опціональні дужки
*** Менше символів в коді створює меньше візуального галасу, що легше читається
** Ключове слово `new` загалом більше не потрібне при створенні примірників класів
** Формальності об'єкта-пакунка були відкинуті на користь простіших визначень "вищого рівня"
* Зрозуміліша граматика
** Декілька різних використань ключового слова `implicit` були видалені; ці використання замінені на більш очевидні ключові слова, як `given`, `using`, `extension`, фокусуючись на призначенні замість механізмів (дивіться розділ Given)
** Методи розширення замінюють імплісіт-класи з яснішим та простішим механізмом
** Додавання модифікатора `open` до класів робить явними наміри розробника зробити клас відкритим для модифікацій, таким чином обмежуючи ad-hoc розширення кодової бази
** Мультиверсальна еквівалентність відкидає безглуздзі порівняння за допомогою `==` та `!=` (тобто, порівняння `Person` та `Planet`)
** Макроси реалізовані значно простіше
** Юніони та перетини пропонують гнучкий шлях моделювання типів
** Параметри трейтів замінюють та спрощують ранні ініціалізатори
** Прозорі псевдоніми типів замінюють більшість використань класів-значень, при цьому гарантуючи відсутність боксування
** Твердження експорту провадять простий та узагальнений спосіб вираження агрегації, що може замінити попередній паттерн фасаду наслідування об'єктів пакунку від класів
** Процедурний синтаксис був відкинутий, та синтаксис `varargs` був змінений, обоє щоб зробити мову більш узгодженою
** Анотація `@infix` робить очевидним, як ви бажаєте застосувати метод
** Анотація методу `@targetName` визначає альтернативне ім'я для методу, покращуючи взаємодію з Java, та провадячи псевдоніми для символічних операторів

Демонстрація всіх цих можливостей прямо тут заняла б багато місця, але слідуючи за посиланнями ви можете побачити можливості в дії. Всі ці можливості обговорюються на сторінках _Нове, змінене та відкинуте_ в оглядовій документації.

=== Екосистема Scala

Scala має вируючу екосистему, з бібліотеками та фреймворками для кожної потреби. Список _Awesome Scala_ провадить перелік сотен доступних розробникам проектів з відкритим кодом, та Scaladex провадить пошук Scala бібліотек. Деякі з самих помітних перелічені нижче. 

==== Веб розробка

* _Play Framework_ слідує за моделлю Ruby on Rails, щоб стати легковажною, безстановою, розробник-дружньою, веб-дружньою архітектурою для високо маштабованих застосувань
* _Scalatra_ є маленьким, високопродуктивним, асинхронним веб фреймворком, натхненим Sinatra
* _Finatra_ є Scala сервісами, побудованими на TwitterServer та Finagle
* _Scala.js_ - це сильно типізована заміна для JavaScript, що провадить безпечніший шлях для побудови надійнішого фронт-енду веб застосувань
* _ScalaJs-React_ підіймає бібліотеку Facebook React до Scala.js, та намагається зробити її настільки безпечною та Scala-дружньою, як це можливо
* _Lagom_ - фреймворк мікросервісів, що допомагає декомпозиції існуючих монолітів, та побудові, тестуванню, та розгортанню цілих систем реактивних мікросервісів

==== HTTP(S) бібліотеки

* akka-http
* Finch
* Http4s
* Sttp

==== JSON бібліотеки

* Argonaut
* Circe
* Json4s
* Play-JSON
* ScalaPB (серіалізіція)

==== Наукові обчислення та обробка даних

* Algebird
* Spire
* Squants

==== Big data

* Apache Spark
* Apache Flink

==== AI, машинне навчання

* BigDL (Distributed Deep Learning Framework) для Apache Spark
* TensorFlow Scala

==== Функціональне (та реактивне) програмування 

* Cats
* Zio
* fs2
* monix

==== Інструменти побудови 

* sbt
* Gradle
* Mill

=== Підсумок

Як показує ця сторінка, Scala має багато неймовірних властивостей мови на вищому рівні, на рівні щоденного програмування, та через екосистему розробників.
