== Чому Scala 3?

Існує багато переваг використання Scala, зокрема Scala 3. Важко перелічити всі переваги Scala, але топ-10 може виглядати так: 

1. Scala обіймає злиття функціонального програмування (FP), та об'єктно-орієнтовного програмування (OOP)
2. Scala статично типізована, але часто відчувається як динамічно типізована мова
3. Синтаксис Scala стислий, але все ще зрозумілий; на нього часто посилаються як на _виразний_.
4. _Імплісіти_ в Scala 2 були визначальною можливыстю, і вони були покращені та спрощені в Scala 3
5. Scala безшовно інтегрується з Java, так що ви можете створювати змішані проекти на Scala та Java, та код Scala може легко використовувати тисячі існуючих Java бібліотек
6. Scala може використовуватись на сервері, але також в браузері, за допомогою Scala.js
7. Стандартна бібліотека Scala має десятки пре-побудованих, функціональних методів, щоб зберігти ваш час, та значно зменшити потребу писати власні `for` цикли та алгоритми
8. "Кращі практики" вбудовані в Scala, що надає перевагу незмінності, анонімних функцій, функцій вищого гатунку, порівняння шаблонів, класів, що не розширюються по замовчанню, та інше
9. Екосистема Scala пропонує найбільш сучасні FP бібліоеки в світі
10. Сильна система типів

=== 1) Злиття FP/OOP

Більше ніж будь-яка інша мова, Scala підтримує злиття парадігм FP та OOP. Як стверджував Мартін Одерскі, основа Scala в злитті функціонального та об'єктно-орієнтовного програмування в типовому оточенні: 

* Функції для логіки
* Об'єкти для модульності

Можливо, один з кращих прикладів модульності є класи в стандартній бібліотеці. Наприклад, `List` визначений як клас - технічно це абстрактний клас - і новий примірник створюється так: 
[source,scala]
----
val x = List(1, 2, 3)
----
Однак, для програміста виглядає так, що простий `List` насправді побудований як комбінація декількох спеціалізованих типів, включаючи трейти з назвами `Iterable`, `Seq` та `LinearSeq`. Ці типи подібним чином скомпоновані з інших, меньших, модульних одиниць коду.

На додаток до побудови типів як `List` з послідовності модульних трейтів, `List` API також складається з десятків інших методів, багато з яких є функціями вищого гатунку: 
[source,scala]
----
val xs = List(1, 2, 3, 4, 5)

xs.map(_ + 1)         // List(2, 3, 4, 5, 6)
xs.filter(_ < 3)      // List(1, 2)
xs.find(_ > 3)        // Some(4)
xs.takeWhile(_ < 3)   // List(1, 2)
----
В ціх прикладах значення в списку не може бути модифіковане, клас `List` є незмінним. Так що ці методи повертають нові значення, як показано в коментарях.

=== 2) Динамічне відчуття

_Вивід типів_ Scala часто робить відчуття мови динамічно типізованим, навіть хоча вона статично типізована. Це так для декларацій змінних: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3,4,5)
val stuff = ("fish", 42, 1_234.5)
----
Це також вірно, коли анонімна функція передається до функції вищого гатунку: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
list.filter(_ < 4)
    .map(_ * 2)
----
та при визначенні методів: 
[source,scala]
----
def add(a: Int, b: Int) = a + b
----
Це все ще більше вірно в Scala 3, як при використанні юніон типів: 
[source,scala]
----
// параметр юніон типу
def help(id: Username | Password) =
  val user = id match
    case Username(name) => lookupName(name)
    case Password(hash) => lookupPassword(hash)
  // тут код ...

// значення юніон типу
val b: Password | Username = if (true) name else password
----

=== 3) Стислий синтаксис

Scala - мова без церемоній, "стисла, але читабельна". Наприклад, декларація змінних стисла: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3)
----
Створення типів, як трейти, класи та енумерації, є стислим: 
[source,scala]
----
trait Tail:
  def wagTail(): Unit
  def stopTail(): Unit

enum Topping:
  case Cheese, Pepperoni, Sausage, Mushrooms, Onions

class Dog extends Animal, Tail, Legs, RubberyNose

case class Person(
  firstName: String,
  lastName: String,
  age: Int
)
----
Функції вищого гатунку також стислі: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
----

Всі ці вирази, і багато інших, є стислими, та при цьому все ще зрозумілі: ми називаємо це _виразність_.

=== 4) Імплісіти, спрощені

Імплісіти в Scala 2 були головною знаковою відмінністю дизайну. Вони репрезентували фундаментальний шлях абстрагуватись від контексту, з уніфікованою парадігмою, що служить багатому різноманіттю випадків. Серед них: 

* Реалізація класів типу
* Встановлення контексту
* Ін'єкція залежностей
* Вираз можливостей

З тих пір багато мов прийняли подібні концепції, всі з яких є варіантами головної ідеї _виводу термів_: маючи тип, компілятор синтезує "канонічний" терм, що має цей тип.

Хоча імплісіти були визначальною властивістю в Scala 2, їх дизайн був суттєво покращений в Scala 3: 

* Існує єдиний спосіб визначити `given` значення
* Існує єдиний спосіб ввести імплісіт параметри та аргументи
* Існує окремий шлях імпортувати `given`, що не дозволяє їм загубитись в морі звичайних імпортів
* Існує єдиний спосіб визначити імплісіт конверсію, яка зрозуміло помічена як така, і не потребує спеціального синтаксису

Переваги таких змін наступні: 

* Новий дизайн уникає взаємодії можливостей, та робить мову більш узгодженою
* Це робить імплісіти простішими для вивчання, та складнішими для невірного використання
* Це гарно підвищує прозорість 95% Scala програм, що використовують імплісіти
* Існує потенціал робити вивід термів в принциповий спосіб, що також доступний та дружній

Ці властивості детально описані в інших розділах. Дивіться вступ до Контекстуальної абстракції, та розділ про `given` та `using`.

=== 5) Безшовна Java інтеграція

Інтеграція Scala/Java є безшовною в багатьох сенсах. Наприклад: 

* Ви можете використовувати всі тисячі Java бібліотек в ваших Scala проектах
* Scala `String` в основі є Java `String`, з додатковими можливостями
* Scala безшовно використовує класи дати та часу в пакунку _java.time_.

Ви також можете використовувати Java колекції в Scala, і, щоб надати їм більше функціональності, Scala включає методи, так що ви можете трансформувати їх в Scala колекції.

Хоча майже кожна взаємодія є безшовною, глава _Взаємодія з Java_ демонструє, як використовувати деякі можливості разом, включаючи використання: 

* Java колекції в Scala
* Java `Optional` в Scala
* Java інтерфейси в Scala
* Scala колекції в Java
* Scala `Option` в Java
* Scala трейти в Java
* Scala методи, що закидають виключення, в Java
* Scala `varargs` параметри в Java

Дивіться відповідну главу для додаткової інформації по цім темам.

=== 6) Клієнт і сервер

Scala може бути використана з боку сервера за допомогою несамовитих фреймворків та мікросервісів: 

* _Play Framework_ дозволяє вам будувати високо маштабовані серверні застосування та мікросервіси
* _Akka Actors_ дозволяють використовувати модель акторів, щоб значно спростити розподілені та конкурентні софтверні застосування

Scala також може бути використана в браузері завдяки проекту Scala.js, що є типо-безпечною заміною JavaScript. Екосистема Scala.js має десятки бібліотек, що дозволяють використовувати React, Angular, jQuery, та багато інших бібліотек JavaScript та Scala в браузері.

На додаток до ціх інструментів проект Scala Native "є оптимізуючим ahead-of-time компілятором і легковажним керованим рантаймом, розробленим спеціально для Scala". Він дозволяє будувати бінарні застосування за допомогою звичайного коду Scala, а також дозволяє використовувати низькорівневі примітиви.

=== 7) Методи стандартної бібліотеки

Тепер вам рідко потрібно власноруч писати цикли `for`, тому що десятки функціональних методів в стандартній бібліотеці Scala одночасно зберігає ваш час, та допомагає робити код більш узгодженим між різними застосуваннями.

Наступні приклади демонструють деякі з вбудованих методів колекцій, і є багато ще інших. Хоча всі вони використовують клас `List`, ті самі методи методи роблять з іншими класами колекцій, як `Seq`, `LazyList`, `Set`, `Map`, `Array`, `ArrayBuffer`.

Ось деяки приклади: 
[source,scala]
----
List.range(1, 3)                          // List(1, 2)
List.range(start = 1, end = 6, step = 2)  // List(1, 3, 5)
List.fill(3)("foo")                       // List(foo, foo, foo)
List.tabulate(3)(n => n * n)              // List(0, 1, 4)
List.tabulate(4)(n => n * n)              // List(0, 1, 4, 9)

val a = List(10, 20, 30, 40, 10)          // List(10, 20, 30, 40, 10)
a.distinct                                // List(10, 20, 30, 40)
a.drop(2)                                 // List(30, 40, 10)
a.dropRight(2)                            // List(10, 20, 30)
a.dropWhile(_ < 25)                       // List(30, 40, 10)
a.filter(_ < 25)                          // List(10, 20, 10)
a.filter(_ > 100)                         // List()
a.find(_ > 20)                            // Some(30)
a.head                                    // 10
a.headOption                              // Some(10)
a.init                                    // List(10, 20, 30, 40)
a.intersect(List(19,20,21))               // List(20)
a.last                                    // 10
a.lastOption                              // Some(10)
a.map(_ * 2)                              // List(20, 40, 60, 80, 20)
a.slice(2, 4)                             // List(30, 40)
a.tail                                    // List(20, 30, 40, 10)
a.take(3)                                 // List(10, 20, 30)
a.takeRight(2)                            // List(40, 10)
a.takeWhile(_ < 30)                       // List(10, 20)
a.filter(_ < 30).map(_ * 10)              // List(100, 200, 100)

val fruits = List("apple", "pear")
fruits.map(_.toUpperCase)                 // List(APPLE, PEAR)
fruits.flatMap(_.toUpperCase)             // List(A, P, P, L, E, P, E, A, R)

val nums = List(10, 5, 8, 1, 7)
nums.sorted                               // List(1, 5, 7, 8, 10)
nums.sortWith(_ < _)                      // List(1, 5, 7, 8, 10)
nums.sortWith(_ > _)                      // List(10, 8, 7, 5, 1)
----

=== 8) Вбудовані кращі практики

Ідіоми Scala заохочують кращі практики в декілька способів. Для незмінності вас заохочують створювати незмінні `val` декларації: 
[source,scala]
----
val a = 1   // незмінна змінна
----
Вас також заохочують використовувати класи незмінних колекцій, як `List` та `Map`: 
[source,scala]
----
val b = List(1,2,3)       // List незмінний
val c = Map(1 -> "one")   // Map незмінний
----
Кейс класи загалом призначені для використання в доменному моделюванні, і їх параметри незмінні: 
[source,scala]
----
case class Person(name: String)
val p = Person("Michael Scott")
p.name           // Michael Scott
p.name = "Joe"   // помилка компілятора (переприсвоєння val)
----
Як показано в попередньому розділі, класи колекцій Scala підтримують функції вищого гатунку, і ви можете передавати до них методи (не показані) та анонімні функції: 
[source,scala]
----
a.dropWhile(_ < 25)
a.filter(_ < 25)
a.takeWhile(_ < 30)
a.filter(_ < 30).map(_ * 10)
nums.sortWith(_ < _)
nums.sortWith(_ > _)
----
Вирази `match` дозволяють використовувати порівняння шаблонів, і вони насправді є виразами, що повертають значення: 
[source,scala]
----
val numAsString = i match
  case 1 | 3 | 5 | 7 | 9 => "odd"
  case 2 | 4 | 6 | 8 | 10 => "even"
  case _ => "too big"
----
Оскільки вони повертають значення, вони часто використовуються як тіло функції: 
[source,scala]
----
def isTruthy(a: Matchable) = a match
  case 0 | "" => false
  case _ => true
----

=== 9) Бібліотеки екосистеми

Бібліотеки Scala для функціонального програмування (FP), як Cats та Zio, знаходяться на передньому фланзі бібліотек FP спільноти. Всі ці штампи, як високо-продуктивний, безпека типів, конкурентний, асинхронний, ресурсо-безпечний, тестовний, функціональний, модуларний, бінарно-сумісний, ефективний, та більше, що можна сказати про ці бібліотеки.

Ви можете перегорнути сотні бібліотек, але, на щастя, всі вони перелічені в одному місці: для деталей дивіться _Awesome Scala_.

=== 10) Сильна система типів

Scala має сильну систему типів, і вона була навіть ще більше покращена в Scala 3. Цілі Scala 3 були визначені на ранній стадії, і ті, що мають відношення до системи типів, включають: 

* Спрощення
* Уникнення неузгодженостей
* Безпека
* Ергономіка
* Продуктивність

_Спрощення_ досягається через десятки змінених та відкинутих можливостей. Наприклад, зміна від перевантаженого ключового слова `implicit` в Scala 2, до термів `given` та `using` в Scala 3, що робить мову більш зрозумілою, особливо для розробників-початківців.

_Уникнення неузгодженостей_ пов'язане з десятками відкинутих можливостей, змінених можливостей та доданих можливостей в Scala 3. Деякі з найбільш важливих можливостей в цій категорії: 

* Перетини типів
* Юніон типи
* Типи імплісіт функції
* Типи залежної функції
* Параметри трейтів
* Дженерік тапли

_Безпека_ пов'язана з новими та зміненими властивостями:  

* Мультіверсальна еквівалентність
* Обмеження імплісіт конверсій
* null-безпечність
* Безпечна ініціалізація

Гарні приклади _ергономіки_ є енумерації та методи розширення, що були додані в Scala 3 в дуже зрозумілий спосіб: 
[source,scala]
----
// енумерація
enum Color:
  case Red, Green, Blue

// методи розширення
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius
----
_Продуктивність_ відноситься до декількох речей. Одна з них є прозорі типи. В Scala 2 було декілька спроб вирішити питання дотримання практики Domain-driven design (DDD) надавати значенням більш осмислені типи. Ці спроби включають: 

* Псевдоніми типів
* Класи-значення
* Кейс класи

Нажаль, всі з ціх підходів мають свої вади, як описано в `Opaque Types SIP`. Навпаки, ціллю прозорих типів є, як описано в цьому SIP, щоб "операції на ціх типах-огортках не створювали додаткового навантаження під час виконання, при цьому провадячи безпеку типів рід час компіляції".

Більше щодо деталей системи типів дивіться відповідні посилання.

=== Інші значні властивості

Scala має багато гарних властивостей, та вибір Топ-10 може бути суб'єктиним. Декілька досліджень показали, що різні групи розробників люблять різні властивості. Маємо надію, що ви знайдете інші потужні можливості Scala по мірі використання мови.

== Смак Scala

Ця глава провадить карколомний тур по основним можливостям мови програмування Scala 3. Після цього початкового туру залишок книги провадить більше деталей по цім можливостям, та нарешті Референсна документація надає _значно_ быльше деталей.

На протязі цієї книги ми рекомендуємо експериментувати з прикладами на _Scastie_, або _Scala REPL_, які ми скоро побачимо.

== Hello, Wold!

Приклад "Hello, World!" на Scala 3 виглядає таким чином. Спочатку покладіть наступний код в файл _Hello.scala_: 
[source,scala]
----
 @main def hello = println("Hello, world!")
----
В цьому коді `hello` є метод. Він визначається за допомогою `def`, і задекларований як `main` за допомогою анотації `@main`. Він друкує _"Hello, world!"_ в стандартний вивід (STDOUT), використовуючи метод `println`.

Далі скомпілюйте код в `scalac`: 
[source,bash]
----
$ scalac Hello.scala
----
  Прим.перекл. Станом на 01 січня 2022 року компілятор та ланчер Scala 3 мали назву `scala3-compiler` та `scala3`, відповідно. Майте це на увазі, Scala 2 видасть помилку вже на першій декларації `@main`.

Якщо ви прийшли в Scala з Java, `scalac` такий саме, як `javac`, так що ця команда створить декілька файлів: 
[source,bash]
----
$ ls -1
Hello$package$.class
Hello$package.class
Hello$package.tasty
Hello.scala
hello.class
hello.tasty
----
Як і в Java, файли `.class` є файлами байткоду, і вони готові для виконання в JVM. 

Тепер ви можете виконати метод `hello` в команді ланчера `scala`: 
[source,bash]
----
$ scala hello
Hello, world!
----
Вважаючи, що все робить, прийміть поздоровлення. Ви тільки що скомпілювали та виконали ваше перше застосування на Scala.
  
  Більше інформації щодо _sbt_ та інших інструментів, що спрощують розробку на Scala, можна знайти в главі _Інструменти Scala_.

== REPL

Scala REPL (“Read-Evaluate-Print-Loop”) є інтерпретатором командного рядка, який ви використовуєте для перевірки вашого Scala коду. Ви запускаєте вашу REPL сессію, виконуючи команду `scala` в командному рядку операційної системи. Ви маєте побачити запрошення. подібне до наступного: 
[source,bash]
----
$ scala
Welcome to Scala 3.0.0 (OpenJDK 64-Bit Server VM, Java 11.0.9).
Type in expressions for evaluation.
Or try :help.

scala> _
----
REPL є інтерпретатором командного рядка, так що він очікує, доки ви введете будь-що. Тепер ви можете вводити вирази Scala, щоб побачити як вони роблять: 
[source,scala]
----
scala> 1 + 1
val res0: Int = 2

scala> 2 + 2
val res1: Int = 4
----
Як стверджує результат, якщо ви не присвоєте результат до змінної, REPL створить змінні з іменами `res1`, `res2`, тощо. Ви можете  використовувати ці имена в наступних виразах: 
[source,scala]
----
scala> val x = res0 * 10
val x: Int = 20
----
Зауважте, що REPL також відображужє результат обчислення ваших виразів.

Ви можете виконувати в REPL всі типи експериментів. Цей приклад показує, як створити та потім виконати метод `sum`: 
[source,scala]
----
scala> def sum(a: Int, b: Int): Int = a + b
def sum(a: Int, b: Int): Int

scala> sum(2, 2)
val res2: Int = 4
----
Якщо ви обираєте онлайн плейграунд, ви також можете використовувати http://scastie.scala-lang.org.

Якщо ви обираєте, замість підказки консолі, писати код в текстовому редакторі, ви можете використовувати _worksheet_.

== Змінні і типи даних

Цей розділ провадить погляд на змінні та типи даних Scala.

=== Два типи змінних

Коли ви створюєте нову змінну в Scala, ви декларуєте, чи буде змінна незмінною аба змінною: 

*Тип*  *Опис*
`val`   Створює _незмінну_ змінну, як `final` в Java. Ви завжди маєте створювати змінні за допомогою `val`, крім наявності причини створити змінну змінну.
`var`   створює _мінливу_ змінну, і має створюватись, тільки коли значення повинне змінюватись у часі.

Наступні приклади показують, як створювати змінні `val` та `var`: 
[source,scala]
----
// незмінна
val a = 0

// змінна
var b = 1
----
В застосуванні `val` не може бути переприсвоєна. Ви отримаєте помилку компілятора, якщо спробуєте зробити переприсвоєння: 
[source,scala]
----
val msg = "Hello, world"
msg = "Aloha"   // помилка; це не буде компілюватись
----
І навпаки, `var` мможе бути переприсвоєна: 
[source,scala]
----
var msg = "Hello, world"
msg = "Aloha"   // це скомпілюється, var може переприсвоюватись
----

=== Декларування типів змінних

Коли ви створюєте змінну, ви можете явно декларувати її тип, або дати компілятору вивести тип самостійно: 
[source,scala]
----
val x: Int = 1   // явний тип
val x = 1        // компілятор виводить тип неявно
----
Друга форма має назву _вивід типу_, і це чудовий спосіб підтримувати код стислим. Компілятор Scala загалом може вивести тип даних, як можна бачити з результатів роботи прикладів в REPL: 
[source,scala]
----
scala> val x = 1
val x: Int = 1

scala> val s = "a string"
val s: String = a string

scala> val nums = List(1, 2, 3)
val nums: List[Int] = List(1, 2, 3)
----
Ви завжди можете явно декларувати тип змінної, якщо бажаєте, але в простих випадках в цьому немає потреби: 
[source,scala]
----
val x: Int = 1
val s: String = "a string"
val p: Person = Person("Richard")
----
Зауважте, що при такому підході код виглядає більш галасливим, ніж потрібно. 

=== Вбудовані типи даних

Scala іде зі стандартними числовими типами, як ви можете очікувать, і вони є повноцінні примірники класів. в Scala будь-що є об'єктом.

Ці приклади показують, як декларувати змінні числових типів: 
[source,scala]
----
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
----
Оскільки `Int` та `Double` є числовими типами по замовчанню, ви зазвичай створюєте їх без явного декларування типу даних: 
[source,scala]
----
val i = 123   //  Int
val j = 1.0   //  Double
----
Також в своєму коді ви можете додати символи `L`, `D`, `F` (та їх прописні еквіваленти) до чисел, щоб вказати що це значення `Long`, `Double` або `Float`: 
[source,scala]
----
val x = 1_000L   // val x: Long = 1000
val y = 2.2D     // val y: Double = 2.2
val z = 3.3F     // val z: Float = 3.3
----
Якщо нам треба дійсно великі числа, використовуйте типи `BigInt` та `BigDecimal`: 
[source,scala]
----
var a = BigInt(1_234_567_890_987_654_321L)
var b = BigDecimal(123_456.789)
----
В той час, як `Double` та `Float` округлюють десяткові числа,`BigDecimal` використовують точну арифметику.

Scala також має типи даних `String` та `Char`: 
[source,scala]
----
val name = "Bill"   // String
val c = 'a'         // Char
----

==== Рядки

Рядки Scala подібні до рядків Java, але мають дві додаткові функції: 

* Вони підтримують інтерполяцію рядків
* Легко створювати багаторядкові рядки

===== Інтерполяція рядків

Інтерполяція рядків провадить дуже наочний шлях для використання змінних в рядках. Наприклад, візьмемо наступні три рядка: 
[source,scala]
----
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
----
Ви можете скомпонувати ці змінні в один рядок таким чином: 
[source,scala]
----
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"
----
Просто поставьте перед рядком літеру `s`, та покладіть символ `$` перед ім'ям іменами ваших змінних всередині рядка.

Щоб вбудувати в рядок довільний вираз, заточіть його в фігурні дужки: 
[source,scala]
----
println(s"2 + 2 = ${2 + 2}")   // друкує "2 + 2 = 4"

val x = -1
println(s"x.abs = ${x.abs}")   // друкує "x.abs = 1"
----
Літера `s` перед рядком є лише одним можливим інтерполятором. Якщо замість `s` ви поставите `f`, ви отримаєте `printf`-подібний синтаксис в рядку. Більше того, інтерполятор є лише спеціальним методом, і ви можете визначати власні. Наприклад, деякі бібліотеки баз даних визначають дуже потужний інтерполятор `sql`.

===== Багаторядкові рядки

Багаторядкові рядки створюються оточенням рядка в потрійні подвійні лапки: 
[source,scala]
----
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
----
  Додактові деталі щодо інтерполяції рядків та багаторядкові рядки дивіться главу _Перший погляд на типи_.

=== Керівні структури

Scala має керівні структури, які ви можете знайти в інших мовах, але також має потужні вирази `for` та `match`: 

* `if/else`
* `for` цикли та вирази
* `match` вирази 
* `while` цикли
* `try/catch`

Ці структури продемонстровані в наступних прикладах.

==== if/else

В Scala керівіна структура `if/else` виглядає подібно до інших мов: 
[source,scala]
----
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
----
Зауважте, що це насправді _вираз - не твердження_. Це означає, що це повертає значення, так що ви можете присвоїти його змінній: 
[source,scala]
----
val x = if a < b then a else b
----
Як ви побачите в цій книжці, в Scala _всі_ контрольні структури можуть використовуватись як вирази.

  Вираз повертає результат, тоді як твердження - ні. Твердження типово використовуються для своїх побічних ефектів, таких, як використання `println` для друку на консолі.

==== for цикли  та вирази

Ключове слово `for` використовується для створення `for` циклу. Приклад показує, як надрукувати всі елементи в `List`: 
[source,scala]
----
val ints = List(1, 2, 3, 4, 5)

for i <- ints do println(i)
----
Код `i <- ints` відомий як _генератор_, а код після `do` складає _тіло_ циклу.

Старий синтаксис для цієї структури виглядав так: 
[source,scala]
----
for (i <- ints) println(i)
----

==== Охоронці

Ви можете також використовувати один або більше `if` в своєму циклі `for`. Це відоме як _охоронці_. Приклад друкує всі числа в `ints`, що більше ніж 2: 
[source,scala]
----
for
  i <- ints
  if i > 2
do
  println(i)
----
Ви можете використовувати декілька генераторів та охоронців. Цей цикл ітерує по числах від 1 до 3, і для кожного ітерує по символах від `a` до `c`. Однак ми також маємо два охоронці, так що друкується тільки рядок, коли `i` дорівнює 2, а `j` - символу `b`: 
[source,scala]
----
for
  i <- 1 to 3
  j <- 'a' to 'c'
  if i == 2
  if j == 'b'
do
  println(s"i = $i, j = $j")   // друкує: "i = 2, j = b"
----

==== for вирази

Ключове слово `for` має ще більші можливості: якщо ви, замість `do` використати `yeld`, ви створите _вираз_ `for`, що обчислює та видає результати.

Декілька прикладів демонструють це. Використовуючи той самий список `ints`, що і в попередньому прикладі, цей код генерує новий список, де кожне значення елементу в новому списку є подвоєне значення в оригінальному списку: 
[source,scala]
----
scala> val doubles = for i <- ints yield i * 2
val doubles: List[Int] = List(2, 4, 6, 8, 10)
----
Синтаксис керівних структур Scala гнучкий, і той самий вираз `for` може бути записаний різними шляхами, за вашим вподобанням: 
[source,scala]
----
val doubles = for i <- ints yield i * 2 // стиль, показаний вище
val doubles = for (i <- ints) yield i * 2
val doubles = for (i <- ints) yield (i * 2)
val doubles = for { i <- ints } yield (i * 2)
----
Наступний приклад показує, як капіталізувати кожний рядок зі списку: 
[source,scala]
----
val names = List("chris", "ed", "maurice")
val capNames = for name <- names yield name.capitalize
----
Нарешті, цей `for` вираз ітерує по списку рядків, та повертає довжину кожного рядка, але тільки якщо ця довжина більше чотирьох: 
[source,scala]
----
val fruits = List("apple", "banana", "lime", "orange")

val fruitLengths = for
  f <- fruits
  if f.length > 4
yield
  // тут може бути більше рядків
  f.length

// fruitLengths: List[Int] = List(5, 6, 6)
----
Цикли та вирази `for` розглядаються більш детально в розділі _Керівні структури_ та в референсній документації.

==== `match` вирази

Scala має вираз `match`, який в простіший формі використання подібний до Java `switch`: 
[source,scala]
----
val i = 1

// далі в коді ...
i match
  case 1 => println("one")
  case 2 => println("two")
  case _ => println("other")
----
Однак, насправді `match` є виразом, що означає, що він повертає результат на основі порівняння шаблонів, що може бути прикріплене до змінної: 
[source,scala]
----
val result = i match
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
----
`match` не обмежений робити з цілими значеннями, він може використовуватись з любими типами даних: 
[source,scala]
--------
val p = Person("Fred")

// далі в коді
p match
  case Person(name) if name == "Fred" =>
    println(s"$name says, Yubba dubba doo")

  case Person(name) if name == "Bam Bam" =>
    println(s"$name says, Bam bam!")

  case _ => println("Watch the Flintstones!")
--------
Фактично, вираз `match` може бути використаний для перевірки змінної по багатьом різним типам шаблонів. Приклад показує, (а) як використовувати вираз `match` в якості тіла метода, та (б) як порівнювати різні типи: 
[source,scala]
----
// getClassAsString - метод, що приймає любий тип
def getClassAsString(x: Matchable): String = x match
  case s: String => s"'$s' is a String"
  case i: Int => "Int"
  case d: Double => "Double"
  case l: List[_] => "List"
  case _ => "Unknown"

// приклади
getClassAsString(1)             // Int
getClassAsString("hello")       // 'hello' типу String
getClassAsString(List(1, 2, 3)) // List
----
Метод `getClassAsString` приймає як параметр значення типу `Matchable`, що може бути любим типом, що підтримує порівняння шаблонів (деякі типи не підтримують порівняння, бо це може зламати енкапсуляцію).

Є ще _дуже багато_ чого стосовно порівнянь шаблонів в Scala. Шаблони можуть бути вкладені, результати шаблонів можуть бути захоплені, і саме порівняння може визначатись власним кодом. Дивіться приклади порівнянь в главі Структури керування.

==== try/catch/finally

Керівна структура `try/catch/finally` в Scala дозволяє вам перехоплювати виключення. Це подібне до Java, але синтаксис узгоджений з виразами `match`: 
[source,scala]
----
try
  writeTextToFile(text)
catch
  case ioe: IOException => println("Got an IOException.")
  case nfe: NumberFormatException => println("Got a NumberFormatException.")
finally
  println("Clean up your resources here.")
----

==== `while` цикли

Scala також має конструкцію циклу `while`. Його одно-рядковий синтаксис виглядає так: 
[source,scala]
----
while x >= 0 do x = f(x)
----
Scala 2 має дещо інший синтаксис: умова була оточена дужками, та не було ключового слова `do`: 
[source,scala]
----
while (x >= 0) { x = f(x) }
----
Scala 3 все ще підтримує синтаксис Scala 2 в цілях сумісності.

Багато-рядковий синтаксис циклу `while` має наступний вигляд: 
[source,scala]
----
var x = 1

while
  x < 3
do
  println(x)
  x += 1
----

==== Власні керівні структури

Завдяки таким можливостям, як `by-name` параметри, інфіксна нотація, гнучки інтерфейси, опціональні дужки, методи розширення та функції вищого гатунку, ви можете створити ваш власний код, що робитиме як керівна структура. Ви найдете більше про це в _Керівні структури_.
