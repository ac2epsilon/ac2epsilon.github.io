<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Програмування на Scala 2ed Перекладено українською</title>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
          .refer {
            color: darkgrey; 
            font-size: small;
          }
          h1{
           color: white;
          }
          h2{
           color: white;
          }
          h3 {
           color: white;
          }
          h4 {
           color: white;
          }
          body {
           color: #6fcde8; 
 				   background-color: #21211f;
           font-family: "Verdana", Arial, sans;
           font-size: 1.2em; 
					}
        </style>
  </head>
  <body>
    <address> Перекладено українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <h1 style="text-align: center;">Програмування на Scala</h1>
    <h1 style="text-align: center;">Друга редакція</h1>
    <p style="text-align: center;">Martin Odersky - Lex Spoon - Bill Venner</p>
    <h3>Глава 1</h3>
    <h2>Маштабована мова</h2>
    <p>Ім'я Scala означає "маштабована мова". Мова названа так, оскільки вона
      розроблена до зростання за потребами користувача. Ви можете застосувати
      Scala до широкого диапазона програмних завдань, від написання малих
      скриптів, до побудови великих систем. </p>
    <p>До Scala легко дістатись. Вона робить на стандартній платформі Java, та
      взаємодіє без проблем з усіма бібліотеками Java. Це досить гарна мова для
      написання скриптів, що поєднують разом Java компоненти. Але вона може
      застосувати свої сильні сторони навіть більше, при побудові великих систем
      та фреймворків повторно застосованих компонент. </p>
    <p>Технічно, Scala є сумішшю об'єктно-орієнтовної, та функціональної
      концепції статично типізованої мови. Сплав об'єктно-орієнтованого та
      функціонального програмування проявляє себе в багатьох аспектах Scala; це,
      можливо, більш поширено, ніж в інших, широко застосованих, мовах. Два
      програмні стилі мають доповнюючу силу, коли доходить до маштабованості.
      Конструкції функціонального програмування Scala спрощують швидку побудову
      цікавих речей з простих частин. Її об'єктно-орієнтовні конструкції
      спрощують структурування більших систем, та їх адаптацію до нових вимог.
      Комбінація обох стилів в Scala робить можливим виразити нові різновиди
      шаблонів програмування та абстракції компонент. Це також призводить до
      розбірливого та стислого стилю програмування. Та, оскільки це так
      піддатливе, програмування на Scala може буде дуже приємним. </p>
    <p>Перший розділ відповідає на питання "Чому Scala?". Він дає високорівневий
      погляд да дизайн Scala, та на міркування, що стоять за цім. Після читання
      глави ви повинні отримати базове відчуття, для чого створена Scala, та що
      за типи завдань вона може допомогти вам вирішити. Хоча це книга є
      підручникок зі Scala, ця глава насправді не є частиною підручника. Якщо ви
      прагнете почати писати деякий Scala код, ви можете перейти до Глави 2.</p>
    <h3>1.1 Мова, що зростає разом з вами</h3>
    <p>Програми різного розміру мають схильність потребувати різних програмних
      конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p>
    <pre class="prettyprint linenums language-scala"> var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
      capital += ("Japan" -&gt; "Tokyo")
      println(capital("France"))</pre>
    <p>Ця програма встановлює відображення між країнами, та їх столицями,
      модифікує мапу додаванням нової прив'язки ("Japan" -&gt; "Tokyo"), та
      друкує столицю, асоційовану з країною France. Нотація цього прикладу є
      високорівневою, та не захаращена додатковими крапками та комами, або
      анотаціями типів.Таким чином, вона відчувається як "скриптова" мова, як
      Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що
      відноситься до прикладу вище, в тому, що вони всі підтримують конструкцію
      "асоціативної мапи" в синтаксисі самої мови. </p>
    <p>Асоціативні мапи дуже корисні, оскільки вони допомагають утримувати
      програми розбірливими та стислими. Однак, іноді ви можете на погодитись з
      їх філософією "один розмір для всіх", оскільки вам треба контролювати
      властивості мап, що ви використовуєте в вашій програмі, в більш
      гарно-гранульований спосіб. Scala надає вам цей гарно-гранульований
      контроль, якщо він вам потрібен, оскільки мапи в Scala не є синтаксисом
      мови. Вони є бібліотечними абстракціями, що можна розширити та адаптувати.
    </p>
    <p>В програмі вище ви отримаєте реалізацію Map по замовчанню, але ви можете
      легко змінити це. Ви можете, наприклад, вказати певну реалізацію, таку, як
      HashMap або TreeMap, або ви можете вказати, що мапа повинна бути
      потік-безпечною, змішуючи трейт SynchronizedMap. Ви можете вказати
      значення по замовчанню для мапи, або ви можете перевизначити любий інший
      метод мапи, що ви створюєте. В жодному разі, ви можете використовувати той
      же простий синтаксис доступу до мап, як в прикладі вище.</p>
    <p>Цей приклад показує, що Scala може дати вам обоє, зручність та гнучкість.
      Scala має набір зручних конструкцій, що допомагаються вам швидко
      розпочати, та дозволяє вам програмувати в приємно узгодженому стилі. В той
      же час, ви маєте гарантції, що ви не пеерростете мову. Ви завжди можете
      підкроїти програму до ваших вимог, оскільки все базується на бібліотечних
      модулях, що ви можете обирати та адаптувати, як вам треба.</p>
    <h3>Вирощування нових типів</h3>
    <p>Eric Raymond ввів собор та базар як дві метафори розробки програмного
      забезпечення. Собор є майже-досконалою будівлею, що дуже довго будувати.
      Коли побудований, він стоїть незмінним довгий час. Базар, на відміну,
      адаптується та розширюється кожного дня, людьми, що роблять на ньому. В
      роботі Raymond базар є метафорою для розробки софтверу з відкритим кодом.
      Guy Steele зауважив в розмові про "зростаючу мову", що ту ж відмінність
      можна застосувати до розробки мови. Scala є більше схожою на базар, ніж на
      собор, в тому сенсі, що вона розроблена бути розширеною та адаптованою
      людьми, що програмуються на ній. Замість провадження всіх конструкцій, що
      вам можуть будь-коли знадобитись в одній, "абсолютно повній" мові, Scala
      надає в ваші руки інструменти для побудови таких конструкцій.</p>
    <p>Ось приклад. Багато застосувань потребують тип цілого, що може ставати
      доволі великим, без переповнень та усічень арифметичних операцій. Scala
      визначає такий тип в бібліотечному типі scala.BigInt. Ось визначення
      методу, що використовує цей тип, який обчислює факторіал переданого цілого
      значення:</p>
    <pre class="prettyprint linenums language-scala">        def factorial(x: BigInt): BigInt =<br>	if (x == 0) 1 else x * factorial(x - 1)</pre>
        <p>Тепер, якщо ми викличемо factorial(30), ми отримаємо:</p>
        <pre class="prettyprint linenums language-scala">	265252859812191058636308480000000</pre>
        <p>BigInt виглядає як вбудований, оскільки ви можете використовувати цілі літерали та операції, такі як * та - зі значенями цього типу. Але це тільки клас, що був визначений в стандартній бібліотеці Scala. 
          Якщо б такого класу не було, було б доцільним кожному програмісту на Scala написати реалізацію, наприклад, огорнути 
          Java клас java.math.BigInteger (фактично,&nbsp; це те, як реалізовано Scala BigInt).</p>
        <p>Звичайно, ви можете також використовувати Java клас напряму. Але результат і близько не такий приємний, 
          оскільки, хоча Java дозволяє вам створити нові типи, вони не відчуваються як природно підтримувані мовою:</p>
        <pre class="prettyprint linenums language-scala">import java.math.BigInteger
def factorial(x: BigInteger): BigInteger =
  if (x == BigInteger.ZERO)
    BigInteger.ONE
  else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))</pre>
        <p>BigInt є представником значно більшого переліку число-подібних типів — великих з десятичною крапкою, комплексних чисел, дійсних чисел, довірчих інтервалів, многочленів&nbsp; — це список можна продовжувати. Деякі мови програмування реалізують деякі з ціх типів природно. Наприклад, Lisp, Haskell, Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але жодна мова, що намагалась реалізувати 
          всі ці абстракції одночасно буде просто завеликою, щоб бути керованою. Що найбільше, навіть, якщо застосування будуть напевне 
          мати вигоду від інших число-подібних типів, що не підтримуються. Так що підхід намагання провадити все в рамках мови не буде маштабуватись дуже гарно. </p><p>Замість цього, Scala дозволяє користувачам зростати та адаптувати мову в потрібному їм напрямку, визначаючи прості для використання бібліотеки, що відчуваються як природна підтримка мовою.</p><h3>Вирощування нових структур керування</h3><p>Попередній приклад демонструє, що Scala дозволяє вам додавати нові типи, що можуть бути використані&nbsp; як зручні вбудовані типи. Той же принцип розширення також стосуєтсья до структур керування. Цей різновид розширюваності проілюстровано в Scala API для конкурентного програмування "на акторах".</p><p>Позаяк мультиядерні процесори розповсюджуються в останні роки, досягнення прийнятної продуктивності може все більше потребувати, щоб ви використовували більше паралелізму в ваших застосуваннях. Часто це означає переписування вашого кода, так, щоб обчислення були розпорошені між декільками конкурентними потоками. На жаль, створення надійних багато-поточних застосувань на практиці було визнане неабияким викликом. Модель потоків&nbsp;Java побудована коло розділеної пам'яті та блокувань, модель, що часто складно продумати, особливо з тим, як система маштабується в розмірі та складності. Є складним впевнитись, що ви не маєте стану гонок або не притаїлося глухе блокування — іноді це не можливо показати під час тестувань, але може проявити себе під час використання. Доказово безпечнішою альтернативою є передача повідомлень, така, яку мова програмування Erlang використовує за допомогою "акторів".</p>Java іде з багатою, базованою на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, як і інші Java API. Однак, Scala також пропонує додаткову бібліотеку, що в основному реалізує модель акторів Erlang.<p>
        Актори є абстракціями конкурентності, що можуть бути реалізовані поверху потоків. 
        Вони комунікіють, надсилаючи повідомлення один одному. 
        Актор може виконувати дві базові операції, надсилання та отримання повідомлення. 
        Операція надсиланя, що виглядає як наголос (!), надсилає повідомлення до актора. Ось приклад, в якому актор названий recipient:
        </p>
        <pre class="prettyprint linenums language-scala">recipient ! msg</pre>
        <p>Надсилання є асинхронним; тобто, відсилаючий актор може продовжувати безпосередньо, без очікування, що повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, де входящі повідомлення ставляться в чергу. Актор обробляє прибувше до поштової скриньки через блок receive:
        </p>
        <pre class="prettyprint linenums language-scala">receive {<br>  case Msg1 =&gt; ... // обробляємо Msg1
  case Msg2 =&gt; ... // обробляємо Msg2<br>// ...
        }</pre>
        <p>Блок receive складається з декількох випадків, що ставить запити до поштової скриньки з шаблоном повідомлення. 
          Перше повідомлення в поштовій скриньці, що співпаде з любим з випадків, та відповідний актор, що виконує його. 
          Якщо поштова скринька не містить жодних повідомлень, що співпадають з наданою умовою, актор призупиняється, та 
          очікує на подальші входящі повідомлення.</p><p>Як приклад, ось простий актор Scala, що реалізує сервіс калькулятора 
        контрольної суми:</p>
        <pre class="prettyprint linenums language-scala">actor {
var sum = 0
loop {
  receive {
    case Data(bytes)
		  =&gt; sum += hash(bytes)<br>case GetSum(requester) =&gt; requester ! sum
    }
  }
}</pre><p>Цей актор спочатку визначає локальну змінну, на ім'я sum, з початковим значенням нуль. Потім він постійно очікує в циклі надходження повідомлень, використовуючи твердження. Якщо він отримує повідомлення Data, він додає хеш надісланих байтів да змінної суми. Якщо він отримує повідомлення GetSum, 
        він надсилає поточне значення суми назад, до запитуючого, використовуючи повідомлення через requester ! sum. Поле requester вбудоване в повідомлення GetSum; воно звичайно посилається на актора, що зробив запит.</p><p>Ми не очікуємо, що ви повністю розумієте приклад з актором в цій точці. Скоріше, що важливе щодо цього приклада для теми маштабовності, це те, що ні актор, ні цикл, ні надсилання повідомлення (!) не є вбудованими операціями Scala. Навіть не зважаючи на те, що актор, цикл, та receive виглядають та діють як керівні вбудовані структури, як цикли while або for, вони, фактично, є методами, визначеними в бібліотеці акторів Scala. Таким же чином, навіть якщо ‘!’ виглядає як вбудований оператор, це також тільки метод, визначений в бібліотеці акторів. Всі ці чотири конструкції є повністю незалежні від мови програмування Scala.</p><p>Блок receive та синтаксис (!) виглядає в Scala більше як в Erlang, але в Erlang ці конструкції вбудовані в мову. Scala також реалізує більшість з інших конструкцій конкурентності Erlang, таких, як моніторинг схибивших акторів та тайм-аути. </p><p>Так чи інакше, актори перетворились на дуже приємні умови для виразу конкурентних та розподілених обчислень. Навіть зважаючи, що вони визначені в бібліотеці, актори відчуваються як невід'ємна частина мови Scala.</p><p>Цей приклад ілюструє, що ми можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Щоб бути переконаним, вам знадобляться гарні архитектори та програмісти, щоб зробити це. Але наріжна річ в цьому є розробка та реалізація абстракцій в Scala, що адресують радикально нові галузі застосування, що все ще відчуваються як природна підтримка мови.</p><h3>1.2&nbsp; Що робить Scala маштабованою?</h3><p>Маштабованість складається з багатьох факторів, починаючи з деталей синтаксису, до конструктивів абстракції компонентів. Однак, якщо ви змушені назвати тільки один аспект Scala, що допомагає маштабованості, ми обираємо комбінацію з об'єктно-орієнтованого та функціонального програмування (гаразд, ми прибрехали, це насправді два аспекта, але вони пов'язані).</p><p>Scala іде далі, ніж всі інші, гарно відомі, мови, в сплавленні програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції, як дві різні концепції, в Scala значення функції є об'єктом. Функціональне значення є об'єктом. Функціональні типи є класами, що можуть наслідуватись суб-класами. Це може виглядати як не більше, ніж академічна тонкість, але це має глибокі наслідки для маштабовності. Фактично, концепція акторів, показана раніше, не може бути реалізована без уніфікації функцій та об'єктів. Цей розділ дає огляд спсобу Scala змішування об'єктно-орієнтовної та функціональної концепцій. </p><h4>Scala є об'єктно-орієнтованою</h4><p>Об'єктно-орієнтовано програмування було дуже успішним. Починнаючи з Simula в середині 60х, та Smalltalk в 70х, тепер воно доступне для більшості мов. В деяких галузях об'єкти захопили все повністю. Хоча немає точного визначення, що значить об'єктно-орієнтований, напевне є щось щодо об'єктів, що приваблює програмістів. </p><p>В принципі, мотивація для об'єктно-орієнтованого програмування є дуже простою: всі, окрім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, є покласти дані та операції в деяку форму контейнера. Велика ідея об'єктно-орієнтованого програмування є зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як дані, та що вони сами по собі є значеннями, що можуть зберігатись в інших контейнарах, або передані як параметри до операцій. Такі контейнер називаются об'єктами. Alan Kay, розробник Smalltalk, зауважив, що, таким чином, простіший об'єкт має ту ж принципіальну конструкцію, що і цілий комп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом. Так що об'єкти мають безпосереднє відношення до маштабованості мови: ті ж прийоми стосуються до конструкції малих, так само як і великих, програм.</p>Навіть хоча об'єктно-орієнтоване програмування було головним напрямком на протязі довгого часу, є відносно небагато мов, що послідували за Smalltalk в просуванні принципу побудови до його логічного завершення. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні типи в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтованого програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнювать речі та обмежувати маштабованість.<p>На відміну, Scala є об'єктно-орієнтованою мовою в чистій формі: кожне значення є об'єктом, та кожна операція є виклик метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви, насправді, викликаєте метод&nbsp; +, визначений на класі Int. Ви можете визначити методи з іменами, схожими на оператори, що клієнти вашого API, потім можуть використовувать їх в операторній нотації. Це той спосіб, як API акторів Scala дозволяють вам використовувати вирази, такі як requester ! sum, показаний в попередньому прикладі: ‘!’ є методом класа Actor.</p><p>Scala є більш просунутою, ніж більшість інших мов, коли йдеться до компонування об'єктів. Прикладом є трейти Scala. Трейти як інтерфейси в Java, але вони також можуть мати реалізації методів, та навіть поля. Об'єкти конструюються через міксування композицій, що бере члени класа, та додає до них члени декількох трейтів. Таким чином, різні аспекти класів можуть бути інкапсульовані в різних трейтах. Це виглядає трохи подібним на множинне наслідування, але починає відрізнятись, коли доходить до деталей. на відміну від класа, трейт може додати деяку нову функціональність до невизначеного класа. Це робить трейт більш "плугабельним", ніж класи. Зокрема це виключає класичну проблему "діамантового наслідування" множинного наслідування, що постає, коли той же клас наслідується через декілька різних шляхів. </p><h4>Scala є функціональною</h4><p>На додаток до того, що це об'єктно-орієнтована мова, Scala є також повноцінною функціональною мовою. Ідеї функціонального програмування є старіші, ніж (електронні) комп'ютери. Їх основи були покладені в лямбда-численні Alonzo Church, що розроблене в 1930х. Перша функціональна мова програмування була Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. На протязі довгого часу, функціональне програмування було дещо на обочині, популярне в академічному середовищі, але широко не використовувалось в індустрії. Однак, останні роки показують зростаючу зацікавленість в мовах функціонального програмування та технологіях.</p><p>Функціональне програмування керується двома ідеями. Перша ідея полягає в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з таким же статусом, що і, скажімо, цілі або рядки. Ви можете передати функцію як аргумент до інших функцій, повернути як результат з функції, або зберігти в змінінй. Ви також можете визначити функцію в іншій функції, так, як ви можете визначити ціле значення в функції. Та ви можете визначити функції, давши їм ім'я. Зрошування вашого кода функціональними літералами таке просте, як ви можете записати літерал 42. </p><p>Функції, що є першокласними значеннями, провадять зручний спосіб для абстрагування над операціями, та створення нових структур керування. Це узагальнення провадить величезну виразність, що часто приводить до дуже розбірливих та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, конструкція receive, показана вище, в прикладі актора, є викликом метода, що приймає функцію як аргумент. Код всередині конструкції receive є функція, що передається без виконання в метод receive.</p><p>В більш традиційних мовах, на відміну від цього, функції не є значеннями. Мови, що мають значення функцій, часто зводять їх до другорядного статуса. Наприклад, вказівники на функцію в C та C++ не мають того ж статуса, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись лише на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення зі свого оточення. Також вони не дозволяють вам визначати безіменні функціональні літерали.&nbsp;</p><p>Друга головна ідея функціонального програмування полягає в тому, що операції програми повинні відображати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці. Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масивом символів. Символи в рядку можна змінити індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку та одну крапку, в тому ж об'єкті рядка. В Java та Scala, з іншого боку, рядок є послідовність символів в математичному сенсі. Заміна символа в рядку з використання виразу, як s.replace(';', '.') дає новий об'єкт рядка, що відрізняється від s. Інший шлях виразити це - сказати, що рядки є незмінні в Java, хоча вони змінні в Ruby. Так що дивлячись лише на рядки, Java є функціональною мовою, тоді як Ruby - ні. Незмінні структури даних є одним з наріжних каменів функціонального програмування. Бібліотеки Scala визначають багато незмінних типів даних, зверху тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, кортежі, мапи та набори.</p><p>Інший шлях викласти цю другу ідею функціонального програмування, це те, що метод не повинен мати жодних побічних ефектів. Вони мають комунікувати зі своїм оточенням, тільки приймаючи аргументи, та повертаючи результати. Наприклад, метод заміни в класі&nbsp; Java String підходить до цього критерію. Він приймає рядок та два символа, та дає новий рядок, де всі входження одного символа замінені на інший. Немає іншого ефекту при виклику replace. Методи, як replace, називаються референтно прозорими, що означає, що кожний наданий вхід при виклику метода може бути замінений результатом, без валиву на семантику програми.</p><p>Функціональні мови заохочують незмінні структури даних та референтно прозорі методи. Деякі функціональні мови навіть потребують їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є програмуванням зі змінним станом та побічними ефектами. Але Scala загалом робить легким уникати імперативних конструкцій, за вашим бажанням, оскільки існують гарні функціональні альтернативи. </p><h3>1.3 Чому Scala?</h3><p>Чи є Scala для вас? Ви можете зрозуміти та вирішити для себе. Ми винайшли, що насправді є багато причин, окрім маштабованості, щоб вподобати програмування на Scala. Ми в цьому розділі обсудимо чотири найбільш важливі акпекти: сумісність, стислість, високорівневі абстракції, та просунута статична типізація.</p><h4>Scala є сумісною</h4><p>Scala не потребує, щоб ви зістрибували з Java платформи, щоб піти далі від мови Java. Вона дозволяє вам додати вартість до існуючого кода — будувати на тому, що ви вже маєте — оскільки вона була розроблена для безтурботної взаємодії з Java. Програми Scala компілюються в байткоди JVM. Їх швидкість виконання звичайно на рівних з програмами Java. Код Scala може викликати методи Java, мати доступ до полів Java, наслідувати від класів Java, та реалізувати Java інтерфейси. Жодне з цього не потребує спеціального синтаксису, явних дескрипторів інтерфейсу або зкліючого коду. Фактично, майже весь код Scala потужно використовує біблиотеки Java, часто без того, щоб ставити до відома програміста про цей факт.</p><p>Інший аспект повної сумісності в тому, що Scala потужно використовує типи Java. Scala Int представлені як примітивні цілі Java типу int, Float представлені як float, Boolean як boolean, і так далі. Масиви Scala відображуються на масиви Java. Scala також використовує багато стандартних бібліотечних типів Java. Наприклад, тип рядка "abc" в Scala є java.lang.String, та викликане виключення має бути субкласом java.lang.Throwable.</p><p>Scala не тільки використовує типи Java, але також "принаряджає їх", щоб зробити їх кращими. Наприклад, рядки Scala підтримують методи, як toInt або toFloat, що конвертують рядок на ціле число або число з плаваючою крапкою. Так що ви можете писати str.toInt, замість Integer.parseInt(str). Як це може бути досягнуто без поломки сумісності? Клас Java String напевне ме має методу toInt! Фактично, Scala має дуже загальне рішення, щоб вирішити це напруження між просунутим дизайном бібліотеки, та сумісністю. Scala дозволяє вам визначити неявні перетворення, що завжди застосовуються, коли типи не співпадають звичайно, або коли обираються неіснуючі члени. В випадку вище, коли поглянете на метод toInt на рядкові, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String в примірник класу Scala StringOps, що визначає такий член. Перетворення буде застосоване неявно перед викоранням операції toInt.</p><p>Код Scala може бути викликаний з кода Java. Це іноді трохи більш тонке, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш просунутих можливостей Scala повинні бути закодовані, перед тим, як вони можуть бути відображені на Java. Глава 31пояснює деталі.</p><h4>Scala є стислою</h4><p>Програми Scala схильні бути короткими. Програмісти Scala повідомляли про зменшення числа рядків до десяти разів, порівняно з&nbsp; Java. Це може бути екстремальним випадком. Більш консервативне очікування може полягати в тому, що типова програма на Scala повинна мати половину чила рядків, для тієї ж програми, написаної на Java. Менше рядків кода означає не тільки менше друку, але також менше зусиль при читанні та розумінні програм, та менше можливостей для дефектів. Є декілька факторів, що мають причетність до цього зменшення числа рядків.&nbsp;</p><p>Перше, синтаксис Scala уникає деяких шаблонів, що захаращують Java програми. Наприклад, крапка з комою опціональні в Scala, та, зазвичай, відкидаються. Є також декілька інших областей, де синтакис Scala менш шумний. Для прикладу порівняйте, як ви пишете класи та конструктори в Java та Scala. 
        В Java, клас з конструктором часто виглядає подібно до наступного:</p>
        <pre class="prettyprint linenums language-java">// це Java<br>class MyClass {
    private int index;
    private String name;
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    }
}</pre>В Scala, ви, напевне, замість цього напишите таке:
        <pre class="prettyprint linenums language-scala">class MyClass(index: Int, name: String)</pre>
        <p>Маючи цей код, компілятор Scala спродукує клас, що має дві приватних змінних примірника, Int з іменем index, String з іменем name, та конструктор, що приймає початкові значення для ціх змінних, в якості параметра. Код цього констректора буде ініціалізувати дві змінні екземпляра значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча версія на Java. Клас Scala швидше написати, простіше читати, та, що більше важливо, меньше схильний до помилок, ніж клас Java.</p><p>Вивід типів Scala є іншим фактором, що докладається до стислості. Повторювана інформація про типи може бути відкинута, так що програми стають менш захаращені, та біль читабельні.</p><p>Але, можливо, найбільш важливий ключ до компактного коду є те, що вам не треба писати, бо воно вже реалізоване в бібліотеці за вас. Scala дає вам багато інструментів для визначення потужних бібліотек, що дозволяють вам захопити та примножити загальну поведінку. Наприклад, різні аспекти бібліотечних класів можуть бути виділені в трейти, що потім можуть бути зміксовані разом в гнучкий спосіб . Або бібліотечні методи можуть бути параметризовані операціями, що дозволяє визначити конструкції, які ефективно є вашими структурами керування. Разом ці конструкції дозволяють визначати бібліотеки, що обоє, високорівневі, та гнучкі у використанні.</p><h4>Scala є високорівневою</h4><p>Програмісти постійно стикаються зі складністю. Для продуктивного програмування ви повинні розуміти код, з яким працюєте. Дуже складний код спричинив повалення багатьох софтверних проектів. На жаль, важливі програми часто мають складні вимоги. Такої складності можна уникнути; замість цього єю можна керувати. </p><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракцій в інтерфейсах, що ви розробляєте та використовуєте. Як приклад, уявіть, що ви маєте змінну String name, та ви бажаєте знайти, чи містить, чи ні, ця змінна типу String великі літери. В Java ви можете написати таке:</p>
        <pre class="prettyprint linenums language-java">// це Java
boolean nameHasUpperCase = false;
for (int i = 0; i &lt; name.length(); ++i) {
   if (Character.isUpperCase(name.charAt(i))) {
       nameHasUpperCase = true;
       break;
   }
}</pre>
        <p>На Scala це можна записати так:</p>
        <pre class="prettyprint linenums language-scala">val nameHasUpperCase = name.exists(_.isUpper)</pre>
        <p>Код Java сприймає рядки як низькорівневі сутності, що проходяться в циклі символ за символом. Код Scala трактує той же рядок як послідовність вищого порядку, що може бути опитаний за допомогою предикатів. Ясно, що код Scala більш короткий, та, для треновоного ока, простіший для розуміння, ніж код Java. Так що код Scala менше тисне на загальний бюджет складності. Він також дає вам менше можливостей зробити помилку.&nbsp;</p><p>Предикат _.isUpper є прикладом функціонального літерала в Scala. Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи він є великою літерою.</p><p>В принципі, такі керівні абстракції також можливі і в Java. Вам треба визначити інтерфейс, що містить метод з абстрактною функіональністю. Наприклад, якщо ми бажаємо підтримувати запити до рядків, ви можете ввести інтерфейс, названий CharacterProperty, що має тільки один метод, hasProperty:</p>
        <pre class="prettyprint linenums language-java">// це Java
interface CharacterProperty {
   boolean hasProperty(char ch);
}</pre>
        <br>
        З таким інтерфейсом ви можете зформулювати на Java метод exists: він приймає рядок та CharacterProperty, та повертає true, якщо символ в рядку задовільняє властивості. Ви можете потім викликати exists наступним чином:
        <pre class="prettyprint linenums language-java">// це Java
exists(name, new CharacterProperty() {
    public boolean hasProperty(char ch) {
    	return Character.isUpperCase(ch);
    }
});</pre><p>Але все це, скоріше, заважке. Таке заважке, фактично, що більшість Java програмістів не будуть з цім поркатись. Вони тільки напишуть цикли, та полишать це з додатковою складністю кода. З іншого боку, літеральні функції в Scala є теж легковажними, так що вони часто використовуються. По мірі, як ви пізнаваємете Scala краще, ви винайдете більше і більше можливостей визначати та використовувати свої власні абстракції керування. Ви найдете, що це дозволяє уникати дублікації кода, і, таким чином, утримувати ваші програми коротшими та яснішими. </p><h4>Scala є статично типізованою</h4><p>Статична система типів класифікує змінні та вирази, відповідно до властивостей значень, що вони містять та обчислюють. Scala вирізняється як мова з дуже просунутою системою статичних типів. Починаючи з системи вкладених типів класів, здебільшого як в Java, вона дозволяє параметризувати типи дженеріками, комбінувати типи з використанням перетинів, та приховувати деталі типів, використовуючи абстрактні типи. Це покладає сильне підгрунтя для побудови та компнування ваших власних типів, так що ви можете розробити інтерфейси, що, одночасно, безпечні, та гнучкі до використання.</p><p>Якщо ви вподобали динамічні мови, як Perl, Python, Ruby або Groovy, ви можете знайти це досить дивним, що система статичних типів в Scala перелічується як одна з її сильних сторін. В кінці кінців, відсутність статичної системи типізації визначається деякими як найбільша перевага динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми дуже балакучими, заважають програмістам виражати себе в бажаний спосіб, та роблять неможливим деякі шаблони динамічних модифікацій програмних систем. Однак, часто ці аргументи не ідуть в розріз з ідеєю статичних типів загалом, але проти окремих систем типів, що сприймаються як дуже балакучі та дуже негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись зауважив: "Я не проти типів, вле я не знаю про жодну систему типів, що не є суцільною боллю, так що мені подобається динамічна типізація". Ми сподіваємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільної болі". Фактично, вона гарно адресована до двох звичайних занепокоєнь щодо статичної типізації: галасливість уникається через вивід типів, та гнучкість досягається через співпадіння шаблонів, та декілька нових способів писати та компонувати типи. Коли прибрані ці перешкоди, класичні вигоди статичних систем типів можуть бути краще оценені. Серед найбільш важливих з ціх переваг є перевірка властивостей програмних абстракцій, безпечний рефакторинг, та краща документація.</p><p><em><strong>Перевірка властивостей. </strong></em>Статичні системи типів можуть довести відсутність окремих помилок часу виконання. Наприклад, вони можуть підтвердити властивості, як: логічні ніколи не додаються до цілих; приватні змінні не отримуються доступ поза меж їхнього класу; функції застосовуються до вірно числа аргументів; до набору рядків додаються тільки рядки.</p><p>Інші типи помилок не визначаютьсь сучасними системами статичних типів. Наприклад, вони, звичайно, не помічають не-терміновані функції, порушення меж масиву, або ділення на нуль. Вони також не помічають, що ваша програма не відповідає своїй специфікації (будемо вважати, що така специфікація є!). Статичні системи типів мають, таким чином, розвінчані деякими, як ті, що не є дуже корисними. Аргумент, що слідує за цим, полягає в тому, що системи типів можуть детектувати тільки прості помилки, тоді як юніт тести провадять більш ексенсивне охоплення, то чому взагалі поратись зі статичними типуми? Ми вважаємо, що ці аргументи не мають сенсу. Хоча статичні системи типів, безумовно, не можуть замінити юніт тести, мони можуть зменшити число потрібних юніт тестів, турбуючись про деякі властивості, що в іншому випадку потребували б тестування. Так само, як і юніт тести не можуть замінити статичні типи. В кінці кінців, як сказав Edsger Dijkstra, тестування може лише довести наявність помилок, але ніколи їх відсутність. Так що гарантії, що дає статична типізація, можуть бути простими, але це реальні гарантії, в формі, що не можуть дати купа тестів. </p><p><em><strong>Безпечний рефакторинг.</strong></em> Статична система типів провадить строховочну сітку, що дозволяє вам робити зміни в кодовій базі, з високою ступінню довіри. Уявімо, наприклад, рефакторинг, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто виправити всі рядки, що спричинили помилку. Коли ви скінчите з цім, ви будете впевнені, що знайшли всі місця, що потребували змін. Те ж вірно для багатьох інших простих рефакторингів, як зміна імені метода, або переміщення метода з одного класа до іншого. В усіх випадках перевірка статичного типу буде провадити досить страховки, що нова система буде робити, як стара.</p><p><em><strong>Documentation.</strong></em> Статичні типи є документацією програми, що перевірена компілятором на коректність. На відміну від звичайних коментарів, анотація типу ніколи не буде простроченою (щонайменьше, ні, якщо початковий файл, що містить її, був нещодавно проходив через компілятор). Більше того, компілятори та інтегровані середвища розробки можуть використовувати анотації типів, щоб провадити кращу контекстну допомогу. Наприклад, інтегроване середовище розробки може відображати всі члени, доступні для вибору, визначаючи статичний тип виразу, на якому зроблений вибір, та переглядаючи всі члени цього типу.</p><p>Навіть зважаючи, що статичні типи загалом корисні для документації програми, вони можуть іноді бути надокучливими, коли вони привносять безлад в програму. Типово, корисна документація є те, що читачі програми не можуть просто вивести самі. В визначені метода, як:</p>
<pre class="prettyprint linenums language-scala">def f(x: String) = ...</pre>
<p>є корисним знати, що аргумент f повинний бути String. З іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є надокучливим:</p>
<pre class="prettyprint linenums language-scala">val x: HashMap[Int, String] = new HashMap[Int, String]()</pre>
<p>Зрозуміло, що достатно сказати тільки один раз, що x є HashMap, з Int в якості ключа, та Strings в якості значень; немає потреби повторювати те ж саме двічі.</p><p>Scala має дуже витончену систему виводу типів, що дозволяє вам уникати всієї інформації щодо типів, що звичайно здається надокучливою. В попередньому прикладі наступні дві менш надокучливі альтернативи також можуть виконувати свою справу:</p>
<pre class="prettyprint linenums language-scala">val x = new HashMap[Int, String]()
<br>val x: Map[Int, String] = new HashMap()</pre>
<p>Вивід типів в Scala може піти значно далі. Фактично, не є незвичним для користувацького кода не мати явних типів взагалі. Таким чином, програми Scala часто виглядають як написані на динамічно типізованій мові. Це вірно, зокрема, для клієнтського кода застосування, що зкліює разом попередньо написані бібліотечні компоненти. Це меньш вірно для самих бібліотечних компонент, оскільки вони часто використовують досить складні типи, що дозволяють гнучкі шаблони використання. Це просто природно. Кінець кінцем, всі сігнатури типів членів, що складають інтерфейс повторно використовуваних компонент, повинні бути надані явно, оскільки вони складають головну частину контракту між компонентами та їх клієнтами.</p><h3>1.4&nbsp; Витоки Scala</h3><p>На дизайн Scala вплинули багато мов програмування, та ідей розробки мов програмування. Фактично, тільки декілька можливостей Scala є чисто новими; більшість вже були застосовані в деякій формі в інших мовах. Іновації Scala походять в основному з її конструкцій, що покладаються разом. В цьому розділі ми перелічимо головні джерела впливу на дизайн Scala. Цей список не може бути вичерпним — просто є дуже багато розумних ідей щодо дизайну мови програмування, щоб перелічити тут їх всіх.</p><p>На поверхні Scala адаптує широку частину синтаксису Java та C#, що, в свою чергу, запозичили більшість з їх синтксичних домовленостей з C та C++. Вирази, твердження, та блоки в основному як в Java, так само, як синтаксис класів, пакунків та імпортів. Окрім синтаксиса Scala переймає інші елементи Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p><p>Scala також багато запозичає з інших мов. ЇЇ однорідна об'єктна модель була освоєна в Smalltalk, та згодом розвинена в Ruby. Її ідея універсального вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, останнім часом, в Beta та gbeta. Її принцип одноманітного досупу для викликів методів та вибору полів прийшов з Eiffel. Її підхід до функціонального програмування досить подібне по духу до свмейства мов ML, що включає SML, OCaml, та F# в якості помітних членів. Багато функцій вищого порядку в стандартній бібліотеці Scala, також присутні в ML або Haskell. Неявні параметри Scala&nbsp; були мотивовані класами типів Haskell; вони досягають аналогічних результатів в більш класичному, об'єктно-орієнтовному налаштуванні. Бібліотека базованої на акторах конкурентності Scala значною мірою надихалась Erlang.</p><p>Scala не є першою мовою, що робить наголос на маштабованості та розширюваності. Історичні корені розширюваних мов, що можуть перевизначивати різні області застосувань, є папір від Peter Landin 1966 "Наступні 700 мов програмування". (Мова, що описана в цьому документі, Iswim, стоїть разом з Lisp, як одна з новаторських функціональних мов). Специфічну ідею трактувати інфіксні оператори, як функції, можна відслідити до Iswim та Smalltalk.</p><p>Інша важлива ідея є дозволити використання функціонального літерала (або блока) як параметра, що дозволяє бібліотекам визначати структури керування. Знову, це веде до Iswim та Smalltalk. Smalltalk та Lisp, обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх домен-специфічних мов.&nbsp; C++ є іншою мовою програмування, що може бути адаптований та розширений через перевантаження операторів, та систему шаблонів; порівняно з Scala вона побудована на низькорівневому, більш системно-орієнтованому ядрі.</p><p>Scala також не є першою мовою, що інтегрує функціональне та об'єктно-орієнтоване програмування, хоча вона, можливо, іде далі в цьому напрямку. Інші мови, що що інтегрували деякі елементи функціонального програмування в ООП включають Ruby, Smalltalk та Python. На платформі Java мови Pizza, Nice та Multi-Java розширюють Java-подібне ядро функціональними ідеями. Також є в основному функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F# та PLT-Scheme.</p><p>Scala також доклала деяких інновацій до області мов програмування. Наприклад, її абстрактні типи провадять більш об'єктно-орієнтовану альтернативу до загальних типів (дженеріків), її трейти дозволяють гнучке складання компонентів, та її екстрактори провадять незалежний від репрезентації шлях до співпадіння шаблонів. Ці інновації були представлені останніми роками в паперах на конференціях з мов програмування.</p><h3>1.5&nbsp; Висновок</h3><p>В цій главі ми надали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Будьте певні, що Scala не є срібною кулею, що магічним чином зробить вас більш продуктивним. Щоб просуватись, вам треба застосовувати <br>Scala мистецьки, та це потребуватиме деякого навчання та практики. Якщо ви прийшли до Scala з Java, найбільш складні аспекти вивчення Scala можуть включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книги є лагідно провести вас по кривій засвоєння Scala, крок за кроком. Ми вважаємо, що ви отримаєте винагороду в вигляді інтелектуального досвіду, що розширисть ваші горизонти, то змусить вас думати інакше щодо розробки програм. На щастя, ви також отримаєте задоволення та натхнення від програмування на Scala. </p><p>В наступній главі ми з вами почнемо писати деякий код Scala.</p><h3>Глава 2</h3><h2>Перші кроки в Scala</h2><p>Прийшов час написати деякий код на Scala.Перед тим, як ми розпочнемо глибинне вивчення Scala, ми покладемо дві глави, що дадуть вам ширшу картину Scala, та, що більше важливо, почнемо писати код. Ми закликаємо вас насправді спробувати всі приклади кода, представлені в цій та наступній главах, по мірі просування. Кращий спосіб почати вивчати Scala - це програмувати на ній. </p><p>Щоб виконувати приклади, ви маєте встановити стандартну інсталяцію Scala. Щоб отримати її, завітайте на http://www.scala-lang.org/downloads, та слідуйте настановам для вашої платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans, але для кроків в цій главі ми вважаємо, що ви використовуєте дистрибутив Scala зі scala-lang.org.</p><p>Якщо ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, щоб ви змогли почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий з матеріала може здатись вам незбагненним. Але не турбуйтесь. Щоб ви швидко набрали швидкість, ми опустимо деякі деталі. Все буде пояснено в менш "пожежному" режимі в подальших главах. На додаток, ми вставили в наступні дві глави деякі примітки, щоб спрямувати вас на подальші розділи книги, де ви знайдете більш детальні пояснення.</p><h4>Крок 1. Навчимось використовувати інтерпретатор Scala</h4><p>Найлегший шлях почати зі Scala - це використати інтерпретатор Scala, інтерактивну "оболонку" для написання виразів та програм Scala. Просто наберіть вираз в інтерпретаторі, та він обчислить вираз та надрукує результуюче значення. Інтерактивна оболонка для Scala називається просто scala.</p><p>Ви можете використати її, набравши scala в командному рядку:</p>
<pre class="prettyprint linenums language-bash">$ scala
Welcome to Scala version 2.8.1.
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</pre>
<p>Після цього надрукуйте вираз, такий, як 1 + 2, та нажміть Enter:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 1 + 2</pre>
<p>The interpreter will print:</p>
<pre class="prettyprint linenums language-scala">res0: Int = 3</pre>
<p>Цей рядок включає:<br>• автоматично згенероване, або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає result 0),<br>• двокрапку (:), за якою слідує тип виразу (Int),<br>• Знак рівняння (=),<br>• значення результата від обчислення виразу (3).</p><p>Тип Int іменує клас Int в пакунку scala. Пакунки в Scala подібні до пакунків в Java: вони розділяють глобальний простір імен, та провадять механізм для приховування інформації. Значення класу Int відповідають значенням Java int. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку scala. Наприклад, scala.Boolean відповідає до Java boolean. scala.Float відповідає Java float. Та коли ви компілюєте ваш код Scala в байткоди Java, компілятор Scala буде використовувати примітивні типи Java, де це можливо, щоб надати вам переваги швидкості примітивних типів.</p><p>Ідентифікатор resX може використовуватись в наступних рядках. Наприклад, оскільки&nbsp; res0 було попередньо встановлено в&nbsp; 3, res0 * 3 буде 9:</p>
<pre class="prettyprint linenums language-scala">scala&gt; res0 * 3
res1: Int = 9</pre>
<p>Щоб надрукувати необхідне, але недостатнє Hello, world! greeting, надрукуйте:
</p><pre class="prettyprint linenums language-scala">scala&gt; println("Hello, world!")
Hello, world!</pre>Функція println друкує переданий рядок на стандартний вивід, подібно до&nbsp; System.out.println в Java.<br><br><h4>Крок 2. Визначимо деякі змінні</h4>Scala має два типи змінних, val та vars. val подібне до final змінних в Java. Після ініціалізації val не може бути повторно присвоєна. На відміну від цього, var подібна до не-final змінної в Java. var може бути повторно присвоєна на протяжі життєвого циклу. Ось визначення val:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg = "Hello, world!"
msg: java.lang.String = Hello, world!</pre>
Це твердження вводить msg як ім'я для рядка "Hello, world!". Типом msg є java.lang.String, оскільки рядки Scala ралізовані через Java String. Якщо ви декларували змінні в Java, ви помітили тут одну вражаючу відмінність: ні java.lang.String, ні String не з'являються ніде в визначенні val. Цей приклад ілюструє вивод типу, здатність Scala визначає типи, що ви не  вказали. І цьому випадку, оскільки ви ініціалізували msg літералом рядка, Scala виводить, що тип msg буде String. Коли інтерпретатор Scala (або компілятор) може вивести типи, часто краще дозволити йому зробити це, скоріше, ніж заповнювати код непотрібними явними анотаціями типу. Однак ви можете вказати тип явно, якщо бажаєте, та індоі ви, можливо, маєте це зробити. Явна анотація типу може як переконати компілятор Scala вивести потрібний вам тип, та також прислуговується як корисна документація для майбутніх читачів кода. На відміну від Java, де ви вказуєте тип змінної перед ім'ям, в Scala ви вказуєте тип змінної після імені, відокреплюючи двома крапками. Наприклад:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: java.lang.String = Hello again, world!</pre>
Або, оскільки типи java.lang видимі зі своїми простими іменами в програмах Scala, просто:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</pre>
Повертаючись до оригінального msg, тепер, коли вона визначена, ви можете використовувати її, як і очікували, наприклад:<br>
<pre class="prettyprint linenums language-scala">scala&gt; println(msg)
Hello, world!</pre>
Що ви не можете робити з msg, зважаючи що це val, а не var, це переприсвоїти її. Наприклад, подивіться, як буде скаржитись інтерпретатор, коли ви спробуєте наступне:<br>
<pre class="prettyprint linenums language-scala">scala&gt; msg = "Goodbye cruel world!"
:6: error: reassignment to val
msg = "Goodbye cruel world!</pre>ˆ
<br>Якщо перепризначення це те, що вам потрібне, вам треба var, як нижче:<br>
<pre class="prettyprint linenums language-scala">scala&gt; var greeting = "Hello, world!"
greeting: java.lang.String = Hello, world!</pre>
<br>Оскільки greeting є var, не val, ви можете переприсвоїти її пізніше. Якщо ви пізніше почуватиметесь буркотливим, наприклад, ви можете змінити ваше побажання світові:<br>
<pre class="prettyprint linenums language-scala">scala&gt; greeting = "Leave me alone, world!"
greeting: java.lang.String = Leave me alone, world!</pre>
<br>Щоб ввести дещо в інтерпретатор, що обіймає декілька рядків, просто продовжуйте набирати після першого рядка. Якщо код, що ви набрали до цього, ще не завершений, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.
<pre class="prettyprint linenums language-scala">scala&gt; val multiLine =
      | "This is the next line."
multiLine: java.lang.String = This is the next line.</pre>
<p>Якщо ви зрозумієте, що ви використали тип невірно, але інтерпретаор все ще очікує додаткового вводу, ви можете вийти, двічи нажавши enter:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oops =
   |
   |
You typed two blank lines.&nbsp;Starting a new command.
scala&gt;</pre>В решті цієї книги, ми відкидатимо вертикальні риски, щоб зробити код простішим для читання (та простішим для копіювання та вставки з електронної книги PDF eBook в інтерпретатор).<h4>Крок 3. Визначимо деякі функції</h4><p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
  }
max: (x: Int,y: Int)Int</pre>
<p>Визначення функції починається з def, далі ім'я функції, в цьому випадку max, за яким іде розділений комами список параметрів в дужках. Кожний параметр функції має включати анотацію типу через дві крапки, оскільки компілятор Scala (та інтерпретатор, але від тепер ми казатимо тільки про компілятор) не виводить типи переметрів функції. В цьому прикладі функція з ім'ям max приймає два параметри, x та y, обоє типу Int. Після закриття дужок за списком параметрів max, ви знайдете іншу анотацію типу ": Int". Це визначає тип результата самої функції max. </p>
<pre class="prettyprint linenums language-scala">"def" починає визначення функції
 |  ім'я функції
 |   |  список параметрів в дужках
 |   |   |              тип результата функції
 |   |   |               |  знак рівності
 |   |   |               |   | тіло функції в фігурних дужках<br> |   |   |               |   |  |<br><br>def max(x: Int, y: Int): Int = {
  if (x &gt; y)
    x
  else
    y
}</pre>
<p>Малюнок 2.1 Базова форма визначення функції в Scala.</p><p>Після типу результату функції іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить єдиний вираз if, що обирає x або y, більший з двох, в якості результата функції max. Як тут продемонстровано, вираз if в Scala може мати знечення результата, подібно до тернарного оператора Java. Наприклад, вираз Scala "if (x &gt; y) x else y"&nbsp; поводиться подібно до "(x &gt; y) ? x : y" в Java. Знак рівності, що передує тілу функції, дає підказку, що, з точки зору функціонального світу, функція визначає вираз, що має закінчується значенням. Базова структура функції проілюстрована на Малюнку 2.1.</p>
<p>Іноді компілятор Scala буде потребувати, щоб ви вказали тип результату функції. Наприклад, якщо функція рекурсивна (викликає сама себе), ви мусите явно вказати тип результату функції. Однак в випадку max, ви можете відкинути тип результата, та компілятор виведе його. Також, якщо функція складається тільки з одного твердження, ви можете опіціонально відкинути фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def max2(x: Int, y: Int) = if (x &gt; y) x else y
max2: (x: Int,y: Int)Int</pre>
<p>Коли ви визначили функцію, ви можете викликати її по імені, ось так:</p>
<pre class="prettyprint linenums language-scala">scala&gt; max(3, 5)<br>res4: Int = 5</pre>
<p>Ось визначення функції, що не приймає жодних параметрів, та не повертає ніякого цікавого результата:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</pre>
<p>Коли ви визначаєте функцію greet(), інтерпретатор відповість greet: ()Unit, де "greet" це, звичайно, ім'я функції. Пусті дужки вказують, що функція не сприймає параметрів. Та Unit є типом результата greet. Тип результата Unit вказує, що функція не повертає цікавого значення. Тип Scala Unit подібний до типу Java void, та, фактично, кожний метод, що повертає void в Java відзеркалюється на метод, що повертає Unit в Scala. Методи з типом результата Unit, таким чином, виконуються тільки заради побічних ефектів. В випадку greet(), побічний ефект є друк дружнього привітання на стандиртний вивід.</p><p>В наступному кроці, ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, або ввівши :quit або :q.</p>
<pre class="prettyprint linenums language-scala">scala&gt;$<br>:quit</pre>
<h4>Крок 4. Напишемо деякі Scala скрипти</h4><p>Хоча Scala розроблена щоб допомогти програмістам будувати велико-маштабні системи, вона також гарно маштабується донизу, до скриптингу. Скрипт - це просто послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть його в файл hello.scala:</p>
<pre class="prettyprint linenums language-scala">println("Hello, world, from a script!")</pre>
<p>потім виконайте:</p>
<pre class="prettyprint linenums language-scala">$ scala hello.scala</pre>
<p>Та ви отримаєте ще одне привітання:</p>
<pre class="prettyprint linenums language-scala">Hello, world, from a script!</pre>
<p>Аргументи командного рядка до скрипта Scala доступні через масив Scala на ім'я args. В Scala масиси починаються з нуля, та ви отримуєте доступ до елемента, вказуючи індекс в дужках. Так що перший елемент в масиві Scala на ім'я steps є steps(0), не steps[0], як в Java. Щоб спробувати це, неберіть наступне в новому файлі на ім'я helloarg.scala:</p>
<pre class="prettyprint linenums language-scala">// Скажіть hello першому аргументу<br>println("Hello, "+ args(0) +"!")</pre>
<p>потім виконайте:</p>
<pre class="prettyprint linenums language-scala">$ scala helloarg.scala planet</pre>В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як args(0). Таким чином ви маєте побачити:
<pre class="prettyprint linenums language-scala">Hello, planet!</pre>
<p>Зауважте, що цей скрипт включає коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та всі символи між <br>/* та */. Цей приклад також показує Strings, конкатеновані за допомогою оператора +. Це робить як ви очікуєте. Вираз "Hello, "+"world!" завершиться рядком "Hello, world!".</p><p>Крок 5. Цикли while; рішення з if</p><p>Щоб спробувати while, наберіть наступне в файлі printargs.scala:</p>
<pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {<br>  println(args(i))
  i += 1
}</pre>
<h4>Зауваження. </h4><p>Хоча приклади в цьому розділі допомагають пояснити деякі цикли, вони не демонструють кращий стиль Scala. В наступному розділі ми побачимо кращі підходи, що уникають ітерації по масивам за допомогою індексів.</p><p>Цей скрипт стартує з визначення змінної, var i = 0. Вивід типу надає i тип scala.Int, оскільки це тип її початкового значення, 0. Конструкція while в наступному рядку спричиняє що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз i &lt; args.length на стане фальшивим. args.length дає довжину масива args. Блок містить два твердження, кожний зсунутий на два проміжки, рекомендований стиль відступів для Scala. Перше твердження, println(args(i)), друкує i-й аргумент комадного рядка. Друге твердження, i += 1, інкрементує i на один. Зауважте, що Java ++i та i++ не роблять в Scala. Щоб інкрементувати в Scala, вам треба сказати або i = i + 1, або i += 1. Виконайте цей скрипт за допомогою наступної команди:</p>
<pre class="prettyprint linenums language-scala">$ scala printargs.scala Scala is fun</pre>
<p>Ви маєте побачити таке:</p>
<pre class="prettyprint linenums language-scala">Scala
is
fun</pre>Для ще більшої розваги наберіть наступний код в новий файл на ім'я echoargs.scala:<br>
<pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()
</pre>
<p>І цій версії ви замінили виклик println на виклик print, так що всі аргументи будуть надруковані в одному рядку. Щоб зробити це читабельним ми вставили проміжок перед кожним аргументом, за винятком першого, через конструкцію if (i != 0). Оскільки i != 0 буде false для першого оберту циклу while, проміжок не надрукується перед першим аргументом. В кінці ми додаємо ще один println, щоб отримати новий рядок після друку всіх аргументів. Ваш вивід буде дійсно дуже красивим. Якщо ви виконаєте цей скрипт за допомогою наступної команди:</p>
<pre class="prettyprint linenums language-scala">$ scala echoargs.scala Scala is even more fun</pre>
<p>Ви отримаєте:</p>
<pre class="prettyprint linenums language-scala">Scala is even more fun</pre>
<p>Зауважте, що в Scala, як і в Java, ви мусите покладати логічниі вирази для while або if в дужки. (Іншими словами, ви не можете сказати в Scala речі, як if i &lt; 10, як ви можете зробити в таких мовах, як Ruby. Ви мусите казати if (i &lt; 10) в Scala). Інша подібність до Java в тому, що якщо блок if має тільки одне твердження, ви можете опціонально відкинути фігурні дужки, як це демонструється в твердженні if в echoargs.scala. Та хоча ви не бачите жодних з них, Scala використовує крапку з комою для розділення тверджень, як в Java, за тим виключенням, що в Scala крапки з комою дуже часто опціональні, що надає полегшення вашому правому мізинцю. Одже, якщо ви в дещо більш балакучому настрої, ви можете записати скрипт echoargs.scala наступним чином:</p>
<pre class="prettyprint linenums language-scala">var i = 0;
while (i &lt; args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();</pre>
<h4>Крок 6. Ітерація за допомогою foreach та for</h4><p>Хоча ви можете ще не розуміти цього, коли ви пишете цикл while на попередньому кроці, ви програмуєте в імперативному стилі. В імперативному стилі, що є стилем, який ви використовуєте в мовах як Java, C++ та C, ви отримуєте одну імперативну команду за раз, ітеруєте за допомогою циклів, та часто змінюєте стан, що розподілений між різними функціями. Scala дозволяє вам програмувати імперативно, але коли ви краще пізнаєте Scala, ви, вірогідно, винайдете, що почали програмувати в більш функціональному стилі. Фактично, однією з головних цілей цієї книги є допомогти вам стати настільки ж комфортабельним з функціональним стилем, як і з імперативним стилем.</p><p>Однією з головних характеристик функціональної мови є те, що функції є першокласними конструкціями, і це дуже вірно в Scala. Наприклад, інший, <br>(значно більш стислий) шлях надрукувати аргумент командного рядка, є:</p>
<pre class="prettyprint linenums language-scala">args.foreach(arg =&gt; println(arg))</pre>
<p>В цьому коді ви викликаєте метод foreach на args, та передаєте результат в фукнцію. В цьому випадку ви передаєте в функцію літерал, що приймає один аргумент на ім'я arg. Тіло функції є println(arg). Якщо ви наберете код вище в новому файлі на ім'я pa.scala, та виконаєте його за допомогою команди:</p>
<pre class="prettyprint linenums language-scala">$ scala pa.scala Concise is nice</pre>
<p>Ви побачите:</p>
<pre class="prettyprint linenums language-scala">Concise
is
nice</pre>
<p>В попередньому прикладі інтерпретатор Scala виводить тип arg як String, оскільки String є типом елементів масива, на якому ви викликаєте foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу, але тоді там треба огорнути артументи в дужки (що в жодному разі є нормальною формою синтаксиса):</p>
<pre class="prettyprint linenums language-scala">args.foreach((arg: String) =&gt; println(arg))</pre>Виконання цього скрипта має ту ж поведінку, що і попереднього. Якщо ви в настрої для більшої стислості, замість більшої відкритості, ви можете отримати вигоду спеціального скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та вказувати цей аргумент. Таким чином, наступний код також буде робити:<br>
<pre class="prettyprint linenums language-scala">args.foreach(println)</pre>
<p>параметри функції в дужках</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стрілка<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; тіло функції<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>(x: Int, y: Int) =&gt; x + y</p><p>Малюнок 2.2 Синтаксис функціонального літерала в Scala.</p><p>Щоб підсумувати, синтаксис для функціонального літерала є списком поіменованих параметрів в дужках, права стрілка, та потім тіло функції. Цей синтаксис проілюстрована на Малюнку 2.2.</p><p>Тепер, в цій точці, ви можете здивуватись, що відбувається з тіма випробовуваними циклами for, що ви звикли використовувати в імперативних мовах, як Java або C. В спробі вести вас в фукнціональному напрямку, в Scala існує тільки функціональний родич імперативного for (що називається for виразом). Ви не побачите його повну потужність та виразність, доки не дійдете (або не перестрибнете) до Розділу 7.3, але ми дамо вам можливість поглянути вже тут. В новому файлі з назвою forargs.scala, наберіть наступне:</p>
<pre class="prettyprint linenums language-scala">for (arg &lt;- args)
  println(arg)</pre>
<p>Дужки після "for" містять arg &lt;- args. Зправа до символа &lt;- є знайомий масив args. Зліва від &lt;- стоїть "arg", ім'я val, не var. (Оскільки це завжди val, ви просто пишете поодиноке "arg", не "val arg".) Хоча arg може виглядати як var, тому що вона отримуватиме нове значення на кожній ітерації, насправді це val: arg не може бути переприсвоєна в тілі for виразу. Замість цього, для кожного елементу масива args буде створена нова arg val, та ініціалізована значенням елемента, після чого буде виконане тіло for.</p><p>Якщо ви виконаєте скрипт forargs.scala за допомогою команди:</p>
<pre class="prettyprint linenums language-scala">$ scala forargs.scala for arg in args</pre>
<p>Ви побачите:
</p><pre class="prettyprint linenums language-scala">for
arg
in
args</pre>For вирази Scala можуть робити значно більше від цього, але цей приклад є достатнім для початку. Ми покажемо більше щодо for в Розділі 7.3 та Главі 23.<br><h3>Висновок</h3><p>В цій главі ви навчились деяким основам Scal, та, маємо надію, отримали перевагу від написання деякого кода Scala. В наступній главі ми продовжимо цей вступний огляд, та розглянемо більш просунуті теми.&nbsp;</p><h3>Глава 3</h3><h2>Наступні кроки в Scala</h2><p>Ця глава продовжує попередні вступ до Scala в попередніх главах. В цій главі ви введемо деякі більш просунуті можливості. Коли ви завершите цю главу, ви матемите досить знань, що дозволять вам почати писати корисні скрипти на Scala. Як і в попередній главі, ми рекомендуємо вам перевіряти приклади по мірі просування. Кращий шлях отримати відчуття Scala є почати писати код на Scala.</p><h4>Крок 7. Параметризація масивів за допомогою типів</h4><p>В Scala ви можете створювати об'єкти, або примірники класів, використовуючи new. Коли ви створюєте об'єкт в Scala, ви можете параметризувати його значеннями та типуми. Параметризація означає "конфігурацію" примірника, коли ви створюєте його. Ви параметризуєте примірник за допомогою значень, що передаються об'єктам в конструктор в дужках. Наприклад, наступний код Scala створює примірник нового java.math.BigInteger, та параметризує його значенням "12345":</p>
<pre class="prettyprint linenums language-scala">val big = new java.math.BigInteger("12345")</pre>
<p>Ви параметризуєте примірник типом, через вказання одного або більше типів в квадратних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі greetStrings є значення типу Array[String] ("масив рядків"), що ініціалізований довжиною 3, що параметризує його в першому рядку кода значенням 3. Якщо ви виконаєте код з Лістингу 3.1 як скрипт, ви побачите інше привітання <br>Hello, world!. Зауважте, що ви параметризуєте примірник обоє, типом та значенням, тип іде першим в квадратних дужках, за чим слідує значення в дужках.</p>
<pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
<p>Лістинг 3.1 Параметризація масива типом.</p><h4><span style="font-weight: bold;">Зауваження</span></h4><p><span
style="font-weight: bold;"></span>Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендований спосіб створювати та ініціалізувати масиви в Scala. Ви побачите кращий спосіб в Лістингу 3.2.</p><p>Якщо ви в дещо більш явному настрої, ви можете явно вказати тип greetStrings наступним чином:</p>
 <pre class="prettyprint linenums language-scala">val greetStrings: Array[String] = new Array[String](3)</pre>
 <p>Маючи вивід типів Scala, цей рядок кода семантично еквівалентний до справді першого рядка Лістингу 3.1. Але ця форма демонструє, що хоча чистина параметризації типу (імена типів в квадратних дужках) формує частину типу примірника, частина параметризації значення (значення в дужках) - ні. Тип greetStrings є Array[String], та не Array[String](3).</p><p>Наступні три рядка кода в Лістингу 3.1 ініціалізують кожний елемент масива <br>greetStrings:</p>
 <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"</pre>
 <p>Як ми вже зазначали, масиви в Scala отримують доступ, розміщуючи індекс в дужки, не в квадратні дужки, як в Java. Таким чином, нульовий елемент масива є greetStrings(0), не greetStrings[0].</p><p>Ці три рядка кода ілюструють важливу для розуміння концепцію щодо розуміння Scala значення val. Коли ви визначаєте змінну за допомогою val, змінна не може бути перепризначена, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Так що в цьому випадку ви не можете переприсвоїти greetStrings до іншого масиву; greetStrings буде завжди посилатись на той же примірник Array[String], яким він був ініціалізований. Але ви можете з часом змінювати елементи цього Array[String], так що сам масив є змінним.</p><p>Два заключні рядки Лістингу 3.1 містять вираз for, що друкує кожний елемент масиву greetStrings по порядку:</p>
 <pre class="prettyprint linenums language-scala">for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
 <p>Перший рядок кода в цьому виразі ілюструє інше головне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки та дужок. Метод to в цьому прикладі насправді є методом, що приймає один аргумент Int. Код 0 to 2 перетворюється в виклик метода (0).to(2).1 Зауважте, що цей синтаксис робить тільки якщо ви вказали отримувача виклику метода. Ви не можете записати "println 10", але ви можете записати "Console println 10".</p><p>Scala технічно не має перевантаження операторів, оскільки вона не має операторів в традиційному сенсі. Замість цього такі символи, як +, -, *, та / можуть використовуватись як імена методів. Таким чином, коли ви друкуєте 1 + 2 в інтерпретаторі Scala на Кроці 1, ви насправді викликали метод з ім'ям + на Int об'єкті 1, передавши йому 2 в якості параметра. Як проілюстровано на Малюнку 3.1, ви можете альтернативно записати 1 + 2, використовуючи традиційний синтаксис виклику метода, (1).+(2).</p><p>Інша важлива ідея, проілюстрована в цьому прикладі, надасть вам погляд на те, чому доступ до масивів в Scala виконується за допомогою дужок. Scala має меньше особливих випадків, ніж Java. Масиви є просто примірниками класів, як любі ішні класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala перетворить код в виклик метода, що називається apply, до цієї змінної. Так що greetStrings(i) буде трансформовано в greetStrings.apply(i). Таким чином, доступ до елементів в масиві Scala є простим викликом метода, як любого іншого. Це принцип не обмежується масивами: любе застосування деякого об'єкту до деяких аргументів в дужках буде трансформовано в виклик метода apply. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкту дійсно визначає метод apply. Так що це не спеціальний випадок, а загальне правило.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp; 2</p><p>Об'єкт Int зі значенням 1 &nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на 1 викликається метод ‘+’<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; якому передається параметр Int 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1).+(2)</p><p>Малюнок 3.1 В Scala всі оператори є викликами методів.</p><p>Подібно до цього, коли виконується присвоєння до змінної, до якої застосовуються дужки, та один або більше аргументів, компілятор трансформує це в виклик метода update, що приймає аргументи в дужках, а також об'єкт зправа від знаку присвоєння. Наприклад:</p>
 <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"</pre>
 <p>буде трансформоване в:</p>
 <pre class="prettyprint linenums language-scala">greetStrings.update(0, "Hello")</pre>
 <p>Таким чином, наступне буде семантичним еквівалентом кода Лістинга 3.1:</p>
 <pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
 greetStrings.update(0, "Hello")
 greetStrings.update(1, ", ")
 greetStrings.update(2, "world!\n")
 for (i &lt;- 0.to(2))
   print(greetStrings.apply(i))</pre>
   <p>Scala досягає концептуальної простоти, розглядаючи все, від масивів до виразів, як об'єкти з методами. Вам не треба запам'ятовувати особливі випадки, такі як відмінності в Java між примітивами, та їх відповідними огортками, або між масивами та регулярними об'єктами. Більше того, ця одноманітність не стає в помітну ціну. Компілятор Scala використовує масиви Java, примітивні типи та природну арифметику, коли це можливо, в скомпільованому коді.</p><p>Хоча приклади, що ви бачили до тепер на цьому кроці, компілюються та виконуються досить гарно, Scala провадить більш стислий шлях створювати та ініціалізувати масиви, що ви будете зазвичй використовувати. Це виглядає як в Лістингу 3.2. Цей код створює новий масив довжиною три, та ініціалізує його переданими рядками, "zero", "one" та "two". Компілятор виводить тип масива як Array[String], оскільки ви передали йому рядки.</p>
   <pre class="prettyprint linenums language-scala">val numNames = Array("zero", "one", "two")</pre>
   <p>Лістинг 3.2 Створення та ініціалізація масива.</p><p>Що ви насправді робите в Лістингу 3.2, це виклик метода-фабрики, що називається apply, що створює та повертає новий масив. Цей метод apply приймає змінне число аргументів, та визначений на об'єкті-компанйоні Array. Ви пізнаєте більше про об'єкти-компанйони в Розділі 4.3. Якщо ви програміст на Java, ви можете думати про це як про виклик статичного метода з іменем apply на класі Array. Більш галасливий шлях викликати той же метод apply є наступним:</p>
   <pre class="prettyprint linenums language-scala">val numNames2 = Array.apply("zero", "one", "two")</pre>
   <h4>Крок 8. Використання списків</h4><p>Одна з великих ідей функціонального стилю програмування полягає в тому, що методи не повинні мати побічних ефектів. Єдиною дією повинне бути обчислення та повернення значення. Деякі вигоди, отримані при прийнятті цього підоходу, є те, що методи стають менш заплутані, та, таким чином, більш надійними та використовуваними. Інша вигода (в статично типізованій мові) є та, що все, що іде в, та з, метода, перевіряється контролем типу, так що логічні помилки більш вірогідно проявлять себе, як помилки типу. Застосовуючи цю функціональну філософію до світу об'єктів означає зробити об'єкти незмінними.</p><p>Як ви бачили, масиви Scala є змінними послідовостями об'єктів, що всі поділяють один тип. Наприклад, Array[String] містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як він був створений, ви можете змінити значення його елементів. Таким чином, масиви є змінними об'єктами.</p><p>Для незмінної послідовності об'єктів, що розділяють один тип, ви можете використовувати клас Scala List. Як і з масивами, List[String] містить тільки рядки. В Scala List, scala.List, відрізняється від типу java.util.List, в тій частині, що Scala List завжди незмінні (тоді як Java List може бути змінені). Більш загально, Scala List розроблений щоб дозволити функціональний стиль програмування. Створення списку просте. Лістинг 3.3 показує, як:
</p><pre class="prettyprint linenums language-scala">val oneTwoThree = List(1, 2, 3)</pre>
<p>Лістинг 3.3 Створення та ініціалізація списка.</p><p>Код в Лістингу 3.3 встановлює нову val&nbsp; на ім'я oneTwoThree, ініціалізованою за допомогою new List[Int] з числовими елементами 1, 2 та 3. Оскільки списки Lists незмінні, вони поводяться трохи подібно до рядків Java: коли ви викликаєте метод на списку, що, згідно з ім'ям, виглядає як такий, що мав би змінювати список, він, замість цього, повертає нове значення. Наприклад, List має метод на ім'я ':::' для конкатенації списків. Ось як ви використовуєте його:</p>
<pre class="prettyprint linenums language-scala">val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(oneTwo +" and "+ threeFour +" were not mutated.")
println("Thus, "+ oneTwoThreeFour +" is a new list.")</pre>
<p>Якщо ви виконаєте цей список, ви побачите: </p>
<pre class="prettyprint linenums language-scala">List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</pre>
<p>Можливо, найбільш загальним оператором, що ви будете використовувати зі списками, є ‘::’, що вимовляється як "cons". Cons ствить новий елемент в початок існуючого списку, та повертає отриманий список. Наприклад, якщо ви виконаєте цей скрипт:</p>
<pre class="prettyprint linenums language-scala">val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)</pre>
<p>Ви побачите:</p>
<pre class="prettyprint linenums language-scala">List(1, 2, 3)</pre>
<h4>Зауваження</h4><p>В виразі "1 :: twoThree", :: є методом свого правого операнда, списка twoThree. Ви можете запідозрити, що щось негарне з асоциативністю метода ::, але насправді це просте правило, що легко запам'ятати: якщо метод використовується в нотації оператора, такій, як a * b, метод викликається на лівому операнді, як в a.*(b) — за винятком, коли метод закінчується на дві крапки. Якщо це так, метод викликається на правому операнді. Таким чином, в 1 :: twoThree, метод :: викликається для twoThree, передаючи 1: </p>
<pre class="prettyprint linenums language-scala">twoThree.::(1).</pre>
<p>Асоциативність операторів буде описана більш детально в Розділі 5.8.</p><p>Зважаючи, що скорочений спосіб для вказання пустого списку є Nil, одним шляхом для ініціалізації нових списків є рядок елементів з оператором cons, та з Nil в якості останнього елемента. Наприклад, наступний скрипт буде продукувати той ж вивід, що і попередній, "List(1, 2, 3)":</p>
<pre class="prettyprint linenums language-scala">val oneTwoThree = 1 :: 2 :: 3 :: Nil
println(oneTwoThree)</pre>
<p>Scala List оздоблений корисними методвами, багато з яких перелічені в Таблиці 3.1. Повна потужність списків буде розкритою в Главі 16.</p><p><span
style="font-weight: bold;">Чому ми не додаємо до списків?</span><br>Клас List надає операцію "append" — вона записується як :+ та пояснюється в Главі 24 — але ця операція рідко використовується, оскільки час, що займає додавання до списку, зростає лінійно з розміром списку, тоді як додавання зпереду :: займає сталий час. Вашими опціями, якщо бажаєте побудувати список ефективно додаванням елементів, є ставити їх зпереду, та потім, коли скінчите, виконати реверс; або використовуйте ListBuffer, змінний список, що пропонує операцію додавання, та коли скінчите, виконайте toList. ListBuffer буде описаний в Розділі 22.2.</p><p>Таблиця 3.1 Деякі методи List та їх використання</p><table
style="width: 100%" border="0"><tbody><tr><td><span style="font-weight: bold;">Що це</span></td><td><span
style="font-weight: bold;">Що робить</span></td></tr><tr><td style="width: 269.717px;">List() or Nil</td><td
style="width: 382.25px;">Пустий список</td></tr><tr><td>List("Cool", "tools", "rule")</td><td>Створює новий List[String] з трьох значень, "Cool", "tools" та "rule"</td></tr><tr><td>val thrill = "Will" :: "fill" :: "until" :: Nil</td><td
style="margin-left: -27.7778px;">Створює новий List[String] з трьох елементів "Will", "fill" та "until"</td></tr><tr><td>List("a", "b") ::: List("c", "d")</td><td>Конкатенує два списки (повертає новий List[String] зі значень "a", "b", "c", "d")</td></tr><tr><td>thrill(2)</td><td>Повертає елемент з індексом 2 (від нуля) зі списку thrill ("until")</td></tr><tr><td>thrill.count(s =&gt; s.length == 4)</td><td>Рахує число рядків в thrill з довжиною 4 (повертає 2)</td></tr><tr><td>thrill.drop(2)</td><td>Повертає список thrill без перших двох елементів (List("until"))</td></tr><tr><td>thrill.dropRight(2)</td><td>Повертає список thrill без його двох правих елементів (List("Will"))</td></tr><tr><td>thrill.exists(s =&gt; s == "until")</td><td>Визначає, чи існує в thrill елемент-рядок "until" (true)</td></tr><tr><td>thrill.filter(s =&gt; s.length == 4)</td><td>Повертає список всіх елементів thrill, по порядку, з довжиною 4 (<br>List("Will", "fill"))</td></tr><tr><td>thrill.forall(s =&gt; s.endsWith("l"))</td><td>Вказує, чи всі елементи списка thrill завершуються на літеру "l"<br>(true)</td></tr><tr><td>thrill.foreach(s =&gt; print(s))</td><td>Виконує твердження print для кожного елемента в списку thrill (друкує "Willfilluntil")</td></tr><tr><td>thrill.foreach(print)</td><td>Те саме, але стисліше (друкує "Willfilluntil")</td></tr><tr><td>thrill.head</td><td>Повертає перший елемент в списку thrill ("Will")</td></tr><tr><td>thrill.init</td><td>Повертає список з усіх елементів списку, крім останнього (List("Will", "fill"))</td></tr><tr><td>thrill.isEmpty</td><td>Вказує, чи список thrill є пустим (false) </td></tr><tr><td>thrill.last</td><td>Повертає останній елемент списку thrill ("until")</td></tr><tr><td>thrill.length</td><td>Повертає число елементів в списку (3)</td></tr><tr><td>thrill.map(s =&gt; s + "y")</td><td>Повертає список, що утворений додаванням"y" до кожного елемента-рядка списка thrill (List("Willy", "filly", "untily"))</td></tr><tr><td>thrill.mkString(", ")</td><td>Робить рядок з елементів списку ("Will, fill, until")</td></tr><tr><td>thrill.remove(s =&gt; s.length == 4)</td><td>Повертає список з елементів, по порядку, окрім тих, що мають довжину 4 (List("until"))</td></tr><tr><td>thrill.reverse</td><td>Повертає список з усіх елементів, в зворотньому порядку (List("until", "fill", "Will"))</td></tr><tr><td>thrill.sort((s, t) =&gt; s.charAt(0).toLower &lt; t.charAt(0).toLower)</td><td>Повертає список, що містить всі елементи списку thrill list в алфавітному порядку за першою літерою в нижньому реєстрі (List("fill", "until", "Will"))</td></tr><tr><td>thrill.tail</td><td>Повертає список thrill без першого елемента (List("fill", "until"))</td></tr></tbody></table><h4>Крок 9. Використання кортежів</h4><p>Інший корисний контейнерний об'єкт є кортеж. Як і списки, кортежі незмінні, але на відміну від списків, кортежі можуть містити різні типи елементів. Тоді як список може бути List[Int] або List[String], кортеж може містити обоє, і цілі і рядки, одночасно. Кортежі є дуже корисними, наприклад, якщо ви бажаєте повернути незмінні об'єкти з метода. Тоді як в Java ви повинні часто створити JavaBean-подібний клас, щоб утримувати декілька повернутих значень, в Scala ви можете просто повернути кортеж. Та це просто: щоб створити новий кортеж, що містить декілька об'єктів, просто розмістіть об'єкти в дужках, розділивши їх комами. Коли ви маєте створений примірник кортежу, ви можете отримати доступ до його елементів за допомогою крапки, підкреслення, та базованому на одиниці індексу елементів. Приклад показаний в Лістингу 3.4:</p>
 <pre class="prettyprint linenums language-scala">val pair = (99, "Luftballons")
 println(pair._1)
 println(pair._2)</pre>
 <p>Лістинг 3.4 Створення та використання кортежу.</p><p>В першому рядку Лістингу 3.4, ви створюєте новий кортеж, що містить ціле 99, в якості першого елемента, та рядок "Luftballons", як другий елемент. Scala виводить тип кортежу як Tuple2[Int, String], та дає цей тип також і змінній pair. В другому рядку ви отримуєте доступ до поля _1, що поверне перший елемент, 99. "." в другому рядку є тою ж крапкою, що ви використовували для доступу до полів, або викликали метод. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте цей скрипт, ви побачите:</p><pre
class="prettyprint linenums language-scala">99<br>Luftballons</pre><p>Справжній тип кортежу залежить від числа елементів, що він містить, та типів ціх елементів. Таким чином, тип (99, "Luftballons") є Tuple2[Int, String]. Тип ('u', 'r', "the", 1, 4, "me") є Tuple6[Char, Char, String, Int, Int, String].</p><p><br><span
style="font-weight: bold;">Доступ до елементів кортежу</span></p><p>Ви можете зацікавитись, чому ви не можете отримати доступ до елементів кортежу як до елементів списку, наприклад, через "pair(0)". Причина в тому, що метод списку apply завжди повертає той самий тип, але кожний елемент кортежу може мати різний тип: _1 може мати один тип результату, _2 інший, і так далі. Ці _N чисел базуються на одиниці, замість нуля, оскільки починати з 1 є традицією, що встановлена іншими мовами зі статично типізованими кортежами, як Haskell та ML.</p><h4>Крок 10. Використання множин та мап</h4><p>Оскільки Scala націлена допомогти вам отримати переваги з обох, функціонального та імперативного стилю, його бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви є завжди змінними; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж прості імена для обох версій. Для множин та мап Scala моделює змінність в ієрархії класів.&nbsp;</p><p>Наприклад, Scala API містить базовий трейт для множин, де трейт є дещо подібним до інтерфейсу Java. (Ви винайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних наборів, інший для незмінних наборів. Як ви можете бачити на Малюнку 3.2, ці три трейти всі поіляють те ж просте ім'я, Set. Їх повністю кваліфіковані імена, однак, відрізняються, оскільки кожен знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи HashSet, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширююте" або "домішуєте" трейти). </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; «trait»<br><br><br>scala.collection.immutable&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashSet<br><br>Малюнок 3.2 Ієрархія класів для множин Scala.
</p><p>Таким чином, якщо ви бажаєте використати HashSet, ви можете обрати між змінними та незмінними різновидами, в залежності від ваших потреб. Спосіб по замовчанню для створення множини показаний в Лістингу 3.5:</p>
<pre class="prettyprint linenums language-scala">var jetSet = Set("Boeing", "Airbus")
jetSet += "Lear"
println(jetSet.contains("Cessna"))</pre>
<p>Лістинг 3.5 Створення, ініціалізація та використання незмінної множини.</p><p>В першому рядку кода Лістингу 3.5, ви визначаєте нову var на ім'я jetSet, та ініціалізуєте її незмінною множиною, що містить два рядки, "Boeing" та "Airbus". Як показує цей приклад, ви можете створити множини в Scala подібно до того, як ви створюєте масиви: викликаючи метод-фабрику на ім'я apply на об'єкті-компанйоні Set. В Лістингу 3.5 ви викликаєте apply на об'єкті-компанйоні для scala.collection.immutable.Set, що повертає примірник незмінного Set по замовчанню. Компілятор Scala виводить тип jetSet’s як незмінний Set[String].</p><p>Щоб додати новий елемент до множини ви викликаєте + на множині, передаючи новий елемент. Обоє, зминна та незмінна множина, пропонують метод +, але їх поведінка відрізняється. В той час, коли змінна множина буде додавати елемент до себе, незмінна множина створить, та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною, так що виклик + дасть повністю нову множину. Хоча змінні множини пропонують справжній метод +=, незмінні множини - ні. В цьому випадку, другий рядок коду, jetSet += "Lear", є в основі скороченням для:</p>
<pre class="prettyprint linenums language-scala">jetSet = jetSet + "Lear"</pre>
<p>Таким чином, другий рядок Лістингу 3.5 ви перевизначаєте var jetSet новою множиною, що містить "Boeing", "Airbus" та "Lear". Нарешті, останній рядок Лістингу 3.5 друкує те, чи множина містиь рядок "Cessna". (Як ви можете очікувати, вона друкує false). Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показане в Лістингу 3.6:</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.Set
val movieSet = Set("Hitch", "Poltergeist")
movieSet += "Shrek"
println(movieSet)</pre>
<p>Лістинг 3.6 Створення, ініціалізація, та використання змінної множини.</p><p>В першому рядку Лістингу 3.6 ви імпортуєте змінний Set. Як і в Java, твердження імпорту дозволяє вам використовувати просте ім'я, як Set, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі scala.collection.mutable.Set. На цьому рядку ви ініціалізуєте movieSet за допомогою змінної множини, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод += на множині, та передаючи рядок "Shrek". Як вже зазначалось, += є насправді методом, визначеним на змінних множинах. Коли ви побажаєте, замість писати movieSet += "Shrek", ви можете записати movieSet.+=("Shrek").</p><p>Хоча показана реалізація множини по замовчанню, що продукується змінною та незмінною методом-фабрикою Set, показаною тут, вірогідно, буде достатньою для більшості ситуацій, іноді ви можете побажати явно задати клас. На щастя, синтаксис подібний. Просто імпортуйте клас, що вам потрібний, та використовуєте метод-фабрику на об'єкті-компанйоні. Наприклад, якщо вам треба незмінний HashSet, ви можете зробити таке:</p>
<pre class="prettyprint linenums language-scala">import scala.collection.immutable.HashSet
val hashSet = HashSet("Tomatoes", "Chilies")
println(hashSet + "Coriander")</pre>
<p>Іншим корисним класом колекції в Scala є Map. Як і з множинами, Scala провадить змінні та незмінні версії Map, використовуя ієрархію класів. Як ви можете бачити на Малюнку 3.3, ієрархія класів для мап виглядає здебільшого як така ж для множин. Є базовий трейт Map в пакунку scala.collection, та два субтрейта Map: змінний Map в scala.collection.mutable, та незмінний в <br>scala.collection.immutable.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Map<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br><br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap<br><br>Малюнок 3.3 Ієрархія класів для мап Scala.</p><p>Реалізації Map, такі як HashMap, показані в ієрархії класів на Малюнку 3.3, розширює або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи методи-фабрики, подібні до тих, що використовуютсья для масивів, списків та множин. Наприклад, Лістинг 3.7 показує змінну мапу в дії.</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.Map
val treasureMap = Map[Int, String]()
treasureMap += (1 -&gt; "Go to island.")
treasureMap += (2 -&gt; "Find big X on ground.")
treasureMap += (3 -&gt; "Dig.")
println(treasureMap(2))</pre>
<p>Лістинг 3.7 Створення, ініціалізація та використання змінної мапи.</p><p>В першому рядку Лістингу 3.7 ви імпортуєте змінну Map. Потім ви визначаєте val з іменем treasureMap, та ініціалізуєте її пустою змінною Map, що має цілі ключі, та рядки як значення. Мапа порожня, бо ви нічого не передали в метод-фабрику (дужки в "Map[Int, String]()" порожні). В насупних трьох рядках ви додаєте пари ключ/значення до мапи, використовуючи методи -&gt; та +=. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази-оператори, як 1 -&gt; "Go to island." на (1).-&gt;("Go to island."). Таким чином, коли ви кажете 1 -&gt; "Go to island.", ви насправді викликаєте метод на ім'я -&gt; на цілому зі значенням 1, якому передається рядок зі значенням "Go to island.". Цей метод -&gt;, який ви можете викликати для любого об'єкта в програмі Scala, повертає двоелементий кортеж, що містить ключ та значення. Потім ви передаєте цей кортеж до метода += об'єкта мапи, на який посилається treasureMap. Нарешті, останній рядок друкує значення, що відповідає ключю 2 в treasureMap. Якщо ви виконаєте цей код, він надрукує:</p>
<pre class="prettyprint linenums language-scala">Find big X on ground.</pre>
<p>Якщо ви бажаєте незмінну мапу, вам не потрібен імпорт, оскільки незмінні мапи по замовчанню. Приклад показаний в Лістингу 3.8:</p>
<pre class="prettyprint linenums language-scala">val romanNumeral = Map(
  1 -&gt; "I", 2 -&gt; "II", 3 -&gt; "III", 4 -&gt; "IV", 5 -&gt; "V"
)
println(romanNumeral(4))</pre>
<p>Лістинг 3.8 Створення, ініціалізація та використання незмінної мапи.</p><p>Приймаючи до уваги, що ми не маємо імпортів, коли ми кажемо Map в першому рядку Лістинга 3.8, ви отримаєте по замовчанню scala.collection.immutable.Map. Ви передаєте п'ять кортежів ключ/значення до метода-фабрики мапи, що повертає незмінну Map, що містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p><h4>Крок 11. Навчаемось розпізнавати функціональний стиль</h4><p>Як зазначено в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптуватись до більш функціонального стилю. Якщо ви прийшли до Scala з імперативного підгрунтя — наприклад, якщо ви прогаміст на Java — один з найбільших викликів, на який ви можете натрапити при вивченні Scala, це зрозуміти, як програмувати в фукнціональному стилі. Ми розуміємо, що цей стиль спершу може здатись незвичним, але в цій книзі ми докладаємо зусиль, щоб провести вас через це перетворення. Це потребуватиме деякої роботи з вашого боку, та ми заохочуємо вам докласти зусуль. Якщо ви прийшли з імперативного підгрунтя, ми віримо, що навчання програмування в фукнціональному стилі не тільки зробить вас кращим програмістом на Scala, та також розширить ваші горизонти, та зробить вас кращим програмістом взагалі.</p><p>Перший крок до розпізнання різниці між двома стилями в коді. Одним натяком може бути, чи код містить будь-які var, він, можливо, є в імперативному стилі. Якщо код не містить жодних var взагалі — тобто, він містить тільки val — він, можливо, є в функціональному стилі. Одним шляхом просунутись далі в функціональному стилі, таким чином, є спробувати програмувати без var.</p><p>Якщо ви погодите з імперативного підгрунтя, такого, як Java, C++, або<br>C#, ви можете думати про var, як про звичайну змінну, та val як про спеціальний тип змінної. З іншого боку, якщо ви прийшли з функціонального підгрунтя, такого, як Haskell, OCaml, або Erlang, ви можете думати про val як про звичайні змінні, таvar як різновид богохульства. Точка зору Scala, однак, в тому, що val та var є тільки двома різними інструментами в вашому наборі, обоє корисні, та жодний не є природним злом. Scala заохочує вас вивчити щодо val, але кінець кінцем досягти обрати кращий інструмент для завдання, що вирішується. Однак, навіть коли ви згодні з цією збалансованою філософією, ви можете все ще знайти це спочатку складиним, визначитись, як подолати var в вашому коді.</p><p>Розлянемо, наприклад, такий приклад цикла while, адаптований з Глави 2, що використовує var, та є, таким чином, в імперативному стилі:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  var i = 0
  while (i &lt; args.length) {
    println(args(i))
    i += 1
  }
}</pre>
<p>Ви можете трансформувати цей шматок кода в більш функціональний стиль, прибравши var, наприклад, таким чином:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  for (arg &lt;&lt;- args)<br>    println(arg)
}</pre>
<p>або так:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  args.foreach(println)
}</pre>
<br>Цей приклад ілюструє одну перевагу програмування з меньшим числом var. Рефакторений (більш функціональний) код більш чистий, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує функціональний стиль, фактично, полягає в тому, що функціональний стиль може допомогти вам писати більш зрозумілий, менш схильний до помилок, код.<br><br>Ви можете навіть піти далі. Рефакторений метод printArgs не є повністю функціональним, оскільки він має побічний ефект&nbsp; — в цьому випадку його побічний ефект є друк в стандартний потік. Натякаячий знак фукнції з побічним ефектом є те, що тип, якій вона повертає, є Unit. Якщо функція не повертає ніякого цікавого значення, що саме те, що означає тип Unit, єдиним шляхом, яким функція може вплинути на цей світ, є деякий різновид побічного ефекту. Більш функціональний підхід може полягати в визначенні методів, що форматують передані аргументи для друку, але тільки повертають форматований рядок, як показано в Лістингу 3.9:<br><br>
<pre class="prettyprint linenums language-scala">def formatArgs(args: Array[String]) = args.mkString("\n")</pre>
<br>Лістинг 3.9 Функція без побічних ефектів або var.<br><br>Тепер вона дійсно функціональна: не має жодних споминів про побічні ефекти або var. Метод mkString, що ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повертаючи рядок, що складається з результата виклика toString на кожному елементі, розділених переданим рядком. Таким чином, якщо args містить три елементи, "zero", "one", та "two", formatArgs поверне "zero\none\ntwo". Звичайно, ця функція насправді нічого не друкує, як це робив метод printArgs, але ви можете просто передати його результат до println, щоб досягти цього:<br>
<pre class="prettyprint linenums language-scala">println(formatArgs(args))
</pre>
<br>Здається, кожна корисна програма має мати побічний ефект в деякій формі, оскільки інакше вона б не змогла запровадити значення до зовнішнього світу. Схиляння до методів без побічних ефектів заохочує вас розробляти програми, де код побічних ефектів мінімальний. Однією з переваг цього підходу є те, що він може допомогти зробити ваші програми простішими для тестування. Наприклад, щоб протестувати любий з трьох методів printArgs, показаних вище в цьому розділі, вам треба перевизначити println, захопити вивід кожнього з них, та переконатись, що він такий, як ви очікували. На відміну від цього, ви можете протестувати функцію formatArgs, просто перевіривши її результат:<br>
<pre class="prettyprint linenums language-scala">val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")</pre>
<br>Метод Scala assert перевіряє передане Boolean, та якщо це false, підіймає AssertionError. Якщо передане Boolean є true, assert просто тихо завершується. Ви вивчите більше про допущення в Главі 14.
<p>Кажучи це, майте на увазі, що ні var, ні побічні ефекти не є злом по суті. Scala не є чистою функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гіблидною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще пасує до вирішуваних проблем, та в таких випадках ви не повинні вагатись, та використосувати його. Однак, щоб допомогти вам програмувати без var, ми покажемо багато специфічних прикладів коду з var, та як трансформувати ці var в val в Главі 7.</p><p><br><span
style="font-weight: bold;">Збалансована настанова для Scala програмістів</span></p><p>Схиляйтесь до val, незмінних об'єктів, та методів без побічних ефектів. Спочатку опануйте їх. Використовуйте var, змінні об'єкти ти методи з побічними ефектами, коли ви маєте особливі потреби, та можете це обгрунтувати. </p><h4>Крок 12. Читання рядків з файлу</h4><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробляти рядки в файлах. В цьому розділі ми побудуємо скрипт, що читає рядки з файлу, та друкує їх, ставлячи зпереду число символів в кожному рядку. Перша версія показана на Лістингу 3.10:</p>
 <pre class="prettyprint linenums language-scala">import scala.io.Source
if (args.length &gt; 0) {
  for ( line &lt;- Source.fromFile(args(0)).getLines())
    println(line.length +" "+ line)
}
else
  Console.err.println("Please enter filename")
</pre>
 <p>Лістинг 3.10 Читання рядків з файла.</p><p>Цей скрипт починається з імпорту класа на ім'я Source з пакунка scala.io. Потім він перевіряє, чи вказані додаткові аргументи в командному рядку. Якщо це так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробтити. Вираз Source.fromFile(args(0)) намагається відкрити вказаний файл, та повертає об'єкт Source, на якому ви викликаєте. Метод getLines повертає Iterator[String], що провадить один рядок за ітерацію, за винятком символа нового рядка. Вираз for ітерує поціх рядках, та друкує для кожного довжину рядка, та сам рядок. Якщо немає аргументів, наданих в командному рядку, завершальне твердження else буде друкувати повідомлення на стандартний вивід помилок. Якщо ви покладете цей код в файл з назвою countchars1.scala, та виконаєте його з самим собою:</p>
 <pre class="prettyprint linenums language-scala">$ scala countchars1.scala countchars1.scala</pre>
 <p>Ви побачите:</p>
 <pre class="prettyprint linenums language-scala">22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51&nbsp;&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())
35&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)
1 }
4 else
46 &nbsp; Console.err.println("Please enter filename")</pre>
 <p>Хоча скрипт в його теперішній формі друкує потрібну інформацію, ви можете захотіти пронумеровати рядки, зробити праве вирівнювання, та додати символ стовпчика, так щоб вивід виглядав замість цього так:</p><p>22 | import scala.io.Source<br>0&nbsp;&nbsp; |<br>22 | if (args.length &gt; 0) {<br>0&nbsp;&nbsp; |<br>51 |&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())<br>35 |&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)<br>1&nbsp;&nbsp; | }<br>4&nbsp;&nbsp; | else<br>46 |&nbsp;&nbsp; Console.err.println("Please enter filename")</p><p>Щоб досягти цього, вам треба ітерувати по рядках двічі. Перший раз ви визначатимите максимальну ширину, потрібну для лічильника символів. Другий раз ви будете друкувати вивід, використовуючи максимальну ширину, що була обчислена перед цім. Оскільки ви будете ітерувати по рядках двічі, ви можете також присвоїти їх до змінної:</p>
 <pre class="prettyprint linenums language-scala">val lines = Source.fromFile(args(0)).getLines().toList</pre>
 <p>Заключний toList потрібен, бо метод getLines повертає ітератор. Коли ви проітерували по ітератору, він вичерпався. Трансформуючи його на список через виклик toList, ви отримуєте можливість ітерувати стільки разів, скільки побажаєте, ціною зберігання всіх рядків з файла в пам'яті, одночасно. Змінна lines, таким чином, посилається на список рядків, що містить вміст файла, вказаного в командному рядку.</p><p>Далі, оскільки ми будемо обчислювати довжину лічильника символів кожного рядка двічі, один раз на ітерацію, ви можете виділити цей вираз в маленьку функцію, що обчислює довжину лічильника символів кожного наданого рядка:</p>
 <pre class="prettyprint linenums language-scala">def widthOfLength(s: String) = s.length.toString.length</pre>
 <p>З цією функцією ви можете обчислити максимальну довжину таким чином:</p>
 <pre class="prettyprint linenums language-scala">var maxWidth = 0
for (line &lt;- lines)
  maxWidth = maxWidth.max(widthOfLength(line))</pre>
 <p>Тут ви ітеруєте по кожному рядку за допомогою виразу for, обчислюєте довжину символів довжини рядка, та, якщо вона більша, ніж поточний максимум, присвоюєте її до maxWidth, var, що була ініціалізована як 0. (Метод max, що ви можете викликати для кожного Int, повертає більше значення, з того, на якому він викликаний, та того, який йому переданий). Альтернативно, якщо ви схильні знайти максимум без var, ви можете спочатку знайти найдовший рядок, ось так:</p>
 <pre class="prettyprint linenums language-scala">val longestLine = lines.reduceLeft(
  (a, b) =&gt; if (a.length &gt; b.length) a else b
)</pre><p>Метод reduceLeft застосовує передану функцію до перших двох елементів, та потім застосовує її до результату першого застосування, та наступного елемента в lines, в так далі, по всьому списку. На кожному такому застосуванні результатом буде найдовший зустрічний рядок, оскільки передана функція, (a, b) =&gt; if (a.length &gt; b.length) a else b, повертає найдовший з двох переданих рядків. "reduceLeft" поверне результат останнього застосування функції, що, в цьому випадку, буде найдовшим елементом рядка в lines.</p><p>Маючи цей результат, ви можете обчислити максимальну довжину, передаіши найдовший рядок до widthOfLength:</p>
<pre class="prettyprint linenums language-scala">val maxWidth = widthOfLength(longestLine)</pre>
<p>Все що залишається, це надрукувати рядкі в потрібному форматі. Ви можете зробити це так:</p>
<pre class="prettyprint linenums language-scala">for (line &lt;- lines) {
  val numSpaces = maxWidth - widthOfLength(line)
  val padding = " " * numSpaces
  println(padding + line.length +" | "+ line)
}</pre>
<p>В цьому прикладі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте часло проміжків, потрібних перед довжиною рядка, та присвоюєте його до numSpaces. Тоді ви створюєте рядок, що містиь numSpaces проміжків, за допомогою виразу " " * numSpaces. Нарешті, ви роздруковуєте інформацію в бажаному форматі. Цілий скрипт виглядає, як показано в Лістингу 3.11:</p>
<pre class="prettyprint linenums language-scala">import scala.io.Source
def widthOfLength(s: String) = s.length.toString.length
if (args.length &gt; 0) {
  val lines = Source.fromFile(args(0)).getLines().toList
  val longestLine = lines.reduceLeft(
    (a, b) =&gt; if (a.length &gt; b.length) a else b
  )
  val maxWidth = widthOfLength(longestLine)
  for (line &lt;- lines) {
    val numSpaces = maxWidth - widthOfLength(line)
    val padding = " " * numSpaces
    println(padding + line.length +" | "+ line)
}}
else
  Console.err.println("Please enter filename")</pre>
<p>Лістинг 3.11 Друк форматованих підрахунків символів для рядків з файла.</p><h3>Висновок</h3><p>Зі знанням, що ви набули в цій главі, ви повинні вже бути в змозі починати використовувати Scala для малих завдань, особливо скриптів. В майбутньому ми заглибимось в більші деталі цієї теми, та введемо інші теми, з якими ми навіть не перетинались до тепер.</p><h3>Глава 4</h3><h2>Класи та об'єкти</h2><p>Ви вже бачили основи класів та об'єктів в Scala в попередніх двох главах. В цій главі ми підемо трохи глибше. Ви навчитесь більше щодо класів, полів та мметодів, та отримаєте огляд виводу краапки з комою. Ви більше навчитесь щодо об'єта-синглтона, включаючи, як їх використовувати для написання та виконання застосування Scala. Якщо ви добре знайомі з Java, ви винайдете концепції Scala подібними, але не точно такими. Так що, навіть якщо ви є Java гуру, варто прочитати це.</p><h3>4.1 Класи, поля і методи</h3><p>Клас є проектом для об'єктів. Коли ви визначаєте клас, ви можете створити об'єкти з цього класу-проекту, за допомогою ключового слова new. Наприклад, маючи таке визначення класу:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
// class definition goes here
}</pre>
<p>Ви можете створити об'єкти ChecksumAccumulator таким чином:</p>
<pre class="prettyprint linenums language-scala">new ChecksumAccumulator</pre>
<p>В визначенні класа ви розміщуєте поля та методи, що разом називаються членами. Поля. які ви визначаєте або за допомогою val, або var, є змінними, що посилаються на об'єкти. Методи, що визначені за допомогою def, містять виконавчий код. Поля містять стан, або дані, об'єкта, тоді як методи використовують ці дані&nbsp; для виконання обчислювальної роботи об'єкта. Коли ви створюєте примірники класу, середа виконання виділяє деяку пам'ять, щоб утримувати образ стану цього образу — тобто, вміст його змінних. Наприклад, якщо ви визначили клас ChecksumAccumulator, та надали йому поле var з назвою sum :</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  var sum = 0
}</pre>
<p>та потім створили два екземпляри:</p>
<pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator</pre>
<br>Образ об'єктів в пам'яті може виглядати так:<br><br><br>acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum <br><br>Оскільки sum, поле, задеклароване в класі ChecksumAccumulator, є var, а не val, ви можете пізніше переприсвоїти sum інше значення Int, ось так:<br><br>acc.sum = 3<br><br>Тепер схема виглядатиме так:<br><br>acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
<br>Одна річ, що треба зауважити щодо цього малюнка, щоє є дві змінні sum, одна в об'єкті, на який посилається acc, та інша, в об'єкті, на який посилається csa. Поля також відомі як змінні примірника, оскільки кожний примірник отримує власний набір змінних. Всі разом, змінні примірника об'єкта складають його образ в пам'яті. Ви можете бачити це, проілюстроване тут, не тільки тому, що ви бачите дві змінні sum, але і тому, що коли ви змінюєте одну, це не впливає на іншу.
<p>Інша річ, яку варто зауважити щодо цього прикладу, є те, що ви в змозі змінити об'єкт, на який посилається acc, навіть коли acc є val. Що ви не зможете робити з acc (або csa ), зважаючи, що це val, а не var, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба не буде успішною:</p>
<pre class="prettyprint linenums language-scala">// Не буде компілюватись, бо  acc є val
acc = new ChecksumAccumulator</pre>
<p>Таким чином ви можете розраховувати на те, що acc буде завжди посилатись на той самий об'єкт ChecksumAccumulator, яким він був ініціалізований, але поля цього об'єкта можуть з часом змінюватись.</p><p>Один важливий спосіб досягти стійкості об'єкта - це переконатись, що стан об'єкта — значення змінних примірника — залишаються допустимі на протязі всього життєвого циклу. Першим кроком є запобігти безпосередньому доступу до полів ззовні, зробивши поля приватними. Оскільки приватні поля можуть отримати доступ тільки з методів того ж класа, весь код, що може оновлювати стан, буде локалізовано в класі. Щоб декларувати приватне поле ви розміщуєте модифікатор приватного доступу зпереду поля, таким чином:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
}</pre>
<p>Маючи таке визначення ChecksumAccumulator, кожне намагання отримати доступ до sum ззовні класа буде хибним:</p>
<pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
acc.sum = 5 // Не буде компілюватись, бо sum приватне</pre>
<h4>Зауваження</h4><p>Спосіб, як ви робите члени публічними в Scala - це просто не вказувати явно модифікатор доступу. Кажучи інакше, коли ви кажете "public" в Java, ви просто нічого не кажете в Scala. Публічний доступ стоїть в Scala по замовчанню.</p><p>Тепер, коли sum є приватним, єдиний код, що може отримати доступ до sum, є код, визначений в тілі самого класа. Таким чином, ChecksumAccumulator не може якось використовуватись будь-ким, якщо ми не визначимо в ньому деякі методи:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = {
    sum += b
  }
  def checksum(): Int = {
    return ~ (sum &amp; 0xFF) + 1
  }
}</pre>
<p>Тепер ChecksumAccumulator має два методи, add та checksum, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1. Любі параметри метода можуть бути використані в методі. Одна важлива характеристика параметрів метода в Scala в тому, що вони є val, не var. Таким чином, якщо ви спробуєте перепризначити параметр зсередини метода в Scala, це не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">def add(b: Byte): Unit = {
  b = 1
// Це не компілюється, оскільки b є val
  sum += b
}</pre>
<p>Хоча add та checksum в цій версії ChecksumAccumulator коректно реалізують бажану функціональність, ви можете виразити їх з використанням більш стислого стилю. Перше, return в кінці метода checksum є надлишковим, та може бути відкинутий. За відсутності явного твердження return метод Scala повертає останнє значення, обчислене методом.</p><p>Рекомендований стиль для методів фактично полягає в тому, щоб уникати явних, а тим більше декількох тверджень return. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке потім повертається. Ця філософія буде спонукати вас робити методи досить малими, щоб поділяти більші методи на декілька меньших. З іншого боку вибір дизайну залежить від контекста розробки, та Scala спрощує написання методів, що мають декілька явних return, якщо це те, що вам треба.</p><p>Оскількі все, що робить checksum, є обчислення значення, він не потребує явного return. Інше скорочення для методів є те, що ви можете вилучити фігурні дужки, якщо метод обчислює тільки єдиний вираз результата. Якщо отримуваний вираз короткий, він може навіть розташовуватись в тому ж рядку, що і сам def. З ціма змінами клас ChecksumAccumulator виглядає таким чином:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = sum += b
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
<p>Методи з типом результата Unit, такі як метод ChecksumAccumulator add, виконуються заради своїх побічних ефектів. Побічний ефект загалом визначаєтся як зміна стану десь зовні метода, або виконання дії ввода-вивода. А випадку add, наприклад, побічний ефект полягає в тому, що перепризначується sum. Інший шлях виразити такі методи є відкинути тип результата та знак рівності, та замкнути тіло метода в фігурні дужки. В цій формі метод виглядає як процедура, тобто метод, що виконуєтся виключно для побічних ефектів. Метод add в Лістингу 4.1 ілюструє цей стиль:</p>
<pre class="prettyprint linenums language-scala">// In file ChecksumAccumulator.scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte) { sum += b }
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
<p>Лістинг 4.1 Остаточна версія класа ChecksumAccumulator.</p><p>Один підводний камінь, за яким треба слідити, коли опускаєте знак рівняння перед тілом функції, це те, що тип її  результата в любому випадку буде Unit. Це буде так, і не важливо що міститиме тіло, оскікільки компілятор Scala може привести кожний тип до Unit. Наприклад, якщо результат метода є String, але тип результата метода задекларований як Unit, String буде перетворено на Unit, та його значення буде втрачене. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def f(): Unit = "this String gets lost"
f: ()Unit</pre>
<p>В цьому прикладі String перетворюється на Unit, оскільки Unit є задекларованим результатом функції f. Компілятор Scala трактує функцію, визначену в процедурному стилі, тобто в фігурних дужках без знака рівняння, загалом так само, як функцію, що явно декларує свій тип результата як Unit :</p>
<pre class="prettyprint linenums language-scala">scala&gt; def g() { "this String gets lost too" }
g: ()Unit</pre>
<p>Таким чином, підводний камень виникає, якщо ви маєте намір повернути значення не-Unit, але забули знак рівняння. Щоб отримати те, що ви бажаєте, вам треба вставити пропущений знак рівняння:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def h() = { "this String gets returned!" }
h: ()java.lang.String
scala&gt; h
res0: java.lang.String = this String gets returned!</pre>
<h3>4.2 Виведення крапки з комою</h3><p>В програмі Scala крапка з комою в кінці твердження зазвичай є опціональною. Ви можете набирати її, коли бажаєте, але ви не маєте це робити, якщо твердження з'являється одне на рядку. З іншого боку крапка з комою потрібна, якщо ви записуєте декілька тверджень на одному рядку:</p>
<pre class="prettyprint linenums language-scala">val s = "hello"; println(s)</pre>
<p>Якщо ви бажаєте ввести твердження, що продовжується на декілька рядків, в більшості випадків ви можете просто ввести його, та Scala розділить твердження в потрібних місціях. Наприклад, наступне трактуєтсья як одне твердження на чотирьох рядках:</p>
<pre class="prettyprint linenums language-scala">if (x &lt; 2)
  println("too small")
else
  println("ok")</pre>
<p>Однак іноді, тим не менш, Scala буде розділяти твердження на дві частини супроти вашого бажання:</p>
<pre class="prettyprint linenums language-scala">x
+ y</pre>
<p>Це розглядається як два твердження, x та +y . Якщо ви мали на увазі розглядати це як одне твердження x + y, ви завжди можете огорнути його в дужки:</p>
<pre class="prettyprint linenums language-scala">(x
+ y)</pre>
<p>В якості альтернативи ви можете розмістити + в кінці рядка. Само з цієї причини, коли ви зціплюєте інфіксні операції, такі як +, є загальним в стилі Scala класти оператори в кінці рядка, але не в началі:</p>
<pre class="prettyprint linenums language-scala">x +
y +
z</pre>
<h4>Правила виводу крапки з комою</h4><p>Точні правила для розділення тверджень напрочуд прості, щодо того, як вони роблять. Коротко кажучи, кінець рядка розглядається як крапка з комою, тільки якщо не виконуються наступні умови:</p><p>1. Рядок, що розглядається, закінчується на терм, що не може бути легальним в кінці твердження, такий, як кома або інфіксний оператор.</p><p>2. Наступний рядок починається зі слова, що не може починати твердження.</p><p>3. Рядок завершується в дужках (...) або в прямокутних дужках [...], оскільки вони в жодному разі не можуть містити декілька тверджень.</p><h3>4.3 Об'єкти-синглтони</h3><p>Як зазначалось в Главі 1, один спосіб, як Scala є більш об'єктно-орієнтовною, ніж Java, є те, що класи Scala не можуть мати статичних членів. Замість цього Scala має об'єкти-синглтони. Визначення об'єкта-синглтона виглядає як визначення класа, за тим виключенням, що замість ключового слова class ви використовуєте ключове слово object. Лістинг 4.2 показує приклад.</p>
<pre class="prettyprint linenums language-scala">// В файлі ChecksumAccumulator.scala
import scala.collection.mutable.Map
object ChecksumAccumulator {
  private val cache = Map[String, Int]()
  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c &lt;- s)
        acc.add(c.toByte)
      val cs = acc.checksum()
      cache += (s -&gt; cs)
      cs
    }
}</pre>
<p>Лістинг 4.2 Об'єкт-компанйон до класа ChecksumAccumulator.</p><p>Створений об'єкт-синглтон називається ChecksumAccumulator, тобто має те ж ім'я, що і клас в попередньому прикладі. Коли о'бєкт-синглтон поділяє те ж ім'я, що і клас, він називається об'єктом-компанйоном цього класа. Ви повинні визначата обоє, клас та його компанйон-об'єкт в тому ж файлі. Клас називаєтсья класом-компанйоном об'єкта синглтона. Клас та об'єкт-компанйон можуть отримувати доступ до приватних членів один одного. Синглтон-об'єкт ChecksumAccumulator має один метод з назвою calculate, що приймає String, та обчислює контрольну суму для символів в String. Він також має одне приватне поле, змінну мапу, в якій кешуються попередньо обчислені контрольні суми. Перший рядок метода, " if (cache.contains(s))", перевіряє кеш, щоб побачити, чи переданий рядок вже є як ключ в мапі. Якщо це так, він повертає збережене значення з кешу. Інакше він виконує твердження else, що обчислює контрольну суму. Перший рядок твердження else визначає val на ім'я acc, та ініціалізує її новим примірником ChecksumAccumulator. Наступний рядок є вираз for, що в циклі проходить по кожному символу в переданому рядку, перетворює символи на Byte, викликаючи toByte, та передає це до метода add примірника ChecksumAccumulator, на який посилається acc. Після завершення виразу for, наступний рядок метода викликає checksum на acc, що повертає контрольну суму для переданого String, та зберігає її в val на ім'я cs. В наступному рядку, cache += (s -&gt; cs), переданий рядок в якості ключа відображуєтся на ціле значення контрольної суми, та ця пара додається до мапи кешу. Останній вираз метода, cs, повертає контрольну суму як результат метода.</p><p>Якщо ви Java програміст, ви можете мислити про об'єкти-синглтони як про домівку для статичних методів, що ви писали в Java. Ви можете викликати ці методи на об'єктах синглтона, використовуючи подібний синтаксис: ім'я об'єкта-синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод calculate об'єкта-синглтона ChecksumAccumulator таким чином:</p>
<pre class="prettyprint linenums language-scala">ChecksumAccumulator.calculate("Every value is an object.")</pre>
<p>Об'єкт-синглтон є більше, ніж утримувач для статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта-синглтона як про "тег імені", приєднаний до об'єкта:</p><p>ChecksumAccumulator - - - &gt; cache - - - &gt; змінна мапа<br><br>Визначення об'єкта-синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкта ChecksumAccumulator, ви не можете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначений класом-компанйоном об'єкта-синглтона. Однак об'єкти-синглтони розширюють суперклас та можуть домішувати трейти. Зважаючи, що кожний об'єкт-синглтон є примірником своїх суперкласів та домішаних трейтів, ви можете викликати його методи через ці типи, посилаючись на них зі змінних ціх типів, та передаючи його до методів, що очікують ці типи. Ми покажемо деякі приклади о'бєктів-синглтонів, що походять від класів та трейтів, в Главі 13.</p><p>Одна відмінність між класами та об'єктами-синглтонами полягає в тому, що ці об'єкти-синглтони не можуть сприймати параметрів, тоді як класи можуть. Оскільки ви не можете створити примірник об'єкта-синглтона за допомогою ключового слова new, ви не маєте способа передати йому параметри. Кожний об'єкт-синглтон реалізований як примірник синтетичного класу, що посилається зі статичної змінної, так що вони мають ту ж симантику ініціалізації, що і статичні в Java. Зокрема, об'єкт-синглтон ініціалізується тоді, коли деякий код вперше отримує до нього доступ. </p><p>Об'єкт-синглтон, що не поділяє те є ім'я з класом-компанйоном, називаєтся окремим об'єктом. Ви можете використовувати окремі о'бєкти для багатьох цілей, включаючи збирання пов'язаних допоміжних методів разом, або визначення точки входу до застосування Scala. Цей випадок використання показаний в наступному розділі.</p><h3>4.4 Застосування Scala</h3><p>Щоб виконати програму Scala, ви повинні надати ім'я окремого об'єкта-синглтона з методом main, що приймає один параметр, Array[String], та має тип результата Unit. Кожний окремий об'єкт з методом main відповідної сигнатури може бути використаний як точка входу в ваше застосування. Приклад показаний в Лістингу 4.3:</p>
<pre class="prettyprint linenums language-scala">// В файлі Summer.scala
import ChecksumAccumulator.calculate
object Summer {
  def main(args: Array[String]) {
    for (arg &lt;- args)
      println(arg +": "+ calculate(arg))
  }
}</pre>
<p>Лістинг 4.3 Застосування Summer.</p><p>Ім'я об'єкта-синглтона в Лістингу 4.3 є Summer. Його метод main ває відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода calculate, визначеного в об'єкті ChecksumAccumulator з попереднього приклада. Це твердження import дозволяє вам використовувати прості імена методів в залишку файла. Тіло метода main просто роздруковує кожний аргумент, та контрольну суму для аргумента, розділяючи їх двома крапками.</p><h4>Зауваження</h4><p>Scala неявно імпортує члени пакунків java.lang та scala, так само, як члени об'єкта синглтона на ім'я Predef, в кожний початковий файл кода Scala. Predef, що знаходиться в пакунку scala, містить багато корисних методів. Наприклад, коли ви кажете println в коді Scala, ви насправді викликаєте println з Predef. (Predef.println обертається, та викликає Console.println, що робить справжню роботу). Коли ви кажете assert, ви викликаєте Predef.assert.</p><p>Щоб викликати застосування Summer, розмістіть код з Лістингу 4.3 в файлі з назвою Summer.scala. Оскільки Summer використовує ChecksumAccumulator, помістіть код для ChecksumAccumulator, обоє, клас, показаний в Лістингу 4.1, та його об'єкт-компанйон, показаний в Лістингу 4.2, в файл з назвою ChecksumAccumulator.scala.</p><p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічний клас у файл за назвою класа — наприклад, ви кладете клас SpeedRacer в файл SpeedRacer.java — в Scala ви можете іменувати файли <br>.scala будь-як, як забажаєте, не важливо, які класи Scala або код ви розміщуєте в них. Однак, загалом, в випадку не-скриптів, рекомендованим стилем іменування файлів є називати їх за ім'ям класа, як це робить в Java, так що програмісти можуть більш швидко знаходити класи, переглядаючи імена файлів. Це підхід, що ми приймемо для двох файлів нашого приклада, Summer.scala та ChecksumAccumulator.scala .</p><p>Ані ChecksumAccumulator.scala, ані Summer.scala не є скриптами, оскільки вони закінчуються визначенням. Скрипт, навпаки, повинен завершуватись виразом результата. Таким чином, якщо ви спробуєте виконати Summer.scala як скрипт, інтерпретатор Scala буде скаржитись, що Summer.scala не зваершується заключним виразом (вважаємо, що ви не додали своїх власних виразів після визначення о'бєкта Summer). Замість цього вам буде потрібно насправді скомпілювати ці файли за допомогою компілятора Scala, та потім виконати отримані файли класів. Одним способом зробити це є використання scalac, що є основним компілятором Scala, таким чином:</p>
<pre class="prettyprint linenums language-scala">$ scalac ChecksumAccumulator.scala Summer.scala</pre>
<p>Це скомпілює ваші файли коду, але може бути помітна затримка перед тим, як компіляція завершиться. Причина в тому, що кожного разу, коли компілятор стартує, він витрачає час, скануючи вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть погляне на ваші файли, що ви йому надіслали.&nbsp; З цієї причини дистрибутив Scala також включає демон компілятора Scala, що називається fsc (fast Scala compiler). Ви використовуєте його таким чином:</p>
<pre class="prettyprint linenums language-scala">$ fsc ChecksumAccumulator.scala Summer.scala</pre>
<p>Перший раз, коли ви виконуєте fsc, він створить демон локального сервера, приєднаний до порта на вашому комп'ютері. Потім він надішле список файлів для коспіляції демону через порт, і демон буде компілювати ці файли. Наступного разу, коли виконуєтсья fsc, демон вже буде працювати, так що fsc просто надішле список файлів демону, що беспосередньо скомпілює ці файли. Використовуючи fsc, вам треба зачекати, тільки коли Java стартує перший раз. Якщо вам колись знадобиться зупинити демон fsc, ви можете зробити це командою fsc -shutdown.</p><p>Виконання ціх команд, scalac або fsc, спродукує файли класів Java, що ви потім можете виконати через команду scala, ту ж команду, що ви викликали інтерпретатор в попередніх прикладах. Однак замість надавати ім'я файла з розширенням .scala, що містить код Scala, до інтерпретатора, що ви робили в попередньому прикладі, в цьому випадку ви даєте йому ім'я окремого об'єкта, що містить метод main відповідної сигнатури. Таким чином, ви можете виконати застосування Summer, набравши:</p>
<pre class="prettyprint linenums language-scala">$ scala Summer of love</pre>
<p>Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:</p>
<pre class="prettyprint linenums language-scala">of: -213
love: -182</pre>
<h3>4.5 Трейт Application</h3><p>Scala провадить трейт scala.Application, що може зберігти деякий набір тексту. Хоча ми не охопили все, що вам треба для розуміння, як саме воно робить, ми дійшли висновку, що в любому випадку вам треба знати про це  саме зараз. Лістинг 4.4 показує приклад:</p>
<pre class="prettyprint linenums language-scala">import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends Application {
  for (season &lt;- List("fall", "winter", "spring"))
    println(season +": "+ calculate(season))
}</pre>
<p>Лістинг 4.4 Використання трейта Application.</p><p>Щоб використати трейт, ви спочатку пишете "extends Application" після імені вашого об'єкта-синглтона. Потім, замість щоб писати метод main, ви розташовуєте код, що ви мали б покласти у метод main, напряму між фігурними дужками о'бєкта-синглтона. Ісь і все. Ви можете скомпілювати та виконати це застосування, як і любе інше.</p><p>Спосіб, яким це робить, полягає в тому, що трейт Application декларує метод main з відповідною сигнатурою, що наслідує ваш об'єкт-синглтон, роблячи його придатним в якості застосування Scala. Код між фігурними дужками збирається в первинний конструктор об'єкта-синглтона, та виконується, коли об'єкт ініціалізуєтся. Не турбуйтесь, якщо ви не розумієте, що все це означає. Все буде пояснене в наступних главах, і поки ви зможете використовувати трейт без повного розуміння деталей.</p><p>Наслідування від Application коротше, ніж написання явного метода main, але є і деякі обмеження. Перше, ви не можете використовувати цей трейт, якщо вам треба доступ до аргументів командного рядка, оскільки масив args не доступний. Наприклад, оскільки застосування Summer використовує аргументи командного рядка, воно має бути напиисане з явним методом main, як показано в Лістингу 4.3. Друге, завдяки деяким обмеженням моделі потоків JVM, вам потрібен явний метод main, якщо ваше застосування багатопоточне. Нарешті, деякі реалізації JVM не оптимізують код ініціалізації об'єкта, що виконується трейтом Application. Так що ви повинні наслідувати від Application тільки коли ваша програма відносно проста та однопоточна.</p><h4>Висновок</h4><p>Ця глава надала вам основи щодо класів та об'єктів в Scala, та показала, як компілювати та виконувати застосування. В наступній главі ви навчитесь базовим типум Scala, та як їх використовувать.</p><h3>Глава 5</h3><h2>Базові типи та операції</h2><p>Тепер, коли ми побачили класи та об'єкти в дії, настав гарний час поглянути на базові типи та операції Scala більш глибоко. Якщо ви добре знайомі з Java, ви будете раді винайти, що базові типи та оператори Java мають те ж значення в Scala. Однак є деякі цікаві відмінності, що роблять цю главу варту читання, навіть якщо ви досвідчений Java розробник. Оскільки деяки з аспектів Scala, охоплені в цій главі, є в основі такі самі, як в Java, ми вставили зауваження, що вказують, що Java розробники можуть безпечно пропустити, щоб прискорити ваш прогрес. </p><p>В цьому розділі ви отримаєте огляд базових типів Scala, включаючи String та значення типів Int, Long, Short, Byte, Float, Double, Char та Boolean. Ви навчитесь операціям, які ви можете виконувати з ціма типуми, включаючи, як робить старшинство операторів в виразах Scala. Ви також навчитесь, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи вам додаткові операції, за межами тих, що підтримуються Java.</p><h3>5.1 Деякі базові типи</h3><p>Декілька фундаментальних типів Scala, разом з диапазонами значень примірників ціх типів, яки вони можуть мати, показані в Таблиці 5.1. Загалом, типи Byte, Short, Int, Long та Char називають цілими, або інтегральними, типуми. Інтегральні типи, плюс Float та Double, називають числовими типуми. Окрім String, що міститься в пакунку java.lang&nbsp; всі з типів, що показані в Таблиці 5.1, є членами пакунку scala. </p><p>Таблиця 5.1 Деякі базові типи</p><table
style="width: 672px; height: 142px;" border="0"><tbody><tr><td style="width: 142.85px; text-align: center;"><h5>Значення типу</h5></td><td
style="width: 519.15px; text-align: center;"><h5>Диапазон</h5></td></tr><tr><td>Byte<br>
</td><td>8-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Short</td><td>16-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Int</td><td>32-біт зі знаком двокомпонентне ціле
</td></tr><tr><td>Long</td><td>64-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Char</td><td>16-біт деззнаковий символ Unicode</td></tr><tr><td>String</td><td>Послідовність Char</td></tr><tr><td>Float</td><td>32-біт IEEE 754 з плаваючою крапкою одинарної точності</td></tr><tr><td>Double</td><td>
64-біт IEEE 754 з плаваючой крапкою подвійної точності</td></tr><tr><td>Boolean</td><td>true або false</td></tr></tbody></table><p>Наприклад, повне ім'я Int є scala.Int. Однак, зважаючи на те, що всі члени пакунку scala та java.lang автоматично імпортується в кожний файл Scala, ви можете просто використовувати прості імена (тобто, імена як Boolean, Char або String) будь-де.</p><p>Уважні Java розробники помітять, що базові типи Scala мають точно такі ж диапазони, що і відповідні типи в Java. Це дозволяє компілятору Scala трансформувати в байткодах примірники значення типів Scala, такі як Int або Double, в примітивні типи Java.</p><h3>5.2 Літерали</h3><p>Всі базові типи, перелічені в Таблиці 5.1, можуть бути записані за допомогою літералів. Літерал є спосіб записати значення-константу напряму в коді. </p><h4>Швидке орієнтування для Java програмістів</h4><p>Синтаксис більшості літералів, показаних в цьому розділі, точно таке, як в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Дві розбіжності, про які вам треба прочитати, є літерали Scala для необроблених рядків та символів, що описане десь нижче.</p><h4>Цілі літерали</h4><p>Цілі літерали для типіів Int, Long, Short та Byte, ідуть в трьох формах: десятичні, шіснадцятирічні та восьмирічні. Те, як починається літерал, визначає його основу. Якщо число починається з 0x або 0X, це шіснадцятиричне (основа 16), та може містити символи від 0 до 9, а також від A до F, в нижньому або верхньому реєстрі . Деякі приклади:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val hex = 0x5
hex: Int = 5
scala&gt; val hex2 = 0x00FF
hex2: Int = 255
scala&gt; val magic = 0xcafebabe
magic: Int = -889275714</pre>
<p>Зауважте, що Scala буде завжди друкувати цілі по основі 10, не важливо, яку літеральну форму ви використовуєте для ініціалізації. Таким чином, інтерпретатор відображує значення змінної hex2, що ви ініціалізували літералом 0x00FF, як десятичне 255. (Звичайно, вам не треба сприймати це на слово. Гарний спосіб почати відчувати мову є спробувати ці твердження в інтерпретаторі по ходу читання цієї глави). Якщо число починається з нуля, воно є восьмиричним (основа 8), та може, таким чином, містити цифри від 0 до 7 . Деякі приклади цього:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oct = 035
// (35 восьмиричне є 29 десятичне)
oct: Int = 29
scala&gt; val nov = 0777
nov: Int = 511
scala&gt; val dec = 0321
dec: Int = 209</pre>
<p>Якщо число починається з не-нульової цифри, та не ще будь-як не декорована, це десятичне (основа 10). Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val dec1 = 31
dec1: Int = 31
scala&gt; val dec2 = 255
dec2: Int = 255
scala&gt; val dec3 = 20
dec3: Int = 20</pre>
<p>Якщо цілий літерал завершується на L або l, це є Long, інакше це Int. Деякі приклади цілих літералів Long:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val prog = 0XCAFEBABEL
prog: Long = 3405691582
scala&gt; val tower = 35L
tower: Long = 35
scala&gt; val of = 31l
of: Long = 31</pre>
<p>Якщо літерал Int присвоєний типу Short або Byte, літерали трактуються як вони б були типу Short або Byte, докі значення літералу належить до диапазону цього типу. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val little: Short = 367
little: Short = 367
scala&gt; val littler: Byte = 38
littler: Byte = 38</pre>
<h4>Літерали з плаваючою крапкою</h4><p>Літерали з плаваючою крапкою зроблені з десятичних цифер, опціонально містять десятичну крапку, та опціонально за ними слідує E або e, та значення експоненти. Деякі приклади літералів з плаваючою крапкою:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val big = 1.2345
big: Double = 1.2345
scala&gt; val bigger = 1.2345e1
bigger: Double = 12.345
scala&gt; val biggerStill = 123E45
biggerStill: Double = 1.23E47</pre>
<p>Зауважте, що частина експоненти означає ступіть десяти, на яку домножується друга частина. Таким чином, 1.2345e1 є 1.2345 разів по 10, що є 12.345. </p><p>Якщо літерал з плаваючою крапкою закінчується на F або f, це є Float, інакше це Double. Опціонально, літерали з плаваючою крапкою Double можуть завершуватись на D або d. Деякі приклади літералів Float:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val little = 1.2345F
little: Float = 1.2345
scala&gt; val littleBigger = 3e5f
littleBigger: Float = 300000.0</pre>
<p>Останнє значення, представлене як Double, може приймати ці (та інші) форми:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val anotherDouble = 3e5
anotherDouble: Double = 300000.0
scala&gt; val yetAnother = 3e5D
yetAnother: Double = 300000.0</pre>
<h4>Символьні літерали</h4><p>Character literals are composed of any Unicode character between single<br>quotes, such as:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val a = 'A'
a: Char = A</pre>
<p>На додаток до провадження явного символа між одинарними лапками, ви можете надати восьмиричне або шіснадцятиричне число для кодової точки символа після зворотньої косої. Восьмиричне число має бути від '\0' до '\377'. Наприклад кодова точка Unicode для літери A є восьмиричне 101. Таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val c = '\101'
c: Char = A</pre>
<p>Символьний літерал також може бути наданий як загальний символ Unicode, що складається з чотирьох шіснадцятеричних цифер, якім передує \u, як тут:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val d = '\u0041'
d: Char = A
scala&gt; val f = '\u0044'
f: Char = D</pre>
<p>Фактично, такі символи Unicode можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також записати ідентифікатор таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val B\u0041\u0044 = 1
BAD: Int = 1</pre>
<p>Ідентифікатор трактується як ідентичний до BAD, результат розширення двох символів Unicode в коді нижче. Загалом, це є поганою ідеєю іменувати ідентифікатори таким чином, оскільки їх важче читати. скоріше цей синтаксис призначений для того, щоб дозволити первинним файлам Scala, що містять не-ASCII символи Unicode бути представленими в ASCII.</p>Нарешті, є також декілька символьних літералів, представлених спеціальними екранованими послідовностями, показаними в Таблиці 5.2. <br><p>Таблиця 5.2 Спеціальні літеральні екрановані послідовності
</p><table style="width: 100%;" border="0">
<tbody><tr><td style="width: 116.817px; text-align: center;">Літерал</td><td style="width: 519.3px; text-align: center; background-color: white;">Значення</td></tr><tr><td>\n</td><td>новий рядок ( \u000A )</td></tr><tr><td>\b</td><td>забій ( \u0008 )</td></tr><tr><td
style="height: 20.35px;">\t</td><td>табуляція ( \u0009 )</td></tr>
  <tr>
    <td>\f</td>
    <td>нова сторінка ( \u000C )</td>
  </tr>
<tr><td>\r</td><td>на початок рядка ( \u000D )</td></tr><tr><td>\"</td><td>подвійні лапки ( \u0022 )</td></tr>
  <tr>
    <td>\'</td>
    <td>одиночні лапки ( \u0027 )</td>
  </tr>
  <tr>
    <td>\\</td>
    <td>зворотня коса ( \u005C )</td>
  </tr>
</tbody></table>
<p>Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val backslash = '\\'
backslash: Char = \</pre>
<h4>Рядкові літерали</h4><p>Рядкові літерали складаються з символів, оточених подвійними лапками:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val hello = "hello"
hello: java.lang.String = hello</pre>
<p>Синтаксис символів в лапках є такий же, як і для символьних літералів. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val escapes = "\\\"\'"
escapes: java.lang.String = \"'</pre>
<p>Оскільки синтаксис для рядків з багатьма екранованими послідовностями або для рядків на декількох рядках є незграбним, Scala сключає спеціальний синтаксис для чистих рядків. Ви починаєте та закінчуєте чистий рядок трьома подвійними лапками поспіль ( """ ). В середині чистого рядка може міститсь будь-що, включаючи повністю довільні символи, включаючи нові рядки, знаки лапок та спеціальні символи, зрозуміло, за винятком потрійних лапок поспіль. Наприклад, наступна програма роздруковує повідомлення з використанням чистого рядка:</p>
<pre class="prettyprint linenums language-scala">println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")</pre>
<p>Однак, виконання цього кода не видасть саме того, що було бажано:</p>
<pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
           Type "HELP" for help.</pre>
<p>Проблема в тому, що проміжки на початку другого рядка включені в рядок! Щоб допомоготи в цій загальній ситуації, ви можете викликати stripMargin для рядка. Щоб виконати цей метод, покалдіть сивол стовпчика ( | ) на початку кожного рядка, та потім викличте stripMargin на цілому рядку:</p>
<pre class="prettyprint linenums language-scala">println("""|Welcome to Ultamix 3000.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |Type "HELP" for help.""".stripMargin)</pre>
<p>Тепер код поводиться як було задумано:</p>
<pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
Type "HELP" for help.</pre>
<h4>Символічні літерали</h4><p>Символічні літерали записуються як 'ident, де ident може бути любим літерно-числовим ідентифікатором. Такі літерали відзеркалюються на примірники попередньо визначеного класа scala.Symbol. Точніше, літерал&nbsp; 'cymbal буде розширений компілятором до виклику метода-фабрики: Symbol("cymbal"). Символічні літерали типово використовуються в ситуаціях, коли ви використувуєте просто ідентифікатор в динамічно типізованій мові. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def updateRecordByName(r: Symbol, value: Any) {
// code goes here
}
updateRecordByName: (Symbol,Any)Unit</pre>
<p>Метод сприймає в якості параметрів символ, що вказує на ім'я запису поля, та значення, з яким поле повинне бути оновлене в запису. В динамічно типізованих мовах ви можете викликати цю операцію, передавши незадекларований ідентифікатор поля до методу, але в Scala це не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName(favoriteAlbum, "OK Computer")
:6: error: not found: value favoriteAlbum
&nbsp;&nbsp;&nbsp;&nbsp; updateRecordByName(favoriteAlbum, "OK Computer")
&nbsp;&nbsp;&nbsp;&nbsp; ^</pre>
<p>Замість цього, і при тому майже так же стисло, ви можете передати символічний літерал:</p>
<pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName('favoriteAlbum, "OK Computer")</pre>
<p>С символами немає чого багато робити, окрім з'ясувати його ім'я:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol
scala&gt; s.name
res20: String = aSymbol</pre>
<p>Інша річ, що варто зауважити, це те, що символи інтерновані. Якщо ви запишете той же літерал двічі, обоє вирази будуть посилатись на той самий об'єкт Symbol.</p><h4>Логічні літерали</h4><p>Лолгічний тип Boolean має два літерала, true та false :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val bool = true
bool: Boolean = true
scala&gt; val fool = false
fool: Boolean = false</pre>
<p>Це все що потрібно знати. Тепер ви, літерально, є експертом в Scala.</p><h3>5.3 Оператори ти методи</h3><p>Scala провадить багатий набір операторів для своїх базових типів. Як зазначалось в попередніх главах, ці оператори насправді є тільки милим синтаксисом для звичайних викликів методів. Наприклад, 1 + 2 насправді означає те ж, що і (1).+(2). Іншими словами, клас Int містить метод з ім'ям&nbsp; +, що сприймає Int, та повертає Int як результат. Цей метод + викликається, коли ви додаєте два Int:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val sum = 1 + 2
// Scala викликає (1).+(2)
sum: Int = 3</pre>
        <p>Щоб самому перевірити це, ви можете записати вираз явно, як виклик метода:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val sumMore = (1).+(2)
sumMore: Int = 3</pre>
        <p>Фактично, Int містить декілька перевантажених методів +, що сприймають різні типи параметрів. Наприклад, Int має інший метод, також з назвою +, що приймає та повертає Long. Якщо ви додасте Long до Int, буде визваний цей альтернативний метод +:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val longSum = 1 + 2L
// Scala викликає (1).+(2L)
longSum: Long = 3</pre>
        <p>Символ + є оператором — точніше, інфіксним оператором. Операторна нотація не обмежується методами як +, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній нотації. Наприклад, клас String має метод indexOf, що приймає один параметр Char. Метод indexOf шукає перше входження вказаного символу в рядку, та повертає його індекс, або -1, якщо він не може знайти символ. Ви можете використовувати indexOf як оператор, таким чином:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s indexOf 'o'
// Scala викликає s.indexOf(’o’)
res0: Int = 4</pre>
        <p>На додаток String пропонує перевантажений метод indexOf, що приймає два параметри, символ, що треба шукати, та індекс, з якого потрібно починати пошук. (Інший метод indexOf, показаний раніше, починає з індекса ноль, тобто, з початку String). Навіть не зважаючи, що цей метод indexOf приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів, використовуючи операторну нотацію, ви маєте покласти ці аргументи в дужки. Наприклад, ось як ви використовуєте цю іншу форму indexOf як оператор (продовження попереднього приклада):</p>
        <pre class="prettyprint linenums language-scala">scala&gt; s indexOf ('o', 5) // Scala викликає s.indexOf(’o’, 5)
res1: Int = 8</pre>
        <h4>Кожний метод є оператором</h4><p>В Scala не є окремим синтаксисом мови: кожний метод може бути оператором. Що робить метод оператором, це те, як ви його використовуєте. Коли в и пишете " s.indexOf('o') ", indexOf не є оператором. Але коли ви пишете " s indexOf 'o' ", indexOf є оператором, тому що ви використовуєте його в операторній нотації.</p><p>До сих пір ви бачили приклади операторів в інфіксній нотації, що означає, що метод сидить між об'єктом, та параметром або параметрами, що ви бажаєте передати в метод, як в " 7 + 2 ". Scala також має інші операторні нотації: префіксну та постфіксну. В рефіксній нотації ви ставите ім'я метода перед об'єктом, на якому ви виконуєте метод, наприклад, ‘ - ’ в -7. В постфіксній нотації ви ставите метод після об'єкта, наприклад, " toLong " в "7 toLong ".</p><p>На відміну від інфіксної операторної нотації — в якій оператори мають два операнди, один зліва та інший зправа — префіксні та постфіксні оператори є унарними: вони сприймають тільки один операнд. В префіксній нотації операнд є зправа від оператора. Деякі приклади префіксних операторів є&nbsp; -2.0, !found, та ~0xFF. Як і з інфіксними операторами, ці префіксні оператори є скороченим шляхом виклику методів. Однак в цьому випадку ім'я метода має "unary_" перед символом оператора. Наприклад, Scala трансформує вираз -2.0 в виклик метода "(2.0).unary_-". Ви можете продемонструмати це собі, набравши виклик метода через операторну нотацію, та напряму:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; -2.0
// Scala викликає (2.0).unary_-
res2: Double = -2.0
scala&gt; (2.0).unary_-
res3: Double = -2.0</pre>
        <p>Єдині ідентифікатори, що можуть бути використані як префіксні оператори, це +, -, ! та ~. Таким чином, якщо ви визначаєте метод на ім'я unary_!, ви можете викликати цей метод на значенні або на змінній відповідного типу з використанням префіксної операторної нотації, такої, як !p. Але якщо ви визначите метод з назвою unary_*, ви не будете в змозі використовувати префіксну операторну нотацію, оскільки * не є одним з чотирьох ідентифікаторів, що можуть бути використані як префіксні оператори. Ви можете викликати метод звичаним чином, як p.unary_*, яле якщо ви спробуєте викликати його через *p, Scala розбере це як би ви написали *.p, що, можливо, не те, що ви мали на увазі!</p><p>Постфіксні оператори є методами, що не приймають аргументів, коли вони викликаються без клапки або дужок. В Scala ви можете відкинути пусті дужки на викликах методів. За домовленістю ви включаєте дужки, якщо метод має побічні ефекти, такі, як println(), але ви можете відкинути їх, якщо метод не має побічних ефектів, як в toLowerCase, викликаному на String:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s.toLowerCase
res4: java.lang.String = hello, world!</pre>
        <p>В цьому останньому випадку методу, що не потребує аргументів, ви можете альтернативно відкинути крапку, та використовувати постфіксну операторну нотацію:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; s toLowerCase
res5: java.lang.String = hello, world!</pre>
        <p>В цьому випадку toLowerCase використовується як постфіксний оператор на операнді s. Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типуми Scala, все що вам потрібно, це подивитись на методи, задекларовані в класах типів в документації Scala API. Однак приймаючи до уваги, що це Scala туторіал, ми зробимо швидкий тур по більшості з ціх методів в декількох наступних розділах.</p><h4>Швидке орієнтування для Java програмістів</h4><p>Багато аспектів Scala, описаних в залишку цієї глави такі ж самі, що і в Java. Якщо ви є Java гуру, що поспішає, ви можете безпечно пропустити все до Розділу 5.7, що описує, як Scala відрізняється від Java стосовно рівності об'єктів.</p><h3>5.4 Алгебраїчні оператори</h3><p>Ви можете визивати алгебраїчні методи через інфіксну операторну нотацію для додавання ( + ), віднімання ( - ), множення ( * ), ділення ( / ), та отримання залишку (%), на любому числовому типі. Ось деякі приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1.2 + 2.3
res6: Double = 3.5
scala&gt; 3 - 1
res7: Int = 2
scala&gt; 'b' - 'a'
res8: Int = 1
scala&gt; 2L * 3L
res9: Long = 6
scala&gt; 11 / 4
res10: Int = 2
scala&gt; 11 % 4
res11: Int = 3
scala&gt; 11.0f / 4.0f
res12: Float = 2.75
scala&gt; 11.0 % 4.0
res13: Double = 3.0</pre><p>Коли обоє, лівий та правий операнди є цілими (інтегральними) типуми ( Int, Long, Byte, Short або Char), оператор / буде повертати цілу частину без залишку. Оператор % вказує залошок від цілого ділення. Залишок з плаваючою крапкою, отриманий за допомогою %, не є таким, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлене ділення, не ділення з відкиданням при обчисленні залишку, так що це досить різне з операцією знаходження цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати IEEEremainder зі scala.math:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0</pre>
        <p>Числові типи також пропонують унарні префіксні оператори + (метод unary_+), та - (метод unary_- ), що дозволяє вам вказувати літеральні числа як позитивні або негативні, як -3 або +4.0. Якщо ви не вкажете унарний + або -, літеральне число розглядається як позитивне. Унарний + існує виключно для симетрії з унарним -, але не має ефекту. Унарний - також може використовуватись для обернення змінної. Ось приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val neg = 1 + -3
neg: Int = -2
scala&gt; val y = +3
y: Int = 3
scala&gt; -neg
res15: Int = 2</pre>
        <h3>5.5 Операції відношення та логічні операції</h3><p>Ви можете порівняти числові типи за допомогою методів відношення: бульше ніж ( &gt; ), меньше ніж ( &lt; ), більше або дорівнює ( &gt;= ), та меньше або дорівнює ( &lt;= ), що дає логічній результат типу Boolean. На додаток ви можете використовувати унарний оператор ‘ ! ’ (метод unary_!) для обернення значення Boolean. Ось декілька прикладів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 &gt; 2
res16: Boolean = false
scala&gt; 1 &lt; 2
res17: Boolean = true
scala&gt; 1.0 &lt;= 1.0
res18: Boolean = true
scala&gt; 3.5f &gt;= 3.6f
res19: Boolean = false
scala&gt; 'a' &gt;= 'A'
res20: Boolean = true
scala&gt; val thisIsBoring = !true
thisIsBoring: Boolean = false
scala&gt; !thisIsBoring<br>res21: Boolean = true</pre>
        <p>Логічні методи, ТА ( &amp;&amp; ) та АБО ( || ), приймають операнди Boolean в інфіксній нотації, та дають результат Boolean. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val toBe = true
toBe: Boolean = true
scala&gt; val question = toBe || !toBe
question: Boolean = true
scala&gt; val paradox = toBe &amp;&amp; !toBe
paradox: Boolean = false</pre>
        <p>Логічні операції ТА та АБО обчислюються за скороченою схемою, як в Java: вирази, побудовані з ціх операторів, обчислюються тільки доти, доки треба для визначення результата. Іншими словами, права сторона виразу логічного ТА, та логічного АБО не буде обчислюватись, якщо ліва сторона визначає результат. Наприклад, якщо ліва сторона логічного виразу ТА обчислюється як false, результат виразу буде однозначно false, так що права сторона не буде обчислюватись. Подібно, якщо ліва сторона логічного АБО обчислюється як true, результат виразу буде однозначно true, так що права сторона не обчислюється. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; def salt() = { println("salt"); false }
salt: ()Boolean
scala&gt; def pepper() = { println("pepper"); true }
pepper: ()Boolean
scala&gt; pepper() &amp;&amp; salt()
pepper
salt
res22: Boolean = false
scala&gt; salt() &amp;&amp; pepper()
salt
res23: Boolean = false</pre>
        <p>В першому виразі викликаються pepper та salt, але в другому викликається тільки salt. Зважаючи, що salt повертає false, немає потреби викликати pepper.</p><h4>Зауваження</h4><p>Ви можете здивуватись, як коротке обчислення може робити, якщо оператори є тільки методами. Звичайно, всі аргументи обчислюються до входу в метод, то як може метод уникнути обчислення другого аргументу? Відповідь в тому, що всі методи Scala мають змогу відкласти обчислення своїх аргументів, або навіть зовсім відмовитись від їх обчислення. Ця можливість названа викликом параметрів за ім'ям, та обговорюється в Розділі 9.5.</p><h3>5.6 Побітові операції</h3><p>Scala дозволяє вам виконувати операції на окремих бітах цілих типів, за допомогою декількох побітових методів. Побітові методи такі: побітове-ТА ( &amp; ), побітове-АБО ( | ), та побітове-АБО_НІ ( ˆ ). Унарний оператор доповнення НІ ( ~, метод unary_ ~ ), інвертує кожний біт в операнді. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 &amp; 2
res24: Int = 0
scala&gt; 1 | 2
res25: Int = 3
scala&gt; 1 ˆ 3
res26: Int = 2
scala&gt; ~ 1
res27: Int = -2</pre>
        <p>Перший вираз, 1 &amp; 2, робить побітове-ТА кожного біта 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, 1 | 2, робить побітове-АБО кожного біта тих самих операндів, що дає 3 (0011). Третій вираз, 1 ˆ 3, робить побітове-АБО_НІ кожного біта 1 (0001) та 3 (0011), що дає 2 (0010). Останній вираз, ~ 1, інвертує кожний біт 1 (0001), даючи -2, що в двоїчній системі виглядає як&nbsp;11111111111111111111111111111110.</p><p>Цілі типи Scala також пропонують три методи зсувів: зсув вліво ( &lt;&lt; ), зсув вправо ( &gt;&gt; ), та беззнаковий зсув вправо ( &gt;&gt;&gt; ). Методи зсувів, коли використовуються в інфіксній операторній нотації, зсувають ціле значення зліва операнда на число біт, вказане цілим числом зправа. Зсув вліво та беззнаковий зсув вправо заповнюють біти нулями по мірі зсуву. Зсув вправо заповнює старший біт (знаковий біт) значенням самого лівого біта по мірі зсуву. Ось деякі приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; -1 &gt;&gt; 31
res28: Int = -1
scala&gt; -1 &gt;&gt;&gt; 31
res29: Int = 1
scala&gt; 1 &lt;&lt; 2
res30: Int = 4</pre>
        <p>-1 в двоїчній системі буде 11111111111111111111111111111111. В першому прикладі -1 &gt;&gt; 31, -1 зсувається вправо на 31 бітових позицій. Оскільки Int має 32 біти, ця операція ефективно пересуває самий лівий біт, доки він не стане самим правим. Оскільки метод &gt;&gt; заповню одиницями по мірі зсуву вправо, бо найлівішій біт -1 є 1, результат ідентичний до оригінального операнад, 32 біт одиниць, або -1. В другому прикладі&nbsp; -1 &gt;&gt;&gt; 31, найлівіший біт знову зсувається вправо, доки не стане самим правим, але цього разу заповнення іде нулями. Таким чином цього разу отримаємо двоїчне 00000000000000000000000000000001, або 1. В останньому прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на дві позиції (та заповнює нулями), даючи двоїчне 00000000000000000000000000000100, або 4.</p><h3>5.7 Рівність об'єктів</h3><p>Якщо ви бажаєте порівняти два об'єкти на рівність, ви можете використовувати або ==, або його протилежність, !=. Ось декілька прикладів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 == 2
res31: Boolean = false
scala&gt; 1 != 2
res32: Boolean = true
scala&gt; 2 == 2
res33: Boolean = true</pre>
<p>Ці оператори насправді стосуються до всіх об'єктів, не тільки до базових типів. Наприклад, ви можете використовувати == для порівняння списків:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true
scala&gt; List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false</pre>
        <p>Ідучі далі, ви можете порівняти два об'єти, що мають різні типи:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 == 1.0
res36: Boolean = true
scala&gt; List(1, 2, 3) == "hello"
res37: Boolean = false</pre>
        <p>Ви можете порівняти навіть з null, або з речами, що можуть бути null. Виключення не виникне:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == null
res38: Boolean = false
scala&gt; null == List(1, 2, 3)
res39: Boolean = false</pre>
        <p>Як ви бачите, == було змайстровано на славу, так що якщо вам треба порівняння на еквівалентність, ви отримаєте його в більшості випадків. Це досягається за допомогою дуже простого правила: зпершу перевіряєтося плава частина на null, та якщо це не null, викликається метод equals. Оскільки equals є методом, точне порівняння, що ви отримаєте, залежить від типу аргументу з лівої сторони. Оскількі існує автоматична перевірка на null, ви на маєте робити це самому.</p><p>Цей тип порівняння даватиме true на різних об'єктах, доки їх вміст той же самий, та їхній метод equals написаний так, щоб базуватись на вмісті. Наприклад, ось порівняння двох рядків, що мають ті ж самі&nbsp; п'ять літер:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; ("he"+"llo") == "hello"
res40: Boolean = true</pre>
        <h4>Як Scala == відрізняється від Java</h4><p>В Java ви можете використовувати == для порівняння обох, примітивних та об'єктних типів. На примітивних типух Java == порівнює еквівалентність значень, як і в Scala. Однак, на об'єктних типух, Java == порівнює еквівалентність посилань, що означає, що дві змінні вказують на той же об'єкт в купі JVM. Scala також провадить здатність порівнювати еквівалентність посилань, під ім'ям eq. Однак, eq, та його антонім, ne, стосуються тільки до об'єктів, що напряму відзеркалюються на Java об'єкти. Всі деталі щодо eq та ne надані в Розділах 11.1 та 11.2. Також дивіться Главу 30, щодо того, як писати гарні методи equals.</p><h3>5.8 Преоритети на асоціативність операторів</h3><p>Преоритетність операторів визначає, які частини виразу обчислюються перед іншими чистинами. Наприклад, вираз 2 + 2 * 7 обчислюється до 16, не до 28, оскільки оператор * має вищий преоритет, ніж оператор +. Таким чином, частина виразу множення обчислюється перед додаванням. Ви можете, звичайно, використовувати дужки для прояснення порядку обчислення, або для зміни преоритетності. Наприклад, якщо ви дійсно бажаєте, щоб результат обчислень виразу вище склав 28, ви можете записати вираз таким чином:</p>
        <pre class="prettyprint linenums language-scala">(2 + 2) * 7</pre>
        <p>Зважаючи на те, що Scala не має операторів, як таких, та тільки методіи в операторній нотації, ви можете здивуватись, як робить преоритетність операторів. Scala визначає преоритет на основі першого символа метода, що використовується в операторній нотації (є одне виключення з цього правила, що буде обговорене нижче). Якщо ім'я починається на *, наприклад, воно буде мати більший преоритет, ніж метод, що починається на + .Таким чином, 2 + 2 * 7 буде обчислюватись як 2 + (2 * 7), та +++ b *** c (де a, b, c є змінними, а +++ та *** є методами) буде обчислюватись як a +++ (b *** c), оскільки метод *** має вищий преоритет, ніж метод +++.</p><p>Таблиця 5.3 Преоритети операторів</p><table
style="width: 100%" border="1"><tbody><tr><td>(інші спец.символи)</td><td>*/% </td><td> +-</td><td> :</td><td>=!</td><td>&lt;&gt;</td><td>&amp;</td><td>ˆ</td><td> |</td><td>(всі літери)</td><td>(всіприсвоєння)</td><td><br></td></tr></tbody></table><p>Таблиця 5.3 показує преоритетність на основі першого символа метода, в порядку зменшення преоритета, де згруповані разом оператори мають однаковий преоритет. Чим лівіший символ в таблиці, тим вищий преоритет методів, що починається з цього символа. Ось приклад, що ілюструє іплив преоритетів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 2 &lt;&lt; 2 + 2
res41: Int = 32</pre>
        <p>Метод &lt;&lt; починається з символа &lt;, що виявляється нижче за преоритетом, ніж символ +, що є першим та єдиним символом метода +. Таким чином &lt;&lt; буде мати нижчий преоритет, ніж +, та вираз буде обчислюватись, спочатку викликаючи метод +, ніж метод &lt;&lt;, як в <br>2 &lt;&lt; (2 + 2) . За нашими підрахунками 2 + 2 є 4, та 2 &lt;&lt; 4 дає 32. Ось інший приклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 2 + 2 &lt;&lt; 2
res42: Int = 16</pre>
        <p>Оскільки перші символи такі ж самі, як і в попередньому прикладі, методи будуть викликатись в тому ж порядку. Перший буде викликаний метод +, потім метод &lt;&lt;. Так що 2 + 2 знову дає 4, та 4 &lt;&lt; 2 буде 16. </p><p>Одним виключенням до правила преоритетів, що озвучені вище, стосуєтсья операторів присвоєння, що закінчуються на символ знака рівності&nbsp; (=), та це не один з операторів порівняння &lt;=, &gt;=, ==, або !=. Тоді преоритет оператора той самий, що і простого присвоєння (=). Тобто, воно менше, ніж преоритет любого іншого оператора. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">x *= y + 1</pre>
        <p>означає те саме, що і:</p>
        <pre class="prettyprint linenums language-scala">x *= (y + 1)</pre>
        <p>оскільки *= класифікується як оператор присвоєння, чий преоритет ніжчий, ніж +, не зважаючи, що перший символ оператора є *, що вказує на більший преоритет, ніж у +.</p><p>Коли декілька операторів з однаковим преоритетом з'являють пліч-о-пліч в виразі, тоді групування операторів визначається асоциативністю. Асоциативність операторів визначається останнім символом. Як зазначалось в Главі 3, якщо метод завершується на символ ‘:’, він викликається на правому операнді, передаючи лівий операнд. Методи, що закінчуються на любий інший символ, роблять все навпаки. Вони викликаються на лівому операнді, передаючи правий операнд. Так що a * b дає a.*(b), але a ::: b дає b.:::(a) .</p><p>Однак не мажливо, що за асоціативність в операторів, та їх операнди завжди обчислюються зліва направо. Так що якщо вираз, що не є простим посиланням на незмінне значення, тоді a ::: b біль точно трактується як наступний блок:</p>
        <pre class="prettyprint linenums language-scala">{ val x = a; b.:::(x) }</pre>
			  <p>В цьому блоці a все ще обчислюється перед b, та потім результат цього обчислення передається як операнд в метод b :::.</p><p>Це правило асоціативності також грає роль, коли декілька операторів тієї ж процедури стоять поряд. Якщо метод завершується на ‘:’, вону групуються зправа наліво; інакше, вони групуються зліва направо. Наприклад, a ::: b ::: c трактується як a ::: (b ::: c). Але a * b * c, навпаки, трактується як (a * b) * c.</p><p>Преоритети операторів є частиною мови Scala. Вам не треба боятися використовувати їх. Тим не менш є гарним стилем використовувати дужки для прояснення, які операнди оперують з якими виразами. Можливо, єдиний преоритет, на який ви можете розраховувати, що його без підказок розуміють інші розробники, це преоритет мультиплікативних операторів: *, /, %, над аддитивними + та&nbsp; -. Таким чином, навіть якщо вам зрозуміло, що a + b &lt;&lt; c дає потрібний результат без дужок, додаткова ясність від написання (a + b) &lt;&lt; c може зменшити частоту, з якою ваші колеги будуть споминати ваше ім'я в операторній нотації, наприклад, плюючи з огидою, "bills !*&amp;ˆ % ~ code!".</p><h3>5.9 Збагачені огортки</h3><p>Ви можете викликати значно більше методів на базових типух Scala, ніж описано в попередніх розділах. Декілька прикладів надаються в Таблиці 5.4.</p><p>Таблиця 5.4 Деякі збагачені операції
</p><table style="width: 100%;" border="0">
<tbody><tr><td style="text-align: center;">Код</td><td style="text-align: center;">Результат</td></tr><tr><td>0 max 5</td><td>5</td></tr><tr><td>0 min 5</td><td>0</td></tr>
  <tr>
    <td>-2.7 abs</td>
    <td>2.7</td>
  </tr>
  <tr>
    <td>-2.7 round</td>
    <td>-3L</td>
  </tr>
  <tr>
    <td>1.5 isInfinity</td>
    <td>false</td>
  </tr>
  <tr>
    <td>(1.0 / 0) isInfinity</td>
    <td>true</td>
  </tr>
  <tr>
    <td>4 to 6</td>
    <td>Range(4, 5, 6)</td>
  </tr>
  <tr>
    <td>"bob" capitalize</td>
    <td>"Bob"</td>
  </tr>
  <tr>
    <td>"robert" drop 2 5</td>
    <td>"bert"</td>
  </tr>
</tbody></table>
<br>Ці методи також доступні через неявні приведення типів, прийом, що буде детально описаний в Главі 21. Все що вам треба знати, це що для кожного базового типу, описаного в цій главі, є також "збагачена огортка", що провадить декілька додаткових методів. Таким чином, щоб побачити всі доступні методи для базових типів, ви маєте поглянути на документацію API до збагаченого типу кожного базового типу. Ці класи перелічені в Таблиці 5.5.<br><br>Таблиця 5.5 Збагачені класи-огортки<br>

<table style="width: 100%;" border="0">
<tbody><tr><td style="text-align: center;">Базовий тип</td><td style="text-align: center;">Збагачена огортка</td></tr><tr><td>Byte</td><td>scala.runtime.RichByte</td></tr>
  <tr>
    <td>Short</td>
    <td>scala.runtime.RichShort</td>
  </tr>
  <tr>
    <td>Int</td>
    <td>scala.runtime.RichInt</td>
  </tr>
  <tr>
    <td>Char</td>
    <td>scala.runtime.RichChar</td>
  </tr>
  <tr>
    <td>Float</td>
    <td>scala.runtime.RichFloat</td>
  </tr>
  <tr>
    <td>Double</td>
    <td>scala.runtime.RichDouble</td>
  </tr>
  <tr>
    <td>Boolean</td>
    <td>scala.runtime.RichBoolean</td>
  </tr>
  <tr>
    <td>String </td>
    <td>scala.collection.immutable.StringOps</td>
  </tr>
</tbody></table>
<br><h3>5.10 Висновок</h3><p>Головне, що треба взяти з цієї глави, це те, що оператори в Scala є викликами методів, та існують неявні перетворення до збагачених варіантів для базових типів Scala, що додає навіть більше корисних методів. В наступній главі ми покажемо вам, що означає розробляти об'єкти в функціональному стилі, та як це дає нові реалізації деяких з операторів, що ми бачили в цій главі. </p><h3>Глава 6</h3><h2>Функціональні об'єкти</h2><p>З розумінням основ Scala, які ви отримали в попередніх главах, ви вже готові побачити, як розробляти більш дієздатні класи в Scala. Наголос в цій главі стоїть на класах, що визначають функціональні об'єкти, тобто, об'єкти, що не мають жодного змінного стану. В якості нагального прикладу ми створимо клас, що моделює раціональні числа, як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри та конструктори класів, перевизначиття, перевірку передумов, перевантаження та посилання на себе.</p><h3>6.1 Специфікація класу Rational</h3><p>Раціональне число є таким, що може бути виражене як відношення d/n, де n та d є цілими, за тим винятком, що d не може бути нулем. n називається чисельником, d називаєтсья знаменником. Прикладами раціональних чисел є 1/2, 2/3, 112/239, та 2/1.</p><p>В порівнянні з числами з плававючою крапкою, раціональні числа мають перевагу в тому, що дріб представлена точно, без округлень та апроксимації. Клас, що ми розробляємо в цій главі повинен моделювати поведінку раціонального числа, включаючи додавання, віднимання, множення та ділення. Щоб додати два раціональні числа спочатку вам треба знайти загальний дільник, та потів додати два чисельника. Наприклад, щоб додати 1/2 + 2/3, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає 3/6 + 4/6. Додавання двох чисельників дає 7/6. Щоб помножити два раціональні числа, ви просто множите чисельники та знаменники. Таким чином, 2/1 ∗ 2/5 дає 2/10, що може бути представлене більш компактно в "нормалізованій" формі як 5/1. Ви ділите, переставляючи чисельник та займенник правого операнда, та поті виконуючи множення. Наприклад, 1/2 / 3/5 те ж саме, що і 1/2 ∗ 5/3, або 6/5.</p><p>Одне, можливо досить тривіальне, дослідження цієї метаматики, дає те, що раціональні числа не мають змінного стану. Ви можете додати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть "змінені". Незмінний клас Rational, що ми розробляємо в цій главі, буде мати ти ж властивості. Кожне раціональне число буде представлене одним об'єктом Rational. Коли ви додаєте два об'єкта Rational, ви створюєте новий об'єкт Rational, що міститиме суму.</p><p>Ця глава дасть вам побіжне враження щодо шляхів, як Scala дозволяє вам писати бібліотеки, що виглядають як природна підтримка мови. Наприклад, наприкінці цієї глави ви будете в змозі зробити наступне з класом Rational :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/42</pre>
        <h3>6.2 Побудова Rational</h3><p>Гарним місцем для початку розробки класа Rational є прийняти рішення, як програмісти клієнтів будуть створювати новий об'єкт Rational. Приймаючи до уваги, що ми прийняли незмінність об'єктів Rational, нам буде треба, щоб клієнти провадили всі дані, потрібні для примірника (в цьому випадку чисельник да займенник) при створенні примірника. Таким чином, ми почнемо розробляти з такого:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int)</pre>
        <p>Одна з перших речей, що треба зазначити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори n та d в дужках після імені класа, Rational, називаються параметрами класа. Компілятор Scala збере ці два параметри класа, та створить первинний конструктор, що приймає саме два параметри.</p><h4>Недоліки незмінних об'єктів</h4><p>незмінні об'єкти пропонують декілька переваг над змінними об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіші до промислення, ніж змінні, оскільки вони не мають складних просторів стану, що змінюється з часом. Друге, ви можете передавати незмінні об'єкти будь-куди досить вільно, тоді як вам може знадобитись захисні копії змінних об'єктів перед передачею їх в інший код. Третє, немає способу для двох потоків конкурентно мати доступ до незмінного об'єкту, щоб зіпсувати його стан після того, як він був відповідно сконструйований, оскільки жодний потік не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт змінюється після того, як він покладений, наприклад, в HashSet, цей об'єкт може бути не знайдений наступного разу, коли ви будете його шукати в HashSet .</p><p>Головний недолік незмінних об'єктів в тому, що вони часом потребують копіювання великого об'єктного графу, там, де в іншому випадку може знадобитись тільки оновлення на місці. В деяких випадках це може бути незграбним під час реалізації, та також може призвести до вузьких місць продуктивності. Як результат, не є незвичним для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас StringBuilder є змінною альтернативою до незмінного String. Ми надамо вам більше інформації щодо розробки змінних об'єктів в Scala в Главі 18.</p><h4>Зауваження</h4><p>Цей початковий приклад Rational підкреслює різницю між Java та<br>Scala. В Java класи мають конструктори, що можуть мати параметри, тоді як в Scala класи можуть приймати параметри напряму. Нотація Scala є більш стислим — параметри класа можуть використовуватись напряму в тілі класів; немає потреби визначати поля та писати присвоєння, що копіюють параметри клнструктора в поля. Це може дати значні збереження в шаблонному коді, особливо для малих класів.</p><p>Компілятор Scala буде компілювати любий код, що ви розмістите в тілі класа, що не є частиною визначення поля або метода в первинний конструктор. Наприклад, ви можете надрукувати повідомлення таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  println("Created "+ n +"/"+ d)
}</pre>
<p>Маючи цей код, компілятор Scala буде розміщувати виклик println в первинний конструктор Rational. Виклик println буде, таким чином друкувати його повідомлення налаштування при створенні нового примірника Rational:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(1, 2)
Created 1/2
res0: Rational = Rational@90110a</pre>
        <h3>6.3 Перевизначення метода toString</h3><p>Коли ми створили примірник Rational в попередньому прикладі, інтерпретатор друкує "Rational@90110a". Інтерпретатор отримує дещо дивно виглядаючий рядок, викликаючи метод toString об'єкта Rational. По замовчанню клас Rational наслідує реалізацію toString, визначений для класа class java.lang.Object, що тільки друкує ім'я класа, знак @, та шіснадцятиричне число. Результат toString призначений в першу чергу допомагати програмістам, провадячи інформацію, що може використовуватись для налаштування тверджень друку, журнальний повідомлень, тестових звітів про збої, та вивід інтерпретатора та налагодження. Результат, що наразі провадиться toString, не є особливо корисним, оскільки він не дає жодної підказки щодо значення раціонального значення. Більш корисна реалізація toString буде друкувати значення чисельника та займенника Rational. Ви можете переписати реалізацію по замовченню, додаючи метод toString до класа Rational, наприклад, таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  override def toString = n +"/"+ d
}</pre>
        <p>Модифікатор override на початку визначення метода сигналізує, що попереднє визначення метода буде перевизначите; більше щодо цього в Главі 10. Оскільки число Rational тепер буде відображуватись досить мило, ми видалимо твердження println, що ми поклали в тіло попередньої версії класа Rational. Ви можете протестувати нову поведінку Rational в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 3)
x: Rational = 1/3
scala&gt; val y = new Rational(5, 7)
y: Rational = 5/7</pre>
        <h3>6.4 Перевірка передумов</h3><p>В якості наступного кроку ми перемикнемо нашу увагу на проблему поточної поведінки первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якости займенника. Однак наразі первинний конструктор приймає нуль в якості d :</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(5, 0)
res1: Rational = 5/0</pre>
        <p>Одна з переваг об'єктно-орієнтовного програмування в тому, що воно дозволяє вам інкапсулювати дані в об'єктах, так що ви можете переконатись, що дані коректні на протязі їх життя. В випадку незмінного об'єкта, такого, як Rational, це означає, що ви повинні переконатись в валідності даних при конструюванні об'єкта. Маючи на увазі, що нульовий займенник є неприпустимим станом для числа Rational, ви не повинні дозволити конструювання Rational, якщо в параметрі d переданий нуль.</p><p>Кращим шляхом у підході до цієї проблеми, це визначити передумову в первинному конструкторі, що d не повинне бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, яким повинні задовільняти викликаючі. Одним з шляхів зробити це можна таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  override def toString = n +"/"+ d
}</pre>
        <p>Метод require приймає одне логічне значення. Якщо передане значення є<br>true, require повернеться нормально. Інакше require запобігатиме об'єкт від створення, викликаючи виключення IllegalArgumentException.</p><h3>6.5 Додавання полів</h3><p>Тепер, коли первинний конструктор відповідним чином накладає передумову, ми перенесемо нашу увагу на реалізацію додавання. Щоб зробити це, ми визначимо публічний метод add на класі Rational, що приймає інше Rational в якості параметра. Щоб утримувати Rational незмінним, метод add не повинен додавати передане раціональне число до себе. Скоріше, він повинен новий Rational, що міститиме суму. Ви можете думати про це, записавши add таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) { // Це не буде компілюватись
  require(d != 0)
  override def toString = n +"/"+ d
  def add(that: Rational): Rational =
  new Rational(n * that.d + that.n * d, d * that.d)
}</pre>
        <p>Однак надання цього кода призведе до скарги компілятора:</p>
<pre class="prettyprint linenums language-scala">&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                      ˆ
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                                               ˆ</pre>
<p>Хоча параметри класа n та d є в полі зору кода вашого метода add, ви можете отримувати доступ до них на об'єкті, на якому він викликається. Таким чином, коли ви кажете n або d в реалізації add, компілятор щасливий провадити вам значення для параметрів цього класа. Але він не дозволить вам казати that.n або that.d, оскільки це не посилається на об'єкт Rational, на якому він викликаєтсья. Щоб отримати доступ до чисельника та займенника на ньому, нам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класа Rational. </p><p>В увц ваерсії Rational, показаній в Лістингу 6.1 ми додаємо два поля з іменами numer та denom, та ініціалізуємо їх значеннями параметрами класів n та d. Ми також змінюємо реалізацію toString та add, так що вини використовують поля, не параметри класа. Ця версія класа Rational буде компілюватись. Ви можете протестувати його, додаючи деякі раціональні числа:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}</pre>
        <p>Лістинг 6.1 Rational з полями.</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; oneHalf add twoThirds
res3: Rational = 7/6</pre>
        <p>Одна інша річ, що ви можете зробити прямо зараз, та що ви не могли до цього, це доступ до значень чисельника та займенника за межами об'єкта. Просто отримуйте доступ до полів numer та denom:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(1, 2)
r: Rational = 1/2
scala&gt; r.numer
res4: Int = 1
scala&gt; r.denom
res5: Int = 2</pre>
        <h3>6.6 Посилання на себе</h3><p>Ключове слово this посилається на примірник об'єкта, на якому наразі викликається метод, або, якщо використовується в конструкторі, примірник об'єкта, що створюється. В якості приклада розглянемо новий метод, lessThan, що перевіряє, чи даний Rational меньше, ніж параметр:</p>
<pre class="prettyprint linenums language-scala">def lessThan(that: Rational) =
&nbsp; this.numer * that.denom &lt; that.numer * this.denom</pre>
        <p>Тут this.numer посилається на чисельник об'єкта, на якому викликається lessThan. Ви також можете облишити цей префікс, та просто записати numer; дві нотації є еквівалентними. В якості приклада, як ви можете це зробити без цього, розгляньте додавання метода max до класа, що повертає більше з наданого раціонального числа, та аргумента:</p>
<pre class="prettyprint linenums language-scala">def max(that: Rational) =
&nbsp; if (this.lessThan(that)) that else this</pre>
        <p>Тут перше this є зайвим. Ви можете точно таким же чином опустити ліву частину, та записати lessThan(that). Але другий this представляє результат метода в випадку, коли перевірка дає false; коли ви опустите і його, вам просто не буде що повертати!</p><h3>6.7 Додаткові конструктори</h3><p>Іноді вам треба декілька конструкторів для класа. В Scala конструктори, крім первинного, називають додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш стисло, як один чисельник. Наприклад, замість 1/5, ви можете записати просто 5. Таким чином, це може бути милим, якщо замість писати new Rational(5, 1), програмісти клієнтів можуть просто записати new Rational(5). Це може потребувати створення додаткового конструктора Rational, що приймає тільки один аргумент, чисельник, та вважате займенник рівним 1. Лістинг 6.2 демонструє, як це може виглядати.</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  def this(n: Int) = this(n, 1) // додатковий конструктор
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}
</pre><p>Лістинг 6.2 Rational з додатковим конструктором.</p>
<p>Додаткові конструктори в Scala починаються з def this(...). Тіло зовнішнього конструктора Rational просто викликає первинний конструктор, передаючи йому свій один аргумент, n, в якості чисельника, та 1 в яксті займенника. Ви можете бачити додатковий конструктор в дії, набравши наступне в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val y = new Rational(3)
y: Rational = 3/1 </pre>
        <p>В Scala кожний зовнішній конструктор має викликати інший конструктор того ж класа в якості першої дії. Іншими словами, перше твердження кожного зовнішнього конструктора кожного класа Scala буде мати форму "this( . . . ) ". Викликаний конструктор є або первинним конструктором (як в прикладі Rational), або іншим додатковим конструктором, що текстуально іде перед викликаючого конструктора. Нетто-ефект цього правила полягає в тому, що кожний виклик конструктора в Scala раніше чи пізніше завершиться викликом первинного конструктора класа. Первинний конструктор, таким чином, є єдиною точкою входу в клас.</p><h4>Зауваження</h4><p>Якщо ви добре знайомі з Java, ви можете здивуватись, чому правила Scala для конструкторів є дещо більш обмеженними, ніж в Java. В Java конструктор має або викликати інший конструктор того ж класа, або напряму викликати конструктор для суперкласа, в якості першої дії. В класі Scala тільки первинний конструктор може викликати конструктор суперкласа. Підвищене обмеження в Scala насправді є компромісом, на який треба піти, а обмін на більшу стислість та простоту конструкторів Scala, у порівнянні з Java. Суперкласи, та деталі щодо того, як виклик конструктора та наслідування взаємодіють муж собою, буде пояснене в Главі 10.</p><h3>6.8 Приватні поля та методи</h3><p>В попередній версії Rational ми просто ініціалізуєте numer за допомогою n, та denom за допомогою d. Як результат чисельник та займенник Rational можуть бути більші, ніж треба. Наприклад, дріб 66/42 може бути нормалізований до нормалізованої скороченої форми 11/7, але первинний конструктор Rational наразі не робить цього:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res6: Rational = 66/42</pre>
        <p>Щоб нормалізувати число таким чином, вам треба роділити чисельник та займенник на найбільший загальний дільник. Наприклад, найбільший загальний дільник для 66 та 42 є 6. (Іншими словами, 6 є більшим цілим, що нарівно ділить 66 та 42). Поділівши обоє, чисельник та займенник на 6&nbsp; дасть скорочену форму, 11/7. Лістинг 6.3 показує один зі шляхів, як це зробити:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
        <p>Лістинг 6.3 Rational з приватними полем та методом.</p><p>В цій версії Rational ми додаємо приватне поле g, та модифікуємо ініціалізатори numer та denom. (Ініціалізатор є код, що ініціалізує змінну, наприклад, "n / g", що ініціалізує numer). Оскільки g є приватним, д онього є доступ з середини тіла класа, але не зовні. Ми також додаємо приватний метод, gcd, що обчислює найбільший загальний дільник двох переданих Int. Наприклад, gcd(12, 8) дає 4. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто ставите ключове слово private перед визначенням. Призначення приватного "допоміжного метода" gcd є виділення кода, що потрібен для деякої іншої частини класа, в данному випадку первинного конструктора. Щоб переконатись, що g є завжди позитивним, ми передає абсолютні значення n та d, що ми отримуємо, викликаючи abs, метод, що ви можете викликати для любого Int для отримання абсолютного значення.</p><p>Компілятор Scala буде розміщувати код для ініціалізаторів трьох полів Rational в первинний конструктор, в тому порядку, як вони з'являються в коді. Таким чином, ініціалізатор g, gcd(n.abs, d.abs), буде викликаний пере іншими двома, оскільки він з'являється першим в початковому коді. В результаті поле g буде ініціалізоване більшим загальним дільником абсолютного значення параметрів класа, n and d. Потім поле g використовується в ініціалізаторів numer та denom. Ділячі n та d на їх більший загальний дільник, g, кожне Rational буде сконструйоване в нормалізованій формі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res7: Rational = 11/7</pre>
        <h3>6.9 Визначення операторів</h3><p>Поточна реалізація додавання Rational є пристойним, але може бути зроблене більш зручним для застосування. Ви можете запитати, чому ми можемо просто записати:</p>
<pre class="prettyprint linenums language-scala">x + y</pre>
        <p>якщо x та y є цілими числами, чи з плаваюсою крапкою, але ми маємо писати:</p>
<pre class="prettyprint linenums language-scala">x.add(y)</pre>
        <p>або щонайменьше:</p>
<pre class="prettyprint linenums language-scala">x add y</pre>
        <p>якщо вони є раціональними числами. Немає переконливого пояснення, чому це має бути саме так. Раціональні числа є числами, так само як будь-які інші. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою. Чому ви не можете використовувати арифметичні операції з ними? В Scala ви можете це робити. В залишку цієї глави ми покажемо вам, як саме. </p><p>Перший крок є заміна add на звичайний математичний спосіб. Це робиться прямолінійно, бо + є легальним ідентифікатором в Scala. Ми можемо просто визначити метод з + в якості імені. Та коли ми вже беремось до цього, ми також можемо реалізувати метод на ім'я *, що виконує множення. Результат показаний в Лістингу 6.4:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
        <p>Лістинг 6.4 Rational з методами-операторами.</p><p>Коил клас Rational визначений в такий спосіб, ви тепер можете записати:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 2)
x: Rational = 1/2
scala&gt; val y = new Rational(2, 3)
y: Rational = 2/3
scala&gt; x + y
res8: Rational = 7/6</pre>
        <p>Як і завжди операторний синтаксис в останньому рядку еквівалентний до виклику метода. Ви також можете записати:</p>
<pre class="prettyprint linenums language-scala">scala&gt; x.+(y)
res9: Rational = 7/6</pre>
        <p>але це не читабельне.</p><p>Інша річ, що треба занотувати, це надані правила Scala до преоритетів операторів, що були описані в Розділі 5.8, метод * буде асоціюватись більш тісно, ніж метод + для Rational. Іншими словами, вирази, що включають оператори + та * над Rational будуть поводитись, як очікується. Наприклад, x + x * y буде виконуватись як x + (x * y), не як (x + x) * y:</p>
<pre class="prettyprint linenums language-scala">scala&gt; x + x * y
res10: Rational = 5/6
scala&gt; (x + x) * y
res11: Rational = 2/3
scala&gt; x + (x * y)
res12: Rational = 5/6</pre>
        <h3>6.10 Ідентифікатори в Scala</h3><p>Тепер ви побачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифровий, та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Окрім двох форм ви бачили ще два інші. Всі чотири форми формування ідентифікаторів описані в цьому розділі.</p><p>Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за якими можуть слідувати літери, цифри або підкреслення. Сивол ‘$’ також вважається за літеру, однак він зарезервований для ідентифікаторів, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах не повинні містити символи ‘$’, навіть якщо вони компілюються; не дотримання цього може призвести до конфліктів імен з ідентифікаторами, згенерованими компілятором Scala.</p><p>Scala слідує домовленостім Java щодо використання ідентифікаторів в верблюжому реєстрі, таких,як toString та HashSet. Хоча підкреслення допустимі в ідентифікаторах, вони не так часто використовуються в програмах Scala, частково для узгодженості з Java, але також оскільки підкреслення має багато інших, не-індефікаторних використань в коді Scala. Як результат, краще уникати ідентифікаторів як to_string, __init__, або name_. Верблюжий реєстр для полів, параметрів методів, локлаьних змінних та функцій повинні починатись з малої літери, наприклад: length, flatMap, та s. Верблюжий реєстр імен класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: BigInt, List, та UnbalancedTreeMap.</p><h4>Зауваження</h4><p>Одне зі слідоцтв використання підкреслення в кінці ідентифікатора є те, що коли ви спробуєте написати декларацію такого гатунку<br>"val name_: Int = 1", ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь задекларувати val на ім'я "name_:". Щоб примусити це компілюватись, вам треба вставити додатковий проміжок перед двома крапками: "val name_ : Int = 1".</p><p>Одним шляхом, як домовленості Scala відрізняються від Java, включають імена констант. В Scala ключове слово constant означає не тільки val. Навіть зважаючи на те, що val залишаєтся незмінним після ініціалізації, це все ще змінна. Наприклад, параметри метода є val, але кожного разу, коли викликається метод, ці val може містити різні значення. Константи є більш сталими. Наприклад, scala.math.Pi визначене є бути значенням double, найближчим до дійсного значення π, відношення довжини кола до деаметру. Це значення чи навряд колись зміниться, і, таким чином, Pi є дійсною константою. Також ви можете використовувати константи для іменування значень, що в іншому випадку були б магічними числами в вашому коді: літеральні значення без пояснень, що в гіршому випадку з'являються в декількох місцях. Також ви можете побажати визначити константи для використання в співпадіння шаблонів, випадок використання, що буде описаний в Розділі 15.2. В Java по домовленості імена констант отримують імена з великих літер, з підкресленнями для розділення слів, як в MAX_VALUE або PI. В Scala за домовленостю тільки перший символ має бути великою літерою. Таким чином, константи, що названі в стилі Java, такі як X_OFFSET, будуть робити як константи в Scala, але домовленість Scala використовувати верблюжий реєстр для констант, такі як XOffset .</p><p>Ідентифікатори-оператори складаються з одного або більше операторних символів. Операторні символи є друкуємі символи ASCII, такі як +, :, ?, ~ або #. Ось деякі приклади операторних ідентифікаторів:</p>
<pre class="prettyprint linenums language-scala">+
++
:::
&lt;?&gt;
:-&gt;</pre>
        <p>Компілятор Scala буде внутрішньо "підмальовувати" операторні ідентифікатори, щоб перетворити їх на звичайні ідентифікатори Java з вбудованими символвами $. Наприклад, ідентифікатор :-&gt; врутрішньо буде представлений як $colon$minus$greater. Якщо ви бажаєте отримати доступ до такого ідентифікатора з кода Java, вам буде треба використовувати інутрішнє представлення.</p><p>Оскільки операторні ідентифікатори в Scala можуть мати довільну довжину, є мала різниця між Java та Scala. В Java x&lt;-y буде розібране як чотири лексичні символи, так що це буде еквівалентне до x &lt; - y. В Scala <br>&lt;- буде розібране як один ідентифікатор, даючи x &lt;- y. Якщо ви бажаєте першу інтерпретацію, вам треба розділити символи &lt; та - за допомогою проміжка. Це навряд чи буде проблемою на практиці, бо дуже мало людей будуть писати x&lt;-y в Java, без вставки проміжків або дужок між операторами.</p><p>Змішані ідентифікатори складаються з алфавітно-цифрового ідентифікатора, за яким іде підкреслення та операторний ідентифікатор. Наприклад, unary_+використовується як ім'я метода, що визначає оператор +. Або myvar_= використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі myvar_= генеруються компілятором Scala для підтримки властивостей; більше про це ви знайдете в Главі 18.</p><p>Літеральний ідентифікатор є довільним рядком, що заточений в зворотні лапки ( ` . . . ` ). Деякі приклади літеральних ідентифікаторів:</p>
<pre class="prettyprint linenums language-scala">`x`
`&lt;clinit&gt;`
`yield`</pre>
        <p>Ідея полягає в тому, що ви можете покласти любий рядок, що доступний під час виконання, як ідентифікатор між зворотніми лапками. Результатом завжди є ідентифікатор Scala. Це робить навіть якщо ідентифікатор в зворотніх лапках буде зарезервованим словом Scala. Типовий приклад використання є доступ до статичного метода yield в класі Java Thread. Ви не можете написати Thread.yield(), оскільки yield є зарезервованим словом в Scala. Однак ви все ще можете назвати метод в зворотніх лапках, тобтоThread.`yield`() .</p><h3>6.11 Перевантаження методів</h3><p>Повернемось до класа Rational. З останніми змінами тепер ви можете виконувати додавання та множення в природний спосіб на раціональних числах. Але одна річ, що нам бракує, є змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди * мають бути Rational. Доки для раціонального числа r ви не можете записати r * 2. Ви маєте записати r * new Rational(2), що не є гарним. Щоб зробити Rational навіть більш зручним, ми додамо нові методи до класа, що виконують змішені додавання та множення на раціональних числах та цілих. Доки ми розглядаємо це, ми додамо методи для віднімання та ділення. Результат показаний в Лістингу 6.5.</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
        denom * that.denom
    )
  def + (i: Int): Rational =
    new Rational(numer + i * denom, denom)
  def - (that: Rational): Rational =
    new Rational(
      numer * that.denom - that.numer * denom,
      denom * that.denom
    )
  def - (i: Int): Rational =
    new Rational(numer - i * denom, denom)
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  def * (i: Int): Rational =
    new Rational(numer * i, denom)
  def / (that: Rational): Rational =
    new Rational(numer * that.denom, denom * that.numer)
  def / (i: Int): Rational =
    new Rational(numer, denom * i)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre><p>Лістинг 6.5 Rational з перевантаженими методами.</p>

<p>Тепер є дві версії кожної арифметичної операції: одна, що приймає раціональний аргумент, та інший, що приймає ціле. Іншими словами, кожне з ціх імен методів є перевантаженими, оскільки кожне ім'я тепер використовується декількома методами. Наприклад, ім'я + використовується одним методом, що приймає Rational, та інше, що приймає Int. Коли викликається метод компілятор обирає версію перевантаженого метода, що коректно співпадає з типуми аргументів. Наприклад, якщо аргумент y в x.+(y) є Rational, компілятор обере метод +, що приймає параметр Rational. Але якщо аргумент ціле, компілятор обере метод, що приймає параметр Int. Якщо ви спробуєте таке:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(2, 3)
x: Rational = 2/3
scala&gt; x * x
res13: Rational = 4/9
scala&gt; x * 2
res14: Rational = 4/3</pre>
        <p>Ви побачите, що метод *, що викликається в кожному випадку, буде відповідати до типу операнду.</p><h4>Зауваження</h4><p>Процес Scala обробки розрішення перевантажених методів дуже подібний до Java. В жодному випадку обрана перевантажена версія буде та, що найкраще співпадає зі статичними типуми аргументів. Іноді немає унікальної кращої співпадаючої версії; в цьому випадку компілятор видасть вам помилку "неоднознозначного посилання".</p><h3>6.12 Неявні перетворення</h3><p>Тепер, коли ви можете записати&nbsp; r * 2, ви також можете побажати переставити операнди, як в 2 * r. На жаль, це доки не працює:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 2 * r
&lt;console&gt;:7: error: overloaded method value * with
alternatives (Double)Double &lt;and&gt; (Float)Float &lt;and&gt;
(Long)Long &lt;and&gt; (Int)Int &lt;and&gt; (Char)Int &lt;and&gt; (Short)Int
&lt;and&gt; (Byte)Int cannot be applied to (Rational)
2 * r<br>ˆ</pre>
        <p>Тут проблема в тому, що 2 * r еквівалентне до 2.*(r), так що метод викликається на числі 2, яке є цілим. Вле клас Int не має метода множення, що приймає аргумент Rational — він і не може, бо клас Rational не є стандартним класом бібліотеки Scala. </p><p>Але є інший шлях до вирішення цієї проблеми в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі в раціональні в разі необхідності. Спробуйте додати такий рядок в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; implicit def intToRational(x: Int) = new Rational(x)</pre>
        <p>Це додасть метод конвертації з Int до Rational. Модифікатор implicit попереду метода каже компілятору автоматично застосовувати його в деяких ситуаціях. З визначеним перетворенням тепер ви можете спробувати приклад, що раніше давав збій:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(2,3)
r: Rational = 2/3
scala&gt; 2 * r
res16: Rational = 4/3</pre>
        <p>Зауважте, щоб неявне перетворення робило, воно має бути в полі зору. Якщо ви покладете визначення неявного метода в клас Rational, він не буде в полі зору компілятора. Покі ви маєте визначати його напряму в інтерпретаторі. </p><p>Як може промайнути з цього приклада, неявні перетворення є дуже потужним прийомом, щоб зробити бібліотеки більш гручкими та більш зручними в використанні. Оскільки вони такі потужні, вони можуть бути легко невірно застосовуватись. Ви знайдете більше щодо неявних перетворень, включаючи шляхи по занесенню їх в поле зору, в Главі 21.</p><h3>6.13 Слово попередження</h3><p>Як демонструє ця глава, створення методів з операторними іменами та визначення неявних перетворень можуть допомогти вам розробити бібліотеки, для яких клієнтський код буде стислим та простим для розуміння. Scala надає вам велику потужність розробляти такі прості для використання бібліотеки, але майте на увазі, що ці потужність супроводжується відповідальністю. </p><p>При незграбному використанні обоє, операторні методи та неявні перетворення можуть дати життя клієнтському коду, що буде важко читати та розуміти. Оскільки неявні перетворення неявно застосовуються компілятором, а не явно прописані в коді, може бути неочевидним для програмістів клієнтськох частини, які неявні перетворення будуть застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його більш читабельним тільки в тій мірі, доки програмісти будуть розпізнавати та пам'ятати значення кожного оператора.</p><p>Ціль, що ви маєте утримувати на увазі при розробці бібліотек, це не тільки давати стислість клієнтського кода, але також сприяти читабельності та розумінню клієнтського кода. Стислість значною мірою буде частиною цієї читабельності, але ви можете завести цю стислість надто далеко. Розроблюючи бібліотеки, що надають витончено стислий, та, в той же час, зрозумілий клієнтський код, ви можете допомогти продуктивній роботі програмістам клієнтської частини.</p><h3>6.14 Висновок</h3><p>В цій главі ви побачили більше аспектів класів в Scala. Ви побачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, щоб їх було природно використовувати. Можливо, найбільш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить природним способом кодування в Scala.</p><p>Хоча заключна версія Rational, показана в цьому розділі, задовільняє вимогам, сформульованим на початку цієї глави, вона все ще може бути покращена. Фактично, ми будем оповертатись до цього приклада пізніше в цій книзі. Наприклад, в Главі 30 в инавчитесь, як перевизначивати equals та hashcode, щоб Rational краще поводились при порівнянні за допомогою ==, або при розміщенні в хеш таблицях. В Главі 21 ви навчитесь, як розміщувати визначення неявних методів в об'єкті-компанйоні Rational, так що ви більш просто зможете заносити його в поле зору, коли програмісти клієнтів будуть робити з Rationals.</p><h4>Глава 7</h4><h3>Вбудовані структури керування</h3><p>Scala має тільки декілька вбудованих структур керування. Єдині структури є if, while, for, try, match, та виклики функцій. Причина, чому Scala має так небагато в тому, що вона включає літерали функцій з самого моменту її створення. Замість аккумуляції однієї за одною високорівневих структур керування в базовому синтаксисі, Scala акумулює їх в бібліотеках. Глава 9 покаже в точності, як це робиться. Ця глава покаже декілька структур керування, що вбудовані в мову.</p><p>Одна річ, що ви занотуєте, це те, що майже всі структури керування в Scala повертають деяке значення. Цей підхід, взятий від функціональних мов, в якому програми розглядаються як обчислення значення, так що компоненти програми повинні обчислювати значення. Ви також можете розглядати цей підхід як логічне довершення тенденції, що вже присутня в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть якщо виклик функції оновлюють вихідну змінну, що передана як аргумент, також буде робити. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор ?: в&nbsp; C, C++, та Java), який поводиться точно як if, але повертає значення. Scala адаптує цю модель тримісного оператора, але викликає його як if. Іншими словами, в Scala if може продукувати значення. Потім Scala продовжує цей тренд, маючи for, try, та match, що також повертають значення.</p><p>Програмісти можуть використовувати ці результати для спрощення свого кода, так само, як вони використовують повернуті функціями значення. Без цієї можливості програміст змушений створювати тимчасові змінні тільки для збереження результатів зсередини керівних структур. Видалення ціх тимчасових змінних робить код трохи простішим, та це також уникає багатьох помилок, коли ви встановлюєте змінну в одному відгалуженні, але забуваєте встановити її в іншому.</p><p>Загалом, базові керівні структури Scala, мінімальні як вони є, достатні для провадження всіх основ з імперативних мов. Більше того, вони дозволяють вам скоротити ваш код, узгоджено маючи значення результата. Щоб показати вам, як все це робить, ця глава надає ближчий погляд на кожну з керівних структур Scala.</p><h3>7.1 Вирази if</h3><p>В Scala вираз if робить так само, як і в багатьох інших мовах. Він перевіряє умову, та потім виконує одне або двок відгалужень кода, в залежності від того, чи умова обчислюється як true. Ось загальний приклад, написаний в імперативному стилі:</p>
<pre class="prettyprint linenums language-scala">var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)</pre>
        <p>Цей код декларує змінну filename, та використовує її як значення по замовчанню. Потім використовєуться вираз if, щоб перевірити, чи до програми були передані будь-які аргументи. Якщо це так, код змінює змінну, щоб вона отримала значення, вказане в списку аргументів. Якщо аргументи не надані, він залишає змінну, встановлену в значення по замовчанню.</p><p>Цей код може бути записаний більш гарно, оскільки, як вказано на кроці 3 в Главі 2, в Scala if є виразом, що продукує значення. Лістинг 7.1 показує, як ви можете досягти такого ж ефекту, що і приклад вище, але без використання жодного var:</p>
<pre class="prettyprint linenums language-scala">val filename = if (!args.isEmpty) args(0) else "default.txt"</pre>
        <p>Лістинг 7.1 Ідіома Scala для умовної ініціалізації.</p><p>На цей раз if має два відгалуження. Якщо args не пустий, обирається елемент ініціалізації args(0). Інакше обирається значення по замовчанню. Вираз if дає результат в вигляді обраного значення, та змінна filename ініціалізується цім значенням. Цей код трохи коротший, але справжня перевага в тому, що він використовує val замість var. Використання val є функціональним стилем, та це допомагає вам майже в той же спосіб, що і фінальні змінні в Java. Це каже читачам кода, що змінна ніколи не буде змінюватись, зберігаючи їх від сканування всього кода в полі зору змінної, щоб побачити, чи не змінюється вона де-інде.</p><p>Друга перевага використання val замість var в тому, що це краще підтримує міркування рівності. Введене значення є рівним виразу, що обчислює його, при умові, що вираз не має побічного ефекту. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, ви можете замість цього записати вираз. Замість println(filename), наприклад, ви можете записати таке:</p>
<pre class="prettyprint linenums language-scala">println(if (!args.isEmpty) args(0) else "default.txt")</pre>
        <p>Вибір за вами. Ви можете писати будь-як. Використовуючи val допомагає вам безпечно робити цей різновид рефакторингу, кожного разу, коли обчислюється ваш код. Шукайте можливості використовувати val. Вони можуть зробити ваш код обоє, простішим для читання, та простішим для рефакторингу.</p><h3>7.2 Цикли while</h3><p>Цикл Scala while поводиться як в інших мовах. Він має умову та тіло, та це тіло виконується раз за разом, доки умова обчислюється як true. Лістинг 7.2 показує приклад:</p>
<pre class="prettyprint linenums language-scala">def gcdLoop(x: Long, y: Long): Long = {
  var a = x
  var b = y
  while (a != 0) {
    val temp = a
    a = b % a
    b = temp
  }
  b
}</pre>
        <p>Scala також має цикл do - while. Це робить як цикл while, за винятком того, що умова перевіряється після виконання тіла цикла, а не перед. Лістинг 7.3 показує скрипт Scala, що використовує do-while для виводу рядків, що читаються зі стандартного вводу, доки не буде введений пустий рядок:</p>
<pre class="prettyprint linenums language-scala">var line = ""
do {
  line = readLine()
  println("Read: "+ line)
} while (line != "")</pre>
        <p>Лістинг 7.3 Читання з стандартного вооду за допомогою do-while.</p><p>Конструкції while та do-while називаються "циклами", не виразами, оскільки вони не повертають цікавого значення. Тип результата є Unit. Існує тільки одне значення (та, фактично, це дійсно тільки одне значення), чий тип є Unit. Це називається значенням блоку, та записується (). Існування () є тим, як Scala Unit відрізняється від Java void. Спробуйте це в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def greet() { println("hi") }
greet: ()Unit
scala&gt; greet() == ()
hi
res0: Boolean = true</pre>
        <p>Оскільки перед тілом не стоїть знак рівності, greet визначена як процедура, з типом результата Unit. Таким чином, greet повертає значення блока, (). Це підтверджується в наступному рядку: порівнюючи результат greet на рівність зі значенням блоку, (), дає true.</p><p>Одна інша конструкція, що повертає значення блоку, що стосується нашої теми, є повторне присвоєння до var. Наприклад, коли ви намагаєтесь прочитати рядкі в Scala з використанням наступного цикла while, ідіоматичного для Java (C та C++), ви натрапите на проблеми:</p>
<pre class="prettyprint linenums language-scala">var line = ""
while ((line = readLine()) != "") // Це не працює!
  println("Read: "+ line)</pre>
        <p>Коли ви компілюєте цей код, Scala видасть вам попередження, що порівняння значень типу Unit та String з використанням != завжди буде повертати true. Коли в Java присвоєння повертає присвоєне значення, в цьому випадку рядок зі стандартного входу, в Scala присвоєння завжди повертає значення блоку, (). Таким чином, значення присвоєння "line = readLine()" завжди буде (), та ніколи "". Як результат, умова цього цикла while ніколи не будет false, і, таким чином, цикл ніколи не завершиться.</p><p>Оскільки цикл while не повертає значення, він часто не використовується в чисто функціональних мовах. Такі мови мають вирази, але не цикли. Scala, тим не менш, включає цикли while, оскільки іноді імперативне рішення може краще читатись, особливо для програмістів з переважно імперативним підгрунтям. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес, доки не зміниться деяка умова, цикл while може виразити це напряму, але функціональна альтернатива, що, вірогідно, включатиме рекурсію, може бути менш очевидною для читачів кода.</p><p>Наприклад, Лістинг 7.4 показує альтернативний шлях визначити більший загальний дільник двох чисел. Беручи ті самі два значення x та y, що і функція gcd, показана в Лістингу 7.4, буде отримано такий самий результат, що і в функції gcdLoop, показаній в Лістингу 7.2. Різниця між ціма двома підходами в тому, що gcdLoop написаний в імперативному стилі, з використанням var s та цикла while, тоді як gcd написана в більш функціональному стилі, що включає рекурсію (виклики самої gcd), та не потребує var.</p>
<pre class="prettyprint linenums language-scala">def gcd(x: Long, y: Long): Long = if (y == 0) x else gcd(y, x % y)</pre>
        <p>Лістинг 7.4 Обчислення найбільшого загального дільника за допомогою рекурсії.</p><p>Загалом, ми рекомендуємо вам позбуватись від циклів while в вашому коді, таким же чином, як ви позбуваєтесь var. Фактично, цикли while та var часто ідуть рука в руку. Оскільки цикли while не призводять до значення, щоб зробити будь-яку зміну в вашій програмі, цикл while буде звичайно або потребувати оновлення var, або виконання I/O. Ви можете бачити це в дії в прикладі gcdLoop, що показаний раніше. По мірі того, як цикл while робить свою справу, він оновлює var a та b. Таким чином, ми рекомендуємо вам бути трохи підозрілим до уиклів while в вашому коді. Якщо немає гарного обгрунтування для окремого циклу while або do-while, спробуйте знайти спосіб зробити ті ж речі без них.</p><h3>7.3 Вирази for</h3><p>Вираз Scala є швейцарським ножем в віті ітерацій. Він дозволяє вам комбінувати декілька простих інгредієнтів в різний спосіб, щоб виразити різні ітерації. Прості використання дозволяють загальні операції, такі, як ітерація по послідовності цілих. Більш складні вирази можуть ітерувати по декільком колекціям, різного типу, можуть фільтрувати елементи, базуючись на довільних умовах, та можуть продукувати нові колекції.</p><h4>Ітерація по колекціях</h4><p>Найпростіша річ, що ви можете зробити за допомогою for, це ітерація по елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що роздруковує всі файли в поточному каталозі. I/O виконується за допомогою Java API. Перше, ми створюємо java.io.File на поточному каталозі, ".", та викликаємо його метод listFiles. Цей метод повертає масив з об'єктів File, по одному для кожного каталогу та файла в поточному каталозі. Ми зберігаємо отриманий масив в змінній filesHere.</p>
<pre class="prettyprint linenums language-scala">val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere)
println(file)</pre>
        <p>Лістинг 7.5 Перелік файлі в каталозі за допомогою виразу for.</p><p>За допомогою синтаксиса "file &lt;- filesHere", що називається генератором, ми ітеруємо по елементах filesHere. На кожній ітерації нове val на ім'я file ініціалізується значенням елемента. Компілятор виводить тип file як File, оскільки filesHere є Array[File]. Для кожної ітерації виконується тіло виразу for, println(file). Оскільки метод File toString дає ім'я файла або каталога, таким чином будуть надруковані імена всіх файлів та каталогів в поточному каталозі. Синтаксис виразів for робить для любого різновиду колекцій, не тільки для масивів. Одним зі зручних особливих випадків є тип Range, що ми коротко бачили в Таблиці 5.4. Ви можете створити Range з використанням синтаксису на кшталт "1 to 5", та можете ітерувати по ньому за допомогою for. Ось простий приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; for (i &lt;- 1 to 4)
  println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3
Iteration 4</pre>
        <p>Якщо ви не бажаєте включити верхню межу диапазону в значення, по яких відбувається ітерація, використовуйте until замість to :</p>
<pre class="prettyprint linenums language-scala">scala&gt; for (i &lt;- 1 until 4)
  println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3</pre>
        <p>Ітерація по цілим в такий спосіб є загальною в Scala, але навряд чи так само в інших мовах. В інших мовах ви можете використовувати цю можливість для ітерації по масиву:</p>
<pre class="prettyprint linenums language-scala">// Не є загальним в Scala...
for (i &lt;- 0 to filesHere.length - 1)
&nbsp; println(filesHere(i))</pre>
        <p>Цей вираз вводить змінну i, встановлює її на кожному циклі в ціле між 0 та filesHere.length - 1, та виконує тіло вираза for для кожного встановленого i. Для кожної установки i виділяється та обробляється i-тий елемент filesHere. Причина, за якої цей тип ітерації менш загальний в Scala полягає в тому, що ви можете добре ітерувати по самій колекції. Якщо ви так робите, ваш код стає коротшим, та ви обходите багато з численних помилок, що можуть виникнути, коли ви ітеруєте по масивах. Повинні ви починати з 0 або 1? Повинні ви додавати -1, +1, або нічого до заключного індекса? На такі питання легко відповісти, але просто відповісти невірно. Безпечніше зовсім уникати таких питань.</p><h4>Фільтрація</h4><p>Іноді ви не бажаєте ітерувати по колекції повністю. Ви бажаєте відфільтрувати її до деякої підмножити. Ви можете зробити це за допомогою виразу for, додавши фільтр в вигляді твердження if в дужках for. Наприклад, код, показаний в Лістингу 7.6 перелічує тільки ті файли в поточному каталозі, що закінчуються на ".scala":</p>
<pre class="prettyprint linenums language-scala">val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere if file.getName.endsWith(".scala"))
  println(file)</pre>
        <p>Listing 7.6 · Finding .scala files using a for with a filter.</p><p>Ви можете альтернативно досягти тієї ж цілі за допомогою такого кода:</p>
<pre class="prettyprint linenums language-scala">for (file &lt;- filesHere)
if (file.getName.endsWith(".scala"))
  println(file)</pre>
        <p>Цей код дає той же вивод, що і попередній, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Імперативна форма, однак, є тільки опцією, оскільки цей окремий вираз for виконується тільки заради його побічного ефекта, друку, та повертає значення типу блок (). Як ми продемонструємо пізніше в цьому розділі, вираз for називається "виразом", оскільки він може повертати результат в вигляді цікавого значення, колекції, чий тип визначається твердженням виразу &lt;-.</p><p>Ви можете задати більше фільтрів за бажанням. Просто додавайте твердження if. Наприклад, для додаткового захисту, код в Лістингу 7.7 друкує тільки файли, але не каталоги. Віно робить це, додаючи фільтр, що перевіряє метод файла isFile.</p>
<pre class="prettyprint linenums language-scala">for (
  file &lt;- filesHere
  if file.isFile
  if file.getName.endsWith(".scala")
) println(file)</pre>
        <p>Лістинг 7.7 Використання декількох фільтрів в виразі for.</p><h4>Вкладені ітерації</h4><p>Якщо ви додасте декілька тверджень &lt;-, ви отримаєте вкладені "цикли". Наприклад, вираз for, показаний в Лістингу 7.8 має два вкладені цикли. Зовнішній цикл ітерує по filesHere, та внутрішній цикл ітерує по fileLines(file) для кожного файла, що закінчується на .scala .</p>
<pre class="prettyprint linenums language-scala">def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
  for (
    file &lt;- filesHere
    if file.getName.endsWith(".scala");
    line &lt;- fileLines(file)
    if line.trim.matches(pattern)
  ) println(file +": "+ line.trim)
grep(".*gcd.*")</pre>
        <p>Лістинг 7.8 Використання декількох генераторів для виразу for.</p><p>Якщо така ваша ласка, ви можете використовувати фігурні дужки замість дужок, щоб огортати генератори та фільтри. Одна перевага від використання фігурних дужок в тому, що ви можете відкинути декілька крапок з комою, що потрібні при викорстанні звичайних дужок, оскільки, як пояснюється в Розділі 4.2, компілятор Scala не буде виводити крапки з комою в звичайних дужках.</p><h4>Прикріплення змінних посередині потоку обробки</h4><p>Зауважте, що попередній код повторює вираз line.trim. Це нетривіальне обчислення, так що можете побажати виконати його тільки один раз. Ви можете зробити це, прив'язавши результат до нової змінної з використанням знака рівності ( = ). Прив'язана змінна вводиться та використовується як val, тільки без самого ключового слова. Лістинг 7.9 показує приклад. В Лістингу 7.9 вводиться змінна на ім'я trimmed посередині виразу for. Ця змінна ініціалізована результатом line.trim. Залишок виразу використовує змінну в двох місцях, один раз в if, та ще раз в println.</p>
<pre class="prettyprint linenums language-scala">def grep(pattern: String) =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
    line &lt;- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(pattern)
  } println(file +": "+ trimmed)
grep(".*gcd.*")</pre>
        <p>Лістинг 7.9 Присвоєння під час виконання виразу for.</p><h4>Продукування нової колекції</h4><p>Доки всі приклади оперували з отриманими значеннями, та потім забували про них, але також можливо генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, поставьте в якості префікса ключове слово yield. Наприклад, ось функція, що ідентифікує файли .scala, та зберігає їх в масиві:</p>
<pre class="prettyprint linenums language-scala">def scalaFiles =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
  } yield file</pre>
        <p>Кожного разу, коли виконується тіло виразу for, воно продукує значення, в даному випадку просто file. Коли цей вираз закінчується, результат буде включати всі отримані значення в вигляді однієї колекції. Тип отриманої колекцій базується на типі колекції, що оброблялась в ітерації. В цьому випадку результат буде Array[File], оскільки filesHere є масивом, і тип отриманих значень є File. До речі, будьте уважні, де розміщати ключове слово yield. Синтаксис для виразу for - yield такий:</p>
<pre class="prettyprint linenums language-scala">for clauses yield body</pre>
        <p>Слово yield іде перед цілим тілом. Навіть якщо тіло є блоком, оточеним ффігурними дужками, ставьте yield перед першими фігурними дужками, не перед останнім виразом в блоці. Уникайте спокуси писати такі речі:</p>
<pre class="prettyprint linenums language-scala">for (file &lt;- filesHere if file.getName.endsWith(".scala")) {
  yield file
// Синтаксична помилка!
}</pre>
        <p>Наприклад, якщо вираз, показаний в Лістингу 7.10 спочатку трансформує Array[File] на ім'я filesHere, що містить всі файли в поточному каталозі, в один, що містить тільки файли .scala. Для кожного з них він генерує Iterator[String] (результат метода fileLines, чиє визначення показане в Лістингу 7.8). Iterator пропонує методи next та hasNext, що дозволяють вам ітерувати по колекції елементів. Цей початковий ітератор трансформується в інший, Iterator[String], що містить тільки обрізані рядки, що включають підрядок "for". Нарешті, для кожного з них отримується ціла довжина. Результат цього виразу Array[Int], що містить ці довжини.</p>
<pre class="prettyprint linenums language-scala">val forLineLengths =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
    line &lt;- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(".*for.*")
  } yield trimmed.length</pre>
        <p>Лістинг 7.10 Трансформація Array[File] до Array[Int] за допомогою for.</p><p>На цей момент ви бачили всі головні можливості Scala щодо виразів for. Однак цей розіл пройшов по них досить швидко. Більш щільне покриття виразів for надається в Главі 23.</p><h3>7.4 Обробка виключень за допомогою виразів try</h3><p>Виключення Scala поводяться просто як більшість багатьох інших мовах. Замість повернення значення в звичайний спосіб, метод може перервати виконання, піднявши виключення. Той, хто викликає метод, може або перехопити та обробити це виключення, або він може зам завершитись, в якому випадку виключення просувається до того, хто викликав викликаючого. Виключення просувається в такий спосіб, розмотуючи стек викликів, доки метод не обробить його, або коли не залишиться більше методів. </p><h4>Підняття виключень</h4><p>Підняття виключень виглядає так само, як в Java. Ви створюєте виключення, та потім підіймаєте його за допомогою ключового слова throw:</p>
<pre class="prettyprint linenums language-scala">throw new IllegalArgumentException</pre>
        <p>Хоча це може виглядати трохи парадоксальним, в Scala throw є виразом, що має тип повернення. Ось приклад, де тип повернення має значення:</p>
<pre class="prettyprint linenums language-scala">val half =
  if (n % 2 == 0)
    n / 2
  else
    throw new RuntimeException("n must be even")</pre>
        <p>Що тут відбувається, це те, що коли n парне, half буде ініціалізоване як половина n. Якщо n непарне, буде підійняте виключення, перед тим, як half взагалі буде ініціалізоване. Завдяки цьому є безпечним трактувати підняті виключення як любий тип значення. Любий контекст, що намагається використовувати результат після throw, ніколи не отримає можливість зробити це, і, таким чином, нічого поганого не відбудеться. Технічно, підняття виключення має тип Nothing. Ви можете використовувати throw як вираз, навіть не зважаючи на те, що він насправді нічого не обчислює. Цей невеликий фрагмент технічної гімнастики може виглядати збоченим, але часто є корисним в випадках, схожий не показаний вище приклад. Одна гілка if обчислюється до значення, тоді як інша підіймає виключення, та обчислюється до Nothing. Тип цілого виразу if потім буде типом тієї гілки, що обчислює дещо. Тип Nothing обговорюється в Розділі 11.3.</p><h4>Перехоплення виключень</h4><p>Ви перехоплюєте виключення з використанням синтаксису, показаному в Лістингу 7.11. Синтаксис для тверджень catch був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та більш детально в Главі 15.</p>
<pre class="prettyprint linenums language-scala">import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException
try {
  val f = new FileReader("input.txt")
  // Використовуємо за зачиняємо файл
} catch {
  case ex: FileNotFoundException =&gt; // Обробка відсутнього файла
  case ex: IOException =&gt; // Обробка інших помилок I/O
}</pre>
        <p>Лістинг 7.11 Твердження try-catch в Scala.</p><p>Поведінка цього виразу try - catch така ж, що і в інших мовах з виключеннями. Тіло виконується, та якщо там підіймається виключення, перебираються кожне твердження catch один за одним. В цьому прикладі, якщо виключення є типу FileNotFoundException, буде викликане перше твердження. Якщо тип IOException, буде викликане друге твердження. Якщо виключення не одного з перелічених типів, try - catch завершиться, та виключення буде передане далі. </p><h4>Зауваження</h4><p>Одна відмінність від Java, що ви швидко помітили, в тому, що Scala, на відміну від Java, не змушує вас перехоплювати перевірені виключення, або декларувати їх в твердженні throws. Ви можете декларувати твердеження throws, якщо ви бажаєте, за допомогою анотації @throws, але це не є вимогою. Дивіться Розділ 31.2 для додаткової інформації щодо @throws.</p><h4>Твердження finally</h4><p>Ви можете огорнути вираз в твердження finally, якщо ви бажаєте, щоб деякий код виконувався, безвідносно від того, як завершиться деякий вираз. Наприклад, ви можете бажати переконатись, що файл буде закритий, навіть якщо метод скінчиться підняттям виключення. Лістинг 7.12 показує приклад.</p>
<pre class="prettyprint linenums language-scala">import java.io.FileReader
val file = new FileReader("input.txt")
try {
  // Використовуємо файл
} finally {
  file.close()
  // Переконались, що файл буде закритий
}</pre>
        <p>Лістинг 7.12 Твердження try-finally в Scala.</p><h4>Зауваження</h4><p>Лістинг 7.12 показує ідеоматичний спосіб переконатись, що ресурс не-з-пам'яті, такий, як файл, сокет або з'єднання за базою даних, буде закритий. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок try, в якому ви використовуєте ресурс. Нарешті, ви закриваєте ресурс в блоці finally. Ця ідіома та ж сама в Scala, що і в Java, однак, в Scala ви можете альтернативно задіяти прийом, що називаєтсья шаблоном позичання, щоб досягти тієї ж цілі більш стисло. Шаблон позичання описаний в Розділі 9.4.</p><h4>Отримання значення</h4><p>Як і більшістю структр керування Scala, try - catch - finally завершується отриманням значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Цей призводить до того, що дає твердження try, якщо виключення не спрацювало. Якщо виключення було підійняте, але не перехоплене, вираз зовсім не має результата. </p>
<pre class="prettyprint linenums language-scala">import java.net.URL
import java.net.MalformedURLException
def urlFor(path: String) =
  try {
    new URL(path)
  } catch {
    case e: MalformedURLException =&gt;
      new URL("http://www.scala-lang.org")
  }
</pre><p>Лістинг 7.13 Твердження catch, що повертає значення.</p>
<p>Значення, обчислене в твердженні finally, якщо тако є, буде відкинуте. Звичайно твердження finally виконують деякий різновид очищення, таке, як зачинення файлів; вони зазвичай не змінюють значення, обчислене в головному тілі, або в блоці catch конструкції try. Якщо ви добре знайомі з Java, стає зрозумілим, що поведінка Scala відрізняється від Java, хоча б тому, що в Java try-finally не повертає значення. Як і в Java, якщо блок finally включає явне тверодження return, або підіймає виключення, це повернуте значення або виключення будуть "перемагати" любі попередні, що походять з блоку try, або з одного з пунктуів catch. Наприклад, маємо таке, трохи надумане, визначення функції:</p>
<pre class="prettyprint linenums language-scala">def f(): Int = try { return 1 } finally { return 2 }</pre>виклик f() дає 2. Для контрасту, маючи таке:
<pre class="prettyprint linenums language-scala">def g(): Int = try { 1 } finally { 2 }</pre>
        <p>виклик g() повертає 1. Обоє з ціх функцій демонструють поведінку, що може здивувати більшість програмістів, і, таким чином, зазвичай краще уникати повернення значень з блока finally. Кращий шлях думати про блок finally, як про спосіб переконатись, що відбудеться деякий побічний ефект, такий, як закриття відчиненого файла.&nbsp;</p><h3>7.5 Вирази match</h3><p>В Scala вирази match дозволяють вам обирати з декількох альтернатив, просто як в твердженнях switch в інших мовах. Загалом, вираз match дозволяє вам використовувати довільні шаблони, що будуть описані в Главі 15. Загальна форма може зачекати. Поки що просто зупинимось на використанні співставлення з декількома альтернативами.</p><p>В якості приклада скрипт в Лістингу 7.14 читає назву їжі зі списка аргументів, та друкує додаток до цієї їжі. Цей вираз match перевіряє firstArg, що був встановлений в значення першого аргументу зі списку аргументів. Якщо значення встановлене в "salt", він друкує "pepper", але якщо це рядок "chips", він друкує "salsa", і так далі. Випадок по замовчанню вказаний підкресленням ( _ ), підстановочним символом, що часто використовується в Scala як замінник для повністю невідомого значення.</p><p>Є декілька важливих відмінностей від твердження Java switch. Одна полягає в тому, що любий тип констант, а також інших речей, може використовуватись в&nbsp;cases Scala, не тільки цілі типи та enum константи, як в твердженнях Java case. В Лістингу 7.14 альтернативами є рядки. </p>
<pre class="prettyprint linenums language-scala">val firstArg = if (args.length &gt; 0) args(0) else ""
firstArg match {
  case "salt" =&gt; println("pepper")
  case "chips" =&gt; println("salsa")
  case "eggs" =&gt; println("bacon")
  case _ =&gt; println("huh?")
}</pre>
        <p>Лістинг 7.14 Вираз match з побічними ефектами.</p>
<p>Інша різниця в тому, що немає break на кінці кожної альтернативи. Замість цього break є неявними, немає провалювання від одної альтернативи до наступної. Загальний випадок — не провалюватись — стає коротшим, та уникається витока помилок, оскільки програмісти не можуть більше провалитись випадково. Найбільш важлива різниця з Java switch, однак. може полягати в тому, що вирази match повертають значення. В попередньому прикладі кожна альтернатива в виразі match роздруковує значення. Це може робити так само, як повернення значення замість його друку, як показує Лістинг 7.15. Значення, що повертається з виразу match, зберігається в змінній friend. Крім того, що код стає коротшим (щонайменьше в частині токенів), тепер код розплутує дві різні турботи: зпершу він обирає їжу, та потім друкує її.</p>
<pre class="prettyprint linenums language-java">val firstArg = if (!args.isEmpty) args(0) else ""
val friend =
  firstArg match {
    case "salt" =&gt; "pepper"
    case "chips" =&gt; "salsa"
    case "eggs" =&gt; "bacon"
    case _ =&gt; "huh?"
  }
println(friend)</pre>
        <p>Лістинг 7.15 Вираз match, що повертає значення.</p><h3>7.6 Життя без break та continue</h3><p>Можливо, ви помітили, що ми не споминали про break або continue. Scala живе без ціх команд, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Зрозуміло, що continue означає в циклі while, але що це має значити в функціональному літералі?</p><p>Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Є багато способів програмувати без break та continue, та якщо ви приймете переваги функціональних літералів, ці альтернативи будуть загалом коротші, ніж оригінальний код.</p><p>Простіший підхід є замінити кожне continue на if, та кожний break на логічне значення. Логічне значення вказує, чи замикаючий цикл повинен продовжуватись. Наприклад, уявіть, що ви шукаєте серед списку аргументів рядок, що закінчується на ".scala", але не починається на мінус. В Java ви можете, якщо ви прихильник циклів while, break, та continue, написати наступне:</p>
<pre class="prettyprint linenums language-scala">int i = 0;
// Це Java
boolean foundIt = false;
while (i &lt; args.length) {
    if (args[i].startsWith("-")) {
        i = i + 1;
        continue;
    }
    if (args[i].endsWith(".scala")) {
        foundIt = true;
        break;
    }
    i = i + 1;
}</pre>
        <p>Щоб траслювати цей код Java напряму в Scala, замість робити if, та потім continue, ви можете написати if, що оточує цілий цикл while. Щоб позбутись break, ви можете звичайно додати логічну змінну, що вказує, чи треба продовжувати, але в цьому випадку ви можете використати foundIt. Використовуючи обоє з ціх трюків, код перетворюється на показаний в Лістингу 7.16.</p>
<pre class="prettyprint linenums language-scala">var i = 0
var foundIt = false
while (i &lt; args.length &amp;&amp; !foundIt) {
  if (!args(i).startsWith("-")) {
    if (args(i).endsWith(".scala"))
      foundIt = true
  }
  i = i + 1
}</pre>
        <p>Лістинг 7.16 Цикл без break та continue.<br><br>Цей код Scala в Листингу 7.16 досить подібний до оригінального кода Java. Всі базові частини ідуть в тому ж порядку. Є дві обумовлені змінні та цикл while. В циклі є перевірка, що i менше ніж args.length, перевірка на "-", та перевірка на ".scala". Якщо ви бажаєте прибрати var з Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію searchFrom, що сприймає ціле на вході, шукає далі з цього місця, та потім повертає індекс бажаного аргументу. Використовуючи цей прийом код буде виглядати як показано в Лістингу 7.17:
</p><pre class="prettyprint linenums language-scala">def searchFrom(i: Int): Int =
  if (i &gt;= args.length) -1
  else if (args(i).startsWith("-")) searchFrom(i + 1)
  else if (args(i).endsWith(".scala")) i
  else searchFrom(i + 1)
val i = searchFrom(0)</pre>
<p>Лістинг 7.17 Рекурсивна альтернатива циклу з var.</p>Версія в Лістингу 7.17 отримує зрозуміле людині ім'я того, що робить функція, та вона використовує рекурісію для заміни цикла. Кожне continue замінене на рекурсивний виклик з i + 1 в якості аргумента, ефективно просуваючись до наступного цілого. Багато людей знаходять цей стиль програмування простішим до розуміння, коли вони починають використовувати рекурсію.<h4>Зауваження</h4>Компілятор Scala не буде насправді створювати рекурсивну функцію для кода, показаного в Лістингу 7.17. Оскільки всі рекурсивні виклики знаходяться в самому кінці, компілятор згенерує код, подібний до циклу while. Кожний рекурсивний виклик буде реалізовано як стрибок назад до початку функції. Оптимізація кінцевих викликів буде обговорюватись в Розділі 8.9.<br><br>Якщо після всіх ціх розмов ви все ще потребуєте використання break, на поміч прийде стандартна бібліотека Scala. Клас Breaks в пакунку scala.util.control пропонує метод break, що може застосовуватись для виходу з оточуючого блоку, що помічений як breakable. Ось приклад, як можна застосовувати цей, наданий бібліотекою, метод break:<br>
<pre class="prettyprint linenums language-scala">import scala.util.control.Breaks._
import java.io._
<br>val in = new BufferedReader(new InputStreamReader(System.in))
<br>breakable {<br>  while (true) {
    println("? ")
    if (in.readLine() == "") break
  }
}</pre>
Це буде постійно читати непорожні рядки зі стандартного входу. Як тільки пористувач вводить пустий рядок, потік керування виходить з оточуючого breakable, та, разом з цім, з циклу while. Клас Breaks реалізує break через підняння виключення, що перехоплюється оточуючим застосуванням метода breakable. Таким чином, виклик break не обов'язково повинен бути в тому ж методі, що і виклик breakable.<br><h3>7.7 Поле зору змінних</h3>Тепер, коли ви побачили вбудовані структури Scala, ми будемо викристовувати їх в цьому розділі для пояснення, як робить поле зору змінних в Scala.<br><h4>Швидка орієнтація для Java програмістів</h4>Якщо ви Java програміст, ви знайдете, що правила поля зору Scala майже ідентичні до Java. Однак існує одна різниця між Java та Scala:&nbsp; Scala дозволяє вам визначати змінні з тими ж іменами у вкладених полях зору. Таким чином, якщо ви Java програміст, ви маєте хоча б переглянути цей розділ.<br><br>Декларації змінних в програмах Scala мають поле зору, що визначає, де ви можете використовувати це ім'я. Найбільш загальний приклад поля зору є фігурні дужки, що зазвичай визначають нове поле зору, так що все, що визначене в фігурних дужках знаходиться за полем зору після замикаючих дужок. В якості ілюстрації розглянемо функцію, показану на Лістингу 7.18.<br>
<pre class="prettyprint linenums language-scala">def printMultiTable() {
  var i = 1
// в полі зору тільки i
  while (i &lt;= 10) {
    var j = 1
// в полі зору i та j
    while (j &lt;= 10) {
      val prod = (i * j).toString
// в полі зору i, j, prod
      var k = prod.length
// в полі зору i, j, prod, k
      while (k &lt; 4) {
        print(" ")
        k += 1
      }
      print(prod)
      j += 1
    }
// в полі зору все ще i та j; prod та k за полем зору
    println()
    i += 1
  }
// i все ще в полі зору; j, prod, k за полем зору
}
</pre>Лістинг 7.18 Поле зору змінних при друкуванні таблиці множення.<br>
<br>Функція printMultiTable, показана в Лістингу 7.18 друкує таблицю множення. Перше твердження цієї функції вводить змінну на ім'я i, та ініціалізує її цілим 1. Потім ви можете використовувати ім'я i на протязі всієї функції.<br><br>Наступне твердження printMultiTable є цикл while:<br>
<pre class="prettyprint linenums language-scala">while (i &lt;= 10) {
  var j = 1
  ...
}</pre>
<br>Ви можете використовувати тут i, оскільки вона все ще в полі зору. В першому твердженні в ціклі while в вводите іншу змінну, на цей раз з ім'ям j, та знову ініціалізуєте її в 1. Оскільки змінна j була визначена в відкриваючих фігурних дужках циклу while, вона може використовуватись тільки в циклі while. Якщо ви спробуєте зробить будь-що з j після закриваючих фігурних дужок цього циклу while, де коментар каже, що&nbsp; j, prod, k за полем зору, ваша програма не буде компілюватись.<br><br>Всі змінні, визначені в цьому прикладі —&nbsp; i, j, prod, k — є локальними змінними. Такі змінні є "локальними" відносно функції, в якій вони визначені. Кожного разу, коли викликається функція, використовується новий набір локальних змінних.<br><br>Коли визначається змінна, ви не можете визначити нову змінну з тим же ім'ям в тому ж полі зору. Наприклад, наступний скрипт з двома зміними на ім'я a в одному полі зору не будуть компілюватись:<br>
<pre class="prettyprint linenums language-scala">val a = 1
val a = 2 // не компілюється
println(a)</pre>З другого боку ви можете визначити змінну у внутрішньому полі зору. Наступний скрипт буде компілюватись і виконуватись:<br>
<pre class="prettyprint linenums language-scala">val a = 1;
{
  val a = 2 // компілюється дуже добре
  println(a)
}
println(a)</pre>При виконанні скрипт, показаний раніше, буде друкувати 2, потім 1, оскільки a, визнчаена в фігурних дужках, є окремною змінною, що є в полі зору до закриття замикаючих фігурних дужок. Одна відмінність, що треба зауважити, між Scala та Java, полягає в тому, що на відмінність від Scala, Java не дозволяє вам створювати змінну у внутрішньому полі зору, що має те є ім'я, що і змінна у зовнішньому. В програмі Scala кажуть, що внутрішня змінна затіняє зовнішню змінну з тією ж назвою, оскікльи зовнішня змінна стає невидімою у внутрішньому полі зору. Ви могли помітити щось, що виглядає як затінення, в інтерпретаторі:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val a = 1
a: Int = 1
scala&gt; val a = 2
a: Int = 2
scala&gt; println(a)
2</pre>В інтерпретаторі ви можете повторно використовувати імена змінних згідно з покликом серця. Поміж інших речей, це дозволяє вам змінювати вашу думку, якщо ви зробили помилку під час визначення змінної в перший раз в інтерпретаторі. Причина, чому ви можете робити це, концептуально полягає в тому, що інтерпретатор створює нові вкладені поля зору для кожного нового твердження, що ви набираєте. Таким чином, ви можете візуалізувати попередньо інтерпретований код таким чином:<br>
<pre class="prettyprint linenums language-scala">val a = 1;
{
  val a = 2;
  {
    println(a)
  }
}</pre>
<br>Цей код буде компілюватись і виконуватись як Scala скрипт, та і як код, введений в інтерпретатор, буде друкувати 2. Майте на увазі, що такий код може бути дуже збентежливим для читачів, оскільки імена отримують нове значення у вкладених полях зору. Зазвичай краще обрати нове, значуще ім'я змінної, ніж затінювати зовнішню змінну.<br><h3>7.8 Рефакторинг імперативного стилю кода&nbsp;</h3>Щоб допомогти вам отримати уявлення щодо функціонального стилю, цей розділ буде присвячений рефакторингу&nbsp; імперативного підоходу до друку таблиці множення, показаній в Лістингу 7.18. Наша функціональна альтернатива показана в Лістингу 7.19.<br><br>Імперативний стиль виказує себе в Лістингу 7.18 в два способи. Перше, виклик printMultiTable має побічний ефект: друк таблиці множення на стандартний вивід. В Лістингу 7.19 ми робимо рефакторинг функції, щоб вона повертала таблицю множення як рядок. Оскільки функція більше не друкує, ми переіменовуємо її на multiTable. Як ми вже казали, одна з переваг функції без побічних ефектів в тому, що вони простіші до юніттестування. Щоб протестувати printMultiTable вам треба дещо перевизначити print та println, так що ви можете перевірити вивід на коректність. Ви можете тестувати multiTable більш просто, перевіряючи отриманий рядок.<br><br>Інша промовиста ознака імперативного стилю printMultiTable є її цикл <br>while та var. На відміну, функція multiTable використовує val, вирази for, допоміжні функції, та виклики до mkString .<br>
<pre class="prettyprint linenums language-scala">// Повертає рядок таблиці як послідовність
def makeRowSeq(row: Int) =
  for (col &lt;- 1 to 10) yield {
    val prod = (row * col).toString
    val padding = " " * (4 - prod.length)
    padding + prod
  }
<br>// Повертає рядок таблиці як рядок смволів
def makeRow(row: Int) = makeRowSeq(row).mkString
<br>// Повертає таблицю як рядок сиволів
def multiTable() = {
  val tableSeq = // послідовність рядків таблиці
    for (row &lt;- 1 to 10)
      yield makeRow(row)
  tableSeq.mkString("\n")
}</pre>
<br>Лістинг 7.19 Функціональний спосіб створити таблицю множення.<br><br>Ми виділили дві допоміжні функції, makeRow та makeRowSeq, щоб зробити код простішим до читання. Функція makeRowSeq використовує вираз for, чий генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього for обчислює множення номерів рядка і стовпчика, визначає відступ, потірбний для добутку, та видає результат конкатенації рядків вирівнювання та добутку. Результатом виразу for буде послідовність (деякий субклас scala.Seq), що містить ці отримані рядки в якості елементів.<br><br>Інша допоміжна функція, makeRow, просто викликає mkString на результаті, що повертає makeRowSeq. mkString буде конкатенувати рядки в послідовності, та поверне їх як один рядок.<br><br>Метод multiTable спершу ініціалізує tableSeq за допомогою результата <br>for вираза, чий генератор ітерує по рядках від 1 до 10, та для кожного викликає makeRow, щоб отримати результати для цього рядка. Це результати потрапляють в yield, і, таким чином, результатом виразу for буде послідовність рядків. Одне завдання, що залишилось, є конвертація послідовності рядків в один рядок. Виклик mkString забезпечує це, та якщо ми передаємо "\n", ми отримуємо вставку вимволів нового рядка між кожними рядками. Якщо ми передамо рядок, повернений multiTable, на println, ви побачите, що отримано той самий вивід, що і продукує виклик до printMultiTable:<br><br>1&nbsp; &nbsp; 2&nbsp;&nbsp; 3 &nbsp; 4 &nbsp; 5 &nbsp; 6 &nbsp; 7 &nbsp; 8 &nbsp; 9&nbsp; 10 <br>2&nbsp; &nbsp; 4 &nbsp; 6 &nbsp; 8&nbsp; 10 12 14 16 18 20<br>3 &nbsp;&nbsp; 6&nbsp;&nbsp; 9&nbsp; 12 15 18 21 24 27 30 &nbsp; <br>4&nbsp;&nbsp;&nbsp; 8&nbsp; 12 16 20 24 28 32 36 40 <br>5&nbsp;&nbsp; 10 15 20 25 <br>6 &nbsp; 12 18 24 30<br>7&nbsp;&nbsp; 14 21 28 35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . . . . . . <br>8 &nbsp; 16 24 32 40<br>9&nbsp;&nbsp; 18 27 36 45 <br>10 20 30 40 50 <br><h3>Висновок</h3>Вбудовані структури управління Scala є мінімальними, але вони виконують свою роботу. Вони діють здебільшого як їх імперативні еквіваленти, але оскільки вони мають тенденцію повертати значення, вони також підтримують функціональний стиль. Так само важливо, вони уважні щодо того, чого вони уникають, таким чином залишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.<br><br><h4>Глава 8</h4><h2>Функції та замикання</h2>Коли програми стають більшими, вам треба деякий спосіб поділити їх на меньші, більш керовані частини. Щоб поділити потік керування Scala пропонує підхід, знайомий для всіх досвідчених програмістів: розділити код на функції. Фактично, Scala пропонує декілька шляхів для визначення функцій, що не присутні в Java. Окрім методів, що є функціями-членами деякого об'єкта, є також функції, вкладені в функції, функціональні літерали, та функціональні значення. Ця глава запрошує вас в подорож по всіх ціх різновидах функцій в Scala.<br><h3>8.1 Методи</h3>Найбільш загальним шляхом визначити функцію в вигляді члена деякого об'єкта. Така функція називається методом. Як приклад, Лістинг 8.1 показує два методи, що разом читають файл з заданим ім'ям, та роздруковують всі рядки, чия довжина перебільшуе надану довжину. Кожний наданий рядок зпеерду має ім'я файла, де він трапився.<br><br>Метод processFile приймає ім'я файла та ширину, як параметри.Він створює об'єкт Source з імені файла, та в генератоі виразу for, викликає getLines на джерелі рядків. Як зазначалось на Кроці 12 Глави 3, getLines повертає ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи символи нового рядка.Вираз for обробляє кожний з ціх рядків, викликаючи допоміжний метод, processLine.<br><br>Метод processLine приймає три параметри: ім'я файла, ширину, та рядок. Він&nbsp; перевіряє, чи довжина рядка більша, ніж надана ширина, та, якщо так, він друкує ім'я файла, двокрапку, та рядок.
<pre class="prettyprint linenums language-scala">import scala.io.Source
object LongLines {
  def processFile(filename: String, width: Int) {
    val source = Source.fromFile(filename)
    for (line &lt;- source.getLines())
      processLine(filename, width, line)
  }
  private def processLine(filename: String,
    width: Int, line: String) {
    if (line.length &gt; width)
      println(filename +": "+ line.trim)
  }
}</pre>Лістинг 8.1 LongLines з приватним методом processLine.<br><br>Щоб використати LongLines з командного рядка, ми створимо застосування, що очікує ширину рядка в якості першого аргумента командного рядка, та інтерпретує наступні аргументи як імена файлів:
<pre class="prettyprint linenums language-scala">object FindLongLines {
  def main(args: Array[String]) {
    val width = args(0).toInt
    for (arg &lt;- args.drop(1))
      LongLines.processFile(arg, width)
  }
}</pre>
Ось як ви використовуєте це застосування для пошуку рядків в LongLines.scala, що більше 45 символів в довжину (він там тільки один):
<pre class="prettyprint linenums language-scala">$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) {</pre>До цього моменту все дуже подібне до того, що ви можете зробити в об'єктно-орієнтованій мові. Однак, концепція функції в Scala є більш загальною, ніж метод. Інші шляхи Scala для вираження функцій будуть пояснені в наступних розділах.<br><h3>8.2 Локальні функції</h3>Конструкція метода processFile в попередньому розділі демонструє важливий принцип розробки функціонального стилю програмування: програми повинні бути декомпоновані на багато меньших функцій, кожна з яких робить гарно визначену роботу. Окремі функції часто є досить малими. Перевага цього стилю в тому, що він надає прогармісту багато будівельних блоків, що можуть бути гнучко скомпоновані в більш складні речі. Кожний будівельний блок повинен бути досить простим, щоб бути зрозумілим індивідуально.<br><br>Одна з проблем цього підхода в тому, що всі імена допоміжних функцій можуть забруднити програмний простір імен. В інтерпретаторі це не є великою проблемою, але тільки функції пакуються в повторно використовувані класи та об'єкти, бажано приховати допоміжні функції від клієнтів класа. Вони часто поодинці не мають сенсу, та ви часто бажаєте залишити досить гнучкості, щоб видалити допоміжні функції, якщо ви пізніше перепишете клас іншим шляхом.<br><br>В Java вашим головним інструментом для ціх цілей є приватний метод. Цей підхід приватних методів робить також і в Scala, як продемонстровано в Лістингу 8.1, але Scala пропонує додатковий підхід: ви можете визначити функції в інших функціях. Точно як і локальні змінні, такі локальні функції видимі тільки в оточуючому блоці. Ось приклад:
<pre class="prettyprint linenums language-scala">def processFile(filename: String, width: Int) {
  def processLine(filename: String,
    width: Int, line: String) {
    if (line.length &gt; width)
      println(filename +": "+ line)
  }
  val source = Source.fromFile(filename)
  for (line &lt;- source.getLines()) {
    processLine(filename, width, line)
  }
}</pre>В цьому прикладі ми рефакторимо оригінальну версію LongLines, показану в Лістингу 8.1, трансформуючи приватний метод processLine в локальну функцію processFile. Для цього ми видаляємо приватний модифікатор, що може застосовуватись (та тільки потрібен) для методів, та розташували визначення processLine всередині визначення processFile. Як локальна функція, processLine в полі зору в processFile, але недосяжна ззовні.<br><br>Тепер ця processLine визначена в processFile, однак, стає можливим інше покращення. Помітили, як ім'я файлу та ширина передаються без змін до допоміжної функції? Це не потірбне, оскільки локальні функції можуть мати доступ до параметрів їх оточуючої функції. Ви можете просто використовувати параметри зовнішньої функції processLine, як показано в Лістингу 8.2:
<pre class="prettyprint linenums language-scala">import scala.io.Source
object LongLines {
  def processFile(filename: String, width: Int) {
    def processLine(line: String) {
      if (line.length &gt; width)
        println(filename +": "+ line)
    }
    val source = Source.fromFile(filename)
    for (line &lt;- source.getLines())
      processLine(line)
  }<br>}</pre>Лістинг 8.2 LongLines з локальною функцією.<br><br>Простіше, чи не так? Це використання параметрів оточующої функції&nbsp; є загальним та корисним прикладом загального вкладання, що провадить Scala. Вкладання та поле зору, описані в Розділі 7.7, стосуються до всіх конструкцій Scala, включаючи функції. Це простий, принцип, але дуже потужний, особливо в мові з першокласними функціями.<br><h2>8.3 Першокласні функції</h2>Scala має першокласні функції. Ви не тільки можете визначити функції, та виклиати їх, але ви можете записати функції як неіменовані літерали, та потім передати їх кудись як значення. Ми ввели функціональні літерали в Главі 2, та базовий синтаксис показаний на Малюнку 2.2.<br><br>Функціональні літерали компілюються в клас, що потім втілюється під час виконання як значення функції. Таким чином, різниця між функціональним літералом та значеннями в тому, що функціональні літерали існують в первинному коді, тоді як значення функцій існує як об'єкт під час виконання. Різниця здебільшого така, як між класами (початковий код) та об'єкти (час виконання). Ось простий приклад функціонального літерала, що додає один до числа:
<pre class="prettyprint linenums language-scala">(x: Int) =&gt; x + 1</pre>Знак =&gt; позначає, що ця функція конвертує річ зліва (любе ціле x ) на річ зправа ( x + 1 ). Таким чином, ця функція відображує любе ціле x на x + 1.<br><br>Функціональні значення є об'єктами, так що ви можете зберігати їх, якщо побажаєте, в змінних. Вони також функції, так що ви можете викликати їх з використанням звичайної нотації виклику функції з дужками. Ось приклад обох активностей:
<pre class="prettyprint linenums language-scala">scala&gt; var increase = (x: Int) =&gt; x + 1
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
res0: Int = 11</pre>Оскільки increase, в цьому випадку, є змінна var, ви можете з часом перепризначити їй інше функціональне значення.
<pre class="prettyprint linenums language-scala">scala&gt; increase = (x: Int) =&gt; x + 9999
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
res1: Int = 10009</pre>
Якщо ви бажаєте мати більш ніж одне твердження в функціональному літералі, оточіть його тіло фігурними дужками, та розташуйте одне твердження в рядок, таким чином формуючи блок. Так само як метод, коли викликається значення функції, всі твердження будуть виконані, та значення, повернуте від функції буде тим, що обчислює останній рядок.
<pre class="prettyprint linenums language-scala">scala&gt; increase = (x: Int) =&gt; {
println("We")
println("are")
println("here!")
x + 1
}
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
We
are
here!
res2: Int = 11</pre>
Так що тепер ви бачили шестерні функціональних літералів та функціональних значень. Багато бібліотек Scala дають вам можливість використовувати їх. Наприклад, метод foreach доступний для всіх колекцій. Він приймає функцію як аргумент, та викликає цю функцію для кожного з його елементів. Ось як це може бути використано для друку всіх елементів списку:
<pre class="prettyprint linenums language-scala">scala&gt; val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala&gt; someNumbers.foreach((x: Int) =&gt; println(x))
-11
-10
-5
0
5
10</pre>
Як інший приклад, типи колекцій також мають метод filter. Цей метод обирає ті елементи з колекції, що проходять перевірку, що надає користувач. Ця перевірка надається в вигляді функції. Наприклад, функція (x: Int) =&gt; x &gt; 0 може бути використана для фільтрації. Ця функція відображує додатні цілі на true, та всі інші на false. Ось як використовувати цей фільтр:
<pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter((x: Int) =&gt; x &gt; 0)
res4: List[Int] = List(5, 10)</pre>Методи як foreach та filter описані далі в цій книзі. Глава 16 розкаже щодо їх використання в класі List. Глава 17 обговорює їх використання з іншими типуми колекцій.<br><h3>8.4 Скорочені форми функціональних літералів</h3>Scala провадить декілька шляхів відкинути непотрібну інформацію та записати функціональні літерали більш коротко. Держіть ваші очі відкритими щодо ціх можливостей, оскільки вони дозволяють вам видалити непотріб з вашого кода.<br><br>Один спосіб зробити функціональний літерал більш коротким є відкинути типи параметрів. Таким чином, попередній приклад з filter може бути записаний таким чином:
<pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter((x) =&gt; x &gt; 0)
res5: List[Int] = List(5, 10)</pre>
Компілятор Scala знає, що x має бути цілим, оскільки він бачить, що ви безпосередньо використовуєте використовуєте функцію для фільтрації списка цілих (посилається на деякий someNumbers ). Це називається цільовою типізацією, оскільки цільове використання виразу — в цьому випадку аргумент до someNumbers.filter() — може впливати на тип виразу — в цьому випадку для визначення типу параметра x. Точні деталі цільової типізації не важливі для вивчення. Ви можете просто почати писати функціональні літерали без типу аргумента, та, якщо компілятор буде сконфужений, додати тип. З часом ви отримаєте відчуття, для яких ситуацій компілятор може, та для яких не може розв'язати загадку.<br><br>Другий шлях для видалення некорисних символів, є відкидання дужок кругом параметра, чий тип виведений. В попередньому прикладі дужки кругом x не потрібні:
<pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(x =&gt; x &gt; 0)
res6: List[Int] = List(5, 10)</pre>
<h3>8.5 Синтаксис заміщувача</h3>Щоб зробити синтаксис функціонального літерала навіть ще стилсішим, ви можете використати підкреслення як заміщувачі для одного або більше параметрів, доки кожний параметр зустрічається тільки один раз в функціональному літералі. Наприклад, _ &gt; 0 є дуже короткою нотацією для функції, що перевіряє, чи значення більше ніж ноль:
<pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(_ &gt; 0)
res7: List[Int] = List(5, 10)</pre>Ви можете думати про підкреслення я "пропуск" в виразі, що має бути "заповнено". Цей проміжок буде заповнений аргументом функції, кожного разу, коли викликається функція. Наприклад, беручи що цей someNumbers був ініціалізований в значення List(-11, -10, -5, 0, 5, 10), метод фільтра буде заміняти проміжок в _ &gt; 0 спочатку -11, як в виразі -11 &gt; 0, потім на -10, як в -10 &gt; 0, потім на -5, як в -5 &gt; 0, і так далі до кінця List. Функціональний літерал _ &gt; 0, таким чином, еквівалентний до трихи більш балакучого x =&gt; x &gt; 0, як продемонстровано тут:
<pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(x =&gt; x &gt; 0)
res8: List[Int] = List(5, 10)</pre>Іноді при використанні підкреслень для заміщення параметрів, компілятор не має достатньо інформації, щоб вивестивідсутні типи параметрів. Наприклад, уявімо, ви пишете _ + _:
<pre class="prettyprint linenums language-scala">scala&gt; val f = _ + _
&lt;console&gt;:4: error: missing parameter type for expanded
function ((x$1, x$2) =&gt; x$1.$plus(x$2))
val f = _ + _
        ˆ</pre>В таких випадках ви можете вказати типи з використанням двокрапки:
<pre class="prettyprint linenums language-scala">scala&gt; val f = (_: Int) + (_: Int)
f: (Int, Int) =&gt; Int = &lt;function2&gt;
scala&gt; f(5, 10)
res9: Int = 15</pre>Зауважте, що _ + _ розширюється в літерал для функції, що приймає два параметри. Ось чому ви можете використовувати цю коротку форму, тільки якщо параметри з'являються в функціональному літералі тільки один раз. Декілька підкреслень озжначають декілька параметрів, не повторне використання одного параметру. Перше підкреслення представляє перший параметр, друге підкреслення другий параметр, третє підкреслення третій параметр, і так далі.<br><h3>8.6 Частково застосовані функції</h3>Хоча попередні приклади заміняють підкреслення замість індивідуальних параметрів, ви можете також замінити цілий список параметрів на підкреслення. Наприклад, скоріше ніж писати println(_), ви можете записати println _ . Ось приклад:
<pre class="prettyprint linenums language-scala">someNumbers.foreach(println _)</pre>
Scala трактує цю коротку форму точно так, якби ви написали наступне:
<pre class="prettyprint linenums language-scala">someNumbers.foreach(x =&gt; println(x))</pre>Таким чином, підкреслення в цьому випадку не є заміщувачем одного параметра. Це заміщувач для всього списка параметрів. Пам'ятайте, що вам треба залишити проміжок між ім'ям функції та підкресленням, оскільки інакше компілятор буде думати, що ви посилаєтесь на інший символ, для цього приклада на метод з ім'ям println_, що, скоріше всього, не існує.<br><br>Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи всі потрібні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад, маючи таку функцію:
<pre class="prettyprint linenums language-scala">scala&gt; def sum(a: Int, b: Int, c: Int) = a + b + c
sum: (a: Int,b: Int,c: Int)Int</pre>Ви можете застосувати функцію sum до аргументів 1, 2, та 3, таким чином:
<pre class="prettyprint linenums language-scala">scala&gt; sum(1, 2, 3)
res10: Int = 6</pre>Частково застосована функція є виразом, і якому ви не надаєте всі аргументи, потрібні для функції. Замість цього, ви надаєте деякі, або жодних, з потрібних аргументів. Наприклад, щоб створити вираз частково застосованої функції, що використовує sum, до якої ви можете надати жодного з трьох потрібних аргументів, ви тільки покладаєте підкреслення після "sum". Отримана функція потім може бути збережена в змінній. Ось приклад:
<pre class="prettyprint linenums language-scala">scala&gt; val a = sum _
a: (Int, Int, Int) =&gt; Int = &lt;function3&gt;</pre>Маючи цей код, компілятор Scala створює примірник значення функції, що приймає три цілі параметри, що відсутні в виразі частково застосованої&nbsp; функції, sum _, та присвоює посилання цього нового значення функції змінній a. Коли ви застосовуєте три аргументи до цього нового значення функції, вона замкнеться, та викличе sum, передаючи ці самі три аргументи:
<pre class="prettyprint linenums language-scala">scala&gt; a(1, 2, 3)
res11: Int = 6</pre>Ось що тільки но відбулось: змінна на ім'я a посилається на об'єкт функціонального значення. Ця значення функції є примірником класа, згенерованого автоматично компілятором Scala з sum _, вираза частково зстосованої функції.<br><br>Згенерований компілятором клас має метод apply, що приймає три аргументи. Метод apply згенерованого класа приймає три аргументи, оскільки в виразі sum _ відсутні три аргументи. Компілятор Scala транслює вираз a(1, 2, 3) на виклик метода apply функціонального значення, передаючи туди три аргументи 1, 2, та 3. Таким чином, a(1, 2, 3) є скороченням для:
<pre class="prettyprint linenums language-scala">scala&gt; a.apply(1, 2, 3)
res12: Int = 6</pre>Цей метод apply, визначений в класі, згенерованому автоматично компілятором Scala з виразу sum _, посто передає ці три відсутні параметри до sum, та повертає результат. В цьому випадку apply викликає sum(1, 2, 3), та повертає що повертає sum, що є 6.<br><br>Інший спосіб думати про цей тип виразів, де підкреслення використовується для представлення всього списку параметерів, як про спосіб трансформувати def на функціональне значення. Наприклад, якщо ви маєте локальну функцію, таку як sum(a: Int, b: Int, c: Int): Int, ви можете "огорнути" її в функціональне значення, чий метод apply має той же список параметрів та тип результата. Коли ви застосовуєте цю функціональне значення до деяких аргументів, вона в свою чергу застосовує sum до тих самих аргументів, та повертає результат. Хоча ви не можете присвоїти метод або вкладену функцію до змінної, або передати його як аргумент до іншої функції, ви можете зробити це, якщо ви огорнете метод або вкладену функцію в функціональне значення, розмістивши підкреслення після імені.<br><br>Тепер, хоча sum _ насправді є частково застосованою функцією, для вас може бути не очевидним, чому вона так називається. Вона має це ім'я, оскільки ви не застосовуєте цю функцію до всіх аргументів. В випадку sum _, ви не застосовуєте її до жодного з аргументів. Але ви також можете виразити частково застосовану функцію, надаючи деякі, але не всі з потрібних аргументів. Ось приклад:
<pre class="prettyprint linenums language-scala">scala&gt; val b = sum(1, _: Int, 3)
b: (Int) =&gt; Int = &lt;function1&gt;</pre>В цьому випадку, ви надали перший&nbsp; та останній аргументи до sum, але середній аргумент відсутній. Оскільки відсутній тільки один аргумент, компілятор Scala генерує новий функцінальний клас, чий метод apply приймає один аргумент. При виклику з цім аргументом, цей згенерований метод apply функції викликає sum, пеердаючи 1, аргумент, переданий до функції, та 3. Ось деякі приклади:<br>
<pre class="prettyprint linenums language-scala">scala&gt; b(2)
res13: Int = 6</pre>В цьому випадку b.apply викликав sum(1, 2, 3) .<br>
<pre class="prettyprint linenums language-scala">scala&gt; b(5)
res14: Int = 9</pre>
Та в цьому випадку b.apply викликав sum(1, 5, 3) .<br><br>Якщо ви пишете вираз&nbsp; частково застосованої функції, в якій ви відкидаєте всі параметри, таку, як println _ або sum _, ви можете виразити це більш стисло, відкинувши також і підкреслення, якщо функція потрібна в цьому місці в коді. Наприклад, замість роздрукування кожного з чисел з someNumbers таким чином:
        <pre class="prettyprint linenums language-scala">someNumbers.foreach(println _)</pre>ви можете просто написати:<br><pre
class="prettyprint linenums language-scala">someNumbers.foreach(println)</pre>Ця остання форма дозволяється тільки в місцях, де потрібна функція, як в виклику foreach в цьому прикладі. Компілятор знає, що в цьому випадку потрібна функція, оскільки foreach потребує, що була передана функція в якості аргумента. В ситуаціях, де функція не потрібна, спроба використовувати цю форму призведе до помилки компіляції. Ось приклад:
<pre class="prettyprint linenums language-scala">scala&gt; val c = sum
&lt;console&gt;:5: error: missing arguments for method sum...
follow this method with `_' if you want to treat it as a
partially applied function
val c = sum
        ˆ
scala&gt; val d = sum _
d: (Int, Int, Int) =&gt; Int = &lt;function3&gt;
scala&gt; d(10, 20, 30)
res15: Int = 60</pre>
<h4>Чому завершуєче підкреслення?</h4>Синтаксис Scala для частково 
застосованих функцій наголошує на різниці в компромісах розробки Scala, 
та класичних функціональних мов, як Haskell або ML. В ціх мовах частково
 застосовані функції розглдаються як нормальний випадок. Більше того, ці
 мови мають досить строгу статичну систему типів, що, звичайно, буде 
виділяти кожну помилку з частковими застосуваннями, які ви можете 
зробити. Scala підтримує значно ближчі стосунки до імперативних мов, 
таких, як Java, де метод, що не застосовується до всіх аргументів, 
розглядається як помилка. Більше того, об'єктно-орієнтована традиція 
субтипів та універсального кореневого типу сприймає деякі програми, що 
можуть бути визнані помилковими в класичних функціональних мовах.<br><br>
Наприклад, скажімо, ви переплутали метод drop(n: Int) з List з<br>tail(),
 і, таким чином, забули передати число відкинутих елементів. Ви можете 
записати&nbsp; "println(drop)". Якби Scala адаптувала б класичну 
функціональну традицію, що частково застосовані функції годні будь-де, 
цей код пройшов би перевірку типів. Однак ви були б здивовані винайти, 
що вивід, надрукований цім твердженням println завжди буде 
&lt;function&gt; ! Що відбулось, це вираз drop був трактований як 
функціональний об'єкт. Оскільки println приймає об'єкти любого типу, це 
буде успішно компілюватись, але це може мати неочікувані результати.<br><br>
Щоб цникнути ситуацій як ця, Scala звичайно потребує, щоб ви вказували 
аргументи функції, що явно відкинуті, навіть якщо показчик такий 
простий, як ‘ _ ’. Scala дозволяє вам відкинути навіть&nbsp; _, але тільки 
очікується функція.<br><h3>8.7 Замикання</h3>До сих пір в цій главі всі приклади функціональних літералів посилались тільки на передані параметри. Наприклад, в (x: Int) =&gt; x &gt; 0, єдина змінна, що використовується в тілі функції, є x, що визначена як параметр до функції. Ви можете, однак, посилатись на змінні, визначені деінде:
<pre class="prettyprint linenums language-scala">(x: Int) =&gt; x + more
// що таке more?</pre>Ця функція додає "more" до свого аргументу, але що таке more? З цієї точки зору на цю функцію, more є вільною змінною, оскільки функціональний літерал сам по собі не дає цьому ради. Змінна x, на відміну від цього, є прив'язаною змінною, оскільки вона має смисл в контексті функції: вона визначена як єдиний параметр функції з типом Int. Якщо ви спробуєте використати цей функціональний літерал сам по собі, без жодного more, визначеного в полі зору, компілятор буде скаржитись:
<pre class="prettyprint linenums language-scala">scala&gt; (x: Int) =&gt; x + more
&lt;console&gt;:5: error: not found: value more
(x: Int) =&gt; x + more
                 ˆ</pre>З іншого боку, той же функціональний літерал буде добре робити, доки дступне дещо доступне на ім'я more :
<pre class="prettyprint linenums language-scala">scala&gt; var more = 1
more: Int = 1
scala&gt; val addMore = (x: Int) =&gt; x + more
addMore: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; addMore(10)
res17: Int = 11</pre>Значення функції (об'єкт), що створений під час виконання з функціонального літерала називається замиканням. Ім'я походить від дії "замикання" функціонального літерала через "захоплення" прив'язок вільних змінних. Функціональний літерал без вільних змінних, як (x: Int) =&gt; x + 1, називається замкнутим термом, де терм це шмат первинного кода. Таким чином, значення функції, створене під час виконання з функціонального літерала не є замиканням в найстогому сенсі, оскільки (x: Int) =&gt; x + 1 є вже закритим від написання. Але любий функціональний літерал з вільними змінними, такий як (x: Int) =&gt; x + more, є відкритим термом. Більше того, любе функціональне значення, створене під час виконання з (x: Int) =&gt; x + more буде по визначенню потребувати, щоб була захоплена прив'язка для його вільної змінної more. Результуюче значення функції, що буде містити посилання на захоплену змінну more, називається замиканням, оскільки значення функції є кінцевим продуктом акта закриття відкритого терма, (x: Int) =&gt; x + more.<br><br>Цей приклад дає на запитання: що відбудеться, якщо more зміниться після створення замикання? В Scala відповідь така, що замикання бачить зміну. Наприклад:
<pre class="prettyprint linenums language-scala">scala&gt; more = 9999
more: Int = 9999
scala&gt; addMore(10)
res18: Int = 10009</pre>Інтцітивно, замикання Scala захоплюють самі змінні, не значення, на які вони посилаються. Як демонструє попередній приклад, замикання, створене для (x: Int) =&gt; x + more бачить зміну more, зроблену ззовні замикання. Те ж саме вірне в зворотньому напрямку. Зміни, зроблені замиканням відносно захопленої змінної, видимі за межами замикання. Ось приклад:
<pre class="prettyprint linenums language-scala">scala&gt; val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala&gt; var sum = 0
sum: Int = 0
scala&gt; someNumbers.foreach(sum += _)
scala&gt; sum
res20: Int = -11</pre>Цей приклад використовує обхідний шлях для підсумку чисел в List. Змінна sum з оточуючого поля зору для функціонального літерала sum += _, що додає числа до sum. Навіть вважаючи, що замикання модифікує sum під час виконання, результат, -11, все ще видиме ззовні замикання.<br><br>Що, якщо замикання отримає доступ до деякої змінної, що має декілька копій під час виконання програми? Наприклад, якщо замикання використовує локальну змінну деякої функції, та функція викликається декілька раз? Який примірник цієї змінної використовується для кожного доступу?<br><br>Тільки одна відповідь узгоджується з рештою мови: використаний примірник буде той, що був активний під час створення замикання. Наприклад, ось функція, що створює та повертає тип замикань "збільшити":
<pre class="prettyprint linenums language-scala">def makeIncreaser(more: Int) = (x: Int) =&gt; x + more</pre>
Кожного разу, коли викликається ця функція, вона буде створювати нове замикання. Кожне замкання буде отримувати змінну more, що була активною, коли замикання було створене.
<pre class="prettyprint linenums language-scala">scala&gt; val inc1 = makeIncreaser(1)
inc1: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; val inc9999 = makeIncreaser(9999)
inc9999: (Int) =&gt; Int = &lt;function1&gt;</pre>Коли ви викликаєте makeIncreaser(1), створюється та повертається замикання, що захоплює значення 1 в якості прив'язки до more. Подібним чином, коли ви викликаєте makeIncreaser(9999), повертається замикання, що захоплює значення 9999 для more. Коли ви застосовуєте ці замикання для аргументів (в цьому випадку є тільки один аргумент, x, що має бути переданий ззовні), результат, що повертається, залежить від того, як було визначене more при створені замикання:
<pre class="prettyprint linenums language-scala">scala&gt; inc1(10)
res21: Int = 11
scala&gt; inc9999(10)
res22: Int = 10009</pre>Не має різниці, що more і цьому випадку є параметром до виклику метода, що вже скінчився. Компілятор Scala переставляє речі в випадках як цей, так що захоплений параметр живе на купі, замість стеку, і, таким чином, може пережити виклик метода, що створив його. Всі ці перестановки робляться автоматично, так що вам не треба хвилюватись щодо цього. Захоплюйте любу змінну, яку побажаєте: val, var, параметр.<br><h4>8.8 Спеціальні форми виклику функцій</h4>Більшість функцій та функціональних викликів, що ви зустрінете, будуть такими, як ви вже бачили в цій главі. Функція буде мати фіксоване число параметрів, виклик буде мати рівне число аргументів, та аргументи будуть вказані в тому ж порядку і числі, що і параметри.<br><br>Однак оскільки виклики функцій є такими центральними для програмування в Scala, декілька спеціальних форм функціональних визначень та викликів функцій були додані до мови, щоб покрити деякі особливі потреби. Scala підтримує повторювані параметри, іменовані аргументи, та аргументи по замовчанню.<br><h4>Повторювані параметри</h4>Scala дозволяє вам вказати, що останній параметр функції може бути повторений. Це дозволяє клієнтам передавати до функції списки аргументів змінної довжини. Щоб задати повторюваний параметр, поставьте зірочку після типу параметра. Наприклад:
<pre class="prettyprint linenums language-scala">scala&gt; def echo(args: String*) =
for (arg &lt;- args) println(arg)
echo: (args: String*)Unit</pre>Визначене таким чином, echo може бути викликане з нулем або багатьма аргументами String:
<pre class="prettyprint linenums language-scala">scala&gt; echo()
scala&gt; echo("one")
one
scala&gt; echo("hello", "world!")
hello
world!</pre>Всередині функції тип поверненого параметра є Array декларованого типу параметру. Таким чином, тип аргументів в функції echo, що декларований як тип "String*" є насправді Array[String]. Тим не менш, якщо ви маєте масив відпоідного типу, та ви спробуєте передати його як повторюваний параметр, ви отримаєте помилку компіляції:
<pre class="prettyprint linenums language-scala">scala&gt; val arr = Array("What's", "up", "doc?")
arr: Array[java.lang.String] = Array(What's, up, doc?)
scala&gt; echo(arr)
&lt;console&gt;:7: error: type mismatch;
found
: Array[java.lang.String]
required: String
echo(arr)
     ˆ</pre>Щоб досягти цього, вам треба додати до аргумента масива дві крапки та символ _* :
<pre class="prettyprint linenums language-scala">scala&gt; echo(arr: _*)
What's
up
doc?</pre>Ця нотація каже компілятору передати кожний елемент arr як окремий аргумент до echo, скоріше ніж всі як один аргумент.<br><h4>Іменовані аргументи</h4>В нормальному виклику функції аргументи виклику співадають один за одним в порядку параметрів викликаної функції:
<pre class="prettyprint linenums language-scala">scala&gt; def speed(distance: Float, time: Float): Float =
distance / time
speed: (distance: Float,time: Float)Float
scala&gt; speed(100, 10)
res28: Float = 10.0</pre>В цьому виклику, 100 співпадає з distance, та 10 з time. 100 та 10 співпали в тому ж порядку, що і перелічені формальні параметри.<br><br>Іменовані аргументи дозволяють вам передавати аргументи до функції в іншому порядку. Синтаксис такий, що кожний аргумент складається з імені, знака рівності та значення. Наприклад, наступний виклик speed еквівалентний speed(100,10):
<pre class="prettyprint linenums language-scala">scala&gt; speed(distance = 100, time = 10)
res29: Float = 10.0</pre>Виклик з іменованими аргументами дозволяє обернути порядок без зміни значення:
<pre class="prettyprint linenums language-scala">scala&gt; speed(time = 10, distance = 100)
res30: Float = 10.0</pre>Також можливо змішати позиціні та іменовані аргументи. В цьому випадку позиційні аргументи ідуть першими.<br><br>Іменовані аргументи використовуються найбільш частов комбінації зі значеннями параметрів по замовчанню.<br><h4>Значення параметрів по замовчанню</h4>Scala дозволяє вам вказати значення по замовчанню для параметрів функції. Аргумент для такого параметра може опціонально бути пропущений у виклику функції, в якому випадку відповідний аргумент буде заповнений по замовчанню.<br><br>Приклад показаний в Лістингу 8.3. Функція printTime має один параметр, out, та він по замовчанню має значення Console.out.
<pre class="prettyprint linenums language-scala">def printTime(out: java.io.PrintStream = Console.out) =
  out.println("time = "+ System.currentTimeMillis())</pre>Лістинг 8.3 Параметр зі значенням по замовчанню.<br><br>Якщо ви викликаєте функцію як printTime(), тобто не вказуючи аргументів для out, тоді він буде встановлений в значення Console.out.<br><br>Ви також можете викликати функцію з явним вказанням вихідного потоку. Наприклад, ви можете надіслати журналювання до стандарного потоку помилки, викликавши функцію як printTime(Console.err).<br><br>Параметри по замовчанню особливо корисні, коли використовуються в комбінації з іменованими параметрами. В Лістингу 8.4 функція printTime2 має два опціональні параметра. Параметр out має замовчання Console.out, та параметр divisor має значення замовчання 1.<br><br>Функція printTime2 може бути викликана як printTime2(), щоб мати обоє свої параметри заповненими значеннями по замовчанню. Однак з використанням іменованих параметрів один з них може бути встановлений, та інший залишитись по замовчанню. Щоб вказати вихідний потік, викличте так:
<pre class="prettyprint linenums language-scala">def printTime2(out: java.io.PrintStream = Console.out,
divisor: Int = 1) =
out.println("time = "+ System.currentTimeMillis()/divisor)</pre>Лістинг 8.4 Функція з двома параметрами, що мають замовчання.
<pre class="prettyprint linenums language-scala">printTime2(out = Console.err)</pre>Щоб вказати дільник часу, викличте так:
<pre class="prettyprint linenums language-scala">printTime2(divisor = 1000)</pre>
<h3>8.9 Кінцева рекурсія</h3>В Розділі 7.2 ми вказували, що трансформація цикла while, що оновлює var на більш функціональний стиль, що використовує тільки val, іноді потребуватиме від вас використання рекурсії. Ось приклад рекурсивної функції, що апроксимує значення, повторюючи покращення guess, докі він не буде досить гарним:
<pre class="prettyprint linenums language-scala">def approximate(guess: Double): Double =
  if (isGoodEnough(guess)) guess
  else approximate(improve(guess))</pre>Функція такого типу часто використовується в проблемах пошуку, з відповідними реалізаціями для isGoodEnough та improve. Якщо ви бажаєте, щоб функція апроксимації робила швидше, ви можете мати спокусу написати її за допомогою цикла while, щоб спробувати пришвидшити її, таким чином:
<pre class="prettyprint linenums language-scala">def approximateLoop(initialGuess: Double): Double = {
  var guess = initialGuess
  while (!isGoodEnough(guess))
    guess = improve(guess)
  guess
}</pre>
<br>Яка з двох версій апроксімації має перевагу? В термінах кратості та уникнення var, перша, функціональна функція пермагає. Але чи є імперативний підхід більш ефективним? Фактично, якщо ми виміряємо час, він буде майже однаковим! Це може виглядати дивним, бо рекурсивний виклик виглядає більш коштовним, ніж простий стрибок від одного краю цикла на початок.<br><br>Однак, в випадку апроксимації вище, компілятор Scala в змозі застосувати важливу оптимізацію. Зауважте, що рекурсивний виклик є останнім, що трапляється в обчисленні тіла функції апроксимації. Функції, подібні до approximate, що викликають себе в якості останньої дії, називаються кінечно рекурсивними. Компілятор Scala детектує кінцеву рекурсію, та заміщує її на перехід назад, на початок функції, після оновлення параметрів функції на нові значення.<br><br>Мораль полягає в тому, що ви не повинні соромитись використовувати рекурсивні алгоритми для вирішення ваших проблем. Часто рекурсивне рішення більш елегантне та стисле, ніж базоване на циклі. Якщо рішення кінцево рекурсивне, ви навіть не&nbsp; заплатите за перенавантаження під час виконання.<br><h4>Відслідковування кінцево-рекурсивних функцій</h4>Кінцево рекурсивні функції не будуть будувати новий стек для кожного виклику; всі виклики будуть виконуватись в одному фреймі. Це може здивувати програміста, що очікує, що відсліджування стек програми, що схибила. Наприклад, ця функція викликає себе декілька разів, та потім підіймає виключення:
<pre class="prettyprint linenums language-scala">def boom(x: Int): Int =
  if (x == 0) throw new Exception("boom!")
  else boom(x - 1) + 1</pre>Ця функція не є кінцево рекурсивною, оскільки вона виконує операцію інкремента після рекурсивного виклику. Ви отримаєте те, що очікували, якщо ви виконаєте її:
<pre class="prettyprint linenums language-scala">scala&gt;
boom(3)
java.lang.Exception: boom!
at .boom(&lt;console&gt;:5)
at .boom(&lt;console&gt;:6)
at .boom(&lt;console&gt;:6)
at .boom(&lt;console&gt;:6)
at .&lt;init&gt;(&lt;console&gt;:6)
...</pre>
<br>Якщо ви тепер модифікуєте boom так, щоб вона стала кінцево рекурсивною:def bang(x: Int): Int =
<pre class="prettyprint linenums language-scala">if (x == 0) throw new Exception("bang!")
else bang(x - 1)</pre>ви отримаєте:
<pre class="prettyprint linenums language-scala">scala&gt; bang(5)
java.lang.Exception: bang!
at .bang(&lt;console&gt;:5)
at .&lt;init&gt;(&lt;console&gt;:6) ...</pre>
<br>На цей раз ви бачите тільки один фрейм стеку для bang. Ви можете подумати, що bang звалився перед тим, як визвати себе, але це не той випадок. Якщо ви думаєте, що можете бути збиті з пантелику оптимізацією кінцевої рекурсії при погляді на трассу стеку, ви можете відключити її, надавши наступний аргумент до оболонки scala shell або до компілятора scalac:
        <pre class="prettyprint linenums language-scala">-g:notailcalls</pre>
<br>Коли вказана ця опція, ви отримаєте довшу трасу стеку:
<pre class="prettyprint linenums language-scala">scala&gt; bang(5)
java.lang.Exception: bang!
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .&lt;init&gt;(&lt;console&gt;:6) ...</pre><h4>Оптимізація кінцевого виклику</h4>Скомпільований код для approximate загалом той самий, що і скомпільований код для approximateLoop. Обі функції компілюються до тих же тринадцяти інструкцій байткоду Java. Якщо ви дивитесь на згенеровані компілятором Scala байткоди для кінцево рекурсивного метода approximate, ви побачите, що хоча обоє, isGoodEnough та improve викликані в тілі метода, approximate ні. Компілятор Scala оптимізував цей рекурсивний виклик:<br>public double approximate(double);
<pre class="prettyprint linenums language-scala">Code:
0: aload_0
1: astore_3
2: aload_0
3: dload_1
4: invokevirtual #24; //Method isGoodEnough:(D)Z
7: ifeq 12
10: dload_1
11: dreturn
12: aload_0
13: dload_1
14: invokevirtual #27; //Method improve:(D)D
17: dstore_1
18: goto 2

</pre><h4>Межі кінцевої рекурсії</h4>Використання кінцевої рекурсії в Scala є досить обмеженою, оскільки набір інструкцій JVM робить реалізацію більш докладних форм кінцевої рекусрії складним. Scala оптимізує тільки прямо рекурсивні виклики назад до тієї самої функції, що робить виклик. Якщо рекурсія є непрямою, як в наступному прикладі двох взаємно рекурсивних функцій, оптимізація неможлива:
<pre class="prettyprint linenums language-scala">def isEven(x: Int): Boolean =
  if (x == 0) true else isOdd(x - 1)
<br>def isOdd(x: Int): Boolean =
if (x == 0) false else isEven(x - 1)</pre>
Ви також не бажаєте кінцеву оптимізацію, якщо заключний виклик іде до функціонального значення. Розгляньте для прикладу наступний рекурсивний код:
<pre class="prettyprint linenums language-scala">val funValue = nestedFun _
  def nestedFun(x: Int) {
    if (x != 0) { println(x); funValue(x - 1) }
}</pre>Зміннна funValue посилається на значення функції, що, загалом, тільки огортає виклик до nestedFun. Коли ви застосовуєте значення функції до аргумента, вона обертається, та застосовує nestedFun до того ж аргумента, та повертає результат.<br><br>Як ви могли здогадатись, компілятор Scala буде виконувати оптимізацію кінцевого виклику, але в цьому випадку це не так. Таким чином, оптимізація кінцевого виклику обмежена до ситуацій, в яких метод або вкладена функція викликає себе напряму, в якості останньої операції, без переходу через функціональне значення, або якійсь інший посередник. (Якщо ви досі не повністю розумієте кінцеву рекурсію, дивіться Розділ 8.9).<br><h3>8.10 Висновок</h3>Ця глава надала вам гранд тур по функціям в Scala. На додаток до методів, Scala провадить локальні функції, функціональні літерали, та значення функцій. На додаток до нормальних викликів функцій, Scala провадить частково застосовані функції, та функції з повторюваними параметрами. Коли можливо, виклики функцій реалізоані як оптимізовані кінцеві виклики, і, таким чином, багато гарно виглядаючих рекурсивних функцій роблять так же швидко, як оптимізовані вручну версії, що використовують цикли while. Наступна глава буде будуватись на ціх засадах, та покаже, наскільки багата підтримка функцій в Scala допомагає вам абстрагуватись над керуванням.<br><br><h3>Глава 9</h3><h2>Абстракція керування</h2>В Главі 7, ми вказали, що Scala не має багато вбудованих абстракцій керування, оскільки вона надає вам можливість створювати ваші власні. В попередній главі ви навчились щодо функціональних значень. В цій главі ми покажемо вам, як застосовувати функціональні значення для створення нових абстракцій керування. По ходу ви також вивчите щодо карування та параметрів за-ім'ям.<br><h3>9.1 Зменьшення дублікації кода</h3>Всі функції поділені на загальні частини, що є однаковими для кожного виклика функції, та незагальних частей, що можуть відрізнтись від одного виклику функції до іншого. Загальні частини знаходяться в тілі функції, тоді як незагальні частити мають бути поставлені через аргументи. Коли ви використовуєте значення функції як аргумент, незагальна частина алгоритму сама по собі є іншим алгоритмом! За кожного виклику такої функції, ви можете передати туди різне функціональне значення в якості аргумента, та викликана функція буде, час від часу, за власним вибором, викликати передані функціональні значення. Ці функції вищого порядку — функції, що приймають функції як параметри — дають вам додаткові можливості до стискання та спрощення кода.<br><br>Одна з вигод функцій вищого порядка в тому, що вони дозволяють вам створювати абстракцій керування, що дозволяє зменшити дублікацію кода. Наприклад, уявімо, ви пишете файловий переглядач, та ви бажаєте провадтити API, що дозволить користувачам шукати файли, що співпадають за деяким критерієм. Перше, ви додаєте можливість шукати файли, чиї імена завершуються на певний рядок. Це може дати вашим користувачам пошук, наприклад, всіх файлів з розширенням ".scala". Ви можете запровадити такий API, визначаючи публічний метод filesEnding в об'єкті-синглтоні, таким чином:<br>
<pre class="prettyprint linenums language-scala">object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles
  def filesEnding(query: String) =
    for (file &lt;- filesHere; if file.getName.endsWith(query))
      yield file
}</pre>
<p>Метод filesEnding отримує список всіх файлів в поточному каталозі з використанням приватного допоміжного метода filesHere, потім фільтрує їх на основі того, чи кожне ім'я файла звершується на заданий користувачем запит. Беручи до уваги, що filesHere є приватним, метод filesEnding є єдиним доступним методом, доступним в FileMatcher, API, що ви провадите користувачам.<br><br>Докі все гарно, та код не повторюється. Однак потім ви вирішуєте дозволити людям шукати на основі любої частини імені файла. Це добре, коли ваші користувачі не пам'ятають, чи вони іменовали файл phb-important.doc, stupid-phb-report.doc, may2003salesdoc.phb, або щось зовсім інше, але вони думають, що "phb" з'являється десь в імені. Ви повертаєтесь назад, та додаєте цю функцію до вашого FileMatcher API:</p>
<pre class="prettyprint linenums language-scala">def filesContaining(query: String) =
  for (file &lt;- filesHere; if file.getName.contains(query))
  yield file</pre>
<p>Ця функція робить так само, як filesEnding. Вона шукає filesHere, перевіряє ім'я, та повертає файл, якщо ім'я співпадає. Єдина різниця є в тому, що ця функція використовуєcontains замість endsWith.</p><p>Проходить декілька місяців, та програма стає більш успішною. Одного разу ви отримуєте запити від декількох потужних користувачів, що бажають шукати на основі регулярних виразів. Ці недбалі хлопці мають величезні каталоги з тисячами файлів, та вони бажають робити такі речі, як шукати всі "pdf" файли, що мають "oopsla" десь в імені. Щоб підтримати їх, ви пишете таку функцію:</p>
<pre class="prettyprint linenums language-scala">def filesRegex(query: String) =
  for (file &lt;- filesHere; if file.getName.matches(query))
    yield file</pre>
<p>Досвідчені програмісти зауважать всі ці повторення, та здогадаються, що все це можна виділити в загальну допоміжну функцію. Однак зробити це в очевидний спосіб не спрацює. Ви хочете бути в змозі робити наступне:</p>
<pre class="prettyprint linenums language-scala">def filesMatching(query: String, method ) =
  for (file &lt;- filesHere; if file.getName. method (query))
    yield file</pre>
<p>Цей підхід буде робити в деяких динамічних мовах, але Scala не дозволяє вклеювати код разом таким чином. То що нам робити? Функціональні значення провадять відповідь. Хоча ви не можете передати ім'я метода як значення, ви можете отримати той же ефект, передаючи функціональне значення, що викликає метод за вас. В цьому випадку ви можете додати параметр matcher до метода, єдине призначення якого є перевірка імені файла відносно запиту:</p>
<pre class="prettyprint linenums language-scala">def filesMatching(query: String,
                  matcher: (String, String) =&gt; Boolean) = {
  for (file &lt;- filesHere; if matcher(file.getName, query))
    yield file
}</pre>
        <p>В цій версії метода вираз if тепер використовує matcher для перевірки імені файла відносно запиту. В точності що робить ця перевірка, залежить від того, що вказано в matcher. Тепер подівіться на тип самого matcher. Це функція, і, таким чином, має в типі =&gt;. Ця функція приймає два рядкових аргументів — ім'я файла та запит — та повертає логічне значення and returns a boolean, так що тип цієї функції (String, String) =&gt; Boolean .</p><p>Мачи цей новий допоміжний метод filesMatching, ви можете спростити три метода пошуку, щоб вони викликали допоміжний метод, передаючи відповідну функцію:</p>
<pre class="prettyprint linenums language-scala">def filesEnding(query: String) =
  filesMatching(query, _.endsWith(_))
def filesContaining(query: String) =
  filesMatching(query, _.contains(_))
def filesRegex(query: String) =
  filesMatching(query, _.matches(_))</pre>
        <p>Функціональні літерали, показані в цьому прикладі, використовують синтаксис заміщувачів, введений в попередній главі, що може відчуватись не дуже природним для вас. Таким чином, ось пояснення, як заміщувачі використовуються в цьому прикладі. Функціональний літерал _.endsWith(_), використаний в методі filesEnding, означає те саме, що і:</p>
<pre class="prettyprint linenums language-scala">(fileName: String, query: String) =&gt; fileName.endsWith(query)</pre>
        <p>Оскільки filesMatching приймає функцію, що потребує два аргументи String, однак вам не треба вказувати типи аргументв. Таким чином, ви можетет також записати: </p>
<pre class="prettyprint linenums language-scala">(fileName, query) =&gt; fileName.endsWith(query). </pre>
        <p>Оскільки параметри використовуються тільки одного разу в тілі функції, та оскільки перший параметр, fileName, використовується першим в тілі, та другий параметр, query, використовується другим, ви можете використовувати синтаксис з заміщувачем: _.endsWith(_). Перше підкреслення є заміщувачем для першого параметра, імені файла, та друге підкреслення заміщує другий параметр, рядок запиту query.</p><p>Цей код вже спрощений, але він може стати навіть коротшим. Зауважте, що запит переданий до filesMatching, але filesMatching нічого не робить з query, за винятком передачі його назад до переданої функції порівняння. Ця передача вперед та назад не є необхідною, оскільки викликач вже знає, яким буде запит! Ви можете також просто видалити параметр запиту з filesMatching та matcher, таким чином спрощуючи код, як показано в Лістингу 9.1.</p><pre
class="prettyprint linenums language-scala">object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles
  <br>  private def filesMatching(matcher: String =&gt; Boolean) =
    for (file &lt;- filesHere; if matcher(file.getName))
      yield file
<br>  def filesEnding(query: String) =
    filesMatching(_.endsWith(query))
  <br>  def filesContaining(query: String) =
    filesMatching(_.contains(query))
  <br>  def filesRegex(query: String) =
    filesMatching(_.matches(query))
}</pre>
        <p>Лістинг 9.1 Використання замикань для зменшення дублікації кода.</p><p>Цей приклад демонструє спосіб, яким першокласні функції можуть допомогти вам виключити дублікований код, де може бути дуже складним зробити це без них. Наприклад, в Java, ви можете створити інтерфейс, що містить метод, що приймає один рядок String, та повертає Boolean, потім створити та передати анонімний внутрішній клас, що реалізує цей інтерфейс до filesMatching. Хоча цей підхід буде видаляти дублікацію кода, якої ви намагаєтесь уникнути, в той же час додасть значно більше нового кода. Таким чином, вигода не варта ціни, та ви можете так же гарно жити з дублікацією.</p><p>Більше того, цей приклад демонструє, як замикання може допомогти вам зменшити дублікацію кода. Ці функціональні літерали, використані в попередньому прикладі, такі, як _.endsWith(_) та _.contains(_), перетворені під час виконання в функціональні значення, що не є замиканнями, оскільки вони не захоплюють любих вільних змінних. Обі змінні, використані в виразі, наприклад,&nbsp; _.endsWith(_), представлені підкресленнями, що означає, що вони отримані з аргументів функції. Таким чином, _.endsWith(_) використовує дві закріплені змінні, але не вільні змінні. На відміну від цього, фукціональний літерал _.endsWith(query), 
використаний в самому останньому прикладі, містить одну закріплену знінну, аргумент, представлений підкресленням, та одну вільну змінну, представлену іменованим 
query. Тільки через підтримку Scala замикань, ми можемо бути в змозі видалити парамтер query з filesMatching в останньому прикладі, таки мчином спрощуючи код навіть ще більше.</p><h3>9.2 Спрощення клієнтського кода</h3><p>Попередній приклад демонструє, що функції вищого опрядку можуть допомогти зменшити дублікацію коду при реалізації API. Інше важливе використання функцій вищого порядка є покласти їх в саме API, щоб зробити код клієнта більш стислим. Гарним прикладом є провадження циклічних методів спеціального призначення типів колекцій Scala. Багато з них перелічені в Таблиці 3.1 в Главі 3, але зараз погленемо тільки на один приклад, щоб побачити, чому ці методи є такими корисними.</p><p>Ці спеціальні циклічні методи визначені в трейті Traversable, що розширюється List, Set, та Map. Дивіться Главу 17 щодо обговорення. Візьмемо exists, метод, що визначає, чи передане значення міститься в колекції. Ви можете, звичайно, шукати елемент, маючи var, ініціалізовану в false, в циклі по колекції перевіряти кожний елемент, та встановити var в true, якщо ви знайшли що шукали.</p><p>Ось метод, що використостовує цей підхід для визначення, чи переданий List містить від'ємне число:</p>
<pre class="prettyprint linenums language-scala">def containsNeg(nums: List[Int]): Boolean = {
  var exists = false
  for (num &lt;- nums)
    if (num &lt; 0)
      exists = true<br>  exists<br>}</pre>
        <p>Якщо ви визначите цей метод в інтерпретаторі, ви можете викликати його таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; containsNeg(List(1, 2, 3, 4))
res0: Boolean = false
scala&gt; containsNeg(List(1, 2, -3, 4))
res1: Boolean = true</pre>
        <p>Однак більш стислий спосіб визначити метод є виклик функції вищого порядку exists на переданому List, ось так:</p>
<pre class="prettyprint linenums language-scala">def containsNeg(nums: List[Int]) = nums.exists(_ &lt; 0)</pre>
        <p>Ця версія containsNeg видає той же результат, що і попередній:</p>
<pre class="prettyprint linenums language-scala">scala&gt; containsNeg(Nil)
res2: Boolean = false
scala&gt; containsNeg(List(0, -1, -2))
res3: Boolean = true</pre>
        <p>Метод exists представляє абстракцію керування. Це циклічна конструкція спеціального призначення, запровадженна бібліотекою Scala, скоріше ніж бути вбудованою в мову Scala, як while або for. В попередньому розділі гетерогенна функція filesMatching зменшила дублікацію кода в реалізації об'єкта FileMatcher. Метод exists провадить подібну вигоду, або оскільки exists є публічною зі Scala’s API колекцій, дублікація кода, що вона зменьшує, є клієнтський код до цього API. Якщо exists не існує, та ви бажаєте написати метод containsOdd, щоб перевірити, чи список містить нпарні числа, ви можете написати таке:</p>
<pre class="prettyprint linenums language-scala">def containsOdd(nums: List[Int]): Boolean = {
  var exists = false
  for (num &lt;- nums)
    if (num % 2 == 1)
      exists = true
  exists
}</pre>
        <p>Якщо ви порівняєте тіло containsNeg з тілом containsOdd, ви знайдете, що все повторюється, за винятком умови перевірки в виразі if. Використовуючи exists, ви замість цього можете написати таке:</p>
<pre class="prettyprint linenums language-scala">def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)</pre>
        <p>Тіло кода в цій версії знову ідентичне до тіла відповідоного метода containsNeg (версія, що використовує), за виключенням того, що відрізняється умова, за якою виконується пошук. Також об'єм дублікації кода значно менший, оскільки вся циклічна інфраструктура виділена в самий метод exists.</p><p>Є багато інших циклічних методів в стандартній бібліотеці Scala. Як і з exists, вони часто можуть скоротити ваш код, якщо ви розпізнали моживості їх використання.</p><h3>9.3 Карування</h3><p>В Главі 1 ми казали, що Scala дозволяє вам створювати нові абстракції керування, що "відчуваються як природна пдітримка мови". Хоча приклади, що ви бачили досі, очевидно є абстракціями керування, ніхто не може сплутати їх з природною підтримкою мови. Щоб зрозуміти, як зробити абстракції керування, що виглядають як розширення мови, вам зпершу треба зрозуміти техніку функціонального програмування,&nbsp; що називається каруванням.</p><p>Карована функція застосовується до декількох списків аргументів, замість одного. Лістинг 9.2 показує звичайну, некаровану функцію, що додає два параметри Int, x та y .</p>
<pre class="prettyprint linenums language-scala">scala&gt; def plainOldSum(x: Int, y: Int) = x + y
plainOldSum: (x: Int,y: Int)Int
scala&gt; plainOldSum(1, 2)<br>res4: Int = 3</pre>
        <p>Лістинг 9.2 Визначення та виклик "звичайної старої" функції.</p><p>На відміну, Лістинг 9.3 показує подібну функцію, що карована. Замість одного списку з двох параметрів Int, ви застосовуєте цю функцію до двох списків, по одному параметру Int в кожному.</p>
<pre class="prettyprint linenums language-scala">scala&gt; def curriedSum(x: Int)(y: Int) = x + y
curriedSum: (x: Int)(y: Int)Int
scala&gt; curriedSum(1)(2)
res5: Int = 3</pre>
        <p>Лістинг 9.3 Визначення та виклик карованої функції.</p><p>Що відбувається тут, це коли ви викликаєте curriedSum, ви, насправді отримуєте два традиційні виклика функцій поспіль. Перший виклик функції приймає один параметр Int на ім'я x, та повертає функціональне значення для другої функції. Друга функція приймає&nbsp; Int параметр y. Ось функція, названа first, що діє в дусі першого традиційного виклику функції curriedSum:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def first(x: Int) = (y: Int) =&gt; x + y
first: (x: Int)(Int) =&gt; Int</pre>
        <p>Застосовуючи 1 до першої функції&nbsp; — іншими словами, викликаючи першу функцію та передаючи їй 1 — дає другу функцію:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val second = first(1)
second: (Int) =&gt; Int = &lt;function1&gt;</pre>
        <p>Застосовуючи 2 до другої функції дає результат:</p>
<pre class="prettyprint linenums language-scala">scala&gt; second(2)
res6: Int = 3</pre>
        <p>Ці перша та друга функції є тільки ілюстрацією процеса карування. Вони не під'єднані напряму до функції curriedSum. Тим не менш, є спосіб отримати справжнє посилання на "другу" функцію curriedSum. Ви можете використати нотацію з заміщувачем для використання curriedSum в виразі частково застосованої функції, таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val onePlus = curriedSum(1)_
onePlus: (Int) =&gt; Int = &lt;function1&gt;</pre>
        <p>Підкреслення в curriedSum(1)_ є заміщувачем для другого списку параметрів. Результатом є посилання на функцію, що, коли викликається, додає один до свого єдиного аргумента Int, та повертає результат:</p>
<pre class="prettyprint linenums language-scala">scala&gt; onePlus(2)
res7: Int = 3</pre>
        <p>Та ось як ви отримаєте функцію, що додає два до свого єдиного аргумента Int:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val twoPlus = curriedSum(2)_
twoPlus: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; twoPlus(2)
res8: Int = 4</pre>
        <h3>9.4 Написання нових структур керування</h3><p>В мовах з першокласними функціями ви можете ефективно зробити нові структури керування, навіть якщо синтаксис мови зафіксовано. Все, що вам треба зробити, це створити методи, що приймають функції як аргументи. Наприклад, ось керівна структура "twice", що повторює операцію два рази, та повертає результат:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def twice(op: Double =&gt; Double, x: Double) = op(op(x))
twice: (op: (Double) =&gt; Double,x: Double)Double
scala&gt; twice(_ + 1, 5)
res9: Double = 7.0</pre>
        <p>В попередній главі, коли нотація заміщувача використовувалась на традиційних методах, як println _, ви мали залишити проміжок між ім'ям та підкресленням. В цьому випадку ні, бо коли println_ є легальним ідентифікатором Scala, curriedSum(1)_ ні. Тип op в цьому прикладі Double =&gt; Double, що означає, що ця функція сприймає один Double як аргумент, та повертає інший Double.</p><p>Кожного разу, коли ви знайдете шаблон керування, повторений в багатьох частинах вашого кода, ви повинні подумати про реалізацію його як структури керування. Раніше в цій главі ви бачили filesMatching, дуще специфічний шаблон керування. Розгляньте тепер широко застосований шаблон керування: відкрити ресурс, виконати операції з ним, та потім зачинити ресурс. Ви можете захопити його в керівній абстракції, використовуючи метод наступним чином:</p>
<pre class="prettyprint linenums language-scala">def withPrintWriter(file: File, op: PrintWriter =&gt; Unit) {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}</pre>
        <p>Маючи такий метод, ви можете використовувати його так:</p>
<pre class="prettyprint linenums language-scala">withPrintWriter(
  new File("date.txt"),
  writer =&gt; writer.println(new java.util.Date)
)</pre>
        <p>Перевага використання цього метода в тому, що його withPrintWriter, не код користувача, гагнтує закриття файла в кінці. Так що неможливо забути закрити файл. Цей прийом називається шаблоном позичання, оскільки функція абстракції керування, як withPrintWriter, відкриває ресурс, та "позичає" його функції. Наприклад,&nbsp; withPrintWriter в попередньому прикладі позичає PrintWriter функції op. Коли функція завершується, вона сигналить, що їй більше не треба "позичений" ресурс. Потім ресурс зачиняється в блоці finally, щоб переконатись, що він напевне закритий, безвідносно, чи функція завершилась нормально, або викликавши виключення.</p><p>Одним способом, як ви можете змусити клієнтський код виглядати більше як вбудовані структури керування, є використання фігурних дужок замість звичайних, щоб оточити список аргументів. В кожному виклику метода Scala, в якому ви передаєте рівно один аргумент, ви маєте можливість використати фігурні дужки для оточення аргумента, замість звичайних. Наприклад, замість:</p>
<pre class="prettyprint linenums language-scala">scala&gt; println("Hello, world!")
Hello, world!</pre>
        <p>ви можете записати:</p>
<pre class="prettyprint linenums language-scala">scala&gt; println { "Hello, world!" }
Hello, world!</pre>
        <p>В другому прикладі ви використовуєте фігурні дужки замість дужок, щоб оточити аргумент println. Однак цей прийом з фігурними дужками буде робити, тільки якщо ви передаєте один аргумент. Ось приклад порушити це правило: </p>
<pre class="prettyprint linenums language-scala">scala&gt; val g = "Hello, world!"
g: java.lang.String = Hello, world!
scala&gt; g.substring { 7, 9 }
&lt;console&gt;:1: error: ';' expected but ',' found.
g.substring { 7, 9 }
               ˆ</pre>
<p>Оскільки ви намагаєтесь передати два аргументи до substring, ви отримуєте помилку, коли ви намагаєтесь оточити ці аргументи фігурними дужками. Замість цього, вам треба використовувати дужки:</p>
<pre class="prettyprint linenums language-scala">scala&gt; g.substring(7, 9)
res12: java.lang.String = wo</pre>
        <p>Призначення цієї можливості замінити дужки на фігурні для передачі одного параметра є дозволити клієнтським програмістам писати функціональні літерали між фігурними дужками. Це може зробити виклик метода виглядати більше як керівна абстракція. Візьміть метод withPrintWriter, попередньо визначений як приклад. В своїй найбільш ранішній формі withPrintWriter приймає два аргументи, так що ви не можете використати фігурні дужки. Тим не менш, оскільки функція, передана до withPrintWriter є останнім аргументом в списку, ви можете використати карування, щоб підтягнути перший аргумент, File, в окремий списк аргументів. Це залишить функцію як єдиний параметр другого списку аргументів.</p><p>Лістинг 9.4 показує, як вам треба перевизначити withPrintWriter.&nbsp;&nbsp;</p>
<pre class="prettyprint linenums language-scala">def withPrintWriter(file: File)(op: PrintWriter =&gt; Unit) {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}</pre>
        <p>Лістинг 9.4 Використання шаблона позичання для написання файла.</p><p>Нова версія відрізняється від старої тільки в тому, що тепер є два списки параметрів, з одним параметром в кожному, замість одного списка з двома параметрами. Подівіться між двома параметрами. В попередній версії withPrintWriter ви бачите . . . File, op . . . . Але в цій версії ви бачите&nbsp; . . . File)(op . . . . Маючи визаченя вище, ви можете викликати метод з більш приємним синтаксисом:</p>
<pre class="prettyprint linenums language-scala">val file = new File("date.txt")
withPrintWriter(file) {
  writer =&gt; writer.println(new java.util.Date)
}</pre>
        <p>В цьому прикладі перший список аргументів, що містить один аргумент File, записаний в оточенні дужок. Другий список аргументів, що містить один функціональний аргумент, осочений фігурними дужками.</p><h3>9.5 Параметри за-ім'ям</h3><p>Метод withPrintWriter, показаний в попередньому розділі відрізняється від вбудованої структури керування мови, такої, як if та while, в тому, що код між фігурними дужками приймає аргумент. Метод withPrintWriter потребує один аргумент типу PrintWriter. Це йаргумент показаний як "writer =&gt;" в:</p>
<pre class="prettyprint linenums language-scala">withPrintWriter(file) {
  writer =&gt; writer.println(new java.util.Date)
}</pre>
        <p>Однак що, якщо ви бажаєте реалізовати щось більше схоже на if або while, де немає значення, що передається в код між фігурними дужками? Щоб допомогти з такими ситуаціями, Scala провадить параметри за-ім'ям.</p><p>Як конкретний приклад, уявімо, що ви бажаєте реалізовати конструкцію припущення з назвою myAssert. Функція myAssert буде приймати функціональне значення на вході, та консультується з флагом, щоб вирішити, що робити. Якщо флаг встановлений, myAssert буде викликати передану функцію, та перевіряти, чи вона повертає&nbsp; true. Якщо флаг вимкнений, myAssert буде мовчки зовсім нічого не робити.</p><p>Без використання параметрів зі-ім'ям, ви можете написати myAssert таким чином: </p>
<pre class="prettyprint linenums language-scala">var assertionsEnabled = true
def myAssert(predicate: () =&gt; Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate())
    throw new AssertionError</pre>
        <p>Визначення гарне, але викорастання його трохи незграбне:</p>
<pre class="prettyprint linenums language-scala">myAssert(() =&gt; 5 &gt; 3)</pre>
        <p>Ви можете спробувати відкинути пустий список параметрів та символ =&gt; в функціональному літералі, та записати код таким чином: </p>
<pre class="prettyprint linenums language-scala">myAssert(5 &gt; 3) // Не буде робити через відсутнє () =&gt;</pre>
        <p>Параметри за-ім'ям існують точно для того, щоб ви могли зробити це. Щоб зробити параметр за-ім'ям, ви надаєте параметру тип, що починається з =&gt; замість () =&gt; . Наприклад, ви можете змінити параметр предиката myAssert на параметр за-ім'ям, змінивши його тип, "() =&gt; Boolean ", на " =&gt; Boolean ". Лістинг 9.5 показує, як це буде виглядати:<br>
</p><pre class="prettyprint linenums language-scala">def byNameAssert(predicate: =&gt; Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate)
    throw new AssertionError</pre>Лістинг 9.5 Використання параметра за-ім'ям.<br><br>Тепер ви можете відкинути пустий параметр у властивості, що ви бажаєте оцінити. Результат в тому, що використання byNameAssert виглядає точно як використання вбудованої структури: ви викликаєте цей myAssert, не assert, оскільки Scala провадить свій власний assert, що буде описане в Розділі 14.1.
<pre class="prettyprint linenums language-scala">byNameAssert(5 &gt; 3)</pre>
        <p>Тип за-ім'ям, в якому пустий список параметрів, (), відкидається, дозволяється тільки для параметрів. Немає такоє речі, як змінна за-ім'ям, або поле за-іменем. Тепер ви можете здивуватись, чому ми просто не пишемо myAssert, з використанням простого старого Boolean для типу параметра, як тут: </p>
<pre class="prettyprint linenums language-scala">def boolAssert(predicate: Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate)
    throw new AssertionError</pre>
        <p>Це формулювання, звичайно, також легальне, та код з використанням цієї версії boolAssert буде також виглядати точно як раніше:</p>
<pre class="prettyprint linenums language-scala">boolAssert(5 &gt; 3)</pre>
        <p>Тим не менш, одна різниця існує між ціма двома підходами, що важливо занотувати. Оскільки тип параметра boolAssert є Boolean, вираз в дужках в boolAssert(5 &gt; 3) обчислюється перед викликом boolAssert. Вираз 5 &gt; 3 дає true, що передається до boolAssert. На відміну, оскільки тип параметра предиката byNameAssert є =&gt; Boolean, вираз в дужках byNameAssert(5 &gt; 3) не обчислюється до виклику byNameAssert. Замість функціонального значення буде створена той метод apply, що обчислюватиме 5 &gt; 3, та це функціональне значення буде передане до byNameAssert. Різниця між двома підходами, таким чином, в тому, що якщо допущення відключене, ви побачите любі побічні ефекті, що може мати вираз в дужках для boolAssert, але не в byNameAssert. Наприклад, ящо допущення відключене, спроба визначитись для "x / 0 == 0" буде давати виключення в випадку boolAssert:</p>
<pre class="prettyprint linenums language-scala">scala&gt; var assertionsEnabled = false
assertionsEnabled: Boolean = false
scala&gt; boolAssert(x / 0 == 0)
java.lang.ArithmeticException: / by zero
at .&lt;init&gt;(&lt;console&gt;:9)
at .&lt;clinit&gt;(&lt;console&gt;)
at RequestResult$.&lt;init&gt;(&lt;console&gt;:9)
at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)</pre>
        <p>Але спроба допущення на тому ж коді в випадку byNameAssert не буде давати виключення:</p>
<pre class="prettyprint linenums language-scala">scala&gt; byNameAssert(x / 0 == 0)</pre>
        <h3>9.6 Висновок</h3><p>Ця глава показала вам, як ви можете будувати на багатій підтримці функцій в Scala абстракції керування. Виможете використовувати функції в вашому коді для виділення загальних шаблонів керування, та ви можете отримати переваги фукнцій вищого порядку в бібліотеці Scala для повторного використання шаблонів керування, що є загальними в коді програміста. Ця глава також показала, як використовувати каринг та параметри за-ім'ям, так, що ваші власні функції можуть бути використані в стислому синтаксисі.</p><p>В попередній та цій главі ви побачили досить багато інформації щодо функцій. Наступні декілька глав повернуться назад до обговорення більш об'єктно-орієнтованих можливостей мови. </p><h3>Глава 10</h3><h2>Композиція та наслідування</h2><p>Глава 6 ввела деякі базові об'єктно-орієнтовані аспекти Scala. Ця глава продовжить там, де скінчила Глава 6, та зануриться в значно глибші деталі підтримки Scala об'єктно-орієнтованого програмування. Ми порівняємо два функціональні відношення між класами: композиція та наслідування. Композиція означає, що один клас містить посилання на інший, використоуючи цей клас для допомоги у виконання своє міссії. Наслідування є відношення суперкласса/субкласа. На додаток до ціх тем ми обсудимо абстрактні класи, методи без параметрів, розширення класів, перевизначення методів та полів, параметричні поля, виклик конструкторів суперкласів, поліморфізм та динамічне зв'язування, фінальні члени та класи, та об'єкти-фабрики та методи.</p><h3>10.1 Бібліотека двовимірного розташування</h3><p>Як робочий приклад цієї глави, ми створимо бібліотеку для побудови та відображення двовимірних елементів розташування. Кожний елемент буде представляти прямокутник, заповнений текстом. Для зручності бібліотека буде провадити методи-фабрики, названі “elem”, що конструюють нові елементи з переданих даних. Наприклад, ви будете в змозі створити елемент розташування, що містить рядок, використовуючи метод-фабрику з наступною сигнатурою:</p>
<pre class="prettyprint linenums language-scala">elem(s: String): Element</pre>
        <p>Як ви можете бачити, елементи будуть змодельовані типом з назвою Element. Ви будете в змозі викликати above або beside з елемнетом, передаючи другий елемент, щоб отримати новий елемент, що комбінує обоє. Наприклад, наступний вираз буде конструювати більший елемент, що складається з двох стовпчиків, кожний висотою два рядки:</p>
<pre class="prettyprint linenums language-scala">val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2</pre>
        <p>Друк результату цього виразу:</p>
<pre class="prettyprint linenums language-scala">hello ***
*** world</pre>
        <p>Елементи розташування є гарним прикладом системи, в якій об'єкти можуть бути сконструйовані з простих частин за допомогою операторів композиції. В цій главі ми визначимо класи, що дозволяють об'єктам елементів бути сконструйованими з масивів, ліній та прямокутниуів — простих частин. Ми також визначимо оператори композиції above та beside. Такі операції композиції також часто називіють комбінаторами, оскільки вони комбінують елементи в деякій галузі в нові елементи.</p><p>Думати в термінах комбінаторів є загалом гарним шляхом для підходу до розробки бібліотеки: це змішує думати про фундаментальні шляхи конструювання об'єктів в галузі застосування. Що таке прості об'єкти? В який спосіб з простих об'єктів можна створити більш цікаві об'єкти? Як комбінатори поєднуються разом? Які комбінації є найбільш загальними? Чи вони задовільняють деяким цікавим законам? Якщо ви маєте гарні відповіді на ці запитання, дизайн вашої бібліотеки на вірному шляху.</p><h3>10.2 Абстрактні класи</h3><p>Наше перше завдання є визначити тип Element, що представляє елементи розташування. Оскільки елементи є двовимірними прямокутниками символів, має сенс включити член contents, що посилається на вміст елементу розташування. Член contents може бути предствлений як масив рядків, де кожний рядок представляє одну лінію. Таким чином, тип результата, що повертає contents, буде Array[String]. Лістинг 10.1 показує, на що це буде схоже. В цьому класі contents декларований як метод, що не має реалізації. Іншими словами, метод є абстрактним членом класа Element. Клас з абстрактними членами має сам бути декларований як абстрактний, що робиться за допомогою модифікатора abstract перед ключовим словом class:</p>
<pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
}</pre>
        <p>Лістинг 10.1 Визначення абстрактного метода та класа.</p>
<pre class="prettyprint linenums language-scala">abstract class Element ...</pre>
        <p>Модифікатор abstract вказує, що клас може мати абстрактні члени, що не мають реалізації. Як результат, ви не можете створити примірник абстрактного класа. Якщо ви спробуєте зробити це, ви отримаєте помилку компілятора:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Element
&lt;console&gt;:5: error: class Element is abstract; 
cannot be instantiated
new Element
ˆ</pre>
        <p>Пізніше в цій главі ми побачимо, як створити субкласи класа Element, що будуть в змозі створювати примірники, оскільки вони заповнять відсутні визначення для contents .</p><p>Зауважте, що метод contents в класі Element не має модифікатора abstract. Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або тіла). На відміну від Java, модифікатор abstract не потрібен (або, навіть, дозволений) на декларації метода. Методи, що мають реалізацію, називаються конкретними.</p><p>Інша термінологія робить розділ між деклараціями та визначеннями. Клас Element декларує абстрактний метод contents, але наразі не визначає конкретних методів. В наступньому розділі, однак, ми розширимо&nbsp;Element, визначивши деякі конкретні методи.</p><h3>10.3 Визначення методів без параметрів</h3><p>Як наступний крок, ми додамо методи до Element, що представлятимуть його ширину та довжину, як показано в Лістингу 10.2. Метод height повертає число ліній вмісту. Метод width повертає довжину першого рядка, або, якщо немає жодного рядка, нуль (це означає, що ви не можете визначити елемент з висотою нуль, та ненульовою шириною).</p>
<pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}</pre>
        <p>Лістинг 10.2 Визначення методів  width та height без параметрів.</p><p>Зауважте, що жодний з трьох методів не має списка параметрів, навіть пустого. Наприклад, замість:</p>
<pre class="prettyprint linenums language-scala">def width(): Int</pre>
        <p>іде метод, визначений без дужок:</p>
<pre class="prettyprint linenums language-scala">def width: Int</pre>
        <p>Такі методи без дужок є досить загальними в Scala. Замість цього, методи, визначені з пустими дужками, такі як def height(): Int, називаються методами з порожніми дужками. Рекомдованою домовленостю є використання дужок, коли немає параметрів, та метод отримує доступ до змінного стану тільки для читання полів об'єкта (зокрема, він не змінює змінний стан). Ця домовленість підтримує одноманітний принцип доступу, що каже, що на код клієнта не повинно впливати рішення реалізоати атрибут як поле або як метод. Наприклад, ви можете обрати реалізовати width та height як поля, замість методів, просто змінивши def в кожному визначенні на val :</p>
<pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  val height = contents.length
  val width =
    if (height == 0) 0 else contents(0).length
}</pre>
        <p>Дві пари визначень повністю еквівалентні з точки зору клієнта. Єдина відмінність в тому, що доступ до поля може бути трохи швидшим, ніж виклики метода, оскільки значення полів попередньо обчислені при ініціалізації класа, замість обчислюватись при кожному виклику метода. З іншого боку, поле потребує додатковий простір пам'яті в кожному об'єкті Element. Так що все залежить від профіля використання класа, буде атрибут краще представлений як поле, або як метод, та цей профіль використання може змінитись з часом. Суть полягає в тому, що клієнти класа Element не повинні зазнвати впливу, коли змінюється внутрішня реалізація. Зокрема, клієнт класа Element не повинен бути переписаний, якщо поле цього класа змінюється на функцію доступу, доки функція доступу залишається чистою, тобто він не має побічних ефектів та не залежить від змінного стану. Клієнт не повинен турбуватись в жодному разі. </p><p>Доки все добре. Але все ще є деяке ускладнення, що пов'язане з тим, як Java обробляє речі. Проблема в тому, що&nbsp; Java не реалізує одноманітний принцип доступу. Так що в Java існує string.length(), не string.length (хоча є array.length, та не array.length()) .</p><p>Не треба казати, що це дуже зпантеличує. Щоб закрити цю дірку, Scala є дуже ліберальною, коли доходить до змішування методів без параметрів та методів з порожніми дужками. Зокрема, ви можете перевизначити метод без параметрів методом з порожніми дужками, та навпаки. Ви також можете відкинути пусті дужки у виклику любої функції, що не має аргументів. Наприклад, наступні два рядки обоє легальні в Scala:</p>
<pre class="prettyprint linenums language-scala">Array(1, 2, 3).toString
"abc".length</pre>
        <p>В принципі, можливо відкинути порожні дужки в викликах функцій Scala. Однак, рекомендовано все ще писати порожні дужки, коли викликаний метод представляє більше ніж чим властивість об'єкта-отримувача. Наприклад, порожні дужки є доречними, якщо метод виконує I/O, записує в переприсвоювані змінні (var), або читає інші var, крім полей отримувача, прямо чи опосередковано, використовуючи змінні об'єкти. Таким чином, список параметрів діє як віруальна підказка, що дещо цікаве обчислення вмикається в результаті цього виклику. Наприклад:</p>
<pre class="prettyprint linenums language-scala">"hello".length // немає (), оскільки немає побічних ефектів
println() // краще не відкидати ()</pre>
        <p>Щоб підсумувати, заохочуваним стилем в Scala є визначати методи, що не приймають параметрів та не мають побічних ефектів, як методи без параметрів, тобто, відкидаючи порожні дужки. З іншого боку, ви ніколи не повинні визначати метод, що має побічні ефекти, без дужок, оскільки тоді виклики цього метода будуть виглядать як вибірка поля. Так що ваші клієнти будуть здивовані побачити побічні ефекти. Також, коли ви викликаєте функції, що мають побічні ефекти, переконайтесь, що включили пусті дужки під час написання виклику. Інший спосіб думати про це: якщо функція, що ви викликаєте, виконує операцію, використовуйте дужки, але якщо вона лише провадить доступ до властивості, відкидайте дужки геть.</p><h3>10.4 Розширення класів</h3><p>Нам все ще треба змога створювати нові об'єкти елементів. Ви вже бачили, що “new Element” не може бути використаний для цього, оскільки клас Element є абстрактним. Щоб створити примірник елемента, таким чином, нам треба створити субклас, що розширює Element та реалізує абстрактний метод contents. Лістинг 10.3 показує один можливий спосіб зробити це:</p>
<pre class="prettyprint linenums language-scala">class ArrayElement(conts: Array[String]) extends Element {
  def contents: Array[String] = conts
}</pre>
        <p>Лістинг 10.3 Визначення ArrayElement як субкласа Element .</p><p>Class ArrayElement визначений для розширення класа Element. Так само як в Java, ви використовуєте extends після імені класа для вираження цього:</p>
<pre class="prettyprint linenums language-scala">... extends Element ...</pre>
        <p>Таке твердження extends має два ефекти: воно робить те, ArrayElement наслідує всі не-приватні члени від класа Element, та він робить тип ArrayElement субтипом типу Element. Якщо ArrayElement розширює Element, клас ArrayElement називається субкласом класа Element. Відповідно, Element є суперкласом ArrayElement. Якщо ви приберете твердження extends, компілятор Scala неявно вважає, що ваш клас розширює scala.AnyRef, що на платформі Java є тим самим, що клас java.lang.Object. Таким чином, клас Element неявно розширює клас AnyRef. Ви можете бачити це відношення розширення на Малюнку 10.1.</p>
<pre class="prettyprint linenums language-scala">      scala
      AnyRef
 «java.lang.Object»<br>       ^ <br>    &nbsp;Element
   «abstract»<br>       ^<br> &nbsp;ArrayElement &lt;- Array[String]
</pre>
        <p>Малюнок 10.1 Діаграма класів дл ArrayElement.<br>
</p>
<p>Наслідовання означає, що всі члени суперкласа є також членами субкласа, з двома виключеннями. Перше, приватні члени суперкласа не наслідуються субкласами. Друге, член суперкласа не наслідується, якщо член з тим же ім'ям та параметрами вже реалізований в субкласі. В цьому випадку ми кажемо, що член субкласа перевизначає член суперкласа. Якщо член субкласа є конкретним, та член суперкласа є абстрактним, ми також кажемо, що конкретний клас реалізує абстрактний.</p><p>Наприклад, метод contents в ArrayElement перевизначає (або, альтернативно: реалізує) абстрактний метод contents в класі Element. На відміну, клас ArrayElement наслідує методи width та height від класа Element. Наприклад, маючи ArrayElement ae, ви можетет запитати його&nbsp;width, використовуючи ae.width, якби width було визначено в класі ArrayElement:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val ae = new ArrayElement(Array("hello", "world"))
ae: ArrayElement = ArrayElement@d94e60
scala&gt; ae.width
res1: Int = 5</pre><p>Один недолік цього дизайну в тому, що оскільки повернутий масив є змінним, клієнти можуть змінити його. Для цієї книги ми будемо утримувати речі простими, але якщо ArrayElement був би частиною реального проекта, ви можете, замість цього, вирішити повертати захищену копію масива. Інша проблема полягає в тому, що ми наразі не гарантуємо, що кожний елемент String масива contents має ту ж довжину. Це може бути вирішено перевіркою цієї умови в первинному конструкторі, та викликати виключення, якщо воно порушене.</p><p>Субтипи означають, що значення суперкласа може бути використане, там, де потрібне значення суперкласа. Наприклад:</p>
<pre class="prettyprint linenums language-scala">val e: Element = new ArrayElement(Array("hello"))</pre>
        <p>Змінна e визначена типу Element, так що її ініціалізоване значення повинно також бути Element. Фактично, тип ініціалізуючого значення є ArrayElement. Це є гаразд, оскільки клас ArrayElement розширює клас Element, та як результат, тип ArrayElement сумісний з типом Element. Малюнок 10.1 також показує відноешння композиції, що існує між ArrayElement та Array[String]. Це відношення називається композицією, бо клас ArrayElement&nbsp; “скомпонований” з класу Array[String], в тому сенсі, що компілятор Scala буде розміщувати в бінарний код, якій він генерує для ArrayElement, поле, що містить посилання на переданий масив conts. Ми обговоримо деякі міркування&nbsp; дизайну щодо композиції та наслідування пізніше в цій главі, в Розділі 10.11.</p><h3>10.5 Перевизначення методів та полів</h3><p>Принцип одноманітного доступу є тільки одним аспектом, коли Scala трактує поля та методи більш одноманітно, ніж Java. Інша різниця в тому, що в Scala поля та методи належать до одного простору імен. Це робить можливим для полів перевизначати методи без дужок. Наприклад, ви можете змінити реалізацію contents в класі ArrayElement, з метода на поле, без необхідності модифікувати визначення абстрактного метода contents в класі Element, як показано в Лістингу 10.4:</p>
<pre class="prettyprint linenums language-scala">class ArrayElement(conts: Array[String]) extends Element {
  val contents: Array[String] = conts
}</pre>
        <p>Лістинг 10.4 Перевизначення метода без дужок на поле.</p><p>Поле contents (визначене за допомогою val) в цій версії ArrayElement є чудово гарною реалізацією метода без дужок contents (декларованого за допомогою&nbsp; def ) в класі Element.&nbsp; Для більшої перспективи щодо різниці між субкласом та субтипом, дивіться глосарій щодо субтипів.</p><p>З іншого боку, в Scala заборонено визначати поле та метод з одним ім'ям в одному і тому ж класі, хоча це дозволено в Java. Наприклад, цей клас Java буде компілюватись повністю нормально:</p>
<pre class="prettyprint linenums language-java">// Це Java
class CompilesFine {
    private int f = 0;
    public int f() {
        return 1;
    }
}</pre>
        <p>Але відповідний клас Scala не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">class WontCompile {
  private var f = 0 // Не буде компілюватись, оскільки поле
  def f = 1 // та метод мають однакові імена
}</pre>
        <p>Загалом, Scala має лише два простори імен для визначень, замість чотирьох в Java. Чотири простори імен Java: поля, методи, типи та пакунки. На відміну, в Scala їх лише два:</p><p>• значення (поля, методи, пакунки, об'єкти-синглтони)<br>• типи (імена класів та трейтів)</p><p>Причина, з якої Scala покладає поля та методи в те ж поле імен, в точності таке, щоб ви могли перевизначити методи без параметрів за допомогою val, що ви не можете зробити в Java.</p><h3>10.6 Визначення параметричних полів</h3><p>Знову розглянемо визначення класу ArrayElement, показаного в попередньому розділі. Він має параметр conts, єдиним призначенням якого є бути скопійованим в поле contents. Ім'я conts параметра було обране таким чином, щоб він виглядав подібно до імені поля contents, без того, щоб насправді перетинатись з ним. Цей “запах коду” є ознакою, що є деяка непотрібна надмірність та повторення в вашому коді. Ви можете уникати запаху коду,&nbsp; комбінуючи параметр та поле в одне параметричне визначення поля, як показане в Лістингу 10.5:</p>
<pre class="prettyprint linenums language-scala">class ArrayElement(
  val contents: Array[String]
) extends Element</pre>
        <p>Лістинг 10.5 Визначення contents як параметричного поля.</p><p>Зауважте, що тепер параметр contents починається з val. Це скорочення, що визначає одночаc<code></code>но параметр та поле з тим же ім'ям. Більш специфічно, клас ArrayElement тепер має (непереприсвоюване) поле contents, що може бути доступне за межами класу. Поле ініціалізоване значенням параметра. Це так, якби клас був написаний таким чином, де x123 є довільним новим ім'ям параметра:</p>
<pre class="prettyprint linenums language-scala">class ArrayElement(x123: Array[String]) extends Element {
  val contents: Array[String] = x123
}</pre>
        <p>Ви також можете почати параметр класа за допомогою var, в якому випадку відповідне поле може бути перепризначене. Нарешті, можливо додати модифікатори, такі як private, protected, або override до ціх параметричних полів, таким же чином, як ви можете зробити для любого іншого члена класа. Розгляньте, наприклад, наступне визначення класа:</p>
<pre class="prettyprint linenums language-scala">class Cat {
  val dangerous = false
}
class Tiger(
  override val dangerous: Boolean,
  private var age: Int
) extends Cat</pre>
        <p>Модифікатор protected, що гарантує доступ до субкласів, буде детально пояснений в Главі 13. Визначення Tiger є скороченням для наступної альтернативи визначення класу, з перевизначенним методом dangerous, та приватним методом age :</p>
<pre class="prettyprint linenums language-scala">class Tiger(param1: Boolean, param2: Int) extends Cat {
  override val dangerous = param1
  private var age = param2
}</pre>
        <p>Обоє члени ініціалізовані з відповідних параметрів. Ми довільно обрали імена ціх параметрів, param1 та param2. Важлива річ, що вони не перетинаються з іншими іменами в полі зору.</p><h3>10.7 Виклик конструкторів суперкласа</h3><p>Тепер ви маєте повну систему, що складається з двох класів: абстрактного класа Element, що розширений конкретним класом ArrayElement. Ви можете також побачити інші шляхи для вираження елемента. Наприклад, клієнт може побажати створити елемент розташування, що складається з одного рядка, що утворює лінію. Об'єктно-орієнтовне програмування спрощує розширення системи за допомогою нових варіантів даних. Ви можете просто додати субкалс. Наприклад, Лістинг 10.6 показує клас LineElement, що розширює ArrayElement:</p>
<pre class="prettyprint linenums language-scala">class LineElement(s: String) extends ArrayElement(Array(s)) {
  override def width = s.length
  override def height = 1
}</pre>
        <p>Лістинг 10.6 Включаючи конструктор суперкласу.</p><p>Оскільки LineElement розширює ArrayElement, та конструктор ArrayElement приймає параметр (Array[String]), LineElement потребує передання аргумента первинному конструктору суперкласа. Щоб викликати конструктор суперкласа, ви просто можете покласти бажаний аргмунт або аргументи в дужки, що йдуть за іменем суперкласа. Наприклад, клас LineElement передає декілька Array до первинного конструктора ArrayElement, кладучи його в дужки після імені суперкласа ArrayElement:</p>
<pre class="prettyprint linenums language-scala">... extends ArrayElement(Array(s)) ...</pre>
<pre class="prettyprint linenums language-scala">     Element
    «abstract»
        ^<br>   ArrayElement  &lt;- Array[String]
        ^<br>    LineElement</pre>
        <p>Малюнок 10.2 Діаграма класа для LineElement.</p><p>З новим субкласом ієрархія наслідування для елементів розташування тепер виглядає як на Малюнку 10.2.</p><h3>10.8 Використання модифікатора override</h3><p>Зауважте, що визначення width та height в LineElement містять модифікатор override. В Розділі 6.3 ви бачили цей модифікатор в визначенні метода toString. Scala вимагає цей модифікатор для всіх членів, що перевизначають конкретний член в батьківському класі. Модифікатор є опціональним, якщо член реалізує абстрактний член з тим же ім'ям. Модифікатор заборонений, якщо член не перевизначає або реалізує деякий інший член базового класу. Оскільки height та width в класі&nbsp; LineElement перекривають конкретні визначення в класі Element, присутніть override вимушена. </p><p>Це правило провадить корисну інформацію для компілятора, що допомагає уникнути деякі складні для відлову помилки, та робить розвиток системи простішою. Наприклад, якщо ви випадково помилились в назві метода, або випадково надали йому інший список параметрів, компілятор відповість повідомленням про помилку:</p>
<pre class="prettyprint linenums language-scala">$ scalac LineElement.scala
.../LineElement.scala:50:
error: method hight overrides nothing
  override def hight = 1
           ˆ</pre>
Домовленість перевизначення навіть більш важлива, коли йдеться про розвиток системи. Скажімо, ви визначили бібліотеку методів 2D малювання. Ви зробили її публічно доступною, та вона масово застосовується. В наступній версії бібліотеки ви бажаєте додати до вашого базового класа Shape новий метод з такою сигнатурою:
<pre class="prettyprint linenums language-scala">def hidden(): Boolean</pre>
        <p>Ваш новий метод буде використаний в багатьох методах малювання, щоб визначити, чи фігура має бути намальована. Це може призвести до значного прискорення, але ви не можете зробити це без ризику поламати клієнтський код. Кінець кінцем, клієнт може визначити субклас Shape з іншою реалізацією hidden. Можилво, метод об'єкта насправді приховує об'єкт, замість перевіряти, чи він є прихованим. Оскільки дві версії hidden перевизначають одна одну, ваш метод малювання може закінчити тим, що приховуватиме об'єкт, що, напевне, не те, чого ви прагнете! Ці&nbsp; “випадкові перевизначення” є найбільш загальною маніфестацією того, що називається проблемою “крихкого базового класа”. Проблема в тому, що якщо ви додаєте новий член до базового класу (що ми звичайно називаємо суперкласом) в ієрархії класів, ви ризикуєте поламати клієнтський код.</p><p>Scala не може повністю вирішити проблему крихкого базового класу, але порівняно з Java вона поліпшує ситуацію.&nbsp; Якщо бібліотека малювання, та її клієнти написані в Scala, тоді оригінальна реалізація клієнта hidden може не мати модифікатора override, оскільки на той час немає іншого метода з цім ім'ям. Коли ви додасте метод hidden до другої весії свойого класа фігури, рекомпіляція клієнта буде давати помилку, як наступна:</p>
<pre class="prettyprint linenums language-scala">.../Shapes.scala:6: error: error overriding method
    hidden in class Shape of type ()Boolean;
method hidden needs `override' modifier
def hidden(): Boolean =
ˆ</pre>Тобто, замість хибної поведінки, ваш клієнт буде отримувати помилку компіляції, що, зазвичай, більш прийнятне. В Java 1.5 була введена анотація @Override, що робить подібно до модифікатора Scala override, але, на відміну від Scala override, вона не обов'язкова.<h3>10.9 Поліморфізм та динамічне зв'язування</h3><p>Ви бачили в Розлілі 10.4, що змінна типу Element може посилатись на об'єкт типу ArrayElement. Ім'я цього феномена є поліморіфзм, що означає “багатогранний” або “що має декілька форм”. В цьому випадку об'єкти Element можуть приймати декілька форм. До тепер ми бачили дві форми: ArrayElement та LineElement. Ви можете створити більше форм Element, визначаючи нові субкласи Element. Наприклад, ось як ви можете визначити нову форму Element, що має надану ширину та висоту, та повністю заповнена наданим символом:</p>
<pre class="prettyprint linenums language-scala">class UniformElement(
  ch: Char,
  override val width: Int,
  override val height: Int
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}</pre>
        <p>Ієрархія наслідування для класа Element тепер виглядає як показано на Малюнку 10.3. </p>
<pre class="prettyprint linenums language-scala">               AbstractElement<br>                 «abstract»
UniformElement                   ArrayElement<br>          <br>                                &nbsp;LineElement</pre>
<p>Малюнок 10.3 Ієрархія класів елементів розташування.</p>
<p>Як результат, Scala буде сприймати всі з наступних присвоєнь, оскільки тип просвоєтого виразу відповідає типи визначеної змінної:</p>
<pre class="prettyprint linenums language-scala">val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)</pre>Якщо ви подивитесь на ієрархію наслідування, ви винайдете, що для кожного з ціх чотирьох визначень val, тип виразу зправа від знака рівності є нижчим від типу val, що ініціалізується зліва від знаку рівності. Інша частина історії, однак, полягає в тому, що виклик методів на змінних та виразах зв'язуються динамічно. Це означає, що дійсна реалізація метода, що буде викликаний, визначається під час виконання, на основі класу об'єкта, не на типі змінної або вираза. Щоб продемструвати цю поведінку, ми тимчасово видалимо всі існуючі члени з нашого Element, та додамо метод, названий demo до Element. Ми перевизначимо demo в ArrayElement та LineElement, але не в UniformElement :
<pre class="prettyprint linenums language-scala">abstract class Element {
  def demo() {
    println("Викликана реалізація Element")
  }
}<br><br>class ArrayElement extends Element {
  override def demo() {
    println("Викликана реалізація ArrayElement")
  }
}
<br>class LineElement extends ArrayElement {
  override def demo() {
    println("Викликана реалізація LineElement")
  }
}
<br>// UniformElement наслідує Element demo
class UniformElement extends Element</pre>
        <p>Якщо ви введете цей код в інтерпретатор, ви потім можете визначити цей метод, що приймає Element, та викликає на ньому demo:</p>
<pre class="prettyprint linenums language-scala">def invokeDemo(e: Element) {
  e.demo()
}</pre>
        <p>Якщо ви передасте ArrayElement до invokeDemo, ви побачите повідомлення, що вказує, що викликана реалізація ArrayElement demo, навіть якщо тип змінної, e, на якій був викликаний demo, був Element:</p>
<pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new ArrayElement)
ArrayElement's implementation invoked </pre>
        <p>Подібно, якщо ви передасте LineElement до invokeDemo, ви побачите повідомлення, що вказує, що був викликаний LineElement demo:</p>
<pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new LineElement)
LineElement's implementation invoked</pre>
        <p>Поведінка при передачі UniformElement може на перший погляд виглядати підозрілою, але вона коректна:</p>
<pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new UniformElement)</pre>
        <p>Реалізація Element визвана, тому що UniformElement не перевизначає demo, він наслідує реалізацію demo від суперкласа, Element. Таким чином, реалізація Element є коректною реалізацією demo, що треба викликати, коли клас об'єкта є UniformElement.</p><h3>10.10 Декларація фінальних членів</h3><p>Іноді, при розробці ієрерхії наслідування, ви бажаєте переконатись, що член не може бути перевизначеним в субкласі. В Scala, як і в Java, ви можете зробити це, додавши модифікатор final до члена. Наприклад, ви можете поставити модифікатор final на метод ArrayElement demo, як показано в Лістингу 10.7.</p><p>Маючи цю версію ArrayElement, спроба перевизначити demo в субкласі LineElement, не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">class ArrayElement extends Element {
  final override def demo() {
    println("ArrayElement's implementation invoked")
  }
}</pre>
        <p>Лістинг 10.7 Декларування фінального метода.</p>
<pre class="prettyprint linenums language-scala">elem.scala:18: error: error overriding method demo
    in class ArrayElement of type ()Unit;
method demo cannot override final member
override def demo() {
             ˆ</pre><p>Ви також часом забажаєте переконатись, що весь клас не буде наслідуватись. Щоб зробити це, ви просто декларуєте цілий клас як&nbsp; final, додаючи модифікатор final до декларації класа. Наприклад, Лістинг 10.8 показує, як ви декларуєте ArrayElement як final:</p>
<pre class="prettyprint linenums language-scala">final class ArrayElement extends Element {
  override def demo() {
    println("ArrayElement's implementation invoked")
  }
}</pre>
        <p>Лістинг 10.8 Декларування фінального класа.</p><p>З цією версією ArrayElement люба спроба визначити субклас не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">elem.scala: 18: error: illegal inheritance from final class
    ArrayElement
class LineElement extends ArrayElement {
                          ˆ</pre>
        <p>Тепер ми видаляємо модифікатор final та метод demo, та повертаємось до ранішньої реалізації сімейства Element. Ми сфокусуємо нашу увагу у залишку цієї глави на довершені робочої вермсії цієї бібліотеки розташування.</p><h3>10.11 Використання композиції та наслідування</h3><p>Композиція та наслідування є двома смособами визначити новий клас в термінах іншого існуючого класа. Якщо ви найбільш бажаєте досягти повторного використання кода, ви, загалом, повинні схилятись до композиції, а не наслідування. Наслідування єдине потерпає від проблеми крихкого базового класа, коли ви можете випадково поламати субкласи, через зміну суперкласу.</p><p>Одне запитання, що ви можете задати собі щодо відношення наслідування, це: коли воно моделює відношення є-одним-з. Наприклад, має сенс сказати, що ArrayElement є-одним-з Element. Інше питання, що ви можете задати: чи клієнти бажатимуть використовувати тип субкласа як тип суперкласа. В випадку ArrayElement, ми, очевидно, очікіємо, що клієнти будуть бажати використовувати ArrayElement як Element.</p><p>Якщо ви питаєте ці запитання щодо відношень наслідування, показаних на Малюнку 10.3, чи не виглядають деякі з відношень підозрілими? Зокрема, чи не виглядає для вас очевидним, що LineElement є-одним-з ArrayElement? Чи ви вважаєте, клієнти будуть колись потребувати використання LineElement як ArrayElement? Фактично, ми визначили LineElement як субклас ArrayElement, тільки щоб повторно задіяти визначення ArrayElement contents. Можливо, буде краще, визначити LineElement як прямий субклас Element, ось так:</p>
<pre class="prettyprint linenums language-scala">class LineElement(s: String) extends Element {
  val contents = Array(s)
  override def width = s.length
  override def height = 1
}</pre>
        <p>В попередній версії LineElement мав відношення наслідування з ArrayElement, від якого він наслідував contents. Тепер він має відношення композиції з Array: він містить посилання на масив рядків зі свого власного поля contents. Маючи цю реалізацію LineElement, ієрархія наслідування для Element тепер виглядає як показане на Малюнку 10.4.</p><p>Клас ArrayElement також має відношення композиції з Array, оскільки його параметричне поле contents місмтить посилання на масив рядків. Код для ArrayElement показаний в Лістингу 10.5. Його відношення композиції представлене в діаграмах класів кристалом, як показане, наприклад, на Малюнку 10.1.</p>
<pre class="prettyprint linenums language-scala">                     Element
                    «abstract»<br><br>ArrayElement        LineElement       UniformElement
</pre>
        <p>Малюнок 10.4 Ієрархія класів з перевизначеним LineElement.</p><h3>10.12 Реалізація above, beside та toString</h3><p>В якості наступного крока ми реалізуємо метод above в класі Element. Поставити один елемент над іншим означає конкатенувати два значення contents елементів. Так що перший чорновик метода above може виглядати наступним чином:</p>
<pre class="prettyprint linenums language-scala">def above(that: Element): Element =
  new ArrayElement(this.contents ++ that.contents)</pre>
        <p>Операція ++ конкатенує два масива. Масиви в Scala представлені як масиви Java, але підтримують значно більше методів. Більше того, масиви в Scala можуть бути конвертовані в примірники класа scala.Seq, що представляє послідовніть-подібні структури, та містить декілька методів для доступу та трансформації послідовностей. Деякі інші методи масивів будуть пояснені в цій главі, та повномаштабна дискусія буде надана в Главі 17.</p><p>Фактично, попередньо показаний код не є дуже ефективним, оскільки він не дозволяє вам покласти елементи з різною шириною один на одний. Однак щоб утримувати речі простими в цьому розділі, ми залишимо це як є, та будемо передавати до above елементи однакової довжили. В Розділі 10.14 ми зробимо покращення above, так що клієнти зможуть використовувати його для комбінування елементів різної ширини.</p><p>Наступний метод, що ми реалізуємо, буде beside. Щоб розташувати два елементи один поряд з іншим, ми створимо новий елемент, в кожному рядку якого будуть конкатеновані відповідні рядки двох елементів. Як і раніше, щоб утримувати речі простими, ми почнемо з припущення, що два елементи мають однакову висоту. Це призведе до наступного дизайну метода beside:</p>
<pre class="prettyprint linenums language-scala">def beside(that: Element): Element = {
  val contents = new Array[String](this.contents.length)
  for (i &lt;- 0 until this.contents.length)
    contents(i) = this.contents(i) + that.contents(i)
  new ArrayElement(contents)
}</pre>
        <p>Метод спочатку розміщує новий масив, contents, та заповнює його конкатенаціями відповідних елементів масивів this.contents та that.contents. Нарешті він продукує новий ArrayElement, що містить новий contents.</p><p>Хоча ця реалізація beside робить, вона виконана в імперативному стилі, промовистою ознакою якого є цикл, в якому ми індексуємо масиви. Альтернативно метод може бути скорочений до одного виразу:</p>
<pre class="prettyprint linenums language-scala">new ArrayElement(
  for (
    (line1, line2) &lt;- this.contents zip that.contents
  ) yield line1 + line2
)</pre>
        <p>Тут два масиви, this.contents та that.contents, трансформуються в масив пар (що представлені як Tuple2), з використанням оператора zip. Метод zip підхоплює відповідні елементи з двох аргументів, та формує масив пар. Наприклад, цей вираз:</p>
<pre class="prettyprint linenums language-scala">Array(1, 2, 3) zip Array("a", "b")</pre>
        <p>буде обчислюватись як:</p>
<pre class="prettyprint linenums language-scala">Array((1, "a"), (2, "b"))</pre>
        <p>Якщо один з двох масивів-операндів довший ніж інший, zip буде скидати залишкові елементи. В виразі вище третій елемент лівого операнда, 3, не формує пару з результатом, оскільки він не має відповідного елемента в правому операнді.</p><p>Зипований масив потім ітерується через вираз for. Тут синтаксист “for ((line1, line2) &lt;- . . . )” дозволяє вам назвати обоє елементи пари в одному шаблоні, тобто line1 тепер означає перший елемент пари, та line2 означає другий. Система порівняння з шаблоном Scala буде описана в Главі 15. На цей час ви можете думати про це, як про дві val, line1 та line2, на кожному кроці ітерації. Вираз for має частину yield, і, таким чином, надає результат. Результат є того ж типу, що і вираз по якому ітерується, тобто, це масив. Кожний елемент масива є результатом конкатенації відповідних рядків, line1 та line2. Так що кінцевий результат цього кода буде той самий, що і першої версії beside, але оскільки він уникає прямої індексації масивів, результат буде отриманий в менш помилко-схильний спосіб.</p><p>Вам все ще треба спосіб для відображення елементів. Як звичано, це робиться через визначення метода toString, що повертає елемент, форматований як рядок. Ось його визначення:</p>
<pre class="prettyprint linenums language-scala">override def toString = contents mkString "\n"</pre>
        <p>Реалізація toString використовує mkString, що визначений для всіх послідовностей, включаючи масиви. Як ви бачили в Розділі 7.8, вираз вигляда “arr mkString sep” повертає рядок, що складається з усіх елементів масива arr. Кожний елемент відображується на рядок, з викликом його метода toString. Рядок роздільника sep вставляється між сусідніми елементами-рядками. Так що вираз “contents mkString "\n"” форматує масив contents як рядок, де кожний елемент масива опиняється в окремому рядку. </p><p>Зауважте, що toString не має пустого списку параметрів. Це слідує рекомендаціям для одноманітного принципу доступу, оскільки toString є чистим методом, що не приймає жодних параметрів. З додаванням ціх трьох методів клас Element тепер виглядає як показано в Лістингу 10.9.</p><h3>10.13 Визначення об'єкта-фабрики</h3><p>Ви маєте ієрархію класів для елементів розташування. Ця ієрархія може бути представлена вашим клієнтам “як є”. Але ви також можете обрати приховати ієрархію за об'єктом-фабрикою. Об'єкт-фабрика містить методи, що конструюють інші об'єкти. Потім клієнти можуть використовувати ці методи-фабрики для створення об'єктів, скоріше, ніж конструювати об'єкти напряму, за допомогою new. Перевага цього підходу в тому, що створення об'єкта може бути централізоване, та деталі, як об'єкти представлені класами, можуть бути приховані. Це приховання буде одночасно робити вашу бібліотеку простішою для розуміння клієнтами, оскільки менше деталей буде висвітлено, та дає вам більше можливостей пізніше змінити реалізацію вашої бібліотеки, без ламання клієнтського кода.
</p>
<pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  def width: Int =
    if (height == 0) 0 else contents(0).length
  def height: Int = contents.length
  def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)
  def beside(that: Element): Element =
    new ArrayElement(
      for (
        (line1, line2) &lt;- this.contents zip that.contents
        ) yield line1 + line2
    )
  override def toString = contents mkString "\n"
}</pre>
        <p>Лістинг 10.9 Клієнт Element з above, beside та toString.</p>Перше завдання в конструюванні фабрики елементів є обрати розташування, де будуть розташовані методи-фабрики. Чи повінні вони бути членами об'єкта-синглтона, або класа? Що повинно викликатись в об'єті або класі? Є багато можливостей. Прямолінійне рішення є створити об'єкт-компанйон до класу Element, та зробити його об'єктом-фабрикою для елементів розташування. Таким чином, вам треба показати клієнтам тільки комбінацію класа/об'єкта, та ви можете приховати три класа реалізації ArrayElement, LineElement, та UniformElement.<p>Лістинг 10.10 є дизайном об'єкта Element, що слідує цій схемі. Об'єкт-компанйон Element містить три перевантажені варіанта метода elem. Кожний варіант конструює різний тип об'єкта розташування. З пришестям ціх методів-фабрик, має сенс змінити реалізацію класа Element, так щоб вона проходила через метод-фабрику elem, скоріше ніж напряму створення нових примірників ArrayElement. Щоб визвати методи-фабрики без кваліфікації їх за допомогою імені об'єкта-синглтона Element, ми будемо імпортувати Element.elem на поверхні в файлі з кодом. Іншими словами, замість виклика метода-фабрики за допомогою Element.elem в класі Element, ми імпортуємо Element.elem, так що ми зможемо тільки викликати методи-фабрики за їх простим ім'ям, elem. Лістинг 10.11 показує, як клас Element буде виглядати після ціх змін.
</p>
<pre class="prettyprint linenums language-scala">object Element {
  def elem(contents: Array[String]): Element =
    new ArrayElement(contents)
  def elem(chr: Char, width: Int, height: Int): Element =
    new UniformElement(chr, width, height)
  def elem(line: String): Element =
    new LineElement(line)
}</pre><p>Лістинг 10.10 Об'єкт-фабрика з методами-фабриками.</p>На додаток, маючи методи-фабрики, субкласи ArrayElement, LineElement та UniformElement тепер можуть бути приватні, оскільки вони більше не повинні бути доступні напряму з клієнтів. В Scala ви можете визначити класи та об'єкти-синглтони в інших класах та об'єктах-синглтонах. Таким чином, один шлях зробити субкласи Element приватними є розташувати їх в об'єкті-синглтоні Element, та декларувати їх тут як приватні. Класи все ще можуть бути доступні для трьох методів-фабрик elem, де вони будуть потрібні. Лістинг 10.12 показує, як це буде виглядати.<h3>10.14 Підвищуємо та розширюємо</h3><p>Нам треба одне останнє покращення. Версія Element, показана в Лістингу 10.11, не є повністю достатньою, оскільки вона не дозволяє клієнтам покладати елементи з різною шириною один зверху іншого, або ставити елементи різної висоти поруч одне одного. Наприклад, обчислення наступного виразу не буде робити коректно, оскільки другий рядок в комбінованому елементі довший ніж перший:</p>
<pre class="prettyprint linenums language-scala">new ArrayElement(Array("hello")) above
new ArrayElement(Array("world!"))

import Element.elem
abstract class Element {
  def contents: Array[String]
  def width: Int =
    if (height == 0) 0 else contents(0).length
  def height: Int = contents.length
  def above(that: Element): Element =
    elem(this.contents ++ that.contents)
  def beside(that: Element): Element =
    elem(
      for (
        (line1, line2) &lt;- this.contents zip that.contents
      ) yield line1 + line2
    )
  override def toString = contents mkString "\n"
}</pre>
        <p>Лістинг 10.11 Рефакторений клас Element для використання методів-фабрик.</p><p>Подібно до цього, обчислення наступного виразу не буде робити як треба, оскільки перший ArrayElement має висоту два, та другий висоту тільки один:</p>
<pre class="prettyprint linenums language-scala">new ArrayElement(Array("one", "two")) beside
new ArrayElement(Array("one"))</pre>
        <p>Лістинг 10.13 показує допоміжний приватний метод, widen, що приймає ширину, та повертає Element такої ширини. Результат містить contents цього Element, відцентрований, доповнений зліва та зправа проміжками, потрібними для отримання потрібної ширини. Лістинг 10.13 також показує подібний метод, heighten, що виконує ту ж функцію в вертикальному напрямку. Метод widen викликається з above, щоб переконатись, що Element, розміщені один під одним, мають однакову ширину. Подібним чином, метод heighten викликається з beside, щоб переконатись, що елементи, поставлені поряд один одного, мають ту саму висоту. З ціма змінами бібліотека розташування готова для використання.</p>
<pre class="prettyprint linenums language-scala">object Element {
  private class ArrayElement(
    val contents: Array[String]
  ) extends Element
  private class LineElement(s: String) extends Element {
    val contents = Array(s)
    override def width = s.length
    override def height = 1
  }
  private class UniformElement(
    ch: Char,
    override val width: Int,
    override val height: Int
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
  }
  def elem(contents: Array[String]): Element =
    new ArrayElement(contents)
  def elem(chr: Char, width: Int, height: Int): Element =
    new UniformElement(chr, width, height)
  def elem(line: String): Element =
    new LineElement(line)
}</pre>
        <p>Лістинг 10.12 Приховування реалізації за допомогою приватних класів.</p>
<pre class="prettyprint linenums language-scala">import Element.elem
abstract class Element {
  def contents: Array[String]
  def width: Int = contents(0).length
  def height: Int = contents.length
<br>  def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    elem(this1.contents ++ that1.contents)
  }
<br>  def beside(that: Element): Element = {
    val this1 = this heighten that.height
    val that1 = that heighten this.height
    elem(
      for ((line1, line2) &lt;- this1.contents zip that1.contents)
        yield line1 + line2)
  }
<br>  def widen(w: Int): Element =
    if (w &lt;= width) this
      else {
        val left = elem(' ', (w - width) / 2, height)
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
      }
<br>  def heighten(h: Int): Element =
    if (h &lt;= height) this
    else {
      val top = elem(' ', width, (h - height) / 2)
      var bot = elem(' ', width, h - height - top.height)
      top above this above bot
    }
<br>  override def toString = contents mkString "\n"
}</pre>
        <p>Лістинг 10.13 Element з методами widen та heighten.</p><h3>10.15 Скадаємо все разом</h3><p>Цікавим завданням, серед усіх елементів бібліотеки розташуванн, є написання програми, що малює спіраль з заданим числом ребер. Наша програма Spiral, показана в Лістингу 10.14, робить саме це:</p>
<pre class="prettyprint linenums language-scala">import Element.elem
object Spiral {
  val space = elem(" ")
  val corner = elem("+")
  def spiral(nEdges: Int, direction: Int): Element = {
    if (nEdges == 1)
      elem("+")
    else {
      val sp = spiral(nEdges - 1, (direction + 3) % 4)
      def verticalBar = elem('|', 1, sp.height)
      def horizontalBar = elem('-', sp.width, 1)
      if (direction == 0)
        (corner beside horizontalBar) above (sp beside space)
      else if (direction == 1)
        (sp above space) beside (corner above verticalBar)
      else if (direction == 2)
        (space beside sp) above (horizontalBar beside corner)
      else
        (verticalBar above corner) beside (space above sp)
    }
  }<br><br> &nbsp;def main(args: Array[String]) {
    val nSides = args(0).toInt
    println(spiral(nSides, 0))
  }
}</pre>
        <p>Лістинг 10.14 Застосування Spiral.</p><p>Оскільки Spiral є окремим об'єктом з методом main відповідної сигнатуру, це є застосування Scala. Spiral приймає один аргумент командного рядка, ціле, та малює спіраль з вказаним числом ребер. Наприклад, ви можете намалювати шести-реберну спіраль, як показано нижче зліва, та більші, як показано зправа:</p>
<pre class="prettyprint linenums language-scala">$ scala Spiral 6       $ scala Spiral 11        $ scala Spiral 17
+-----                 +----------              +----------------
|                      |                        |               
| +-+                  | +------+               | +------------+ 
| + |                  | |      |               | |            | 
|   |                  | | +--+ |               | | +--------+ |  
+---+                  | | |  | |               | | |        | |<br>                       | | ++ | |               | | | +----+ | |<br>                       | |    | |               | | | |    | | |<br>                       | +----+ |               | | | | ++ | | |<br>                       |        |               | | | |  | | | |<br>                       +--------+ &nbsp;             | | | +--+ | | |<br>                                                | | |      | | |<br>                                                | | +------+ | |<br>                                                | |          | |<br>                                                | +----------+ | <br>                                                |              |<br>                                                +--------------+ &nbsp; </pre>
        <h3>10.16 Висновок</h3><p>В ціьому розділі ви бачили більше концепцій, пов'язаних з о'бєктно-орієнтовним програмуванням в Scala. Серед іншого, ви ознайомились з абстрактними класами, наслідуванням та субтипами, ієрархіями класів, параметричними полями та перевизначенням методів. Ви мали виробити відчуття для побудови нетривіальних ієрархій класів в Scala. Ми знову робитимемо з бібліотекою розташувань в Главі 14.</p><h3>Глава 11</h3><h2>Ієрархія Scala</h2><p>Тепер, коли ви побчачили деталі наслідування класів в попередній главі, настав гарний час щоб зробити крок назад, та подивитись в цілому на ієрархію класів Scala. В Scala кожний клас наслідує від загального суперкласу на ім'я Any.</p><p>Оскільки кожний клас є субкласом Any, методи, визначані в Any, є “цніверсальними методами”: вони можуть бути виклакині на кожному об'єкті. Scala також визначає деякі цікаві класи знизу ієрархії, Null та Nothing, що, загалом, діють як загальні субкласи. Наприклад, так, як Any є суперкласом для кожного іншого класа, Nothing є субкласом для кожного іншого класа. В цій главі ми зробимо тур по їєрархії класів Scala.</p><h3>11.1 Ієрархія класів Scala</h3><p>Малюнок 11.1 показує контур ієрархії класів Scala. Зверху ієрархії стоїть клас Any, що визначає методи, що включають наступне:</p>
<pre class="prettyprint linenums language-scala">final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String</pre>
        <p>Оскільки кожний клас наслідує від Any, кожний об'єкт в програмі Scala може бути порівняний з використанням ==, !=, або equals; хешовані за допомогою ## або hashCode; та форматовані за допомогою toString . Методи еквівалентності та нерівності, == та !=, декларовані як final в класі Any, так що вони не можуть бути перевизначені в субкласах.</p><p>Метод == загалом те саме, що equals, та != є завжди обертанням equals. Так що окремі класи можуть підкроїти, що означає == або !=, перевизначивши метод equals. Ми покажемо приклад пізніше в цій главі. Кореневий клас Any має два субкласи: AnyVal та AnyRef. AnyVal є батьківським класом для кожного вбудованого значення класа в Scala. Є дев'ять таких значень класів: Byte, Short, Char, Int, Long, Float, Double, Boolean, та Unit. Перші вісім з них відповідають примітивним типум Java, та їх значення представлені під час виконання як примітивні значення Java. Примірники ціх класів всі записані як літерали в Scala. Наприклад, 42 є примірником Int, 'x' є примірником Char, та false є примірником Boolean. Ви не можете створити примірники ціх класів з використанням new . Це примушене через “трюк”, що класи значень всі визначені одночасно abstract та final. Так що якщо ви напишете таке, ви отримаєте помилку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Int
&lt;console&gt;:5: error: class Int is abstract; cannot be
     instantiated
new Int
ˆ</pre>
        <p>Інший клас значення, Unit, грубо відповідає класу Java void; він використовується як тип результата метода, що інакше не повертає цікавого результата. Unit має єдине значення примірника, що записується (), що обговорювалось в Розділі 7.2.</p><p>Як пояснено в Главі 5, класи значень підтримують звичайні арифметичні та логічні операції як методи. Наприклад, Int має методи на ім'я&nbsp; + та *, та Boolean має методи з іменами || та &amp;&amp; . Класи значень також наслідують всі методи від класа Any. Ви можете перевірити це в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 42.toString
res1: java.lang.String = 42
<br>scala&gt; 42.hashCode
res2: Int = 42
<br>scala&gt; 42 equals 42
res3: Boolean = true</pre>
        <p>Зауважте, що простір класів значень плаский; всі класи значення є субтипами до&nbsp; scala.AnyVal, але вони не наслідують один одного. Замість цього є неявні перетворення між різними типуми класів значення. Наприклад, за потреби, примірник класа scala.Int автоматично розширюється (через неявне перетворення) до примірника класа scala.Long.</p><p>Як зазначалось в Розділі 5.9, неявні перетворення також використовуються для довавання більшої функціональності до типів значень. Наприклад, тип Int підтримує всі операції нижче:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 42 max 43
res4: Int = 43
<br>scala&gt; 42 min 43
res5: Int = 42
<br>scala&gt; 1 until 5
res6: Range = Range(1, 2, 3, 4)
<br>scala&gt; 1 to 5
res7: Range.Inclusive = Range(1, 2, 3, 4, 5)
<br>scala&gt; 3.abs
res8: Int = 3
<br>scala&gt; (-3).abs
res9: Int = 3</pre>
        <p>Ось як це робить: методи min, max, until, to, та abs всі визначені в класі&nbsp; scala.runtime.RichInt, та є неявне перетворення від класу Int до RichInt. Перетворення застосоується кожного разу, коли метод викликається на Int, що не визначений в Int, але визначений в RichInt.</p><p>Подібно існують “класи-прискорювачі” та неявні перетворювачі для інших класів значень. Неявні перетворення будуть обговорені в Главі&nbsp; 21. Інший субклас до кореневого класа Any є клас AnyRef . Це базовий клас до всіх класів посилань в Scala. Як вже обговорювалось, на Java платформі AnyRef є, фактично, тільки псевдонимом для класа java.lang.Object. Так що класи, написані в Java, так само, що написані в Scala, всі насліудють від AnyRef. Таким чином, одним способом думати про java.lang.Object, є як про спосіб, яким AnyRef реалізований на платформі Java. Таким чином, хоча ви можете використовувати Object та AnyRef взаємозамінно в Scala програмах на платформі Java, рекомендований стиль завжди використовувати AnyRef. Класи Scala відрізняються від класів Java в тому, що вони також наслідують від спеціального маркерного трейта на ім'я&nbsp; ScalaObject .</p><h3>11.2 Як реалізовані примітиви</h3><p>Як все це реалізовано? Фактично, Scala зберігає цілі в той же спосіб, що і Java: як 32-біт слова. Це важливо для ефективності на JVM, а також для взаємодії з бібліотеками Java. Стандартні операції, як додавання або множення, реалізовані як примітивні операції. Однак, Scala використовує “класи підтримки”,&nbsp; java.lang.Integer, коли ціле потребує видимості як об'єкт (Java). Це, наприклад, трапляється, коли викликається метод toString на цілому числі, або коли призначається ціле до змінної типу Any. Цілі типу Int прозоро конвертуються до “запакованих цілих” типу java.lang.Integer, кожного разу, коли це потрібно. </p><p>Все це виглядає як авто-боксинг в Java 5, та це, в жодному разі, подібне. Однак, існує одна важлива відмінність, в тому, що боксинг в Scala є значно менш помітний, ніж в Java. Спробуйте наступне в Java: </p>
<pre class="prettyprint linenums language-scala">// Це Java
boolean isEqual(int x, int y) {
    return x == y;
}
System.out.println(isEqual(421, 421));</pre>
        <p>Ви напевне отримаєте true. Тепер змініть типи аргументів isEqual на java.lang.Integer (або Object, результат буде той самий). Причина того, що існує псевдонм AnyRef, замість простого використання імені java.lang.Object, оскільки Scala була розроблена для роботи на обох платформах, Java та .NET. На .NET AnyRef є псевдонимом до System.Object.</p>
<pre class="prettyprint linenums language-scala">// Це Java
boolean isEqual(Integer x, Integer y) {
    return x == y;
}
System.out.println(isEqual(421, 421));</pre>
        <p>Ви винайдете, що ви отримаєте false! Що відбувається, це те, що число 421 боксується двічи, так що аргумент для x та y є два різні об'єкти. Оскільки == означає рівність типів посилань, результат є false. Це один аспект, що показує, що Java не є чистим о'бєктно-орієнтованою мовою. Є різниця між примітивними типуми, та типуми посилань, що може бути просто досліджена.</p><p>Тепер спробуємо той же експеримент в Scala:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def isEqual(x: Int, y: Int) = x == y
isEqual: (Int,Int)Boolean
<br>scala&gt; isEqual(421, 421)
res10: Boolean = true
<br>scala&gt; def isEqual(x: Any, y: Any) = x == y
isEqual: (Any,Any)Boolean
<br>scala&gt; isEqual(421, 421)
res11: Boolean = true</pre>
        <p>Фактично, операція == в Scala розроблена бути прозорою з точки зору до презентації типу. Для типів значення це природна (числова або логічна) рівність. Для типів посилань, інших, ніж боксовані числові типи Java, == розглядається як псевдоним до метода equals, унаслідованого від Object. Цей метод оригінально розроблений як рівність посилань, але перевизначений багатьма субкласами, щоб реалізовати їх власну ідею щодо еквівалентності. Це також означає, що в Scala ви ніколи не піймаєтесь в гарно-відому пастку Java відповідно порівняння рядків. В Scala порівняння рядків робить так, як має:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = "abcd".substring(2)
x: java.lang.String = cd
<br>scala&gt; val y = "abcd".substring(2)
y: java.lang.String = cd
<br>scala&gt; x == y
res12: Boolean = true</pre>
        <p>В Java результат порівняння x з y буде false. Програміст повинен використовувати в цьому випадку equals, але це просто забути. Однак є ситуації, коли вам треба еквівалентність посилань, замість визначеної користувачем. Наприклад, в деяких ситуаціях, коли ефективність вирішує, ви бажаєте хешувати з деякими класами, та порівнювати іх примірники за допомгою еквівалентності посилань. Для ціх класів клас&nbsp; AnyRef визначає додатковий метод eq, що не може бути перевизначаний, та реалізований як еквівалентність посилань&nbsp; (тобто, він поводиться як == в Java для типів посилань).</p><p>Є також протилежність eq, що називається ne. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new String("abc")
x: java.lang.String = abc
<br>scala&gt; val y = new String("abc")
y: java.lang.String = abc
<br>scala&gt; x == y
res13: Boolean = true
<br>scala&gt; x eq y
res14: Boolean = false
<br>scala&gt; x ne y
res15: Boolean = true</pre>
        <p>Еквівалентність в Scala далі обговорюється в Главі 30.</p><h3>11.3 Нижні типи</h3><p>Знизу ієрархії на Малюнку 11.1 ви бачите два класи, scala.Null та scala.Nothing. Це впеціальні типи, що обслуговують деякі “прикордонні випадки” об'єктно-орієнтовної системи типів Scala, в одноманітний спосіб. Клас Null є типом посилання null; це субклас кожного класа посилання (тобто, кожного класа, що сам походить від AnyRef). Null несумісний з типуми значень. Ви не можете, наприклад, присвоїти значення null до цілої змінної:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val i: Int = null
&lt;console&gt;:4: error: type mismatch;
found
: Null(null)
required: Int</pre>
        <p>Тип Nothing є на самому дні ієрархії класів Scala; він є субтипом кожного іншого типу. Однак не існує жодного значення цього типу. Чому має сенс мати тип без значення? Як дискутувалось в Розділі 7.4, дехто може використовувати тип Nothing як сигнал нештатного завершення. Наприклад, існує метод error в об'єкті Predef стандартної бібліотеки Scala, що визначений таким типом:</p>
<pre class="prettyprint linenums language-scala">def error(message: String): Nothing =
  throw new RuntimeException(message)</pre>
        <p>Тип результата помилки є Nothing, що каже користувачам, що метод не буде завершуватись в нормальний спосіб (замість цього він викликає виключення). Оскільки Nothing є субтипом любого іншого типу, ви можете використовувати такі методи, як error, в дуже гнучкий спосіб. Наприклад:</p>
<pre class="prettyprint linenums language-scala">def divide(x: Int, y: Int): Int =
  if (y != 0) x / y
  else error("can't divide by zero")</pre>
        <p>Гілка “then” умовного виразу, x / y, має тип Int, тоді як гілка else, виклик помилки, має тип Nothing. Оскільки Nothing є субтипом Int, тип цілого виразу є Int, як і треба.</p><h3>11.4 Висновок</h3><p>В цій главі ми показали вам класи нагорі на знизу ієрархії класів Scala. Тепер, коли ви отримали гарну основу з наслідування класів в Scala, ви готові зрозуміти композицію підмішування. В наслупній главі ви навчитесь щодо трейтів.</p><h3>Глава 12</h3><h2>Трейти</h2><p>Трейти є фундаментальною одиницею повторного використання кода в Scala. Трейт інкапсулює визначення метода та поля, що потім може повторно використовуватись через підмішування їх до класів. На відміну від наслідування класів, коли кожний калс має наслідувати від одного суперкласа, клас може міксуватись з довільним числом трейтів. Ця глава покаже вам, як роблять трейти, та покаже два найбільш поширень способи, де вони корисні: розширення тонких інтерфейсів до більш багатих, та визначення накладених модифікацій. Тут також показано, як використовувати трейт Ordered, та порівняємо трейти з множинним наслідуванням в інших мовах.</p><h3>12.1 Як роблять трейти</h3><p>Визначення трейта виглядає&nbsp; як визначення класа, з тою різницею, що використовується ключове слово trait. Приклад показаний в Лістингу 12.1:</p>
<pre class="prettyprint linenums language-scala">trait Philosophical {
  def philosophize() {
    println("I consume memory, therefore I am!")
  }
}</pre>
        <p>Лістинг 12.1 Визначення трейта Philosophical.</p><p>Цей трейт названий Philosophical. Він не декларує суперклас, так що як клас, він має суперклас по замовчанню, AnyRef. Він визначає один метод, philosophize, що є конкретним. Це простий трейт, достатній тільки щоб показати роботу трейтів.</p><p>Коли трейт визначений, він може бути зміксований (підмішаний) до класа, використовуючи ключові слова extends, або with. Програмісти Scala “міксують” трейти, скорішен, ніж наслідують від них, оскікільки підмішування трейта має суттєві відмінності від множинного наслідування, що можна знайти в багатьох інших мовах. Ця проблема розглядається в Розділі 12.6. Наприклад, Лістинг 12.2 показує клас, що міксує трейт Philosophical за допомогою extends :</p>
<pre class="prettyprint linenums language-scala">class Frog extends Philosophical {
  override def toString = "green"
}</pre>
        <p>Лістинг 12.2 Підмішування трейта за допомогою extends .</p><p>Ви можете використовувати ключове слово, щоб підмішати трейт; і цьому випадку ви неявно наслідуєте суперклас трейта. Наприклад, в&nbsp; Лістингу 12.2, клас Frog є субкласом AnyRef (суперклас Philosophical ), та підмішує Philosophical. Методи, унаслідовані від трейта, можуть бути використані таким же чином, що і методи, унаслідовані від суперкласа. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val frog = new Frog
frog: Frog = green
<br>scala&gt; frog.philosophize()
I consume memory, therefore I am!</pre>
        <p>Трейт також визначає клас. Ось приклад, в якому Philosophical використовується як тип:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val phil: Philosophical = frog
phil: Philosophical = green
<br>scala&gt; phil.philosophize()
I consume memory, therefore I am!</pre>
        <p>Тип phil є Philosophical, трейт. Таким чином, змінна phil може ініціалюватись любим об'єктом, чий клас міксує Philosophical. Якщо ви бажаєте підмішати трейт до класа, що явно розширює суперклас, ви використовуєте extends, що вказує суперклас, та with, що підмішати трейт. Лістинг 12.3 показує приклад. Якщо ви бажаєте зміксувати декілька трейтів, ви додаєте більше&nbsp; тверджень with. Наприклад, маючи трейт HasLegs, ви можете зміксувати обоє, Philosophical та HasLegs у Frog, як показує Лістинг 12.4.</p>
<pre class="prettyprint linenums language-scala">class Animal
  class Frog extends Animal with Philosophical {
    override def toString = "green"
  }</pre>
        <p>Лістинг 12.3 Міксування трейта за допомогою with .</p>
<pre class="prettyprint linenums language-scala">class Animal
trait HasLegs
  class Frog extends Animal with Philosophical with HasLegs {
    override def toString = "green"<br>  }</pre>
        <p>Лістинг 12.4 Міксування декількох трейтів.</p><p>В прикладах, що ви бачили дотепер, клас Frog наслідував реалізацію philosophize від трейта Philosophical. Альтернативно, Frog може перевизначити philosophize. Синтаксис виглядає такий самий, як перевизначення метода, задекларованого в суперкласі. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">class Animal 
  class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() {
      println("It ain't easy being "+ toString +"!")
    }
  }</pre>
<p>Оскільки це нове визначення Frog все ще підмішує трейт Philosophical, ви можете використовувати його як змінну такого типу. Але оськільки Frog перевизначає реалізацію Philosophical метода philosophize, ви отримаєте нову поведінку, коли ви викличете його:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val phrog: Philosophical = new Frog
phrog: Philosophical = green
<br>scala&gt; phrog.philosophize()
It ain't easy being green!</pre>
        <p>В цьому місці ви можете філосовськи розмірковувати, що трейти - це як інтерфейси Java з конкретними методами, але вони, насправді, можуть значно більше. Трейти можуть, наприклад, декларувати поля та обслуговувати стан. Фактично, ви можете робити будь-що в визначенні трейта, з того, що ви можете робити в визначенні класа, та синтаксис виглядає точно тим самим, тільки з двома виключеннями. Перше, трейт не може мати жодних параметрів “класа”, тобто, параметрів, переданих до первинного конструктора класа. Іншими словами, хоча ви можете визначити клас таким чином: </p>
<pre class="prettyprint linenums language-scala">class Point(x: Int, y: Int)</pre>
        <p>наступна спроба визначити трейт не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">trait NoPoint(x: Int, y: Int) // Does not compile</pre>
        <p>Ви винайдете в Розділі 20.5, як обходити це обмеження. </p><p>Інша відмінність між класами та трейтами в тому, що в класах виклики super пов'язані статично, тоді як в трейтах вони пов'язані динамічно. Якщо ви пишете “super.toString” в класі, ви точно знаєте, який метод реалізації буде викликаний. Однак, коли ви пишете теж саме в трейті, реалізація метода, що буде викликаний для виклику super не визначений на момент визначення трейта. Скоріше, реалізація, що буде викликана, буде визначена кожного раза, коли трейт міксується до конкретного класа. Ця цікава поведінка super є ключем, що дозволяє трейтам робити як накладані модифікації, що буде обговорено в Розділі 12.5. Правила для розрішення викликів super будуть надані в Розділі 12.6.</p><h3>12.2 Протистояння тонких та багатих інтерфейсів</h3><p>Одне головне використання трейтів є автоматичне додавання методів до класа, в термінах методів класа, що він вже має. Тобто, трейти можуть збагатити тонкий інтерфейс, перетворивши його на багатий інтерфейс.</p><p>Протистояння тонких та багатих інтерфейсів представляє загальний коспроміс в об'єктно-орієнтованій розробці. Компроміс між тими, хто реалізує інтерфейс, та клієнтами. Багатий інтерфейс має багато методів, що робить його більш зручним до викликача. Клієнти можуть обрати метод, що точно співпадає з потрібною функціональністю. З іншого боку, тонкий інтерфейс має меньше методів, і, таким чином, простіший для реалізаторів. Натомість, клієнти, що викликають тонкий інтерфейс, мають писати більше кода. Маючи меньший вибір методів для виклика, вони можуть обрати меньш ніж ідеально підходяще для своїх потреб, та писати більше кода для його використання.</p><p>Інтерфейси Java більш часто тонкі, ніж багаті. Наприклад, CharSequence, що був введений в Java 1.4, є тонким інтерфейсом, загальним для всіх рядко-подібних класів, що містять послідовність символів. </p><p>Ось його визначення, якщо дивитись на нього як на трейт Scala:</p>
<pre class="prettyprint linenums language-scala">trait CharSequence {
  def charAt(index: Int): Char
  def length: Int
  def subSequence(start: Int, end: Int): CharSequence
  def toString(): String<br>}</pre>
        <p>Хоча більшість з дюжин методів в класі String можуть застосовуватись до кожного CharSequence, інтерфейс Java CharSequence декларує тільки чотири методи. Якби замість цього CharSequence включав повний інтерфейс String, це б наклало великий безлад на реалізаторів CharSequence. Кожний програміст, що реалізував CharSequence в Java, мав би реалізувати дюжини методів. Оскільки трейти Scala можуть містити конкретні методи, вони роблять багаті інтерфейси значно більш зручними. Додавання конкретного метода до трейта схиляє компроміс тонкий-багатий  значною мірою на бік багатих інтерфейсів. На відміну від Java, додавання конкретного метода до трейта Scala є одноразовим зусиллям. Вам треба реалізувати тільки метод один раз, в самому трейті, замість того, щоб реалізувати його для кожного класа, що міксує цей трейт. Таким чином, багаті інтерфейси вимагають меньшої роботи в Scala, ніж в мовах без трейтів.</p><p>Щоб збагатити інтерфейс з використанням трейтів, просто визначте трейт з малим числом абстрактних методів — тонка частина інтерфейса трейта — та потенційно великим числом конкретних методів, що всі реалізовані в термінах абстрактних методів. Тоді ви можете міксувати збагачений трейт до класа, реалізовати тонку частину інтерфейса, та отримати клас, що має доступним весь багатий інтерфейс.</p><h3>12.3 Приклад: прямокутні об'єкти</h3><p>Графічні бібліотеки часто мають багато різних класів, що представляють дещо прямокутне. Деякими прикладами є вікна, бітові зображення та регіони, обрані за допомогои миши. Щоб зробити ці прямокутні об'єкти зручними в використанні, було б гарно, якщо бібліотека провадила геометричні запити, такі як width, height, left, right, topLeft, і так далі. Однак, існує багато таких методів, які б хотілось мати, що може бути великим безладом до створювачів бібліотеки, щоб провадити всі ці методи для всіх прямокутних об'єктівв бібліотеці Java. Напроти, якщо така бібліотека буде написана в Scala, створювач бібліотеки може використовувати трейти, щоб просто надати всі ці зручні методи до всіх класів, до яких побажає.</p><p>Для того, щоб побачити, як це робить, для початку уявіть, на що буде схожий код без трейтів. Там будуть деякі геометричні класи, як Point та Rectangle :</p>
<pre class="prettyprint linenums language-scala">class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point) {
def left = topLeft.x
def right = bottomRight.x
def width = right - left
// та ще багато геометричних методів...
}</pre>
        <p>Цей клас Rectangle приймає дві точки в своєму первинному конструкторі: координати вернього-лівого, та правого-нижнього кутів. Потім він реалізує багато зручних методів, таких, як left, right та width, виконуючи прості обчислення над ціма двома точками.</p><p>Інший клас графічної бібліотеки може мати двовимірний 2-D графічний віджет:</p>
<pre class="prettyprint linenums language-scala">abstract class Component {
  def topLeft: Point
  def bottomRight: Point
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
// та ще багато геометричних методів...
}</pre>
        <p>Зауважте, що визначення left, right та width такі з самі в обох класах. Вони також будуть однаковими, можливо з малими змінами, в кожному іншому класі для прямокутних об'єктів.</p><p>Цього повторення можна уникнути за допомогою збагачуючого трейта. Трейт буде мати два абстрактні методи: один, що повертатиме верхню-ліву координату об'єкта, та другий, що повертає нижню-праву координату. Потім він може надати конкретні реалізації для всіх інших геометричних запитів. Лістинг 12.5 показує, на що це може виглядати:</p>
<pre class="prettyprint linenums language-scala">trait Rectangular {
  def topLeft: Point
  def bottomRight: Point
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
// та ще багато геометричних...
}</pre>
        <p>Лістинг 12.5 · Визначення збагачуючого трейта.</p><p>Клас Component може приміксувати цей трейс, щоб отримати всі геометричні методи, що провадить Rectangular:</p>
<pre class="prettyprint linenums language-scala">abstract class Component extends Rectangular {
// інші методи...
}</pre>
        <p>Подібно, Rectangle сам може примішати трейт:</p>
<pre class="prettyprint linenums language-scala">class Rectangle(val topLeft: Point, val bottomRight: Point)
  extends Rectangular {
// інші методи...
}</pre>
        <p>Маючи ці визначення, ви можете створити Rectangle, та викликати на ньому геометричні методи, такі як width та left:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val rect = new Rectangle(new Point(1, 1),
new Point(10, 10))
rect: Rectangle = Rectangle@3536fd
<br>scala&gt; rect.left
res2: Int = 1
<br>scala&gt; rect.right
res3: Int = 10
scala&gt; rect.width
res4: Int = 9</pre>
        <h3>12.4 Трейт Ordered</h3><p>Порівняння є іншою галуззю, де зручні багаті інтерфейси. Кожного разу, коли ви порівнюєта два об'єкта, що впорядковані. є зручним, коли ви використовуєте єдиний виклик метода, для запита щодо точного бажаного порівняння. Якщо вам треба “меньше ніж”, ви викличите &lt;, та якщо “меньше або дорівнює”, ви викличите &lt;= . З тонким інтерфейсом порівняння, ви можете мати тільки метод &lt; method, та іноді вам доведеться писати дещо подібне до “(x &lt; y) || (x == y)”. Багатий інтерфес надасть вам всі звичайні оператори порівнянь, таким чином ви зразу зможете писати речі як “x &lt;= y”.</p><p>Перед тим, як подивитись на Ordered, уявіть, що ви можете без нього. Уявіть, ви берете клас Rational з Глави 6, та додаєте до нього оператор порівняння. Ви можете дійти до чогось, подібного наступному:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
// ...
  def &lt; (that: Rational) =
    this.numer * that.denom &gt; that.numer * this.denom
  def &gt; (that: Rational) = that &lt; this
  def &lt;= (that: Rational) = (this &lt; that) || (this == that)
  def &gt;= (that: Rational) = (this &gt; that) || (this == that)
}</pre>
        <p>Цей клас визначає чотири оператора порівняння ( &lt;, &gt;, &lt;=, and &gt;= ), та це є класичною демонстрацією ціни визначення багатого інтерфейса. Зпершу, зауважте, що три з операторів порівняння визначені в термінах першого. Наприклад, &gt; визначений як протилежність &lt;, та &lt;= визначения як буквально “меньше або дорівнює”. Додатково, зауважте, що всі три методи будуть однакові для любого іншого класа, що піддається порівнянню. Немає нічого особливого щодо раціональних чисел щодо &lt;= . В контексті порівняння &lt;= завжди використовується в сенсі “меньше або дорівнює”. Загалом, в цьому класі існує досить багато шаблонного кода, що буде однаковим в кожному іншому класі, що реалізує операції порівняння.</p><p>Ця проблема така загальна, що Scala провадить трей, що допомагає з цім. Трейт називається Ordered. Щоб використовувати його, ви заміняєте всі індифідуальні методи порівняння на один метод&nbsp;compare. Трейт Ordered потім визначає для вас &lt;, &gt;, &lt;=, та &gt;= в термінах цього метода. Таким чином, трейт Ordered дозволяє вам збагатити клас методами порівняння, реалізуючи методи порівняння через реалізацію одного метода, compare.</p><p>Ось як поно виглядає, коли ви визначаєте операції порівняння для Rational, через використання трейта Ordered:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) extends Ordered[Rational] {
// ...
  def compare(that: Rational) =
    (this.numer * that.denom) - (that.numer * this.denom)
}</pre>
        <p>Є тільки дві речі, що треба зробити. Перше, це версія Rational підмішує трейт <br>Ordered. На відміну від трейтів, що ми бачили до тепер, Ordered потребує, щоб ви вказали параметр типу, коли ви підмішуєте його. Параметри типів не будуть детально обговорюватись до Глави 19, але все, що вам треба знати, це те, що коли ви додаєте Ordered, ви, насправді, повинні домінувати Ordered[C], де C є класом, чиї елементи ви порівнюєте. В цьому випадку Rational міксується з Ordered[Rational] .</p><p>Друга річ, що вам треба зробити, це визначити метод compare для порівняння двох об'єктів. Цей метод потрібен порівнювати отримувача, this, з об'єктом, переданим як аргумент до цього метода. Він повинен повертати ціле, що дорівнює нулю, якщо об'єкти однакові, від'ємне, якщо отримувач меньший за аргумент, та додатне, якщо отримувач більший за аргмумент. В цьому випадку метод comparison від Rational використовує формулу, що приводить раціональні до загального займенника, та потім віднімає отримані чисельними. Маючи це змішування, та визначення compare, тепер клас Rational має всі чотири метода порівняння:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val half = new Rational(1, 2)
half: Rational = 1/2
scala&gt; val third = new Rational(1, 3)
third: Rational = 1/3
scala&gt; half &lt; third
res5: Boolean = false
scala&gt; half &gt; third
res6: Boolean = true</pre>
        <p>Кожного разу, коли ви реалізуєте клас, що впорядкований за деяким порядком, вам слідує підмішувати трейт Ordered. Якщо ви зробите це, ви надасте користувачам класа багатний набір методів порівняння. Майте на увазі, що трейт Ordered не визначає метод equals за вас, оскільки він не в змозі це зробити. Проблема в тому, що реалізація equals в термінах compare потребує перевірки типу переданого об'єкта, та завдяки затиранню типів, Ordered сам по собі не може виконати цю перевірку. Таким чином, вам треба визначити equals самому, навіть якщо ви наслідуєте Ordered. Ви побачити, як пройти це, в Главі 30.</p><h3>12.5 Трейти та перекриття модифікацій</h3><p>Тепер ви бачили одне головне використання трейтів: перетворення тонкого інтерфейса на багатий. Тепер ми перейдемо до другого важливого використання: надання класам стекових (накладених) модифікацій. Трейти дозволяють вам модифікувати методи класів, та вони роблять це таким чином, що дозволяє вам накладати ці модифікації одне на одного.</p><p>Як приклад, розглянемо стековану модифікацію черги цілих. Черга буде мати дві операції: put, що ставить ціле в чергу, та get, що вибирає цілі з черги. Черга дотримується принципу перший-ввійшов-перший-вийшов, так що get має повертати цілі в тому ж порядку, що вони булі поставлені в чергу.</p><p>Маючи клас, що реалізує таку чергу, ви можете визначити трейти, що виконують наступні модифікації:<br>• Подвоєння: подвоює всі цілі, що знаходяться в черзі<br>• Збільшення: збільшує на одиницю всі цілі, що знаходяться в черзі<br>• Фільтрація: відфільтровує всі від'ємні цілі з черги</p><p>Ці три трейта представляють модифікації, оскільки вони модифікують поведінку підлеглої класа черги, скоріше, ніж визначати повний новий клас черги. Вони також є скековані. Ви можете обрати любі з трьох, за власним бажанням, домішати їх до класа, та отримати новий клас, що мають всі модифікації, що ви обрали.</p><p>Абстрактний клас IntQueue показаний в Лістингу 12.6. IntQueue має метод put, що додає нові цілі до черги, та метод get, що видаляє та повертає їх. Бвзова реалізація IntQueue, що використовує ArrayBuffer, показана в Лістингу 12.7.</p>
<pre class="prettyprint linenums language-scala">abstract class IntQueue {
  def get(): Int
  def put(x: Int)
}</pre>
        <p>Лістинг 12.6 Абстрактний клас IntQueue .</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.ArrayBuffer
class BasicIntQueue extends IntQueue {
  private val buf = new ArrayBuffer[Int]
  def get() = buf.remove(0)
  def put(x: Int) { buf += x }
}</pre>
        <p>Лістинг 12.7 BasicIntQueue, реалізований за допомогою ArrayBuffer .</p><p>Клас BasicIntQueue має приватне поле, що містить масив буфера. Метод get видаляє елемент з одного кінця буфера, доки метод put додає елементи з іншого боку. Ось як ця реалізація виглядає, коли ви використовуєте її:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val queue = new BasicIntQueue
queue: BasicIntQueue = BasicIntQueue@24655f
<br>scala&gt; queue.put(10)
scala&gt; queue.put(20)
scala&gt; queue.get()
res9: Int = 10
scala&gt; queue.get()
res10: Int = 20</pre>
        <p>Доки все гарно. Тепер поглянемо на використання трейтів для модифікації поведінки. Лістинг 12.8 показує трейт, що подвоює цілі, як вони додаються до черги. Трейт Doubling має дві цікаві особливості. Перше полягає в тому, що він декларує суперклас, IntQueue. Ця декларація означає, що цей трейт може бути зміксований в клас, що також розширює IntQueue. Таким чином, ви можете зміксувати Doubling до BasicIntQueue, але не до Rational.</p>
<pre class="prettyprint linenums language-scala">trait Doubling extends IntQueue {
  abstract override def put(x: Int) { super.put(2 * x) }
}</pre>
        <p>Лістинг 12.8 Стекований трейт модифікації Doubling.</p><p>Друга цікава річ в тому, що трейт має виклик super на методі, що декларований як abstract. Такі виклики є нелегальними для нормальних класів, оскільки вони напевне схиблять під час виконання. Однак для трейтів такий виклик насправді може бути успішним. Оскільки виклики super в трейті зв'язані динамічно, виклик super в трейті Doubling будуть робити доти, доки трейт зміксований після іншого трейта або класа, що надає конкретне визначення метода.</p><p>Такий механізм часто потрібний для трейтів, що реалізують накладені модифікації. Щоб сказати компілятору, що ви робите це навмисно, ви повинні маркувати ці методи як abstract override. Ця комбінація модифікаторів дозволена тільки для членів трейтів, не класів, та це означає, що трейт мусить бути зміксований з деяким класом, що має конкретне визначення розглядаємого метода.</p><p>Навіть такий простий трейт викликає багато наслідків! Ось як виглядає використання трейта:</p>
<pre class="prettyprint linenums language-scala">scala&gt; class MyQueue extends BasicIntQueue with Doubling
defined class MyQueue
<br>scala&gt; val queue = new MyQueue
queue: MyQueue = MyQueue@91f017
<br>scala&gt; queue.put(10)
scala&gt; queue.get()
res12: Int = 20</pre>
        <p>В першому рядку цієї сесії інтерпретатора ми визначаємо клас MyQueue, що розширює BasicIntQueue, та міксується з Doubling. Потім ми кладемо 10 в чергу, але завдяки тому, що зміксований Doubling, 10 подвоюється. Коли ми отримуємо значення з черги, це буде 20.</p><p>Зауважте, що MyQueue не визначає нового кода. Він просто ідентифікує клас, та підмішує трейт. В цій ситуації ви можете надати “BasicIntQueue with<br>Doubling” напряму до new, замість визначення поіменованого класа. Це буде виглядати, як показано в Лістингу 12.9:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val queue = new BasicIntQueue with Doubling
queue: BasicIntQueue with Doubling = $anon$1@5fa12d
<br>scala&gt; queue.put(10)
scala&gt; queue.get()
res14: Int = 20</pre>
        <p>Listing 12.9 · Mixing in a trait when instantiating with new .</p><p>Щоб побачити, як накладати модифікації, нам треба визначити інші два трейти модифікації, Incrementing та Filtering. Реалізації ціх трейтів показані в Лістингу 12.10:</p>
<pre class="prettyprint linenums language-scala">trait Incrementing extends IntQueue {
  abstract override def put(x: Int) { super.put(x + 1) }
}
trait Filtering extends IntQueue {
  abstract override def put(x: Int) {
    if (x &gt;= 0) super.put(x)
  }
}</pre>
        <p>Лістинг 12.10: Стековані модифікації в трейтах Incrementing та Filtering .</p><p>Маючи ці модифікації, тепер ви можете обирати, яки ви застосуєте до окремої черги. Наприклад, ось черга, що одночасно фільтрує від'ємні числа, та додає один до всіх чисел, що зберігає:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val queue = (new BasicIntQueue
with Incrementing with Filtering)
queue: BasicIntQueue with Incrementing with Filtering...
scala&gt; queue.put(-1); queue.put(0); queue.put(1)
scala&gt; queue.get()
res15: Int = 1
scala&gt; queue.get()
res16: Int = 2</pre>
<p>Порядок міксів важливий. Точні правила надаються в наступному розділі, аге. грубо кажучи, трейти, що ближчі зправа, перші набувають чинності. Коли ви викликаєте метод класа з міксами, метод трейта, що правіший, викликається першим. Якщо метод викликає calls, він викликає метод в наступному трейті зліва, і так далі. В попередньому прикладі першим викликаєть Filtering put, так що він для початку видаляє від'ємні. Incrementing put викликається другим, так що він додає один до тих цілих, що остались.</p><p>Якщо ви зміните порядок, зпершу цілі будуть збільшені, та потім цілі, що все ще від'ємні, будуть відкинуті:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val queue = (new BasicIntQueue
with Filtering with Incrementing)
queue: BasicIntQueue with Filtering with Incrementing...
scala&gt; queue.put(-1); queue.put(0); queue.put(1)
scala&gt; queue.get()
res17: Int = 0
scala&gt; queue.get()
res18: Int = 1
scala&gt; queue.get()
res19: Int = 2</pre>
        <p>Загалом, код, написаний в цьому стилі, дає вам величезні можливості гнучкості. Ви можете визначити різні класи, міксуючи їх з ціма трьома трейтами в різному порядку та комбінації. Це величезна гнучкість для такого малого кода, так що ви повинні придивлятись до можливостей створення кода як стекованих модифікацій, що можна накладати один на одного.</p><h3>12.6 Чому не множинне наслідування?</h3><p>Трейти є шляхом наслідування від класо-подібних конструкцій, але відрізняються в важливий спосіб від множинного наслідування, присутньго в багатьох мовах. Одна відмінність особливо важлива: інтерпретація super. З множинним наслідуванням, метод, викликаний за виклика call, може бути визначений прямо тоді, коли відбувається виклик. З трейтами, метод, що буде викликаний, визначається через лінеарізацію класів та трейтів, що домішані до класа. Ця різниця, що дозволяє накладання модифікацій, описана в попередньому розділі.</p><p>Перед тим, як поглянути на лінеарізацію, затратьте момент, та розгляньте. як накладати модифікації в традиційній мові з множинним наслідуванням. Уявіть наступний код, але на цей раз інтерпретований як множинне наслідування, замість міксування трейта:</p>
<pre class="prettyprint linenums language-scala">// Множинне наслідування як експерімент
val q = new BasicIntQueue with Incrementing with Doubling
q.put(42)
// який put має бути викликаний?</pre>
        <p>Перше питання, який метод put повинен бути викликаний під час цього? Можливо, правило полягатиме в тому, що виграє останній суперклас, в якому випадку буде викликаний Doubling. Doubling буде подвоювати свій аргумент, та викликати super.put, та ось і все. Інкрементація не відбудеть! Таким же чином, якщо правило буде таке, що перемагає перший суперклас, отримана черга буде інкрементувати цілі, але не подвоювати їх. Таким чином, жодний порядок не буде працювати.</p><p>Ви можете також розважитись можливістю дозволити програмістам точно ідентифікувати, які суперкласи методів вони бажають, коли вони кажуть super. Наприклад, уявіть, наступний Scala-подібний код, в якому super з'являється, щоб бути викликаним з обох, Incrementing та Doubling :</p>
<pre class="prettyprint linenums language-scala">// Множинне наслідування в якості експеримента
trait MyQueue extends BasicIntQueue
  with Incrementing with Doubling {
    def put(x: Int) {
      Incrementing.super.put(x) // (Несправжня Scala)
      Doubling.super.put(x)
    }
}</pre>
        <p>Цей підхід дає нам нові проблеми. Балакливість цього підходу є найменьшою з його проблем. Що має відбутись, це те що метод get базового класа викликається двічі — одного раза з інкрементованим значенням, та один раз з подвоєним значенням, але жодного разу зі збільшеним та подвоєним значенням.</p><p>Просто не існує гарного рішення цієї проблеми з використанням множинного наслідування. Вам треба мати відкотитись в своїй розробці, та поділити код інакше. На відміну, рішення Scala тейтами прямолінійне. Ви міксуєте Incrementing та Doubling, та особлива трактовка Scala super в трейтах робить все, щоб це робило. Дещо прозоро відрізняє це від традиційного множинного наслідування, але що?</p><p>Як натякалось раніше, віповіддю є лінеарізація. Коли ви створюєте примірник класа за допомогою new, Scala бере клас, та всі його наслідувані класи та трейти, та кладе їх в одному, лінійному порядку. Потім, кожного разу, коли ви викликаєте super в одному з ціх класів, викликаний метод є наступним в цьому ланцюжці. Якщо всі методи, крім останнього, викликають super, нетто-результатом буде стекована поведінка.</p><p>Точний порядок лінеаризації описаний в специфікації мови. Він трохи ускладнений, але основна річ, що ви маєте знати, це те, що в любій лінеарізації, клас завжди лінеаризується, перед тим, як це відбудеться з усіма його суперкласами, та заміксованими трейтами. Таким чином, коли ви пишете метод, що викликає super, цей метод однозначно модифікує поведінку суперкласів та примішаних трейтів, для цього немає обхідного шляху.</p><h4>Зауваження</h4><p>Залишок цього розділу описує деталі лінеаризації. Ви можете вільно пропустити залишок розділу, якщо прямо зараз вас не цікавлять подробиці та деталі.</p><p>Головні властивості лінеаризації Scala ілюструються наступним прикладом: скажімо, ви маєте клас Cat, що наслідує від суперкласа Animal, та двох трейтів , Furry та FourLegged. FourLegged, в свою чергу, розширює трейт HasLegs:</p>
<pre class="prettyprint linenums language-scala">class Animal
trait Furry extends Animal
trait HasLegs extends Animal
trait FourLegged extends HasLegs
class Cat extends Animal with Furry with FourLegged</pre>
        <p>Ієрархія наслідування класа Cat та лінеаризація показані на Малюнку 12.1. Наслідування вказані з використанням тридиційної нотації UML: стілки з білими, трикутними кінцями, вказують на наслідування, де стрілка вказує на супертип. Стрілки з темними, не-трикутними кінцями, зображують лінеаризацію. Темна стрілка вказує в напрямку, в якому розрішується виклик super.</p><img
style="width: 497px; height: 213px;" alt="" src="12.1.png"><br><br>Малюнок 12.1 Ієрархія наслідування та лінеаризація класа Cat .<br>
<p>Лінеаризація Cat обчислюється з кінця на перед наступним чином. Остання частина лінеаризації Cat є лінеаризація його суперкласа, Animal. Ця лінеаризація копіюється без жодних змін. (Лінеаризація кожного з ціх типів показана в Таблиці 12.1). Оскільки Animal явно не розширює суперклас, або міксує жодного супертрейта, він по замовчанню розширює AnyRef, що розширює Any. Лінеарізація Animal, таким чином, виглядає так:</p>
<pre class="prettyprint linenums language-scala">Animal =&gt; AnyRef =&gt; Any</pre>
        <p>Дрігий ззаду в лінеаризації є перший мікс, трейт Furry, але всі класи, що вже в ліеаризації Animal доки полишені, так що кожний клас з'являється тільки один раз в лінеаризації Cat. Результат такий:</p>
        <pre class="prettyprint linenums language-scala">Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
        <p>Це передує лінеаризації FourLegged, де знову, відкидаються всі класи, що вже скопійовані в лінеаризцію суперкласа, або все від першого мікса:</p>
<pre class="prettyprint linenums language-scala">FourLegged =&gt; HasLegs =&gt; Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
        <p>Нарешті, перший клас в лінеаризації Cat є сам Cat:</p><p>Таблиця 12.1 Лінеаризація класів в ієрархії Cat</p><table
border="0"><tbody><tr><td>Animal</td><td>Animal, AnyRef, Any</td></tr><tr><td>Furry</td><td>Furry, Animal, AnyRef, Any</td></tr><tr><td>FourLegged</td><td>FourLegged, HasLegs, Animal, AnyRef, Any</td></tr><tr><td>HasLegs</td><td>HasLegs, Animal, AnyRef, Any</td></tr><tr><td>Cat</td><td>Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</td></tr></tbody></table>
<pre class="prettyprint linenums language-scala">Cat =&gt; FourLegged =&gt; HasLegs =&gt; Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
        <p>Коли кожний з ціх класів та трейтів викликає метод через super, реалізація, до буде викликана, буде першою реалізацією зправа в лінеаризації.</p><h3>12.7 То трейт, або не трейт?</h3><p>Кожного раза, коли ви реалізуєте повторо використовувану колекцію поведінок, вам прийдеться вирішувати, чи ви бажаєте використовувати трейт або абстрактний клас. Не існує жорсткого правила, але цей розділ містить декілька порад, що треба розглянути. Якщо поведінка не буде повторо використана, тоді робіть її в вигляді конкретного класа. Кінець кніцем ця поведінка не для повторного використання.</p><p>Якщо дещо може використовуватись в багатьох непов'язаних класах, робіть це як трейт. Тільки трейти можуть бути зміксовані до різних частин ієрархії класів. Якщо ви бажаєте наслідувати код в Java, використовуйте абстрактний клас. Оскільки трейти з кодом не мають близького аналога в Java, буває складно наслідувати від трейта в класі Java. Тим часом, наслідування від класа Scala точно як наслідування від класа Java. Як одне виключення, трейт Scala тільки з одними абстрактними членами транслюється прямо в інтерфейс Java, так що ви можете вільно визначати такі трейти, навіть коли очікуєте, що Java код буде наслідувати їх. Дивіться Главу 31 щодо додаткової інформації по роботі з Java та Scala одночасно.</p><p>Якщо ви плануєте розповсюджувати код в компільованій формі, та ви очікуєте, що зовнішні групи будуть писати класи, що наслідують він нього, ви маєте схилятись до використання абстрактних класів. Проблема в тому, що коли трейт отримує або втрачає члена, любі класи, що наслідують від нього, мають бути перекомпільовані, навіть якщо вони не змінились. Якщо зовнішні клієнти тільки викликають поведінку, замість наслідувати її, тоді використання трейтів є гарним.</p><p>Якщо ефективність дуже важлива, схиляйтесь до використання класа. Більшість середовищ виконання Java робить виклики віртуальних методів членів класа швидшою операцією, ніж виклик метода інтерфейса. Трейти компілюються як інтерфейси, та, таким чином, можуть накладати деякі додаткові витрати. Однак, ви маєте робити цей вибір, тільки якщо ви знаєте, що розгляданий трейт містить прогалину в продуктивності, та маєте докази, що використання класа заміть трейта наспраавді вирішує проблему.</p><p>Якщо ви все ще не знаєте, після прийняття до уваги всього сказаного, тоді починайте з того, що робіть з усього трейт. Ви завжди зможете змінити це в пізніше, та, загалом, використання трейта відкриває більше опцій.</p><h3>12.8 Висновок</h3><p>Ця глава показала вам, як роблять трейти, та як їх використовувати в декількох загальних ідіомах. Ви побачили, що трейти подібні до множинного наслідування, але оскільки вони інтерпретують super з використанням лінеарізації, вони одночасно уникають деяких складностей традиційного множинного наслідування, та дозволяють вам накладати поведінку одну на одну. Ви також побачили трейт Ordered, та навчились писати ваші власні збагачуючи трейти.</p><p>Тепер, коли ви побачили всі ці аспекти, має сенс повернутись трохи назад, та поглянути на трейти як на ціле. Трейти не просто підтримують описані в цій главі ідіоми. Вони є фундаментальними одиницями кода, що повторно використовується через наслідування. Завдяки цій природі багато з досвідчених Scala програмістів починають з трейтів, коли знаходяться ще на ранішніх стадіях розробки. Кожний трейт може містити меньше, ніж цілу концепцію, тільки фрагмент концепції. По мірі кристалізації розробки фрагменти можуть комбінуватись в більш повні концепції, через змішування трейтів.&nbsp;</p><h3>Глава 13</h3><h2>Пакунки та імпорт</h2><p>Коли ви працюєте над програмою, особливо над великою, важливо зменшити взаємодію — межі, в яких різні частини програми покладаються на інші частини. Слабка зв'язаність зменшує ризик того, що мала, на перший погляд безневинна зміна в одній частині програми буде мати руйнівні наслідки в іншій частині. Один спосіб мінізувати поєднання є писати в модульному стилі. Ви поділяєте програму на декілька меньших модулів, кожний з яких має внутрішній та зовнішній світ. Коли ви робите всередині модуля — в його реалізації — вам треба тільки координуватись тільки з іншими програмістами, що роблять над тим самим модулем. Тільки коли вам треба змінити дещо ззовні модуля — його інтерфейс — тоді треба координуватись з розробниками, що роблять над іншими модулями.</p><p>Ця глава показує деякі конструкції, що допомагають вам програмувати в модульному стилі. Вона показує, як покласти речі в пакунки, зробити імена видимі через імпорт, та контролювати видимість визначень через модифікатори доступу.</p><p>Конструкції подібні по духу до конструкцій в Java, але деякі відмінності — іноді в більш узгоджений спосіб — так що має сенс прочитати цю главу, навіть якщо ви вже знаєте Java.</p><h3>13.1 Покладання речей в пакунки</h3><p>Код Scala міститься в глобальній ієрархії пакунків Java платформи. Приклад кода, що ви вже бачили в цій книзі, знаходився в непоіменованому пакунку. Ви можете покласти код в поіменований пакунок в Scala в два способи. Перше, ви можете покласти вміст цілого файла в пакунок, розмістивши твердження package на початку файла, як показане в Лістингу 13.1.</p>
<pre class="prettyprint linenums language-scala">package bobsrockets.navigation
class Navigator</pre>
        <p>Лістинг 13.1 Покладання цілого файла в пакунок.</p><p>Твердження package в Лістингу 13.1 покладає клас Navigator до пакунка на ім'я bobsrockets.navigation. Можливо, це програма навігації, розроблена компанією Боба, Rockets, Inc.</p><h4>Зауваження</h4><p>Оскільки код Scala є частиною екосистеми Java, рекомендовано слідувати домовленості Java щодо реверного доменного іменування для пакунків Scala, що ви викладаєте на загал. Таким чином, краще ім'я для пакунка Navigator може бути com.bobsrockets.navigation. Однак в цій главі ми будемо відкидати “com.”, щоб зробити приклади простішими для розуміння.</p><p>Інший спосіб, як ви можете покласти код в пакунок в Scala, більш скидається на простори імен C#. Ви ставите за твердженням package розділ в фігурних дужках, що містить визначення, що ідуть до пакунка. Цей синтаксис називається пакуванням. Пакування, показане в Лістингу 13.2, має той же ефект, що в код в Лістингу 13.1:</p>
<pre class="prettyprint linenums language-scala">package bobsrockets.navigation {
  class Navigator
}</pre>
        <p>Лістинг 13.2 Довга форма простої декларації пакунка.</p><p>Для таких простих прикладів ви можете також використовувати синтаксичний цукор, показаний в Лістингу 13.1. Однак, одним з використань більш загальної нотації є мати різні частини файла в різних пакунках. Наприклад, аи можете включити тести класа в той же файл, що і оригінальний код, але покласти тести в інший пакунок, як показано в Лістингу 13.3.</p><pre
class="prettyprint linenums language-scala">package bobsrockets {
  package navigation {
// В пакунку bobsrockets.navigation
    class Navigator
      package tests {
// В пакунку bobsrockets.navigation.tests
        class NavigatorSuite
    }
  }
}</pre>
        
<p>Лістинг 13.3 Багато пакунків в одному файлі.</p>

<h3>13.2 Стислий доступ до пов'язаного кода</h3><p>Коли код поділений в ієрархію пакунків, це не тільки спрощує людям переглядати цей код. Це також каже компілятору, що код в одному пакунку пов'язаний деяким чином, один з одним. Scala використовує перевагу від цього пов'язання, дозволяючі скорочені, некваліфіковані імена, коли ви отримуєте доступ до кода в тому ж пакунку.
</p>Лістинг 13.4 надає три прості приклади. Перше, як ви можете очікувати, клас може бути доступний з його власного пакунка, без необхідності вказувати префікс. Ось чому компілюється new StarMap. Клас StarMap в тому ж пакунку, bobsrockets.navigation, що і вираз new, що отримує доступ до нього,
 так що немає потреби вказувати ім'я пакунка.<br><p>Друге, сам пакунок може бути доступний з пакунка, що містить його, без потреби вказувати його повний шлях. В Лістингу 13.4 подивіться, як створюється примірник класа Navigator. Вираз new з'являється в пакунку bobsrockets, що є пакунком, який містить bobsrockets.navigation.
 Таким чином, він може отримати доступ до пакунка bobsrockets.navigation, просто як navigation.<br>
<br>
Третє, при використанні синтаксиса пакування з фігурними дужками, всі імена, доступні в полі зору за межами пакування, також доступні і в ньому.
 Як приклад, в Лістингу 13.4 є спосіб для addShip() створити новий Ship. Метод визначений в двох пакунках: зовнішній bobsrockets, та внутрішній, bobsrockets.fleets.&nbsp; Оскільки Ship доступний в зовнішньому пакунку, він також може бути використаний в addShip().</p>
<pre class="prettyprint linenums language-scala">package bobsrockets {
  package navigation {
    class Navigator {
// Не треба казати bobsrockets.navigation.StarMap
      val map = new StarMap
    }
    class StarMap
  }
  class Ship {
// Не треба казати bobsrockets.navigation.Navigator
    val nav = new navigation.Navigator
  }
  package fleets {
    class Fleet {
// Не треба казати bobsrockets.Ship
      def addShip() { new Ship }
    }
  }
}</pre>
        <p>Лістинг 13.4 Стислий доступ до класів та пакунків.</p>Зауважте, що цей клас доступу можливий, тільки якщо ви явно вкладуєте пакування. Якщо ви схильні до одного пакунка на файл, тоді, як в like in Java — будуть доступні імена, що визначені в поточному пакунку. <br><pre
class="prettyprint linenums language-scala">package bobsrockets {
  class Ship
}
package bobsrockets.fleets {
  class Fleet {
// Не компілюється! Ship не в полі зору.
    def addShip() { new Ship }
  }
}</pre>
        
<p>Лістинг 13.5 Символи в оточуючих пакунках автоматично не доступні.</p>В Лістингу 13.5 пакування bobsrockets.fleets було переміщене на рівень вище. Оскільки воно більше не оточене пакуванням bobsrockets, імена з bobsrockets не є безпосередньо в полі зору. Як результат, new Ship дає помилку компіляції. Якщо вкладені пакунки з дужками некомфортабельно зсувають ваш код вправо, ви можете також використовувати декілька тверджень package без дужок. Наприклад, код нижче також визначає клас Fleet в двох вкладених пакунках, bobrockets та fleets, точно так само, як ви бачили в Лістингу 13.4:<br>
<pre class="prettyprint linenums language-scala">package bobsrockets
package fleets
class Fleet {
// Не компілюється! Ship не в полі зору.
  def addShip() { new Ship }
}</pre>
        <p>Один заключний прийом, що важливо знати. Іноді вам доводиться кодувати в жорстоко захаращеному полі зору, де вмена пакунків приховують одне одного. </p><pre
class="prettyprint linenums language-scala">// В файлі launch.scala
package launch {
  class Booster3
}
// В файлі bobsrockets.scala
package bobsrockets {
  package navigation {
    package launch {
      class Booster1
    }
    class MissionControl {
      val booster1 = new launch.Booster1
      val booster2 = new bobsrockets.launch.Booster2
      val booster3 = new _root_.launch.Booster3
    }
  }
  package launch {
    class Booster2
  }<br>}</pre>
        <p>Лістинг 13.6 Доступ до прихованих імен пакунків.</p><p>В лістингу 13.6 поле зору класа MissionControl включає три окремі пакунки, з назвами launch! Є launch в bobsrockets.navigation, ще один в bobsrockets, та ще один на верхньому рівні. Як ви повинні посилатись на кожний з Booster1, Booster2, та Booster3?</p><p>Доступ до першого найпростішій. Посилання на launch саме по собі буде давати вам bobsrockets.navigation.launch, оскільки це пакунок launch, визначений в найближчому оточующому полі зору. Таким чином, ви можете посилатись на перший клас booster class, просто як на launch.Booster1. Посилання на другий також не складне. Ви можете записати bobrockets.launch.Booster2, та буде ясним, на що ви посилаєтесь. Однак, остається питанням третій клас booster. Як ви можете отримати доступ до Booster3, приймаючи до уваги, що вкладений пакунок launch затіняє з одноіменний з верхнього рівня?</p><p>Щоб допомогти в цій ситуації, Scala провадить пакунок на ім'я _root_, що є зовнішнім до любого пакунку, що може написати користувач. Кажучи інакше, кожний пакунок вищого рівня, що ви можете написати, розглядається як член пакунка _root_ . Наприклад, обоє, launch та bobsrockets з Лістинга 13.6 є членами пакунка _root_. Як результат, _root_.launch дає нам високорівневий пакунок launch, та _root_.launch.Booster3 означає самий зовнішній клас booster.</p><h3>13.3 Імпорти</h3><p>В Scala пакунки та їх члени можуть бути імпортовані з використанням тверджень import. Імпортовані елементи потім можуть бути досяжні через просте ім'я, як File, на відміну від потреби задавати кваліфіковане ім'я, як java.io.File. Наприклад, розглянемо код, показаний в Лістингу 13.7.</p><p>Твердження import робить члени пакунка або об'єкта доступним через їх імена, без потреби ставити префікс з імені пакунка або об'єкта. Ось деякі прості приклади:</p>
<pre class="prettyprint linenums language-scala">// простий доступ до Fruit
import bobsdelights.Fruit
<br>// простий доступ до всіх членів bobsdelights
import bobsdelights._
<br>// простий доступ до всіх членів Fruits
import bobsdelights.Fruits._

package bobsdelights
<br>abstract class Fruit(
  val name: String,
  val color: String
)<br><br>object Fruits {
  object Apple extends Fruit("apple", "red")
  object Orange extends Fruit("orange", "orange")
  object Pear extends Fruit("pear", "yellowish")
  val menu = List(Apple, Orange, Pear)
}</pre><p>
Лістинг 13.7&nbsp; Улюблені фрукти Боба, готові до імпорта.</p><p>Перше з них відповідає імпорту одного типу в Java, друге - імпорту на вимогу в Java. Єдина різниця в тому, що імпорт на вимогу в Scala записаний з завершуючим підкресленням ( _ ), замість зірочки ( *) (кінець кінцем, * є придатним ідентифікатором в Scala!). Третій імпорт вище відповідає до імпорта полів статичного класа в Java.</p><p>Ці три імпорти дають вам присмак того, що можуть імпорти, але насправді імпорти в Scala значно більш загальні. Для початку, імпорти в Scala можуть з'являтись будь-де, не тільки на початку одиниці компіляції. Також вони можуть посилатись на довільні значення. Наприклад, можливий імпорт, показаний в Лістингу 13.8:</p>
<pre class="prettyprint linenums language-scala">def showFruit(fruit: Fruit) {
  import fruit._
  println(name +"s are "+ color)
}</pre>
        <p>Лістинг 13.8 Імпортування членів звичайного об'єкта (не синглтона).</p><p>Метод showFruit імпортує всі члени свого параметра fruit, що має тип Fruit. Наступне твердження println може безпосередньо посилатись на name та color. Ці два посилання еквівалентні до fruit.name та fruit.color. Цей синтаксис, зокрема, корисний, коли ви використовуєте об'єкти як модулі, що буде описане в Главі 29.</p><h4>Гнучкі імпорти Scala</h4><p>Твердження Scala import є трохи більш складними, ніж в Java. Є три принципові відмінності. Імпорти в Scala: <br>• можуть з'являтись будь-де<br>• можуть посилатись на об'єкти (синглтони або звичайні), на додаток до пакунків<br>• дозволяють вам переіменувати або приховати деякі імпортовані члени</p><p>Інший спосіб, в який імпорти Scala є гнучкими - це те, що вони можуть імпортувати самі пакунки, не тільки їх члени-не-пакунки. Це природно тільки в випадку, коли ви думаєте про вкладені пакунки, що містяться в оточуючих пакунках. Наприклад, в Лістингу 13.9, пакунок java.util.regex є імпортованим. Це робить regex корисним як просте ім'я. Щоб отримати доступ до об'єкта-синглтона Pattern з пакунку java.util.regex, ви можете просто сказати regex.Pattern, як показано в Лістингу 13.9:</p>
<pre class="prettyprint linenums language-scala">import java.util.regex
class AStarB {
// Отримує досутп до java.util.regex.Pattern
  val pat = regex.Pattern.compile("a*b")
}</pre>
        <p>Лістинг 13.9 Імпорт імені пакунку.</p><p>Імпорти в Scala можуть також переіменовувати або приховувати члени. Це робиться за допомогою селектора import, заточеного в фігурні дужки, що слідують за об'єктом, з якого імпортуються члени. Ось деякі приклади:</p>
<pre class="prettyprint linenums language-scala">import Fruits.{Apple, Orange}</pre>
        <p>Це імпотрує члени Apple та Orange з об'єкта Fruits .</p>
<pre class="prettyprint linenums language-scala">import Fruits.{Apple =&gt; McIntosh, Orange}</pre>
        <p>Це імпортує два члени, Apple та Orange з об'єкта Fruits. Однак, об'єкт Apple переіменований на McIntosh. Так що доступ до об'єкта виглядає або Fruits.Apple, або McIntosh. Твердження переіменування завжди має форму “&lt;оригінальне-ім'я&gt; =&gt; &lt;нове-ім'я&gt;”.</p>
<pre class="prettyprint linenums language-scala">import java.sql.{Date =&gt; SDate}</pre>
        <p>Це імпортує клас SQL date як SDate, так що ви можете одночасно імпортувати звичайний клас Java date як прост Date.</p>
<pre class="prettyprint linenums language-scala">import java.{sql =&gt; S}</pre>
        <p>Це імпортує пакунок java.sql як S, так що ви можете писати такі речі, як S.Date .</p>
<pre class="prettyprint linenums language-scala">import Fruits.{_}</pre>
        <p>Це імпортує всі члени об'єякта Fruits. Це означає те ж саме, що import Fruits._.</p>
<pre class="prettyprint linenums language-scala">import Fruits.{Apple =&gt; McIntosh, _}</pre>
        <p>Це імпортує всі члени об'єкта Fruits, але переіменовує Apple на <br>McIntosh .</p>
<pre class="prettyprint linenums language-scala">import Fruits.{Pear =&gt; _, _}</pre>
        <p>Це імпотрує всі члени Fruits, окрім Pear. Твердження в формі <br>“&lt;оригінальне-ім'я&gt; =&gt; _” виключає &lt;оригінальне-ім'я&gt; з імен, що імпортуються. В цьому сенсі, переіменування будь-чого на ‘_’ означає зовсім приховати його. Це корисне для уникнення невизнеченостей. Скажімо, ви маєте два пакунки, Fruits та Notebooks, що обоє визначають клас Apple. Якщо ви бажаєте отримати тільки ноутбук Apple, але не фрукт, ви можете використовувати обоє імпорти на вимогу, наступним чином:</p>
<pre class="prettyprint linenums language-scala">import Notebooks._
import Fruits.{Apple =&gt; _, _}</pre>
        <p>Це буде імпортувати всі Notebooks, та всі фрукти, окрім Apple. Ці виключення демонструють велику гнучкість, що пропонує Scala, коли доходить до вибіркового імпорту членів, та, можливо, під різними іменами.</p><p>Загалом, селектор імпорту може складатись з наступного:<br>• Простого імені x. Це включає x в набір вмпортованих імен.<br>• Твердження переіменування x =&gt; y. Це робить член на ім'я x відомим під ім'ям y .<br>• Твердження приховування x =&gt; _ . Це виключає x з набору імпортованих імен.<br>• Узагальнене ‘ _ ’. Це імпортує всі члени, крім тих, що згадані в попередньому пункті. Якщо задається цей вираз, він іде останнім в селекторі імпорта.</p><p>Простіші форми тверджень імпорта, показані на початку цього розділу, можуть розглядатись як окремі скорочення виразів імпорта з селекторами. Наприклад, “import p._” еквівалентне до “import p.{_}”, та “import p.n”<br>еквівалентне до “import p.{n}”.</p><h3>13.4 Неявний імпорт</h3><p>Scala додає деякі імпорти неявно до кожної програми. Загалом це те саме, якби нагорі кожного файла з розширенням .scala були наступні три твердження import:</p>
<pre class="prettyprint linenums language-scala">import java.lang._ // все в пакунку java.lang
import scala._ // все в пакунку scala
import Predef._ // все в об'єкті Predef</pre>
        <p>Пакунок java.lang містить стандиртні класи Java. Вони завжди неявно імпортуються на JVM реалізації Scala. Реалізація .NET замість цього має імпортувати пакунок system, що в .NET є аналогом java.lang. Оскільки java.lang імпортований неявно, ви, наприклад, можете писати Thread, замість java.lang.Thread.</p><p>Як ви, без сумніву, вже здогадались, пакунок scala містить стандартну бібліотеку Scala, з багатьма загальними класами та об'єктами. Оскільки scala імпортується неявно, ви, наприклад, можете писати List заміть scala.List.</p><p>Об'єкт Predef містить багато визначень типів, методів, та неявних перетворень, що загально використовуються в програмах Scala. Наприклад, оскільки Predef імпортований неявно, ви можете писати assert замість<br>Predef.assert.</p><p>Ці три імпорти вище розглядаються трохи особливо, в тому, що подальші імпорти затіняють попередні. Наприклад, клас StringBuilder визначений одночасно в пакунку scala, та, починаючи з версії Java 1.5, також в пакунку java.lang. Оскільки імпорт scala затінює імпорт java.lang, просте ім'я StringBuilder буде посилатись на scala.StringBuilder, але не на java.lang.StringBuilder.</p><h3>13.5 Модифікатори доступу</h3><p>Члени пакунків, класів або об'єктів можуть бути помічені модифікаторами доступу private та protected. Ці модифікатори обмежують доступ до членів для окремих регіонів кода. Погляд Scala на модифікатори доступу приблизно слідують таким в Java, але є деякі важливі відмінності, що пояснюються в цьому розділі.</p><h4>Приватні члени</h4><p>Приватні члени розглядаються подібно до Java. Член, помічений як private, видимий тільки зсередини класа або об'єкта, що містить визначення члена. В Scala це правило стосується також внутрішніх класів. Ця трактовка більш узгодженна, але відрізняється від Java. Розгляньте приклад, показаний у Лістингу 13.10:</p>
<pre class="prettyprint linenums language-scala">class Outer {
  class Inner {
    private def f() { println("f") }
    class InnerMost {
      f() // OK
    }
  }
  (new Inner).f() // помилка: f недоступне
}</pre>
        <p>Лістинг 13.10 Як доступ private відрізняється в Scala та Java.</p><p>В Scala доступ (new Inner).f() нелегальний, бо f задекларовано як private Inner, та доступ на зсередини класа Inner. Навпаки, перший доступ до f в класі InnerMost є задовільним, оскільки цей доступ міститься в тілі класа Inner. Java дозволятиме обоє доступи, оскільки вона дозволяє зовнішньому класу мати доступ до приватних членів внутрішніх класів. </p><h4>Захищені члени</h4><p>Доступ до захищених членів також трохи більш обмежений, ніж в Java. В <br>Scala захищений член доступний тільки з субкласів класу, в якому визначений цей член. В Java такий доступ також можливий з інших класів в тому ж пакунку. В Scala намає іншого шляху досягти того ж ефекту, як показано нижче, так що protected можна залишити такім, як він є. Приклад, показаний в Лістингу 13.11, ілюструє захищений доступ:</p>
<pre class="prettyprint linenums language-scala">package p {
  class Super {
    protected def f() { println("f") }
  }
  class Sub extends Super {
    f()
  }
  class Other {
    (new Super).f()
    // помилка: f недоступне
  }
}</pre>
        <p>Лістинг 13.11 Як доступ protected відрізняється в Scala та Java.</p><p>В Лістингу 13.11 доступ до f в класі Sub є можливим, бо f декларовне як <br>protected в Super, та Sub є субкласом Super. На відміну від цього, доступ до f в Other не дозволений, оскільки Other не наслідує від Super. В Java, в останньому випадку доступ буде дозволений, оскільки Other в тому ж пакунку, що і Sub.</p><h4>Публічні члени</h4><p>Кожний член, не помічений як private або protected, є публічним. Немає явного можифікатора для публічних членів. Такі члени можуть бути досяжні з відусюди.&nbsp; </p>
<pre class="prettyprint linenums language-scala">package bobsrockets
<br>package navigation {
  private[bobsrockets] class Navigator {
    protected[navigation] def useStarChart() {}
    class LegOfJourney {
      private[Navigator] val distance = 100
    }
    private[this] var speed = 200
  }
}<br><br>package launch {
  import navigation._
  object Vehicle {
    private[launch] val guide = new Navigator
  }
}</pre>
        <p>Лістинг 13.12 Гнучке поле зору protection з кваліфікаторами доступу.</p><h4>Поле зору protection</h4><p>Модифікатори доступу в Scala можуть бути прикрашені кваліфікаторами. Модифікатор має форму private[X] або protected[X], що означає, що доступ є&nbsp; private або protected “аж до” X, де X позначає деякий оточуючий пакунок, клас або об'єкт синглтона.</p><p>Модифікатори з кваліфікованим доступом дають вам гарний контроль над видимістю. Зокрема, вони дозволяють вам виразити нотації доступу Java, такі як пакунок-приватний, пакунок-захищений, або приватний до самого зовнішнього класа, що прямо не має вираження простими модифікаторами в Scala. Але вони також дозволяють вам виразити привила доступності, яких немає в Java. Лістинг 13.12 представляє приклад з використанням декількох кваліфікаторів. В цьому лістингу клас Navigator помічений як private[bobsrockets]. Це означає, що цей клас видимий в усіх класах та об'єктах, що містяться в пакунку bobsrockets. Зокрема, доступ до Navigator в об'єкті Vehicle дозволений, оскільки Vehicle міститься в пакунку launch, що міститься в bobsrockets. З іншого боку, весь код за межами пакунку bobsrockets не має доступу до Navigator .</p><p>Цей прийом є достатньо корисним в великих проектах, що обіймають декілька пакунків. Це дозволяє вам визначати речі, що видимі в декількох субпакунках вашого проекта, але що залишаються приховані від клієнтів, зовнішніх до вашого проекта. Той же прийом неможливий в Java. Там, коли визначення виходить за межі свого безпосереднього пакунка, воно видиме для широкого загалу.</p><p>Звичайно, кваліфікатор private може бути також безпосередньо оточуючим пакунком. Прикладом є модифікатор доступу до guide об'єкта Vehicle в Лістингу 13.12. Такий модифікатор доступу еквівалентний до пакунок-приватного доступу в Java.</p><p>Таблиця 13.1 Ефект кваліфікаторів private на LegOfJourney.distance</p><table
style="width: 100%" border="1"><tbody><tr><td>no access modifier</td><td>public access</td></tr><tr><td>private[bobsrockets]</td><td>access within outer package</td></tr><tr><td>private[navigation]</td><td>same as package visibility in Java</td></tr><tr><td>private[Navigator]</td><td>same as private in Java</td></tr><tr><td>private[LegOfJourney]</td><td>same as private in Scala</td></tr><tr><td>private[this]</td><td>access only from same object</td></tr></tbody></table><p>Всі кваліфікатори можуть також бути застосовані до protected, з тим же значенням, що і для private. Таким чином, модифікатор protected[X] в класі C дозволяє доступ до поміченого визначення в усіх субкласах C, а також в охоблюючому пакунку, класі, або об'єкті X. Наприклад, метод useStarChart в Лістингу 13.12 доступний в усіх субкласах Navigator, а також у всьому коді, що міститься в охоплюючому пакунку navigation. Таким чином, це прямо відповідає до значення protected в Java.</p><p>Кваліфікатори private також можуть посилатись на охоплюючий клас або об'єкт. Наприклад, змінна distance класа LegOfJourney в Лістингу 13.12 помічена як private[Navigator], так що її можна бачити будь-де в класі<br>Navigator. Це дає ті ж можливості доступу, як для приватних членів внутрішнього класа в Java. Модифікатор private[C], де C є замим зовнішнім класом, є тим самим, що просто private в Java.</p><p>Нарешті, Scala також має модифікатор доступу, що навіть більш обмежений, ніж private. Визначення, помічене як private[this], відкриває доступ тільки для того ж об'єкта, що містить це визначення. Таке визначення називається приватним-до-об'єкта. Наприклад, визначення speed в класі Navigator з Лістинга 13.12 є приватним до об'єкта. Це означає, що любий доступ має бути не тільки з класа Navigator, але має бути від того самого примірника Navigator. Таким чином, доступ до “speed” та “this.speed” буде легальним зсередини Navigator. Однак, наступний доступ, не буде можливим, навіть якщо він відбувається в класі Navigator :</p>
<pre class="prettyprint linenums language-scala">val other = new Navigator
other.speed // це не скомпілюється</pre>
        <p>Маркування члена як private[this] є гарантією, що він не буде видимий з інших об'єктів того ж самого класа. Це може бути корисним для документації. Це також іноді дозволяє вам писати більш загальні варіанти анотацій (дивіться Розділ 19.7 щодо деталей).</p><p>Щоб підсумувати, Таблиця 13.1 перелічує ефекти кваліфікатора private. Кожний рядок показує кваліфікований модифікатор private, та що це буде значить, якщо такий модифікатор буде приєднаний до змінної distance, задекларованої в класі LegOfJourney в Лістингу 13.12.</p><h4>Поле зору та об'єкти-компанйони</h4><p>В Java статичні члени та члени примірника належать до одного і того ж класа, так що модифікатори доступу однаково стосуються обох з них. Ви вже бачили, що в Scala немає статичних членів; замість цього ви можете мати об'єкт-компанйон, що містить члени, що існують тільки один раз. Наприклад, в Лістингу 13.13 об'єкт Rocket є об'єктом-компанйоном класа Rocket .</p><p>Правила доступу Scala надають привілеї об'єктам-компанйонам та класам, коли доходить до модифікаторів private або protected. Клас поділяє всі свої права доступу з об'єктом-компанйоном, та навпаки. Зокрема, об'єкт може мати доступ до всіх приватних членів класа-компанйона, так само, як&nbsp; клас може мати доступ до всіх приватних членів свого об'єкта-компанйона.</p><p>Наприклад, клас Rocket вище може отримати доступ до метода fuel, що задекларований як private в об'єкті Rocket. Аналогічно, об'єкт Rocket може отримати доступ до приватного метода canGoHomeAgain класа Rocket.</p><p>Одне виключення, де є закінчується подібність між Scala та Java стосується захищених статичних методів. Захищені статичні члени класа Java C може отримати доступ у всіх субкласах C. На відміну від цього, захищені класи&nbsp; в об'єкті-компанйомі не мають сенсу, бо об'єкт-синглтон не має субкласів.</p>
<pre class="prettyprint linenums language-scala">class Rocket {
  import Rocket.fuel
  private def canGoHomeAgain = fuel &gt; 20
}
<br>object Rocket {
  private def fuel = 10
  def chooseStrategy(rocket: Rocket) {
    if (rocket.canGoHomeAgain)
      goHome()
    else
      pickAStar()
  }
  def goHome() {}
  def pickAStar() {}
}</pre>
        <p>Лістинг 13.13: Доступ до приватних членів класа-компанйона та об'єктів.</p><h4>13.6 Об'єкти пакунка</h4><p>До цього часу, єдиний код, що ви додавали до пакунку, були класи, трейти, та окремі об'єкти. Це найбільш загальні визначення, що покладаються на верхній рівень пакунка, але Scala не обмежує вас цім.</p><p>Любий тип визначення, що ви можете покласти в клас, ви також можете покласти на верхній рівень пакунка. Якщо ви маєте деякій допоміжний метод, що ви бажаєте покласти в полі зору всього пакунка, зробіть так, та покладіть його на верхній рівень пакунка. Щоб зробити це, покладіть визначення в об'єкт пакунка. Кожний пакунок дозволяє мати об'єкт пакунка. Любі визначення, покладені в об'єкт пакунка, будуть розглядатись як члени самого пакунка.</p><p>Приклад, показаний в Лістингу 13.14. Файл package.scala містить об'єкт пакунка для пакунка bobsdelights . Синтаксично, об'єкт пакунка виглядає більше як один з фігурно-дужкових пакунків, показаних раніше в цій главі. Одна різниця полягає в тому, що він включає ключове слово object. Це обєкт пакунка, не сам пакунок. Вміст фігурних дужок може включати любе визначення, яке ви побажаєте. В цьому випадку, об'єкт пакунка включає допоміжний метод showFruit з Лістинга 13.8.</p><p>Маючи це визначення, любий інший код в любому пакунку може імпортувати метод, так само, як він може імпортувати клас. Наприклад, Лістинг 13.14 також показує окремий об'єкт PrintMenu, що розміщений в іншому пакунку. PrintMenu може імпортувати допоміжний метод showFruit, таким же чином, як він може імпортувати клас Fruit .</p>
<pre class="prettyprint linenums language-scala">// В файлі bobsdelights/package.scala
package object bobsdelights {
  def showFruit(fruit: Fruit) {
    import fruit._
    println(name +"s are "+ color)
  }
}
<br>// В файлі PrintMenu.scala
package printmenu
<br>import bobsdelights.Fruits
import bobsdelights.showFruit
<br>object PrintMenu {
  def main(args: Array[String]) {
    for (fruit &lt;- Fruits.menu) {
      showFruit(fruit)
    }
  }
}</pre>
        <p>Лістинг 13.14 Об'єкт пакунка.</p><p>Заглядаючи наперед, є інші використання об'єктів пакунків для типів визначень, що ви вже бачили. Об'єкти пакунків часто використовуються для зберігання псевдонимів типів для всього пакунка (Глава 20) та неявних перетворювань (Глава 21). Високорівневий пакунок scala має об'єкт пакунка, та його визначення доступні для всього кода Scala.</p><p>Об'єкти пакунків компілюються в файли класів на ім'я package.class, що розташовані в каталозі пакунку, що вони представляють. Це корисно, притримуватись тієї ж домовленості для первинних файлів. Так що ви маєте зазвичай покладати файли об'єкта пакунка bobsdelights з Лістинга 13.14 до файла з назвою package.scala, що знаходиться в каталозі bobsdelights.</p><h3>13.7 Висновок</h3><p>В цій главі ви побачили базові конструкції для поділу програми на пакунки. Це дає вам просту та корисну можливість модулярності, так що ви можете працювати з дуже великими обсягами кода, без того, щоб різні частини кода налазили один на одний. Ця система в тому ж дусі, що і пакунки Java, але є деякі відмінності, де Scala обирає бути більш узгодженою або більш загальною.</p><p>Заглядаючи наперед, Глава 29 описує більш гнучку систему модулів, ніж поділ на пакунки. На додаток до можливості поділити код на декілька просторів імен, цей підхід дозволяє модулям бути параметризованими, та наслідувати один від одного. В наступній главі ми звернемо нашу увагу на припущення та юніт-тестування.</p><h3>Глава 14</h3><h2>Припущення та юніт тести</h2><p>Два важливі способи перевірити, що поведінка вашого програмного забезпечення така, як ви очікуєте, є припущення та юніт тести. В цьому розділі ми покажемо деякі доступні вам опції, що ви можете записати та протестувати в Scala.</p><h3>14.1 Припущення</h3><p>Припущення в Scala записуються як виклики попередньо визначеного метода&nbsp; assert. Вираз assert(умова) викликає AssertionError, якщо умова не справдиться. Також є версія assert з двома аргументами. Вираз assert(умова, пояснення) перевіряє умову, та якщо вона не справжується, підіймає&nbsp; AssertionError, що містить надане пояснення. Тип пояснення Any, так що ви можете передати любий об'єкт в якості пояснення. Метод assert буде викликати на ньому toString, щоб отримати рядок пояснення, яке буде розміщене в AssertionError.</p><p>Наприклад, в методі на ім'я “above” класа Element, показаному в Лістингу 10.13, ви можете розмістити assert після виклику widen, щоб переконатись, що розширені елементи мають однакову ширину. Це показано в Лістингу 14.1.</p><p>Інший шлях, що ви можете обрати, щоб зробити це, це перевірити ширину наприкінці метода widen, прямо перед поверненням значення. Ви можете досягти цього, зберігаючи результат в val, виконавши припущення на результаті, та потім вказавши val останнім, так що результат буде повернений, якщо припущення справдиться.</p>
<pre class="prettyprint linenums language-scala">def above(that: Element): Element = {
  val this1 = this widen that.width
  val that1 = that widen this.width
  assert(this1.width == that1.width)
  elem(this1.contents ++ that1.contents)
}</pre>
        <p>Лістинг 14.1 Використання припущень.</p><p>Однак, ви можете зробити це більш стисло, за допомогою зручного метода в Predef, ща називається ensuring, як показано в Лістингу 14.2. Метод ensuring може бути використаний з любим типом результата, завдяки неявній конверсії типів. Хоча це виглядає в коді, якби ми б викликали ensuring на результаті widen, що є типом Element, ми насправді викликаємо ensuring на типі, до якого неявно приводиться Element. Метод ensuring приймає один аргумент, функцію-предикат, що приймає тип результата, та повертає Boolean. Сам ensuring передасть результат в предикат. Якщо предикат поверне true, ensuring поерне результат. Інакше, ensuring підійме AssertionError.</p><p>В цьому прикладі предикат “w &lt;= _.width”. Підкреслення є підміною одного аргумента, що передається до предиката, результат Element метода widen. Якщо передана до widen ширина, w, меньше або дорівнює до width отриманого Element, предикат будет true, та ensuring поверне Element, на якому він був викликаний. Оскільки це останній вираз в методі widen, сам widen завершиться з результатом Element.</p>
<pre class="prettyprint linenums language-scala">private def widen(w: Int): Element =
  if (w &lt;= width)
    this
  else {
    val left = elem(' ', (w - width) / 2, height)
    var right = elem(' ', w - width - left.width, height)
    left beside this beside right
  } ensuring (w &lt;= _.width)</pre>
        <p>Лістинг 14.2 Використання ensuring для перевірки результата функції.</p><p>Припущення (та перевірки ensuring) можуть бути включені або відключені з використанням флагів командного рядка JVM -ea та -da. Коли включені, кожне припущення виступає як невеликий тест, що використовує справжні дані, що трапляються під час виконання програми. В залишку цієї глави ми сфокусуємось на написанні зовнішніх юніт тестів, що провадять власні тестові дані, та виконуються незалежно від застосування.</p><h3>14.2 Юніт тести в Scala</h3><p>Ви маєте багато опцій для юніт тестів в Scala, від визнаних інструментів Java, таких, як JUnit та TestNG, до нових інструментів, написаних на Scala, як ScalaTest, specs, та ScalaCheck. В залишку цієї глави ми надамо вам огляд ціх інструментів. Ми почнемо зі ScalaTest.</p><p>ScalaTest провадить декілька шляхів для написання тестів, простіший з яких є створення класів, що розширюють org.scalatest.Suite, та визначають тестові методи в ціх класах. Suite представляє сюїту тестів. Тестові методи починаються з "test". Лістинг 14.3 показує приклад:</p>
<pre class="prettyprint linenums language-scala">import org.scalatest.Suite
import Element.elem
<br>class ElementSuite extends Suite {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width == 2)
  }
}</pre>
        <p>Лістинг 14.3 Написання тестового метода за допомогою Suite.</p><p>Хоча ScalaTest включає застосування Runner, ви можете виконати Suite напряму з інтерпретатора Scala, викликавши для нього execute. Метод execute використовує рефлексію для пошуку тестових методів, та викликає їх. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; (new ElementSuite).execute()
Test Starting - ElementSuite.testUniformElement
Test Succeeded - ElementSuite.testUniformElement</pre>
        <p>ScalaTest спрощує різні стилі тестування, оскільки execute може бути перевизначений в підтипах Suite. Наприклад, ScalaTest пропонує трейт з назвою FunSuite, що перевизначає execute, так що ви можете визначити тести як функціональні значення, скоріше, ніж методи. Лістинг 14.4 показує приклад:</p>
<pre class="prettyprint linenums language-scala">import org.scalatest.FunSuite 
import Element.elem
<br>class ElementSuite extends FunSuite {
  test("elem result should have passed width") {
    val ele = elem('x', 2, 3)
    assert(ele.width == 2)
  }
}</pre><p>Лістинг 14.4 Написання тестової функції за допомогою FunSuite.</p><p>“Fun” в FunSuite означає функцію. Метод “test ” визначений в FunSuite, що буде викликаний первинним конструктором ElementSuite. Ви задаєте ім'я теста як рядок між дужками, та сам код теста між фінурними дужками. Код теста є функцією, що передається як параметр за-ім'ям до тесту, що реєструє її для подальшого виконання. Одна з переваг FunSuite в тому, що вам не потрібне називати всі ваші тести з початком на “test”. На додаток, ви можете просто отримати довгі імена для ваших тестів, оскільки ми не змушені кодувати їх в верблюжому реєстрі, як це робиться для імен методів.</p><h3>14.3 Інформативні доповіді про тестування</h3><p>Тести в попередніх двох прикладах намагаютсья створити елемент з шириною, та припускають, що ширина отриманого елемента є 2. Коли це припущення схибить, ви побачите повідомлення, що вказує, що припущення схибило.</p><p>Ви отримаєте номер рядка, але не будете знати, що два значення не були рівні. Ви можете винайти це, якщо розмістите рядок в припущення, що вказує на два значення, але більш стислий підхід є використання оператора з трьома знаками рівняння, що ScalaTest провадить саме для ціх цілей:</p>
<pre class="prettyprint linenums language-scala">assert(ele.width === 2)</pre>
        <p>Коли припущення схибить, ви побачите повідомлення, таке як “3 did not equal 2” в доповіді про помилку. Це скаже вам, що ele.width невірно повернуло&nbsp; 3. Оператор з трьма знаками рівняння не розрізняє між дійсним і очікуваним результатом. Він просто вказує, що лівий оператор не був рівним до правого оператора. Якщо ви бажаєте наголосити на цій різниці, ви можете альтернативно використанти метод ScalaTest expect, як це:</p>
<pre class="prettyprint linenums language-scala">expect(2) {
  ele.width
}</pre>
        <p>Цім віразом ви вказуєте, що ви очікуєте, що код в фігурних дужках дасть 2. Коли код в дужках дасть 3, ви побачите повідомлення “Expected 2, but got 3” в доповіді про помилку. Якщо ви бажаєте перевірити, чи метод викликає виключення, ви можете використати метод ScalaTest intercept, таким чином:</p>
<pre class="prettyprint linenums language-scala">intercept[IllegalArgumentException] {
  elem('x', -2, 3)
}</pre>
        <p>Якщо код в фігурних дужках завершається передчасно з примірником вказано класа виключення, intercept поверне викликане виключення, щоб ви могли його подалі достілдити. Більш часто вас буде тільки турбувати, щоб вказане виключення просто було викликане, та ігнорувати результат перехоплення, як це робиться в нашому прикладі. З іншого боку, якщо код не викликає виключення, або викликає інше виключення, метод intercept буде підіймати TestFailedException, та ви отримаєте корисне повідомлення про помилку в доповіді про відмову, ось так:</p>
<pre class="prettyprint linenums language-scala">Expected IllegalArgumentException to be thrown,
  but NegativeArraySizeException was thrown.</pre>
        <p>Ціллю оператора ScalaTest === та його методів expect та intercept - допомогти вам писати методи тестування на основі припущень, що зрозумілі та стислі. В наступному розділі ми покажемо, як використовувати цей синтаксис в тестах JUnit та TestNG, написаних на Scala.</p><h3>14.4 Використання JUnit та TestNG</h3><p>Найбільш популярним фремворком для юніт тестів на платформі Java є JUnit, інструмент з відкритим кодом, написаний Кентоом Беком та Еріхон Гамма. Ви можете писати тести JUnit в Scala досить просто. Ось приклад з використанням JUnit 3.8.1:</p>
<pre class="prettyprint linenums language-scala">import junit.framework.TestCase
import junit.framework.Assert.assertEquals
import junit.framework.Assert.fail
import Element.elem
<br>class ElementTestCase extends TestCase {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assertEquals(2, ele.width)
    assertEquals(3, ele.height)
    try {
      elem('x', -2, 3)
      fail()
    }
    catch {
      case e: IllegalArgumentException =&gt; // expected
    }
  }
}</pre>
        <p>Коли ви скомпілюєте цей клас, JUnit буде виконувати його як любий інший TestCase. JUnit не обходить, що він був написаний на Scala. Однак, якщо ви бажаєте використовувати синтаксис припущень ScalaTest в вашому тесті JUnit 3, ви можете наслідувати JUnit3Suite, як показано в Лістингу 14.5.</p><p>Трейт JUnit3Suite розширює TestCase, так що одного разу, коли ви скомпілюєте цей клас, JUnit буде робити дуже гарно, не зважаючи на те, що він використовує більш стислий синтаксис припущень ScalaTest. Більше того, оскільки JUnit3Suite змішує трейт ScalaTest Suite, ви можете альтернативно виконати цей тест з виконувачем ScalaTest. Ціллю є провадити м'яку міграцію, щоб дозволити користувачам&nbsp; JUnit почати писати тести JUnit на Scala, що мають переваги стислості, надані Scala. ScalaTest також має JUnitWrapperSuite, що дозволяє вам виконувати існуючі тести JUnit, написані на Java, з виконувачем ScalaTest.</p>
<pre class="prettyprint linenums language-scala">import org.scalatest.junit.JUnit3Suite
import Element.elem
<br>class ElementSuite extends JUnit3Suite {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width === 2)
    expect(3) { ele.height }
    intercept[IllegalArgumentException] {
      elem('x', -2, 3)
    }
  }
}</pre>
        <p>Лістинг 14.5 Написання теста JUnit за допомогою JUnit3Suite .</p><p>ScalaTest пропонує подібні класи інтеграції для JUnit 4 та TestNG, обоє з яких щедро використовують анотації. Ми покажемо приклад використання TestNG, фреймворка з відкритим кодом, написаного Седріком Бюстом та Александру Попеску. Як і з JUnit, ви можете просто написати тести TestNG на Scala, скомпілювати їх, та виконати за допомогою виконувача TestNG. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">import org.testng.annotations.Test
import org.testng.Assert.assertEquals
import Element.elem
<br>class ElementTests {
<br>  @Test def verifyUniformElement() {
    val ele = elem('x', 2, 3)
    assertEquals(ele.width, 2)
    assertEquals(ele.height, 3)
  }
<br>  @Test(
    expectedExceptions =
    Array(classOf[IllegalArgumentException])
  )
  <br>  def elemShouldThrowIAE() { elem('x', -2, 3) }
}</pre>
        <p>Однак, якщо ви схиляєтесь до використання синтаксису припущень ScalaTest в ваших тестах TestNG, ви можете розширити трейт TestNGSuite, як показано в Лістингу 14.6:</p>
<pre class="prettyprint linenums language-scala">import org.scalatest.testng.TestNGSuite
import org.testng.annotations.Test
import Element.elem
<br>class ElementSuite extends TestNGSuite {
<br>  @Test def verifyUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width === 2)
    expect(3) { ele.height }
    intercept[IllegalArgumentException] {
      elem('x', -2, 3)
    }
  }
}</pre>
        <p>Лістинг 14.6 Написання теста TestNG за допомогою TestNGSuite.</p><p>Як і з JUnit3Suite, ви можете виконати TestNGSuite або з TestNG<br>або ScalaTest, та ScalaTest також провадить TestNGWrapperSuite, що дозволяє&nbsp; виконувати існуючі тести TestNG, написані на Java, за допомогою ScalaTest. Щоб побачите приклад теста JUnit 4, написаного на Scala, дивіться Розділ 31.2.</p><h3>14.5 Тести як специфікації</h3><p>В розробці в стилі тестування на основі поведінки (behavior-driven development, BDD), ставиться наголос на написанні читабельних людиною специфікацій очікуваної поведінки кода, та супровідних тестів, що перевіряють, що код має вказану поведінку. ScalaTest включає декілька трейтів — Spec, WordSpec, FlatSpec, та FeatureSpec — що спрощують цей стиль тестування. Приклад FlatSpec показаний в Лістингу 14.7.</p><p>В FlatSpec ви пишете тести як твердження специфікацій. Ви починаєте з написання імені для предмета тестування, в вигляді рядка ("A UniformElement" в Лістингу 14.7), потім should (або must, або can), потім рядок, що задає частину поведінки, що очікується від предмета, потім in. В фігурних дужках за in ви пишете код, що тестує вказану поведінку. В наступних твердженнях для посилання на останній згадуваний предмет тестування ви можете писати it. </p>
<pre class="prettyprint linenums language-scala">import org.scalatest.FlatSpec
import org.scalatest.matchers.ShouldMatchers
import Element.elem
<br>class ElementSpec extends FlatSpec with ShouldMatchers {
  "A UniformElement" should
<br>  "have a width equal to the passed value" in {
     val ele = elem('x', 2, 3)
     ele.width should be (2)
  }
<br>  it should "have a height equal to the passed value" in {
    val ele = elem('x', 2, 3)
    ele.height should be (3)
  }
<br>  it should "throw an IAE if passed a negative width" in {
    evaluating {
      elem('x', -2, 3)
    } should produce [IllegalArgumentException]
  }
}</pre>
<p>Лістинг 14.7 Задання та тестування поведінки за допомогою ScalaTest FlatSpec.</p><p>При виконанні FlatSpec він буде виконувати кожний заданий специфікатор як тест ScalaTest. FlatSpec (та інші трейти специфікації ScalaTest) генерують вивід, що читається здебільшого як специфікація, що ви виконуєте. Наприклад, ось на що буде скидатись результат, якщо виконати ElementSpec з Лістинга 14.7 в інтерпретаторі: </p>
<pre class="prettyprint linenums language-scala">scala&gt; (new ElementSpec).execute()
A UniformElement
- should have a width equal to the passed value
- should have a height equal to the passed value
- should throw an IAE if passed a negative width</pre>
        <p>Лістинг 14.7 також ілюструє DSL порівнювачів ScalaTest. Міксуючи трейти ShouldMatchers, ви можете записати припущення, що виглядають більш схожими на природу мову, та генерують більш описові повідомлення відмов. ScalaTest провадить багато порівнювачів в своєму DSL, а також дозволяє вам створювати ваші власні порівнювачі. Порівнювачі, показані в Лістингу 14.7 включають “should be” та синтаксис “evaluating { . . . } should produce”. Ви можете альтернативно доміксувати MustMatchers, якщо ви надаєте перевагу must замість should . Наприклад, міксуючи MustMatchers дозволить вам записати такі вирази:</p>
<pre class="prettyprint linenums language-scala">result must be &gt;= 0
array must have length 3
map must contain key 'c'</pre>
        <p>Якщо припущення схибить, ви побачите повідомлення помилки, подібну до такої:</p>
<pre class="prettyprint linenums language-scala">Map('a' -&gt; 1, 'b' -&gt; 2) did not contain key 'c'</pre>
        <p>Фреймворк тестування specs, інструмент з відкритим кодом, що написаний на Scala Еріком Торреборре, також підтримує стиль тестування BDD, але має інший синтаксис.</p><p>Наприклад, ви можете використовувати specs для написання тесту, показаного в Лістингу 14.8:</p>
<pre class="prettyprint linenums language-scala">import org.specs._
import Element.elem
<br>object ElementSpecification extends Specification {
  "A UniformElement" should {
<br>    "have a width equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.width must be_==(2)
    }
    <br>    "have a height equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.height must be_==(3)
    }
<br>    "throw an IAE if passed a negative width" in {
      elem('x', -2, 3) must
      throwA[IllegalArgumentException]
    }
  }
}</pre>
        <p>Лістинг 14.8 Задання та тестування поведінки за допомогою фреймворка specs.</p><p
class="prettyprint linenums language-scala">Як і ScalaTest, specs провадить DSL порівнювачів. Ви можете бачити деякі приклади порівнювачів specs в дії в Лістингу 14.8, в рядках, що містять “must be_==” та “must throwA”. Ви можете використовувати specs окремо, але він також інтегрований зі ScalaTest та JUnit, так що ви можете виконувати тести specs також і з ціма інструментами. <span
class="refer">Ви можете завантажити specs з http://code.google.com/p/specs/.</span>
        </p><h3>14.6 Тестування на основі властивостей</h3><p>Іншим корисним інструментом для Scala є ScalaCheck, фреймворк з відкритим кодом, написаний Рікардом Нілсоном. ScalaCheck дозволяє вам вказати властивості, яким має підкорятись код, що тестується. Для кожної властивості ScalaCheck буде генерувати тестові дані, та виконувати тести, що перевіряють, чи дотримується ця властивість. Лістинг 14.9 показує приклад використання ScalaCheck зі ScalaTest WordSpec, що примішує трейт Checkers :</p>
<pre class="prettyprint linenums language-scala">import org.scalatest.WordSpec
import org.scalatest.prop.Checkers
import org.scalacheck.Prop._
import Element.elem
class ElementSpec extends WordSpec with Checkers {
  "elem result" must {
    "have passed width" in {
      check((w: Int) =&gt; w &gt; 0 ==&gt; (elem('x', w, 3).width == w))
    }
    "have passed height" in {
      check((h: Int) =&gt; h &gt; 0 ==&gt; (elem('x', 2, h).height == h))
    }
  }
}</pre><p>Лістинг 14.9 Написання тестів на основі властивостей за допомогою ScalaCheck.</p><p>WordSpec є трейтом ScalaTest, що провадить синтаксис, подібний до specs<br>Specification. Трейт Checkers провадить декілька методів перевірки, що дозволяють вам поєднувати базовані на властивостях тести ScalaCheck з традиційними тестами, базованими на припущеннях або порівняннях. В цьому прикладі ми перевіряємо дві властивості, яким має підкорятись фабрика elem. Властивості ScalaCheck виражені як функціональні значення, що приймають в якості параметрів необхідні для тестування дані, що будуть згенеровані ScalaCheck. В першій властивості, показаній в Лістингу 14.9, тестові дані є цілим на ім'я w, що представляє ширину. В тілі функції ми бачимо такий код:</p>
<pre class="prettyprint linenums language-scala">w &gt; 0 ==&gt; (elem('x', w, 3).width == w)</pre>
        <p>Символ ==&gt; є оператором застосування в ScalaCheck. Мається на увазі, що кожного разу, коли вираз в лівій частині є true, вираз в правій також має бути true. Таким чином, в цьому випадку, вираз зправа від ==&gt; мєа бути true, коли w більше ніж 0. Вираз зправа в цьому випадку буде давати true, якщо ширина, передана до фабрики elem буде така сама, як ширина Element, що повертає фабрика.</p><p>За допомогою цієї малої кількості кода ScalaCheck згенерує можливо сотні значень для w, та протестує кожний, шукаючи значення, для якого властивіст не справжується. Якщо властивість залишається true для кожного значення, що спроує ScalaCheck, тест буде пройдено. Інакше тест буде терміново закінчено з AssertionError, що містить інформацію, включаючи значення, що призвело до відмови.&nbsp;</p><h3>14.7 Організація та виконання тестів</h3><p>Кожний фреймворк, розглянутий в цій главі, провадить деякий механізм для організації та виконання тестів. В цьому розділі ми отримаємо швидкий огляд підходу ScalaTest. Однак, щоб отримати повну історію щодо ціх фреймворків, вам знадобиться звертатись до їх документації.</p><p>В ScalaTest ви організуєте великі тестові сюїти, вкладаючи Suite в Suite. Коли виконується сюїта, вона буде виконувати вкладені сюїти, так само, як тести. Вкладені сюїти, в свою чергу, будуть виконувати свої вкладені сюїти, і так далі. Таким чином, велика тестова сюїта представлена як дерево з об'єктів Suite. коли ви виконуєте кореневу сюїту дерева, будуть виконані всі сюїти в дереві.</p><p>Ви можете вкласти сюїти вручну або автоматично. Щоб вкласти вручну, ви або пееркриваєте метод nestedSuites на ваших Suite, або передаєте сюїти, що ви бажаєте вкласти, до конструктора класа SuperSuite, що ScalaTest провадить саме для ції цілей. Щоб вкласти автоматично, ви провадите імена пакунків до ScalaTest Runner, що буде знаходити сюїти автоматично, вкладати їх під кореневу сюїту, та виконувати кореневу Suite .</p><img
alt="" src="14.1.png"><p>Малюнок 14.1 Графічний доповідач ScalaTest.</p><p>Ви можете визвати застосування ScalaTest Runner з командного рядка або з завдання ant. Ви маєте вказати, які сюїти ви бажаєте виконати, або назвавши сюїти явно, або вказавши префікси імен, для яких ви бажаєте, щоб Runner виконав автоматичний пошук. Опціонально ви можете вказати runpath, список каталогів та файлів JAR, з яких будуть завантажені файли класів для тестів, та код, що вони тренують.<span
class="refer"> Тести можуть бути будь-де на runpath або classpath, але зазвичай ви 
будете тримати ваші тести окремо від вашого виробничого кода, в окремій 
ієрархії каталогів, що відзеркалює ієрархію каталогів ваших класів. </span>Також ви можете вказати один або більше доповідачів, що будуть визначати, як будуть представлені результати тестів.</p><p>Наприклад, дистрибутив ScalaTest включає сюїти, що тестують сам ScalaTest. Ви можете виконати одну з ціх сюїт, SuiteSuite, за допомогою наступної команди:</p>
<pre class="prettyprint linenums language-scala">$ scala -cp scalatest-1.2.jar org.scalatest.tools.Runner
  -p "scalatest-1.2-tests.jar" -s org.scalatest.SuiteSuite</pre>
        <p>За допомогою -cp ви покладаєте файл ScalaTest JAR до classpath. Наступний токен, org.scalatest.tools.Runner, є повністю кваліфікованим ім'ям застосування Runner. Scala буде виконувати це застосування, та передасть йому інші токени як аргументи командного рядка. Ключ -p вказує на runpath, що в цьому випадку є JAR файлом, що містить класи сюїти: scalatest-1.2-tests.jar. Ключ -s вказує на SuiteSuite, як на сюїту, що треба виконати. Оскільки ви явно не вказуєте доповідача, ви по замовчанню отримаєте графічного доповідача. Результат показаний на Малюнку 14.1.</p><h3>14.8 Висновок</h3><p>В цій главі ми бачили приклади міксування припущень безпосередньо в виробничий код, а також написання їх зовні, в вигляді юніт тестів. Ви бачили це як Scala програміст, що можна отримати вигоди від популярних тестових інструментів спільноти Java, таких, як JUnit та TestNG, а також від новіших інструментів, розроблених спеціально для Scala, таких, як ScalaTest, ScalaCheck, та specs. Обоє, припущення в коді, та юніт тести можуть допомогти вам досягти ваших цілей щодо якості програми.</p><p>Ми відчуваємо, що ці прийоми досить важливі, щоб виправдати невеликий відступ від розгляду Scala, що і представлено в цій главі. Однак, в наступній главі ми повернемось до розгляду мови, та розкриємо дуже корисний аспект Scala: порівняння шаблонів.</p><h3>Глава 15</h3><h2>Кейс класи та порівняння шаблонів</h2><p>Ця глава вводить кейс класи та порівняння (співпадіння) шаблонів, пов'язані конструкції, що підтримують вас, коли ви пишете регулярні, не інкапсульовані структури даних. Ці дві конструкції, зокрема, корисні для деревоподібних рекурсивних даних. Якщо ви до цього програмували в функціональних мовах, тоді ви, можливо, розпізнаєте порівняння шаблонів. Однак кейс класи будуть новими для вас. Кейс класи є способом Scala дозволити співпадіння шаблонів на об'єктах, без потреби великої кількості рутинного кода. В загальному випадку, все, що вам треба, це додати одне ключове слово case до кожного класа, що ви бажаєте використовувати в співпадіннях з шаблонами.</p><p>Ця глава починається з простого прикладу кейс класа та порівняння. Потім він проходить по всіх типух шаблонів, що підтримуються, промовляє про роль прив'язанних sealed класів, обговорює тип Option, та показує деякі нерчевидні місця в мові, де використовується порівнняння з шаблонами.</p><p>Нарешті, показаний більший, та більш реалістичний приклад порівняння.</p><h3>15.1 Простий приклад</h3><p>Перед тим, як зануритись в усі правила та нюанси порівняння шаблонів, є сенс подивитись на простий приклад, щоб спіймати головну ідею. Скажімо, вам треба написати бібліотеку, що маніпулює арифметичними виразами, можливо, як частину галузевої мови, що ви розробляєте.</p><p>Перший крок зрушити цю проблему є визначення вхідних даних. Щоб утримувати речі простими, ми сконцентруємось на арифметичних виразах, що складаються зі змінних, чисел, та унарних та бінарних операцій. Це виражене ієрархією Scala класі, показаню в Лістингу 15.1.</p>
<pre class="prettyprint linenums language-scala">abstract class Expr
<br>case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr</pre>
        <p>ЛІстинг 15.1 Визначення кейс класів.</p><p class="prettyprint linenums language-scala">Ієрархія включає абстрактний базовий клас Expr з чотирма субкласами, по одному на кожний вираз, що ми розглядаємо. <span
class="refer">Замість абстрактного класа ми з тим же успіхом можемо змоделювати корінь цієї ієрархії класів як трейт. Моделювання через абстрактний клас може бути трохи більш ефективним. </span>Тіла всіх п'яти класів пусті. Як попередньо зазначалось, в Scala ви можете залишити фігурні дужки коло пустого класа, якщо побажаєте, так що клас C те саме, що і клас C {}.</p><h4>Кейс класи</h4><p>Інша варта уваги річ щодо декларацій в Лістингу 15.1, це те, що кожний субклас має можифікатор case. Класи з таким модифікатором називаються кейс класами. Використання цього модифікатора примушує компілятор&nbsp; Scala додати деякі синтаксичні зручності до вашого класа.</p><p>Перше, це додає метод-фабрику з ім'ям класа. Це означає, що ви можете написати, скажімо, Var("x"), щоб побудувати об'єкт Var, замість трохи довшого new Var("x") :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val v = Var("x")
v: Var = Var(x)</pre>
        <p>Методи-фабрики зокрема добрі, коли ви вкладаєте їх. Оскільки немає надокучливих ключових слів new, розсипаних в коді, ви можете охопити структуру виразу з першого погляду:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val op = BinOp("+", Number(1), v)
op: BinOp = BinOp(+,Number(1.0),Var(x))</pre>Друга синтаксична зручність в тому, що всі аргументи зі списка параметрів кейс класа неявно мають префікс val, так що вони обробляються як поля:
<pre class="prettyprint linenums language-scala">scala&gt; v.name
res0: String = x
scala&gt; op.left
res1: Expr = Number(1.0)</pre>
<p>Третьє, компілятор додає до вашого класа “природні” реалізації методів toString, hashCode, та equals. Вони будуть друкувати, хешувати та порівнювати ціле дерево, що складається з класа та (рекурсивно) всіх його аргументів. Оскільки == в Scala завжди делегує до equals, це означає, що елементи кейс класів завжди порівнюються структурно:</p>
<pre class="prettyprint linenums language-scala">scala&gt; println(op)
BinOp(+,Number(1.0),Var(x))
scala&gt; op.right == Var("x")
res3: Boolean = true</pre>
<p>Нарешті, компілятор додає до вашого класа метод copy, щоб робити модифіковані копії. Цей метод корисний для створень нових примірників класа, що такий самий, як інший, за виключенням одного або двох атрибутів. Метод робить з використанням поіменованих параметрів та параметрів по замовчанню (Розділ 8.8). Ви задаєте бажані зміни, використовуючи поіменовані параметри. Для любих параметрів, що ви не вказуєте, буде використане значення зі старого об'єкта. Як приклад, ось як ви можете таку ж операцію, як і op, за тим виятком, що вона має змінений оператор:</p>
<pre class="prettyprint linenums language-scala">scala&gt; op.copy(operator = "-")
res4: BinOp = BinOp(-,Number(1.0),Var(x))</pre>
<p>Всі ці домовленості додають багато зручності за малу ціну. Ціна полягає в тому, що що вам треба вказати модифікатор case, та що ваші класи стають трохи більшими. Вони більші, бо генеруються додаткові методи, та додаються неявні поля для кожного параметра конструктора. Однак, найбільша вигода від кейс класів в тому, що вони підтримують порівняння (співпадіння) шаблонів.</p><h4>Порівняння (співпадіння) шаблонів</h4><p>Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених типів. Є багато можливих правил спрощення. Наступні три служать&nbsp; тільки ілюстрацією:</p>
<pre class="prettyprint linenums language-scala">UnOp("-", UnOp("-", e )) =&gt; e // Подвійна зміна знака
BinOp("+", e, Number(0)) =&gt; e // Додавання нуля
BinOp("*", e, Number(1)) =&gt; e // Множення на одиницю</pre>
        <p>Використовуючи порівняння шаблонів, ці правила можуть бути сприйняті майже так, як вони є, щоб сформувати ядро функції спрощення в Scala, як показано в Лістингу 15.2. Функція, simplifyTop, може бути використана таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; simplifyTop(UnOp("-", UnOp("-", Var("x"))))
res4: Expr = Var(x)<br><br>def simplifyTop(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e)) =&gt; e // Подвійна зміна знака
  case BinOp("+", e, Number(0)) =&gt; e // Додавання нуля
  case BinOp("*", e, Number(1)) =&gt; e // Множення на одиницю
  case _ =&gt; expr 
}</pre>
        <p>Лістинг 15.2 Функція simplifyTop, що виконує порівняння шаблонів.</p><p>Права частина simplifyTop складається з виразу match. match відповідає до switch в Java, але записується після виразу селектора, тобто:</p>
<pre class="prettyprint linenums language-scala">селектор match { альтернативи }</pre><p>замість:</p>
<pre class="prettyprint linenums language-scala">switch ( селектор ) { альтернативи }</pre><p>Порівняння шаблонів включає послідовність альтернатив, кожна з яких починається ключовим словом case. Кожна альтернатива включає шаблон, та один або більше виразів, що будуть обчислені, якщо шаблон співпаде. Символ стрілки =&gt; відділяє шаблон від виразів.</p><p>Вираз match обчислюється через спробу кожного з шаблонів, в тому порядку, як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що слідує за стрілкою, буде виконана.</p><p>Шаблон-константа, як "+" або 1, співпаде зі значеннями, рінвними константі за допомгою відповідного ==. Змінний шаблон як e співпадає з любим значенням. Змінна потім посилається на те значення, що знаходиться зправа до твердження case.</p><p>Зауважте, що перші три приклади обчислюються до e, змінної, що прив'язана до асоційованого шаблона. Узагальнений шаблон ( _ ) також співпадає з кожним значенням, але він не вводить ім'я змінної, що посилається на це значення. Зуважте з Лістингу 15.2, як match завершується випадком по замовчанню, що нічого не робить в виразі. Замість цього, він повертає тільки expr, вираз, до якого виконане порівняння.</p><p>Шаблон конструктора виглядає як UnOp("-", e) . Цей шаблон співпадає з типом UnOp, чий перший аргумент співпадає з "-", та чий другий аргумент співпадає з e. Зауважте, що аргументи конструктора також є шаблонами. Це дозволяє записати глибші шаблони, використовуючи стислу нотацію. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">UnOp("-", UnOp("-", e))</pre>
        <p>Уявіть намагання реалізувати ту ж функціональність за допомогою шаблона візітора! Щонайменьше це буде незграбним, якщо уявити реалізацію як довну послідовність тверджень if, перевірки типів, та приведення типів.</p><p>Оператор match, в порівнянні зі switch виразами, можуть розглядатись як узагальнення switch в Java. Існуючий в Java switch може бути природно виражений як вираз match, де кожний шаблон є сталою, та останній шаблон може бути узагальненням (що представлене як default case в виразі switch ). Однак, є три різниці, що треба мати на увазі. Перше, match є виразом в Scala, тобто, це завжди завершується значенням. Друге, альтернативи-вирази Scala ніколи не "провалюються" на наступний case. Третє, якщо жодний з шаблонів не співпаде, буде підійняте MatchError. Це означає, що ви маєте переконатись, що всі варіанти покриті, навіть якщо це означає додання випадку по замовчанню, що нічого не робить. Лістинг 15.3 показує приклад.</p><p>Другий випадок є необхідним в Лістингу 15.3, бо інакше вираз match буде викликати MatchError для кожного аргумента expr, що не є BinOp. І цьому прикладі для цього другого випадка не визначено ніякого кода, так що в цьому випадку нічого не відбувається. Результатом цього випадку є одничне значення ‘()’, що, таким чином, є і результатом всього виразу порівняння з шаблоном.</p>
<pre class="prettyprint linenums language-scala">expr match {
  case BinOp(op, left, right) =&gt; println(expr +" is a binary operation")
  case _ =&gt;
}</pre>
        <p>Лістинг 15.3 Порівняння шаблона з пустим випадком “по замовчанню”.</p><h3>15.2 Різні типи шаблонів</h3><p>Попередній приклад показує декілька типів шаблонів в швидкому переліку. Тепер витратимо хвилину, щоб поглянути на кожний випадок.</p><p>Синтаксис шаблону простий, так що дуже не хвилюйтесь. Всі шаблони виглядають як відповідний вираз. Наприклад, якщо ми маємо ієрархію з Лістингу 15.1, шаблон Var(x) співпадає з любою змінною, ща закріплює x до імені змінної. Якщо використати як вираз, Var(x) — точно такий синтаксис — відновить еквівалентний об'єкт, вважаючи, що x вже прикріплений до назви змінної. Оскільки синтаксис шаблонів є таким прозорим, головна річ, на що треба звернути увагу, це те, які взагалі шаблони є можливими.</p><h4>Шаблони з узагальнюючими символами</h4><p>Узагальнюючий символ підстановки ( _ ) співпадає з будь-яким об'єктом. Ви вже бачили, як це використовується по замовчанню, для перехоплення альтернативи "все інше", таким чином:</p>
<pre class="prettyprint linenums language-scala">expr match { 
case BinOp(op, left, right) =&gt;
  println(expr +" is a binary operation")
case _ =&gt;
}</pre>
        <p>Узагальнення також можуть використовуватись в для ігнорування частини об'єкта, що вас не турбує. Наприклад, попередній приклад насправді не турбується щодо елементів бінарної операції. Він тільки перевіряє, що це взагалі бінарна операція. Таким чином може так само гарно використовувати узагальнюючий шаблон для елементів BinOp, як показано на Лістингу 15.4:</p>
<pre class="prettyprint linenums language-scala">expr match {
case BinOp(_, _, _) =&gt; println(expr +" is a binary operation")
case _ =&gt; println("It's something else")
}</pre>
        <p>Лістинг 15.4 Порівняння шаблонів з узагальненнями.</p><h4>Шаблони-константи</h4><p>Константи в шаблонах співпадають тільки самі з собою. Кожний літерал може бути використаний як константа. Наприклад: 5, true, або "hello" всі є шаблонами-константами. Також кожне val або об'єкт-синглтон може використовуватись як константа. Наприклад, Nil, об'єкт-синглтон, є шаблоном, що співпадає тільки з пустим списком. Лістинг 15.5 показує деякі приклади шаблонів-констант:</p>
<pre class="prettyprint linenums language-scala">def describe(x: Any) = x match {
case 5 =&gt; "five"
case true =&gt; "truth"
case "hello" =&gt; "hi!"
case Nil =&gt; "the empty list"
case _ =&gt; "something else"
}</pre>
        <p>Лістинг 15.5 Порівняння з шаблонами-константами.</p><p>Ось як шаблон з Лістингу 15.5 виглядає в дії:</p>
<pre class="prettyprint linenums language-scala">scala&gt; describe(5)
res6: java.lang.String = five
<br>scala&gt; describe(true)
res7: java.lang.String = truth
<br>scala&gt; describe("hello")
res8: java.lang.String = hi!
<br>scala&gt; describe(Nil)
res9: java.lang.String = the empty list
<br>scala&gt; describe(List(1,2,3))
res10: java.lang.String = something else</pre>
        <h4>Шаблони-змінні</h4><p>Шаблон-змінна співпадає з кожним об'єктом, так само як символ узагальнюючий підстановки. Відміна в тому, що Scala прикріплює змінну до того об'єкту, що знайде. Потім ви можете використовувати цю змінну, щоб вподальшому задіяти цей об'єкт. Наприклад, Лістинг 15.6 показує порівняння шаблонів, що має окремий випадок для нуля, та випадок по замовчанню для всіх інших значень. Випадок по замовчанню використовує шаблон-змінну, так що надає ім'я значенню, не має значення, якому.</p>
<pre class="prettyprint linenums language-scala">expr match {
case 0 =&gt; "zero"
case somethingElse =&gt; "not zero: "+ somethingElse
}</pre>
        <p>Лістинг 15.6 Порівняння з шаблонами-змінними.</p><h4>Змінна чи константа?</h4><p>Шаблони-константи можуть мати символічні імена. Ви можете задати це, коли використовуєте Nil в якості шаблона. Ось пов'язаний з цім приклад, де шаблон включає константи E (2.71828. . . ) та Pi (3.14159. . . ):</p>
<pre class="prettyprint linenums language-scala">scala&gt; import math.{E, Pi}
import math.{E, Pi}
<br>scala&gt; E match {
case Pi =&gt; "дивне співпадіння? Pi = "+ Pi
case _ =&gt; "OK"
}
res11: java.lang.String = OK</pre>
        <p>Як і очікувалось, E не співпадає з Pi, так що випадок “дивне співпадіння” не використовується. Як компілятор Scala знає, що Pi є константою, імпортованою з scala.math, але не змінною, що не стоїть за самим значенням селектора? Scala використовує просте лексичне правило щодо непорозумінь: просте ім'я, що починається з літери нижнього реєстра, має бути шаблоном-змінною; всі інші посилання розглядаються як константи. Щоб побачити різницю, створіть псевдоним в нижньому реєстрі для pi, та спробуйте використати це:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val pi = math.Pi
pi: Double = 3.141592653589793
<br>scala&gt; E match {
case pi =&gt; "strange math? Pi = "+ pi
}
res12: java.lang.String = strange math? Pi =
2.718281828459045</pre>
        <p>Ось де компілятор навіть не дасть вам додати випадок по замовчанню. Оскільки pi є шаблоном-змінною, вона буде співпадати з будь-чим, так що жодний подальший випадок не буде досяжним:</p>
<pre class="prettyprint linenums language-scala">scala&gt; E match {
case pi =&gt; "strange math? Pi = "+ pi
case _ =&gt; "OK"
}
&lt;console&gt;:9: error: unreachable code
case _ =&gt; "OK"
ˆ</pre>
        <p>Якщо вам конце треба, ви можете застосувати константу в малому реєстрі, з використанням двох трюків. Перше, якщо константа є полем деякого об'єкта, ви можете задати його в вигляді кваліфікатора. Наприклад, pi є шаблоном-змінно, але this.pi або obj.pi є константами, навіть якщо вони вочевидь починаються з малих літер. Якщо це не спрацьовує (оскільки pi є, скажімо, локальною змінною), ви можете альтернативно оточити ім'я змінної в зворотні лапки. Наприклад, `pi` знову буде інтерпретовано як константу, але не змінну:</p>
<pre class="prettyprint linenums language-scala">scala&gt; E match {
case `pi` =&gt; "strange math? Pi = "+ pi
case _ =&gt; "OK"
}
res14: java.lang.String = OK</pre>
        <p>Як ви можете бачити, синтаксис зі зворотніми лапками для ідентифікаторів використовується в&nbsp; Scala для двох різних цілей: щоб допомогти вашому коду знайти вихід в різних скрутних становищах. Тут ви можете бачити, як це використовується для трактування ідентифікатора в нижньому реєстрі в якості константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили, як це також використовувалось для трактування ключового слова як ідентифікатора, тобто, написання Thread.`yield`()&nbsp; трактує yield як ідентифікатор, скорішен, ніж ключове слово.</p><h4>Шаблони конструктора</h4><p>Конструктори при порівнянні шаблонів стають дійсно потужними. Шаблон конструктора виглядає як “BinOp("+", e, Number(0)) ”. Він складається з імені&nbsp; (BinOp), та потім з числа шаблонів в дужках: "+", e, та Number(0). Якщо вважати, що ім'я показує кейс клас, в тій якості, що шаблон буде перевіряти як об'єкт, що є примірником кейс класа, та потім перевірить, що параметри конструктора об'єкта співпадуть з додатковими наданими шаблонами.</p><p>Ці додаткові шаблони означають, що ці шаблони Scala підтримують глибокі порівняння. Такі шаблони не тільки порівнюють надані об'єкти вищого рівня, але також перевіряють об'єкти щодо подальших об'єктів. Оскільки додаткові шаблони можуть, в свою чергу, також бути шаблонами конструкторів, ви можете використовувати їх для перевірки об'єктів будь-якої глибини. Наприклад, шаблон, показаний В Лістингу 15.7, перевіряє, що високорівневий об'єкт є BinOp, що його третій параметр конструктора є Number, та що поле значення цього числа є 0. Цей шаблон довжиною в один рядок, але при цьому перевіряє на три рівні вглиб.</p>
<pre class="prettyprint linenums language-scala">expr match {
case BinOp("+", e, Number(0)) =&gt; println("a deep match")
case _ =&gt;<br>}</pre>
        <p>Лістинг 15.7 Порівняння шаблонів з шаблоном конструктора.</p><h4>Шаблони послідовностей</h4><p>Ви можете порівнювати з типуми послідовностей, як List або Array, точно як робите це з кейс класами. Використовуйте той же синтаксис, але ви можете вказати довільне число елементів в шаблоні. Наприклад, Лістинг 15.8 показує шаблон, що перевіряє список з трьох елементів, якій починається з нуля:</p>
<pre class="prettyprint linenums language-scala">expr match {
case List(0, _, _) =&gt; println("found it")
case _ =&gt;
}</pre>
        <p>Лістинг 15.8 Шаблон послідовності з фіксованою довжиною.</p><p>Якщо ви бажаєте порівняти з послідовністю без надання довжини, ви можете вказати _* в якості останнього елемента шаблона. Цей дивно виглядачий шаблон співпадає з будь-яким числом елементів в послідовносі, включаючи нуль елементів. Лістинг 15.9 показує приклад шаблона, що співпадає з любим списком, що починається на нуль, безвідносно до його довжини.</p>
<pre class="prettyprint linenums language-scala">expr match {
case List(0, _*) =&gt; println("found it")
case _ =&gt;
}</pre>
        <p>Лістинг 15.9 Шаблон послідовності з довільною довжиною.</p><h4>Шаблони кортежів</h4><p>Ви можете також виконати порівняння з кортежем. Кортеж, як (a, b, c), співпадає з довільним тримісним кортежем. Приклад показаний в Лістингу 5.10:</p>
<pre class="prettyprint linenums language-scala">def tupleDemo(expr: Any) =
  expr match {
  case (a, b, c) =&gt; println("matched "+ a + b + c)
  case _ =&gt;
}</pre>
        <p>Лістинг 15.10 Порівняння з шаблоном кортежу.</p><p>Якщо ви завантажете метод tupleDemo, показаний в Лістингу 15.10 до інтерпретатора, та надасте кортеж з трьома елементами, ви побачите:</p>
<pre class="prettyprint linenums language-scala">scala&gt; tupleDemo(("a ", 3, "-tuple"))
matched a 3-tuple</pre>
        <h4>Типізовані шаблони</h4><p>Ви можете використати шаблони за типом, як зручну заміну перевірці та приведенню типів. Лістинг 15.11 показує приклад:</p>
<pre class="prettyprint linenums language-scala">def generalSize(x: Any) = x match {
  case s: String =&gt; s.length
  case m: Map[_, _] =&gt; m.size
  case _ =&gt; -1
}</pre>
        <p>Лістинг 15.11 Порівняння з типізованими шаблонами.</p><p>Ось деякі приклади використання метода generalSize в інтерпретаторі Scala:</p>
<pre class="prettyprint linenums language-scala">scala&gt; generalSize("abc")
res16: Int = 3
<br>scala&gt; generalSize(Map(1 -&gt; 'a', 2 -&gt; 'b'))
res17: Int = 2
<br>scala&gt; generalSize(math.Pi)
res18: Int = -1</pre>
        <p>Метод generalSize повертає розмір або довжину об'єктів різного типу. Його аргумент типу Any, так що може отримувати будь-яке значення. Якщо аргумент є String, метод повертатиме довжину рядка. Шаблон “s: String” є типізованим; він відповідає кожному (не-нульовому) примірнику String. Змінна шаблона&nbsp; s потім посилається на цей рядок.</p><p>Зауважте, що навіть припускаючи, що s та x посилаються на одне значення, тип x є Any, але тип s є String. Таким чином ви можете записати s.length в альтернативному виразі, що відповідає шаблону, але ви не можете записати x.length, оскільки тип Any не має члена length. </p><p>Еквівалентний, але більш розгорнутий спосіб досягти того ж ефекту, що і порівняння з типізованим шаблоном, задіє перевірку типу, за яким слідує приведення типу. Scala використовує інший синтаксис, ніж Java, для ціх цілей. Скажімо, для перевірки, чи є вираз expr типу String, ви пишете:</p>
<pre class="prettyprint linenums language-scala">expr.isInstanceOf[String]</pre>
        <p>Щоб привести деякий вираз до типу String, ви використовуєте:</p><p>expr.asInstanceOf[String]</p><p>Використовуючи перевірку та приведення типу ви можете переписати перший case попереднього виразу match як показане в Лістингу 15.12. Оператори isInstanceOf та asInstanceOf розглядаються як попередньо визначені методи класа Any, що приймають параметр типу в прямокутних дужках.</p>
<pre class="prettyprint linenums language-scala">if (x.isInstanceOf[String]) {
  val s = x.asInstanceOf[String]
  s.length
else ...</pre>
        <p>Лістинг 15.12 Використання isInstanceOf та asInstanceOf (дешевий стиль).</p><p>Фактично, x.asInstanceOf[String] є особливим випадком виклика метода з явним параметром типу String.</p><p>Як ви вже зазначили, написання перевірки типу та приведення (кастинг) типу є балакучим в Scala. Це зроблене навмисно, оскільки це не те, до чого вас закликають. Для вас зазвичай краще використовувати типізовані порівняння шаблонів. Це особливо доречно, якщо вам треба виконати одночасно перевірку та приведення типу, оскільки обі операції згортаються до одного порівняння шаблонів. Другий випадок попереднього виразу порівняння&nbsp; містить шаблон типу “m: Map[_, _]”. Цей шаблон співпадає з кожним значенням, що є Map з деяким довільним типом ключа та виразу, та дозволяє m посилатись на це значення. Таким чином, m.size гарно типізоване, та повертає розмір мапи. Підкреслення в типізованому шаблоні - як підкреслення в інших шаблонах. Ви також могли замість цього використовувати типові змінні (в нижньому реєстрі).</p><h4>Очищення типів</h4><p>Чи можете ви перевірити мапу з певними типуми елементів? Це було б зручним, скажімо, для перевірки, чи певне значення є мапою, що відзеркалює тип Int на тип Int. Давайте спробуємо:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def isIntIntMap(x: Any) = x match {
case m: Map[Int, Int] =&gt; true
case _ =&gt; false
}
warning: there were unchecked warnings; re-run with
-unchecked for details
isIntIntMap: (x: Any)Boolean</pre>
        <p>Інтерпретатор видає неперевірене попередження. Ви можете визначити подробиці, запустивши інтерпретатор знову з опцією командного рядка&nbsp; -unchecked:</p>
<pre class="prettyprint linenums language-scala">scala&gt; :quit
$ scala -unchecked
Welcome to Scala version 2.8.1
(Java HotSpot(TM) Client VM, Java 1.5.0_13).
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;
def isIntIntMap(x: Any) = x match {
case m: Map[Int, Int] =&gt; true
case _ =&gt; false
}
&lt;console&gt;:5: warning: non variable type-argument Int in
type pattern is unchecked since it is eliminated by erasure
case m: Map[Int, Int] =&gt; true
ˆ</pre>
        <p>Scala використовує модель очищення дженериків, так само як це робить Java. Це означає, що під час виконання ніякої інформації щодо типів аргументів не підтримуються. Відповідно, немає можливості визначити під час виконання, чи окремий об'єкт Map був створений з двома аргументами Int, або з двома аргументами інших типів. Все, що може визначити система, це що значення є Map довільними типуми параметрів. Ви можете перевірити ц. поведінку, застосувавши isIntIntMap до аргументів інших примірників класа Map:</p>
<pre class="prettyprint linenums language-scala">scala&gt; isIntIntMap(Map(1 -&gt; 1))
res19: Boolean = true
<br>scala&gt; isIntIntMap(Map("abc" -&gt; "abc"))
res20: Boolean = true</pre>
        <p>Перше застосування повертає true, що виглядає коректним, але друге застосування також повертає true, що може здивувати. Щоб попередити вас щодо, можливо, неінтуітивної поведінки під час виконання, компілятор видає попередження unchecked, як ви бачили вище.</p><p>Одним виключення до правила очищення є масиви, оскільки вони обробляються особливим чином в Java, і так само в Scala. Тип елемента масива зберігається як частина об'єкта масива, так що ви можете виконувати порівняння шаблонів до нього. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def isStringArray(x: Any) = x match {
case a: Array[String] =&gt; "yes"
case _ =&gt; "no"
}
isStringArray: (x: Any)java.lang.String
<br>scala&gt; val as = Array("abc")
as: Array[java.lang.String] = Array(abc)
<br>scala&gt; isStringArray(as)
res21: java.lang.String = yes
<br>scala&gt; val ai = Array(1, 2, 3)
ai: Array[Int] = Array(1, 2, 3)
<br>scala&gt; isStringArray(ai)
res22: java.lang.String = no</pre>
        <h4>Закріплення змінних</h4><p>На додаток до окремих шаблонів зі змінними, ви також можете додати змінні до кожного іншого шаблона. Ви просто пишете ім'я змінної, знак @, та потім шаблон. Це дає вам шаблон з закріпленням до змінної. Значення такого шаблона є виконати перевірку шаблона, та якщо співпадіння буде вдачним, встановити змінну до співпавшого об'єкта, так само, як за простого співпадіння змінної.</p><p>Як пирклад, Лістинг 15.13 показує співпадіння шаблона, що виглядає як&nbsp; абсолютна операція зі значенням, що задіяна двічі поспіль. Такий вираз може бути спрощений щоб мати тільки одне абсолютне значення кожного разу.</p>
<pre class="prettyprint linenums language-scala">expr match {
&nbsp; case UnOp("abs", e @ UnOp("abs", _)) =&gt; e
&nbsp; case _ =&gt;
}</pre>
        <p>Лістинг 15.13 Шаблон з прив'язкою до змінної (через @).</p><p>В Лістингу 15.13 є шаблон з прив'язкою змінної e, та шаблон UnOp("abs", _). Якщо співпадіння цілого шаблона буде успішним, тоді частина, що співпаде з частиною UnOp("abs", _) буде доступною через змінну e. Як записаний цей код, e буде повернена як є .</p><h4>15.3 Вартівник шаблону</h4><p>Іноді синтаксичне порівняння шаблонів не є досить точним. Наприклад, скажімо, ви отримали завдання сформулювати правило спрощення, що замінює вирази суми на два ідентичні операнди, як&nbsp; e + e, на множення на двійку, як e * 2 . В мові дерев Expr вираз як:</p>
<pre class="prettyprint linenums language-scala">BinOp("+", Var("x"), Var("x"))</pre>
        <p>завдяки цьому правилу перетвориться на:</p>
<pre class="prettyprint linenums language-scala">BinOp("*", Var("x"), Number(2))</pre>
        <p>Ви можете спробувати визначити це правило таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, x) =&gt; BinOp("*", x, Number(2))
  case _ =&gt; e
}
&lt;console&gt;:11: error: x is already defined as value x
case BinOp("+", x, x) =&gt; BinOp("*", x, Number(2))
ˆ</pre>
        <p>Це не дає результату, оскільки Scala обмежує шаблони до лінійних: змінна шаблона може потрапити в шаблон тільки один раз. Однак ви можете переформулювати match за допомогою вартівника шаблона, як показано на Лістингу 15.14:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, y) if x == y =&gt;
    BinOp("*", x, Number(2))
  case _ =&gt; e
}simplifyAdd: (e: Expr)Expr</pre>
        <p>Лістинг 15.14 Вираз match з вартівником шаблона.</p><p>Вартівник шаблона іде після шаблона, та починається з if. Вартівник може бути довільним логічним виразом, що типово посилається на змінні в шаблоні. Якщо вартівник присутній, порівняння буде вдалим, тільки якщо вартівник обчислюється до true. Таким чином, перший випадок вище буде співпадати з бінарними операціями з двома однаковими операндами.</p><p>Деякі інші приклади шаблонів з вартівником:</p>
<pre class="prettyprint linenums language-scala">// співпадає тільки з додатними цілими
case n: Int if 0 &lt; n =&gt; ...
<br>// співпадає тільки з рядками, що починаються на літеру ‘a’
case s: String if s(0) == 'a' =&gt; ...</pre>
        <h3>15.4 Перекриття шаблонів</h3><p>Шаблони випробовуються в тому порядку, в якому записані. Версія спрощення, показана в Лістингу 15.15, презентує приклад, коли порядок випадків має значення:</p>
<pre class="prettyprint linenums language-scala">def simplifyAll(expr: Expr): Expr = expr match {
<br>  case UnOp("-", UnOp("-", e)) =&gt; simplifyAll(e)
// ‘-’ інвертує значення
<br>  case BinOp("+", e, Number(0)) =&gt; simplifyAll(e)
// ‘0’ є нейтральним елементом для ‘+’
<br>  case BinOp("*", e, Number(1)) =&gt; simplifyAll(e)
// ‘1’ є нейтральним елементом для ‘*’
<br>  case UnOp(op, e) =&gt; UnOp(op, simplifyAll(e))
<br>  case BinOp(op, l, r) =&gt; BinOp(op, simplifyAll(l), simplifyAll(r))
  <br>  case _ =&gt; expr
}</pre>
        <p>Лістинг 15.15 Вираз порівняння, де порядок має значення.</p><p>Версія спрощення, показана в Лістингу 15.15 буде стосуватись правил спрощення будь-де в виразі, не тільки нагорі, як робив simplifyTop. Він може походити від simplifyTop додаванням двох випадків для загальних унарних та бінарних виразів (чипадки чотири та п'ять в Лістингу 15.15). Четвертий випадок має шаблон UnOp(op, e); тобто, він співпадає з любою унарною операцією. Оператор та операнд унарної операції можуть бути довільними. Вони прив'язані до змінних шаблона op та e, відповідно. Альтернатива в цьому випадку стосується simplifyAll рекурсивно до операнда e, та потім перебудовує ту ж унарну операцію з (можливо) спрощеним операндом.</p><p>П'ятий випадок для BinOp є аналогічним: це випадок “всі-інші” для довільних бінарних операцій, що рекурсивно застосовує метод спрощення до двох операндів.</p><p>В цьому прикладі важливо, що випадки всі-інші ідуть після більш специфічних правил спрощення. Якщо ви напишете іх в іншому порядку, тоді випадки всі-інші будуть мати перевагу над більш специфічними випадками. В багатьох випадках компілятор буде скаржитись за такої спроби.</p><p>Наприклад, ось вираз порівняння, що не буде компілюватись, оскікльи перший випадок буде співпадати з усім, що могло б співпасти з другим випадком:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def simplifyBad(expr: Expr): Expr = expr match {
  case UnOp(op, e) =&gt; UnOp(op, simplifyBad(e))
  case UnOp("-", UnOp("-", e)) =&gt; e
}
&lt;console&gt;:18: error: unreachable code
case UnOp("-", UnOp("-", e)) =&gt; e
ˆ</pre>
        <h3>15.5 Запечатані класи</h3><p>Коли ви пишете порівняння шаблонів, вам треба переконатись, що ви накрили всі можливі випадки. Іноді ви можете зробити це, додавши випадок по замовчанню в кінці&nbsp;match, але це стосується тільки якщо є змістовна поведінка по замовчанню. Що, коли немає нічого по замовчанню? Як ви можете почуватись в безпеці щодо того, що накрили всі випадки?</p><p>Фактично, ви можете залучитись допомогою компілятора Scala в визначенні пропущених комбінацій шаблонів в виразі match. Щоб мати змогу зробити це, компілятор потребує бути в змозі сказати, які випадки є можливими. Загалом, це неможливо в Scala, оскільки нові кейс класи можуть бути визначені будь-коли, в довільних одиницях компіляції. Наприклад, нічого не заважає вам додати п'ятий кейс клас до ієрархії класа Expr в іншій одиниці компіляції, ніж визначені інші чотири випадки.&nbsp;</p><p>Альтернативою є зробити суперклас ваших кейс класів запечатаним. Запечатаний клас не може додати жодних субкласів, за винятком тих, що знаходятся в тому ж файлі. Це дуже корисно для порівняння шаблонів, оскільки це означає, що вам треба турбуватись щодо субкласів, про які ви вже знаєте. Що ще більше, ви також отримуєте кращу підтримку компілятора. Якщо ви порівнюєте з кейс класами, що наслідують від запечатаного класа, компілятор буде відмічати втрачені комбінації шаблонів повідомленнями попереджень.</p><p>Таким чином, якщо ви пишете ієрархію класів, призначену бути шаблонами для порівняння, вам слід розглянути можливість зробити їх запечатаними. Просто додайте ключове слово sealed перед class нагорі ієрархії. Програмісти, що будуть використовувати вашу ієрархію класів, будуть відчувати зручність при порівнянні за їх участю. Ключове слово sealed, таким чином, часто є ліцензією на порівняння з шаблонами. Лістинг 15.16 показує приклад, в якому Expr перетврений на запечатаний клас.</p>
<pre class="prettyprint linenums language-scala">sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
  left: Expr, right: Expr) extends Expr</pre>
        <p>Лістинг 15.16 Запечатана ієрархія кейс класів.</p><p>Тепер визначимо порівняння шаблонів, де пропущені деякі з кейс класів:</p>
<pre class="prettyprint linenums language-scala">def describe(e: Expr): String = e match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
}</pre>
        <p>Ви можете отримати попередження компілятора, подібне до наступного:</p>
<pre class="prettyprint linenums language-scala">warning: match is not exhaustive!
missing combination UnOp
missing combination BinOp</pre>
        <p>Таке повідомленя каже вам, що існує ризик, що ваш код може спродукувати виключення MatchError, оскількі деякі можливі шаблони ( UnOp, BinOp) не оброблени. Попередження вказує на потенційне джерело збоїв часу виконання, так ща, зазвичай, так що ви запрошені допомогти вашій програмі. Однак, часом ви можете натрапити на ситуацію, коли компілятор дуже прискіпливий, щодо надання попередження. Наприклад, ви можете знати з контекста, що ви напевне застосували метод describe вище для виразів, що не Number, ні Var. Так що ви знаєте, що, фактично, не буде спродуковано MatchError. Щоб попередження пішло, ви можете додати третій випадок все-інше до метода, таким чином:</p>
<pre class="prettyprint linenums language-scala">def describe(e: Expr): String = e match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
  case _ =&gt; throw new RuntimeException // не повинно відбутись
}</pre>
        <p>Це робить, але не є ідеальним. Можливо, ви будете не дуже щастливим від того, що змушені додавати код, що ніколи не буде виконаний (або ви так вважаєте), тільки для того, щоб примовчати компілятор.</p><p>Більш легковісна альтернатива є додати&nbsp; анотацію @unchecked до вираза селектора для match. Це робиться таким чином:</p>
<pre class="prettyprint linenums language-scala">def describe(e: Expr): String = (e: @unchecked) match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
}</pre>
        <p>Анотації описані в Главі 27. Загалом, ви можете додати анотацію до виразу в той же спосіб, що ви додаєте тип: після виразу вкажіть дві крапки, заверште вираз іменем анотації (зі знаком @ спереду). Наприклад, в цьому випадку ви додаєте анотацію @unchecked&nbsp; до змінної e, за допомогою “e: @unchecked”. Анотація @unchecked має особливе значення для порівняння шаблонів. Якщо вираз селектора має цю анотацію, перевірка на вичерпність шаблонів, що слідують за анотацією, буде пригнічено.</p><h3>15.6 Тип Option</h3><p>Scala має стандартний тип з назвою Option для опціональних значень. Таке значення може мати дві форми.&nbsp; Це може бути в формі Some(x), де x є справжнім значенням. Або це може бути об'єкт None, що представляє відсутнє значення.</p><p>Опціональні значення продукуються деякими стандартними операціями на <br>Scala колекціях. Наприклад, метод get в Scala Map продукує Some(value), якщо значення, відповідне до наданого ключа, було знайдене, або None, якщо даний ключ не визначений в Map. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val capitals =
  Map("France" -&gt; "Paris", "Japan" -&gt; "Tokyo")
  capitals: scala.collection.immutable.Map[java.lang.String,
  java.lang.String] = Map(France -&gt; Paris, Japan -&gt; Tokyo)
<br>scala&gt; capitals get "France"
res23: Option[java.lang.String] = Some(Paris)
<br>scala&gt; capitals get "North Pole"
res24: Option[java.lang.String] = None</pre><p>Найбільш загальний спосіб сприймати опціональні значення нарізно є порівняння шаблонів. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def show(x: Option[String]) = x match {
  case Some(s) =&gt; s
  case None =&gt; "?"
}
show: (x: Option[String])String
<br>scala&gt; show(capitals get "Japan")
res25: String = Tokyo
<br>scala&gt; show(capitals get "France")
res26: String = Paris
<br>scala&gt; show(capitals get "North Pole")
res27: String = ?</pre>
        <p>Тип Option часто використовується в Scala програмах. Порівняйте це з домінуючою ідіомою в Java використовувати null, щоб вказати відсутність значення. Наприклад, метод get з java.util.HashMap повертає або значення, що зберігаєтсья в HashMap, або null, якщо значення не знайдене. Цей підхід робить для Java, але схильний до помилок, оскільки на практиці складно відсліджувати, якім змінним в програмі дозволено бути null. Якщо змінній дозволено бути null, тоді ви маєте пам'ятати перевіряти її на null кожного разу, коли використовуєте її. Коли ви забудете перевірити, ви відкриваєте можливість того, що під час виконання все може завершиться NullPointerException. Оскільки такі виключення можуть не траплятись часто, може бути складно винайти помилку на протязі тестування. Для Scala цей підхід зовсім не буде робити, оскільки можливо зберігати типи значення в хеш мапах, але null не є легальним елементом для типу значення. Наприклад, HashMap[Int, Int] не може повертати щоб позначити відсутність елемента.</p><p>На відміну, Scala заохочує використання Option, щоб вказати опціональне значення. Цей підхід опціональних значень має декілька переваг над Java.</p><p>Перше, є значно більш очевидним для читачів кода, що змінна, чий тип є Option[String] є опціональним рядком String, ніж змінна типу String, що іноді може бути null. Але більш важливо, що помилка програмування, описана вище з використанням змінної, що може бути null, якщо перед цім не перевірити її на null, стає в Scala помилкою типу. Якщо змінна є типу Option[String], та ви намагаєтесь використовувати її як String, ваша Scala програма не буде компілюватись.</p><h3>15.7 Шаблони скрізь</h3><p>Шаблони дозволяються в багатьох частинах Scala, не тільки як окремі&nbsp; вирази match. Подивіться на деякі інші місця, де ви можете використовувати шаблони.</p><h4>Шаблони в визначенні змінних</h4><p>Кожного разу, коли ви визначаєте val або var, ви можете використовувати шаблон замість простого ідентифікатора. Наприклад, ви можете зробити це, щоб розбити на частини кортеж, та присвоїти кожну частину окремій змінній, як показано в Лістингу 15.17:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val myTuple = (123, "abc")
myTuple: (Int, java.lang.String) = (123,abc)
<br>scala&gt; val (number, string) = myTuple
number: Int = 123
string: java.lang.String = abc</pre>
        <p>Лістинг 15.17 Визначення декількох змінних за допомогою одного присвоєння.</p><p>Ця конструкція досити корисна при роботі з кейс класами. Якщо ви знаєте точний кейс клас, з яким ви працюєте, тоді ви можете деконструювати його за допомогою шаблона. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val exp = new BinOp("*", Number(5), Number(1))
exp: BinOp = BinOp(*,Number(5.0),Number(1.0))
<br>scala&gt; val BinOp(op, left, right) = exp
op: String = *
left: Expr = Number(5.0)
right: Expr = Number(1.0)</pre>
        <h4>Case послідовності як часткові функції</h4><p>Послідовність випадків (альтернатив) в фігурних дужках можуть бути використані будь-де, де може бути використаний функціональний літерал. Загалом кажучи, послідовність case є функціональним літералом, але більш загальним. Замість мати одну точку входу, та перелік параметрів, послідовність case має декілька точок входу, кожний з власним переліком параметрів. Кожний case є точкою входу до функції, та параметри вказуються за допопмогою шаблона. Тіло кожної точки входа є правою частиною case.</p><p>Ось простий приклад:</p>
<pre class="prettyprint linenums language-scala">val withDefault: Option[Int] =&gt; Int = {
  case Some(x) =&gt; x
  case None =&gt; 0
}</pre>
        <p>Тіло цієї функції має два випадки. Перший випадок співпадає з Some, та повертає число в Some. Другий випадок співпадає з None, та повертає число по замовчанню, нуль. Ось як використовувати цю функцію:</p>
<pre class="prettyprint linenums language-scala">scala&gt; withDefault(Some(10))
res28: Int = 10
<br>scala&gt; withDefault(None)
res29: Int = 0</pre>
        <p>Ця можливість досить корисна для акторської бібліотеки, описаної с Главі 32. Ось деякий типовий код актора. Він передає порівняння шаблона напряму до метода react:</p>
<pre class="prettyprint linenums language-scala">react {
  case (name: String, actor: Actor) =&gt; {
    actor ! getip(name)
    act()
  } 
  case msg =&gt; {
    println("Unhandled message: "+ msg)
    act()
  }
}</pre>
        <p>Одне інше узагальнення: послідовність case дає вам часткову фукцію. Якщо ви застосуєте таку функцію на значенні, яке вона не підтримує, вона згенерує виключення часу виконання. Наприклад, ось часткова функція, що повертає другий елемент зі списку цілих:</p>
<pre class="prettyprint linenums language-scala">val second: List[Int] =&gt; Int = {
  case x :: y :: _ =&gt; y
}</pre>
        <p>Коли ви це скомпілюєте, компілятор буде коректно скаржитись, що порівняння не є вичерпним:</p>
<pre class="prettyprint linenums language-scala">&lt;console&gt;:17: warning: match is not exhaustive!
missing combination
Nil</pre>
        <p>Ця функція буде успішною, якщо ви передасте їй список з трьох елементів, але ні, якщо це буде пустий список:</p>
<pre class="prettyprint linenums language-scala">scala&gt; second(List(5, 6, 7))
res24: Int = 6
<br>scala&gt; second(List())
scala.MatchError: List()
at $anonfun$1.apply(&lt;console&gt;:17)
at $anonfun$1.apply(&lt;console&gt;:17)</pre>
        <p>Якщо ви бажаєте перевірити, чи часткова функція є визначеною, ви маєте спочатку сказати компілятору, що ви знаєте, що робите з частковими функціями. Тип List[Int] =&gt; Int включає всі функції, що відзеркалюють список цілих на ціле, безвідносно, чи є ці функції частковими. Тип, що включає тільки часткові функції зі списків на цілі записуються PartialFunction[List[Int],Int]. Ось знову друга функція, на цей раз записана за допомогою типу з частковою функцією:</p>
<pre class="prettyprint linenums language-scala">val second: PartialFunction[List[Int],Int] = {
  case x :: y :: _ =&gt; y
}</pre>
        <p>Часткові функції мають метод isDefinedAt, що може бути використаний для перевірки, чи функція визначена в окремому значенні. В цьому випадку, функція визначена для любих списків, що має щонайменьше два елементи:</p>
<pre class="prettyprint linenums language-scala">scala&gt; second.isDefinedAt(List(5,6,7))
res30: Boolean = true
<br>scala&gt; second.isDefinedAt(List())
res31: Boolean = false</pre>
        <p>Типовий приклад часткової функції є функціональний літерал співпадіння шаблонів, такий, як в попередньому прикладі. Фактично, такий вираз транслюється компілятором Scala до часткової функції, транслюючи шаблони двічі — один раз для реалізації дійсної функції, та ще раз для перевірки, чи функція визначена, чи ні. Наприклад, функціональний літерал { case x :: y :: _ =&gt; y } вище транслюється до наступного значення часткової функції:</p>
<pre class="prettyprint linenums language-scala">new PartialFunction[List[Int], Int] {
  def apply(xs: List[Int]) = xs match {
    case x :: y :: _ =&gt; y
  }
  def isDefinedAt(xs: List[Int]) = xs match {
    case x :: y :: _ =&gt; true
    case _ =&gt; false
  }
}</pre>
        <p>Ця трансляція має ефект, коли декларований тип функціонального літерала є PartialFunction. Якщо декларований тип є тільки Function1, або відсутній, функціональний літерал замість цього транслюється до повної функції.</p><p>Загалом, вам слідує спробувати робити з повними функціями буде-де, де це можливо, оскільки використання часткових функцій відкриває можливість помилок часу виконання, з якими компілятор не може вам допомогти. Однак іноді часткові функції дійсно корисні. Ви можете переконатись, що необроблене значення ніколи не буде надане. Альтернативно, ви можете використовувати фреймворк, що очікує часткові функції, так що буде завжди перевіряти isDefinedAt перед викликом функції. Приклад останнього є наданий вище приклад react, де аргумент є частково визначеною функцією, визначеною точно для тих повідомлень, що бажає обробити викликач. </p><h4>Шаблони в виразах for</h4><p>Ви також можете використовувати шаблон в виразах for, як показане в Лістингу 15.18. Цей вираз повертає всі пари ключ/значення з мапи capitals. Кожна пара співпадає з заблоном (country, city), що визначає дві змінні,&nbsp; country та city.</p>
<pre class="prettyprint linenums language-scala">scala&gt; for ((country, city) &lt;- capitals)
println("The capital of "+ country +" is "+ city)
<br>The capital of France is Paris
The capital of Japan is Tokyo</pre>
        <p>Лістинг 15.18 Вираз for з шаблоном-кортежем.</p><p>Парний шаблон, показаний на Лістингу 15.18 був особливим, бо паравірко з ним ніколи не схибить. Замість цього, capitals отримує послідовність пар, так що ви можете бути певні, що кожна згенерована пара може бути порівняна з парним шаблоном. Але так сама можливо, що шаблон може не співпасти зі згенерованим значенням.</p><p>Лістинг 15.19 показує приклад, де саме це має місце:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val results = List(Some("apple"), None,
  Some("orange"))
results: List[Option[java.lang.String]] = List(Some(apple),
  None, Some(orange))
<br>scala&gt; for (Some(fruit) &lt;- results) println(fruit)
apple
orange</pre>
        <p>Лістинг 15.19 Вибірка елементів зі списка, що співпадають з шаблоном.</p><p>Як ви можете бачити з цього приклада, згенеровані значення, що не співпадають з шаблоном, відкидаються. Наприклад, другий елемент None в списку results не співпадає з шаблоном Some(fruit); таким чином, він не показаний в результаті.</p><h4>Більший приклад</h4><p>Після того, як ви навчились різних формам шаблонів, ви можете бути зацікавлені в їх застосуванні в більшому прикладі. Запропоноване завдання є написати клас-форматувальник виразів, що відображуєарифметичний вираз в двовимірному розташуванні. Діленя, як “x/(x + 1)” повинне бути роздруковане вертикально, розміщуючи чисельник над знайменником, десь так:</p>
<pre class="prettyprint linenums language-scala">               x<br>             -----<br>             x + 1</pre>
        <p>Як інший приклад, ось вираз ((a / (b * c) + 1 / n) / 3) в двовимірному форматі:</p>
<pre class="prettyprint linenums language-scala">            a     1  
          ----- + -
          b * c   n
          ---------
              3</pre>
        <p>З ціх прикладів виглядає, що клас (нехай назвемо його ExprFormatter) буде в значній мірі жонглювати розташуванням, так що має сенс задіяти бібліотеку розміщення, розроблену в Главі 10. Ми також використаємо родину кейс класів Expr, що ви попередньо бачили в цій главі, та покладемо обоє, бібліотеку розташування з Глави 10, та форматувальник виразів з цієї, до одного іменованого пакунка.&nbsp;</p><p>Повний код для цього приклада буде показаний в Лістингу 15.20 та 15.21. Корисний перший крок є концентрація на горизонтальному розташуванні. Структурований вираз, як:</p>
<pre class="prettyprint linenums language-scala">BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
    Var("z")),
  Number(1))</pre>
        <p>має друкуватись як (x + y) * z + 1. Зауважте, що дужки є обов'язковими довкола x + y, але можуть бути опціональні довкола (x + y) * z . Щоб утримувати розташування виразними, вашою ціллю буде уникати дужок там, де вони надлишкові, при цьому переконавшись, що всі необхідні дужки присутні.</p><p>Щоб знати, де ставити дужки, код має знати щодо відносних преоритетів кожного рператора, так що є гарною ідеєю приладнати спочатку це. Ви можете виразити відносні преоритети напряму як мапу-літерал в наступній формі:</p>
<pre class="prettyprint linenums language-scala">Map(
  "|" -&gt; 0, "||" -&gt; 0,
  "&amp;" -&gt; 1, "&amp;&amp;" -&gt; 1, ...
)</pre>
        <p>Однак, це може включати деяке перед-обчислення ціх преоритетів з вашого боку. Більш зручний підхід є просто визначити групи операторів по наростанню преоритетів, та потім обчислити преоритет оператора на цій основі. Лістинг 15.20 показує код.</p><p>Змінна precedence є мапою з операторів до їх преоритетів, що є цілими від 0. Він обчислюється з використанням виразу for. Перший генератор продукує кожний індекс i масива opGroups. Другий генератор продукує кожний оператор op в opGroups(i). Для кожного такого оператора вираз for дає асоціацію оператора op на його індекс i. Таким чином, відносна позиція оператора в масиві сприймається як його преоритет. Асоціації записані в вигляді інфіксної стрілки, тобто, op -&gt; i. До тепер ви бачили асоціації тільки як частину конструкцій мап, але вони можуть використовуватись і самі по собі. Фактично, асоціація op -&gt; i є нічим іншим, ніж пара (op, i).</p><p>Тепер, коли ми зафіксували преоритети всіх двомісних операторів, крім /,<br>має сенс узагальнити цю концепцію, і також захопити одномісні оператори. Преоритет унарних операторів вищий, ніж преоритет кожного з двомісних операторів. Таким чином ми можемо встановити unaryPrecedence (показаний в Лістингу 15.20) в довжину масива opGroups, що на один більше, ніж преоритет операторів * та %.</p><p>Преоритет дробу трактується інакше, ніж інших операторів, бо дріб використовує вертикальне розташування. Однак буде зручним присвоїти оператору ділення спеціальне значення преоритета, -1, так що ми ініціалізуємо fractionPrecedence до -1 (показано в Лістингу 15.20). Після ціх операцій ви готові записати головний метод форматування. Цей метод приймає два аргументи: вираз e, типу Expr, та преоритет оператора enclPrec,&nbsp; що напряму оточує вираз e (якщо немає оточующого оператора, enclPrec повинне бути нулем). Метод дає елемент розташування, що представляє двовимірний масив символів.</p>
<pre class="prettyprint linenums language-scala">package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem
<br>sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
<br>class ExprFormatter {
<br>// Містить оператори в групах з наростаючим рейтингом
  private val opGroups =
   Array(
     Set("|", "||"),
     Set("&amp;", "&amp;&amp;"),
     Set("ˆ"),
     Set("==", "!="),
     Set("&lt;", "&lt;=", "&gt;", "&gt;="),
     Set("+", "-"),
     Set("*", " % ")
  )
<br>// Відображення операторів на їх преоритети
  private val precedence = {
    val assocs =
    for {
      i &lt;- 0 until opGroups.length
      op &lt;- opGroups(i)
    } yield op -&gt; i
    assocs.toMap
  }
<br>  private val unaryPrecedence = opGroups.length
  private val fractionPrecedence = -1
<br>  private def format(e: Expr, enclPrec: Int): Element =
    e match {
      case Var(name) =&gt;
        elem(name)
      case Number(num) =&gt;
        def stripDot(s: String) =
          if (s endsWith ".0") s.substring(0, s.length - 2)
          else s
          elem(stripDot(num.toString))
      case UnOp(op, arg) =&gt;
        elem(op) beside format(arg, unaryPrecedence)
      case BinOp("/", left, right) =&gt;
        val top = format(left, fractionPrecedence)
        val bot = format(right, fractionPrecedence)
        val line = elem('-', top.width max bot.width, 1)
        val frac = top above line above bot
        if (enclPrec != fractionPrecedence) frac
        else elem(" ") beside frac beside elem(" ")
      case BinOp(op, left, right) =&gt;
        val opPrec = precedence(op)
        val l = format(left, opPrec)
        val r = format(right, opPrec + 1)
        val oper = l beside elem(" "+ op +" ") beside r
        if (enclPrec &lt;= opPrec) oper
        else elem("(") beside oper beside elem(")")
    }
  def format(e: Expr): Element = format(e, 0)
}</pre>
        <p>Лістинг 15.21 Нижня частина форматувальника виразів.</p><p>Лістинг 15.21 наприкінці показує частину класа ExprFormatter, що включає три методи. Перший метод, stripDot, є допомоіжним. Наступний метод, приватний метод format, робить більшість роботи по форматуванню виразів. В останньому методі, також з назвою format, є єдиний публічний метод в бібліотеці, що приймає вираз для форматування. </p><p>Приватний метод format робить свою роботу, виконуючи перевірку шаблона на типі виразу. Вираз match має три випадки. Ми обсудимо їх індивідуально. </p><p>Перший випадок такий:</p>
<pre class="prettyprint linenums language-scala">case Var(name) =&gt;
  elem(name)</pre>
        <p>Якщо вираз є змінною, результатом буде елемент, сформований з імені змінної. </p><p>Другий випадок такий:</p>
<pre class="prettyprint linenums language-scala">case Number(num) =&gt;
  def stripDot(s: String) =
    if (s endsWith ".0") s.substring(0, s.length - 2)
    else s
  elem(stripDot(num.toString))</pre>
        <p>Якщо вираз є число, то результат є елемент, сформований зі значення числа. Функція stripDot прояснює відображення числа з плаваючою крапкою, відкидаючи любі суфікси ".0" з рядка. </p><p>Третій випадок такий:</p>
<pre class="prettyprint linenums language-scala">case UnOp(op, arg) =&gt;
  elem(op) beside format(arg, unaryPrecedence)</pre>
        <p>Якщо вираз є унарною операцією UnOp(op, arg), результат формується з операції op, та результата форматування аргумента arg, з найвищим-можливим преоритетом оточення. Це означає, що якщо arg є двомісним оператором (але не діленням), він завжди буде показаний в лапках.</p><p>Четвертий випадок:</p>
<pre class="prettyprint linenums language-scala">case BinOp("/", left, right) =&gt;
  val top = format(left, fractionPrecedence)
  val bot = format(right, fractionPrecedence)
  val line = elem('-', top.width max bot.width, 1)
  val frac = top above line above bot
  if (enclPrec != fractionPrecedence) frac
  else elem(" ") beside frac beside elem(" ")</pre>
        <p>Якщо вираз є діленням, формуєтья проміжний результат frac, шляхом покладання операндів зліва та зправа один над одним, розділених елементом горизонтальної лінії. Ширина горизонтальної лінії є максимумом з довжин форматованих операндів. Цей проміжний результат також є фінальним, тільки якщо саме ділення не з'являється як аргумент іншого ділення. В останньому випадку додається проміжок з кожного боку від frac.</p><p>Щоб побачити, чому так, розглянемо вираз “(a / b) / c”. Без корекцій розширення форматування цього виразу дасть таке:</p>
<pre class="prettyprint linenums language-scala">          a
          -
          b
          -
          c</pre>
        <p>Проблема з цім розташуванням очевидна — не зрозуміло, де риска ділення вищого рівня. Враз вище може значити або “(a / b) / c”, або “a / (b / c)”. Щоб вирішити неоднозначність, повинно додати проміжок з кожного боку розташування вкладеного ділення “a / b”. Тоді розташування стає однозначним:</p>
<pre class="prettyprint linenums language-scala">          a
          -
          b
         ---
          c</pre>
        <p>П'ятий, та останній, випадок:</p>
<pre class="prettyprint linenums language-scala">case BinOp(op, left, right) =&gt;
  val opPrec = precedence(op)
  val l = format(left, opPrec)
  val r = format(right, opPrec + 1)
  val oper = l beside elem(" "+ op +" ") beside r
  if (enclPrec &lt;= opPrec) oper
  else elem("(") beside oper beside elem(")")</pre>
        <p>Цей випадок стосується всіх двомісних операцій. Оскільки це іде за case, що починається з:</p>
<pre class="prettyprint linenums language-scala">case BinOp("/", left, right) =&gt; ...</pre>
        <p>ви знаєте, що оператор op в шаблоні BinOp(op, left, right) не може бути діленням. Щоб форматувати таку операцію, спершу треба відформатувати її операнди зліва та зправа. Параметр переваги для форматування лівого операнда є opPrec оператора op, тоді як для правого це дещо більше. Ця схема запевняє, що дужки також відзеркалюють коректну асоциативність. Наприклад, операція:</p>
<pre class="prettyprint linenums language-scala">BinOp("-", Var("a"), BinOp("-", Var("b"), Var("c")))</pre>
        <p>буде коректно заточена в дужки як “a - (b - c)”. Потім формується проміжний результат oper, шляхом розміщення поряд форматованих правого та лівого операнда, розділених оператором. Якщо преоритет поточного оператора менший, ніж преоритет оточующого оператора, r покладається в дужки, інакше він повертається як є.</p>
<pre class="prettyprint linenums language-scala">import org.stairwaybook.expr._
<br>object Express extends Application {
  val f = new ExprFormatter
  val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),
  <br>  BinOp("+", Var("x"), Number(1)))
  val e2 = BinOp("+", BinOp("/", Var("x"), Number(2)),
  <br>  BinOp("/", Number(1.5), Var("x")))
  val e3 = BinOp("/", e1, e2)
  <br>  def show(e: Expr) = println(f.format(e)+ "\n\n")
  <br>  for (e &lt;- Array(e1, e2, e3)) show(e)
}</pre>
        <p>Лістинг 15.22 Застосування, що друкує форматовані вирази.</p><p>Це завершує розробку приватної функції форматування. Єдиний метод, що залишився, є публічний метод format, що дозволяє програміста клієнтів форматувати вирази вищого рівня без надання аргумента precedence. Лістинг 15.22 показує демо програму, що тренує ExprFormatter.</p><p>Зауважте, що, хоча ця програма не визначає метод main, це все ж таки є застосуванням, оскільки він наслідує від трейта Application. Як зазначалось в Розділі 4.5, трейт Application просто визначає пустий метод main, що був унаслідуваний об'єктом Express. Справжня робота в об'єкті Express робиться як частина ініціалізації об'єкта, перед тим, як виконається метод main. Ось чому ви можете застосувати цей трюк тільки якщо ваша програма не сприяє жодних аргументів командного рядка. Як тільки з'явились аргументи, вам треба писати метод main явно. Ви можете запустити програму Express такою командою:</p>
<pre class="prettyprint linenums language-scala">scala Express</pre><p>Це дасть такий результат:</p>
<pre class="prettyprint linenums language-scala">            1
            - * (x + 1)
            2<br><br>            x   1.5
            - + ---
            2    x

            1
            - * (x + 1)
            2
            -----------
              x   1.5
              - + ---
              2    x

</pre>
        <h3>15.9 Висновок</h3><p>В цій главі ви в деталях вивчили кейс класи Scala, та порівняння шаблонів. З їх використанням ви можете отримати переваги від декількох стислих ідіом, що звичайно недоступні в об'єктно-орієнтовних мовах. Однак співпадіння шаблонів Scala іде далі, ніж описує ця глава. Якщо ви бажаєте використовувати співпадіння шаблонів для ваших класів, але не бажаєте відкривати доступ до ваших класів таким чином, як це роблять кейс класи, тоді ви можете використовувати екстрактори, описані в Главі 26. Однак в наступній главі ми повернемо нашу увагу до списків.</p><h3>

        Глава 16</h3><h2>Робота зі списками</h2>Списки, мабуть, найбільш загально уживані структури даних в програмах на Scala. Ця глава пояснює списки в деталях. Вона представляє багато загальних операцій, що можуть бути виконані зі списками. Вона також навчить деяким важливим принципам розробки для програм, що роблять зі списками.<br><h3>16.1 Спискові літерали</h3>Ви вже бачили списки в попередніх главах, так що ви знаєте, що список, який складається з елементів 'a', 'b', та 'c' записується List('a', 'b', 'c'). Ось деякі інші приклади:<br>
<pre class="prettyprint linenums language-scala">val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
  List(
    List(1, <br>0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
val empty = List()
</pre>
<p>Списки досить подібні до масивів, але є дві важливі різниці. Перше, списки є незмінними. Тобто елементи списку ніколи не можуть бути змінені через присвоєння. Друге, списки мають рекурсивну структуру (тобто, списки зв'язані), тоді як масиви пласкі.</p><h3>16.2 Тип списків</h3><p>Як і масиви, списки є гомогенними: елементи списку завжди того ж самого типу. Тип списку, що має елементи типу T, записується як List[T]. Наприклад, ось ті ж чотири списки з явно заданими типуми: </p>
<pre class="prettyprint linenums language-scala">val fruit: List[String] = List("apples", "oranges", "pears")
<br>val nums: List[Int] = List(1, 2, 3, 4)
<br>val diag3: List[List[Int]] =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
<br>val empty: List[Nothing] = List()</pre>
        <p>Список в Scala є коваріантним. Це означає, що для кожної пари типів S та T, якщо S є субтипом до T, тоді List[S] є субтипом для List[T]. Наприклад, List[String] є субтипом до List[Object]. Це є природним, бо кожний список рядків може також розглядатись як список об'єктів.</p><p>Зауважте, що пустий список має тип List[Nothing]. Ви бачили в Розділі 11.3, що Nothing є низом ієрархії класів Scala. Це є субтипом для кожного іншого типу Scala. Оскільки список є коваріантним, з цього слідує, що List[Nothing] є субтипом до List[T] для кожного тупа T. Так що об'єкт пустого списка, що має тип List[Nothing], може також розглядатись як об'єкт кожного іншого типу в формі List[T]. Ось чому припустимо записати наступний код:</p>
<pre class="prettyprint linenums language-scala">// List() також є типом List[String]!
val xs: List[String] = List()</pre><h3>
16.3 Конструювання списків</h3>Всі списки побудовані на двох фундаментальних блоках, Nil та :: (вимовляється “cons”). Nil представляє пустий список. Інфіксний оператор :: виражає додавання до початку списка. Тобто x :: xs представляє список, чий перший елемент є x, за яким слідують елементи списку xs. Таким чином попередні значення списків також можуть бути визначені так:<br>
<pre class="prettyprint linenums language-scala">val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
  (0 :: (1 :: (0 :: Nil))) ::
    (0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
</pre>
<p>Фактично, попередні визначення fruit, nums, diag3, та empty в термінах List(...) є тільки огорткою, що розширюється до ціх визначень. Наприклад, List(1, 2, 3) створює список 1 :: (2 :: (3 :: Nil)). Оскільки це завершується на дві крапки, оператор :: асоціюється зправа: A :: B :: C інтерпретується як A :: (B :: C). Таким чином ви можете відкинути дужки в попередньому визначенні. Наприклад:</p>
<pre class="prettyprint linenums language-scala">val nums = 1 :: 2 :: 3 :: 4 :: Nil</pre>
        <p>є еквівалентним до попереднього визначення nums. Всі операції зі списками можуть бути виражені в термінах наступних трьох:</p><p>head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; повертає перший елемент зі списка</p><p>tail&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; повертає список, що складається з усіх елементів, за винятком першого</p><p>isEmpty&nbsp;&nbsp;&nbsp; повертає true, якщо список пустий</p><p>Ці операції визначені як методи класа List. Деякі приклади показані в Таблиці 16.1.</p><p>Таблиця 16.1 Базові операції зі списками</p>
        <pre class="prettyprint linenums language-scala">      &nbsp;&nbsp; <strong>Операція</strong>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  <strong>Що повертає</strong>
        empty.isEmpty       true
        fruit.isEmpty       false 
        fruit.head         "apples"
        fruit.tail.head    "oranges"
        diag3.head       List(1, 0, 0)</pre>
<p>Методи head та methods are defined only for non-empty lists. When<br>selected from an empty list, they throw an exception. For instance:</p>
<pre class="prettyprint linenums language-scala">scala&gt; Nil.head 
java.util.NoSuchElementException: head of empty list</pre>
        <p>Як приклад того, як можуть бути оброблені списки, розглянемо сортування елементів списка в зростаючому порядку. Один простий шлях зробити це є сортування вставкою, що робить таким чином: щоб відсортувати непустий список x :: xs, сортувати залишок xs, та вставити перший елемент x в потрібну позицію результата. Сортування пустого списка дає пустий список. Виражене в коді Scala, алгоритм сортування вставкою виглядає так:</p>
<pre class="prettyprint linenums language-scala">def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
<br>def insert(x: Int, xs: List[Int]): List[Int] =
  if (xs.isEmpty || x &lt;= xs.head) x :: xs
  else xs.head :: insert(x, xs.tail)
</pre><h3>
16.5&nbsp; Шаблони списків</h3>Списки також можуть бути розділені на частини через порівняння шаблонів. Шаблони списків відповідають виразам списка один-за-одним. Ви можете або порівнювати на всіх елементах списка, з використанням шаблона в формі List(...), або ви розділяєте список на частки один-за-одним, використовуючи шаблони, що складаються з оператора :: та константи Nil. Ось приклад першого типу шаблона:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears
</pre>
<h4>Щодо шаблонів порівняння зі списками</h4><p>Якщо ви переглядаєте можливі форми шаблонів, що описані в Главі 15, ви можете винайти, що ні List(...), ані :: не пасують до різновидів шаблонів, що визначені тут. Фактично, List(...) є примірником визначеного в бібліотеці шаблону екстрактора. Такі шаблони будуть трактуватись в Главі 26. Шаблон “cons” x :: xs є спеціальним випадком шаблона інфіксної операції. Ви вже знаєте, що коли розглядається як вираз, інфіксна операція еквівалентна до виклику метода. Для шаблонів правило інше: коли розглядається як шаблон, інфіксна операція, такая як p op q, еквівалентна до op(p, q). Таким чином, інфіксний оператор op трактується як шаблон конструктора. Зокрема, шаблон cons, такий як x :: xs, трактується як ::(x, xs). Це підказка, що десь має бути клас на ім'я ::, що відповідає шаблону конструктора. Очевидно десь має бути такий клас. Він називається scala.::, та є саме тим класом, що будує непусті списки. Так що :: існує в Scala двічі, один раз як ім'я класу в пакунку scala, та ще раз як метод в класі List. Ефект метода :: полягає в тому, щоб створювати&nbsp; примірник класа scala.::. Ви знайдете більше щодо того, як реалізований клас List, в Главі 22.</p><p>Шаблон List(a, b, c) співпадає зі списками довжини 3, та прив'язує три елементи до змінних шаблона, a, b, та c. Якщо ви не знаєте число елементі заздалегідь, краще замість цього порівнювати за допомогою ::. Наприклад, шаблон a :: b :: rest співпадає зі списками довжини 2 або більше:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)</pre>
        <p>Брати списки частками за допомогою шаблонів є альтернативою до їх розподілу за допомогою базових методів, head, tail, та isEmpty. Наприклад, ось знову сортування вставкою, на цей раз написаний за допомогою порівняння шаблонів:</p>
<pre class="prettyprint linenums language-scala">def isort(xs: List[Int]): List[Int] = xs match {
  case List() =&gt; List()
  case x :: xs1 =&gt; insert(x, isort(xs1))
}
<br>def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() =&gt; List(x)
  case y :: ys =&gt; if (x &lt;= y) x :: xs
  else y :: insert(x, ys)
}
</pre>
Часто порівняння шаблонів зі списками є чистішим, ніж декомпозиція їх за допомогою методів, так що порівняння шаблонів повинне бути часткою вашого інструментарію роботи зі списками.<br><br>Це все, що вам треба знати щодо списків в Scala, щоб бути в змозі використовувати їх коректно. Однак ще є велике число методів, що охоплюють загальні шаблони операцій над списками. Ці методи роблять програми обробки списків більш стислими та чистими. Наступні два розділи презентують найбільш важливі методи, визначені для класа List.<br><br><h3>16.6&nbsp; Методи першого порядку на класі List</h3>Цей розділ пояснює більшість методів першого порядку, визначених в класі List. Метод є першого порядку, якщо він не приймає жодних функцій як аргументів. Розділ також вводить шляхом двох прикладів деякі рекомендовані прийоми для структурування програм, що оперують списками. <br><h4>Конкатенація двох списків</h4>Операція, подібна до ::, є конкатенація, що записується як ‘:::’. На відміну від&nbsp; ::, ::: приймає два списки в якості операндів. Результат xs ::: ys є новий список, що містить всі елементи xs, за якими ідуть всі елементи ys. Ось декілька прикладів:<br>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)
<br>scala&gt; List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)
<br>scala&gt; List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)</pre>
<p>Як і cons, конкатенація списків асоціюється зправа. Вираз як цей:</p>
<pre class="prettyprint linenums language-scala">xs ::: ys ::: zs</pre>
        <p>інтерпретується таким чином:</p>
<pre class="prettyprint linenums language-scala">xs ::: (ys ::: zs)</pre>
        <h4>Принцип Розділюй та Захоплюй</h4><p>Конкатенація (:::) реалізована як метод в класі List. Також можливо реалізувати конкатенацію "власноруч", з використанням порівнянь шаблонів зі списками. Є корисним спробувати реалізовати це самому, бо це показує загальний шлях для реалізації алгоритмів, що використовують списки. Перше, поглянемо на сигнатуру метода конкатенації, що ми називаємо append. Щоб не дуже змішувати все докупи, уявімо, що append визначена за межами класа List.</p><p>Так що ми маємо два списка, що ми маємо конкатенувати, як параметри. Ці два списки мають домовитись щодо типів ебементів, але цей тип елементів може бути довільним. Це може бути виражене, надавши append тип parameter3, що представляє тип елементів двох вхідних списків:</p>
<pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T]</pre>
        <p>Щоб розробити реалізацію append, треба згадати принцип розробки “діли та захоплюй” для програм з рекурсивними структурами даних, як списки. Багато алгоритмів зі списками спочатку розділяють ввод на простіші випадки за допомогою порівнять шаблонів. Це частина Розділяй нашого принципа. Потім вони конструюють результат для кожного випадка. Якщо результат є непустим списком, деякі з його частин можуть бути сконструйовані через рекурсивні виклики того ж самого алгоритма. це частина Захоплюй нашого принципа.&nbsp;</p><p>Щоб застосувати цей принцип до реалізації метода append, перше питання, що треба задати, це з чим порівнювати списки. Це менш тривіально в випадку append, ніж для багатьох інших методів, оскільки є два вибори. Однак наступна фаза “захоплюй” каже вам, що вам треба конструювати список, що складаєтсья з усіх елементів обох вхідних списків. Оскільки списки складаються з кінця до початку, ys може залишатись без змін, тоді як xs буде потребувати розбиття на частини, та передування до ys. Таким чином, має сенс сконцентруватись на xs як на джерелі для співпадіння шаблонів. Найбільш загальний шаблон зі списками є просте розділення списків на порожні та непорожні. Так що це дає наступний контур метода append:</p>
<pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T] =
xs match {
  case List() =&gt; // ??
  case x :: xs1 =&gt; // ??
}</pre>
        <p>Все що залишилось, це заповнити два місця, позначені як “??”. Перше таке місце є альтернатива, де вхідний список xs порожній. В цьому випадку конкатенацію дає другий список:</p>
<pre class="prettyprint linenums language-scala">case List() =&gt; ys</pre>
        <p>Друге місце, що залишилось відкритим, є альтернатива, де вхідний список xs складається з деякої голови x, за якою іде хвіст xs1. В цьому випадку результат також є непустий список. Щоб сконструювати непорожній список, вам треба знати, що за голова та хвіст в цього списка має бути. Ви знаєте, що перший елемент результуючого списка є x. Щодо залишку елементів, це може бути обчислено додаванням залишку першого списку, xs1, до другого списку ys. Це завершує розробку, і дає наступне:</p>
<pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List() =&gt; ys
    case x :: xs1 =&gt; x :: append(xs1, ys)
  }</pre>
        <p>Обчислення другої альтернативи ілюструює частину "захоплюй" загального принципу: спочатку думайте, який образ бажаного результату повинен бути, потім обчисліть окремі частини цього образу, в потрібних місцях використовуючи рекурсивні виклики. Нарешті, сконструюйте результат з ціх частин.</p><h4>Отримання довжини списку: length</h4><p>Метод length обчислює довжину списка.</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3).length
res3: Int = 3</pre>
        <p>Для списків, на відміну від масивів, довжина є досить коштовною операцією. Вона вимагає пройти цілий список, щоб знайти його кінець, та, таким чином, приймає час, пропорційний числу елементів у списку. Ось чому це не гарна ідея замінити перевірку, таку як&nbsp; xs.isEmpty, на xs.length == 0. Цей результат двох перевірок однаковий, але другий повільніший, особливо якщо список xs довгий.</p><h4>Доступ до кінця списка: init та last</h4><p>Ви вже знаєте базові операції head та tail, що, відповідно, бере перший елемент зі списку та залишок списку, окрім першого елементу. Кожна має подвійну дію: остання повертає останній елемент з (не-порожнього) списку, тоді як init повертає список, що складається з усіх елементів, за винятком першого:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val abcde = List('a', 'b', 'c', 'd', 'e')
abcde: List[Char] = List(a, b, c, d, e)
<br>scala&gt; abcde.last
res4: Char = e
<br>scala&gt; abcde.init
res5: List[Char] = List(a, b, c, d)</pre>
        <p>Як head та tail, ці методи підіймають виключення, коли застосовуються до порожнього списку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List().init
java.lang.UnsupportedOperationException: Nil.init
at scala.List.init(List.scala:544)
at ...
<br>scala&gt; List().last
java.util.NoSuchElementException: Nil.last
at scala.List.last(List.scala:563)
at ...
</pre>
<p>На відміну від head та tail, що обоє роблять сталий час, init та last перейти весь список, щоб обчислити свій результат. Вони, таким чином, приймали час пропорційний до довжини списка. Це гарна ідея організувати ваші дані, так щоб більшість доступа була до голови списка, скоріше ніж до останнього елемента.&nbsp;</p><h4>Реверс списка: reverse</h4><p>Якщо в деякій точці обчислень алгоритм вимагає частого доступу до кінця списку, іноді краще спочатку реверсувати (обернути) список, та робити з результатом замість цього. Ось як робити реверс-обертання:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde.reverse
res6: List[Char] = List(e, d, c, b, a)</pre>
        <p>Зауважте, що як і всі інші операції зі списками, реверс створює новий список, скоріше ніж модифікувати той, з яким працює. Оскільки список незмінний, така зміна неможлива в любому випадку. Щоб перевірити це, перевірте, що&nbsp; оригінальне значення abcde не змінене після операції реверсу:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde
res7: List[Char] = List(a, b, c, d, e)</pre>
        <p>Операції reverse, init, та last відповідають деяким правилам, що можуть бути використані для міркувань щодо обчислень та спрощення програм.</p><p>1. reverse є власною протилежністю:<br>&nbsp;&nbsp;&nbsp; xs.reverse.reverse&nbsp; equals&nbsp; xs</p><p>2. reverse перетворює init на tail, та last на head, та всі елементи також обернені:</p><p>xs.reverse.init&nbsp;&nbsp;&nbsp; equals&nbsp; xs.tail.reverse<br>xs.reverse.tail&nbsp;&nbsp;&nbsp; equals&nbsp; xs.init.reverse<br>xs.reverse.head&nbsp; equals&nbsp; xs.last<br>xs.reverse.last&nbsp;&nbsp;&nbsp; equals&nbsp; xs.head</p><p>Реверс може бути реалізований з використанням конкатенації (:::), як наступний метод, rev:</p>
<pre class="prettyprint linenums language-scala">def rev[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; xs
  case x :: xs1 =&gt; rev(xs1) ::: List(x)
}</pre>
        <p>Однак цей метод менш ефективний, ніж деяко міг би спобіватись. Щоб вивчити складність rev, уявіть, що список xs має довжину n. Зауважте, що існують n рекурсивних викликів до rev. Кожний виклик очікує, окрім останнього, включає конкатенацію списків. Конкатенація списків xs ::: ys забирає час, пропорційний до довжини свого першого аргумента xs. Таким чином, загальна складність rev є:</p>
<pre class="prettyprint linenums language-scala">n + (n − 1) + ... + 1 = (1 + n) ∗ n/2</pre>
        <p>Іншими словами, складність rev є квадратом до довжини своїх вхідних аргументів. Це несподівано, в порівнянні з стандартним реверсом змінного зв'язаного списка, що має лінійну складність. Однак поточна реалізація rev не є кращою можливою реалізацією. Ви побачите в Розділі 4 як можна її прискорити.</p><h4>Префікси та суфікси: drop, take та splitAt</h4><p>Операції drop та take узагальнюють tail та init в тому, що вони повертають довільні префікси та суфікси списка. Вираз “xs take n” повертає перші n елементів зі списка xs. Якщо n більше ніж xs.length, повертається цілий список xs. Операція “xs drop n” повертає всі елементи списку xs, за винятком перших n. Якщо n більше, ніж xs.length, повертається пустий список. Операція splitAt розділяє список по заданому індексові, повертаючи пару з двох списків. Це показує така рівність:</p><p>xs splitAt n&nbsp; equals (xs take n, xs drop n)</p><p>Однак splitAt уникає мандрувати списком xs двічі. Ось деякі приклади ціх трьох методів:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde take 2
res8: List[Char] = List(a, b)
<br>scala&gt; abcde drop 2
res9: List[Char] = List(c, d, e)
<br>scala&gt; abcde splitAt 2
res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))</pre>
        <h4>Вибір елементів: apply та indices</h4><p>Вибір випадкового елементу підтримується через метод apply; однак це менш загальна операція для списків, ніж для масивів.</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde apply 2 // рідке в Scala
res11: Char = c</pre>
        <p>Для всіх інших типів apply вставляється неявно, коли об'єкт з'являється в позиції функції в виклику метода, так що вище може бути скорочене до такого:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde(2)
&nbsp;// рідке в Scala
res12: Char = c</pre>
        <p>Одна з причин, чому вибір довільного елемента менш популярний, ніж для масивів, в тому, що xs(n) забирає часу пропорційно до індексу n. Фактично, apply просто визначена як комбінація з drop та head:</p>
<pre class="prettyprint linenums language-scala">xs apply n&nbsp; ~ (xs drop n).head</pre>
        <p>Це визначення також ясно дає зрозуміти, що списки індексуються з нуля до довжини списку мінус один, так само, як і масиви. Метод indices повертає список, що містить всі допустимі індекси поточного списку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde.indices
res13: scala.collection.immutable.Range =
Range(0, 1, 2, 3, 4)</pre>
        <h4>Спрямлення списка списків: flatten</h4><p>Метод flatten приймає список зі списків, та спрямляє його в один список:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(List(1, 2), List(3), List(), List(4, 5)).flatten
res14: List[Int] = List(1, 2, 3, 4, 5)
scala&gt; fruit.map(_.toCharArray).flatten
res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,
                          s, p, e, a, r, s)</pre>
        <p>ВІн може бути застосований тільки до списків, чиї всі елементи також списки. Спроба спрями любий інший список викличе помилку компілятора:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3).flatten
&lt;console&gt;:5: error: could not find implicit value for
parameter asTraversable: (Int) =&gt; Traversable[B]
List(1, 2, 3).flatten
ˆ
</pre><h4>Складання списків: zip та unzip</h4><p>Операція zip приймає два списки, та формує список з пар:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde.indices zip abcde
res17: scala.collection.immutable.IndexedSeq[(Int, Char)] =
  IndexedSeq((0,a), (1,b), (2,c), (3,d), (4,e))</pre>
        <p>Якщо два списки різної довжини, любі неспівпадаючі елемент відкидаються:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val zipped = abcde zip List(1, 2, 3)
zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))</pre>
        <p>Корисний спеціальний випадок zip є список з його індексами. Це робиться більш ефективно за допомогою метода zipWithIndex, що парує кожний елемент списка з позицією, на якій він знаходиться в списку.</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde.zipWithIndex
res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3), (e,4))</pre>
        <p>Любий список пар може бути змінений назад, до пари&nbsp; списків, використовуючи метод unzip:</p>
<pre class="prettyprint linenums language-scala">scala&gt; zipped.unzip
res19: (List[Char], List[Int]) = (List(a, b, c),List(1, 2, 3))</pre>
        <p>Методи zip та unzip провадять один шлях для операцій над декількома списками разом. Дивіться Розділ 16.9 пізніше в цій главі щодо способу, що іноді може бути коротшим.&nbsp;</p><h4>Відображення списків: toString та mkString</h4><p>Операція toString повертає канонічний рядок, що представляє список:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde.toString
res20: String = List(a, b, c, d, e)</pre>
        <p>Якщо ви бажаєте інше представлення, ви можете використати метод mkString. Операція xs mkString (pre, sep, post) включає чотири операнда: список для відображення xs, рядок префікса pre, що буде відображатись перед всіма елементами, рядок роздільника sep, що буде відображатись між сусідніми елементами, на рядок-постфікс, що буде відображатись в кінці. Результат операції буде рядок у такому вигляді:</p>
<pre class="prettyprint linenums language-scala">pre + xs(0) + sep + . . . + sep + xs(xs.length - 1) + post</pre>
        <p>Метод mkString має два перевантажені варіанти, що дозволяють вам відкинути деякі, або всі його аргументи. Перший варіант приймає тільки рядок роздільника:</p>
        <pre class="prettyprint linenums language-scala">xs mkString sep ~ xs mkString ("", sep, "")</pre>
        <p>Другий варіант дозволяє нам відкинути всі аргументи:</p>
<pre class="prettyprint linenums language-scala">xs.mkString ~ xs mkString ""</pre>
        <p>Ось деякі приклади:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde mkString ("[", ",", "]")
res21: String = [a,b,c,d,e]
<br>scala&gt; abcde mkString ""
res22: String = abcde
<br>scala&gt; abcde.mkString
res23: String = abcde
<br>scala&gt; abcde mkString ("List(", ", ", ")")
res24: String = List(a, b, c, d, e)</pre>
        <p>Є також варіанти методів mkString, названі addString, що додають сконструйований рядок до об'єкта StringBuilder, скоріше, ніж повертати його як результат:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val buf = new StringBuilder
buf: StringBuilder =
scala&gt; abcde addString (buf, "(", ";", ")")
res25: StringBuilder = (a;b;c;d;e)</pre>
        <p>Методи mkString та addString наслідуються від супертрейта List, Traversable, так що вони стосуються всіх інших колкцій, також.</p><h4>Перетворення списків: iterator, toArray, copyToArray</h4><p>Щоб конвертувати дані між пласким світом масивів, та рекурсивним світом списків, ви можете використовувати метод toArray в класі List, та toList в класі Array:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val arr = abcde.toArray
arr: Array[Char] = Array(a, b, c, d, e)
<br>scala&gt; arr.toList
res26: List[Char] = List(a, b, c, d, e)</pre>
        <p>Є також метод copyToArray, що копіює елементи до послідовних позицій в деякому цільовому масиві. Операція:</p><p>xs copyToArray (arr, start) </p><p>копіює елементи списка xs в масив arr, починаючи з позиції start. Ви повинні переконатись, що цільовий масив arr досить великий для утримання цілого списка. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val arr2 = new Array[Int](10)
arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
scala&gt; List(1, 2, 3) copyToArray (arr2, 3)
scala&gt; arr2
res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)</pre>
        <p>Нарешті, якщо вам треба отримати доступ до елементів списка через ітератор, ви можете використовувати метод iterator:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val it = abcde.iterator
it: Iterator[Char] = non-empty iterator</pre>
<pre class="prettyprint linenums language-scala">scala&gt; it.next
res29: Char = a
scala&gt; it.next
res30: Char = b</pre>
        <h4>Приклад: сортування злиттям</h4><p>Сортування вставкою, що представлене раніше, стисле в написанні, але не дуже ефективне. Його середня складність пропорційна квадрату довжини вхідного списку. Більш ефективний алгоритм є сортування злиттям.</p><h4>Швидке орієнтування</h4><p>Цей приклад провадить іншу ілюстрацію принципу розділяй та захоплюй та карування, а також надає корисну дискусію щодо складності алгоритмів. Однак якщо ви бажаєте рухатись трохи швидше при першому прочитанні цієї книги, ви можете безпечно перейти до Розділу 16.7.</p><p>Сортування злиттям робить наступним чином: зпершу, якщо список має нуль або один елемент, він вже впорядкований, так що список можна повертати бе ззмін. Довші списки поділяються на два підсписка, кожний містить близько половини елементів оригінального списка. Кожний підсписок сортується рекурсивним викликом до функції sort, та отримані два відсортованих списки потім комбінуються операцією злиття. </p><p>Для загальної реалізації сортування злиттям ви залишаєте відкритим тип елементів списка, що буде сортуватись, та також залишаєте відкритою функцію, що буде використана для порівняння елементів. Ви отримаєте максимально загальну функцію, передаючи ці два елементи як параметри. Це призводить до реалізації, показаної в Лістингу16.1.</p><p>Складність msort має порядок (n log(n)), де n є довжина вхідного списка. Щоб побачит чому це так, зауважте, що поділення списка на два, та злиття двох списків займає час, пропорційний до довжини списка-аргумента. Кожний рекрсивний виклик msort поділяє навпіл число елементів у вхідному списку, так що буде близько log(n) послідовних рекурсивних викликів, доки не буде досягнуто базового випадку зі списків довжиною 1. Однак для довших списків кожний виклик утворює два інших виклики. Додаючи все докупи, ми отримуємо, що на кожному з log(n) рівней виклику, кожний елемент оригінальних списків бере участь в одній операції розділення, та в одній операції злиття. Таким чином, кожний рівень має загальну складність, пропорційну n. Оскільки загалом log(n) рівней виклику, ми отримуємо загальну вартість, пропорційну до n log(n). Ця вартість не залежить від початкового розподілення елементів </p>
<pre class="prettyprint linenums language-scala">def msort[T](less: (T, T) =&gt; Boolean)
(xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) =&gt; ys
      case (_, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (less(x, y)) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
<br>  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(msort(less)(ys), msort(less)(zs))
  }
}</pre><p>Лістинг 16.1 Функція сортування злиттям для List.</p><p>в цьому списку, так що найгірший випадок ціни є такий же, що і ціна середнього випадка. Ця властивість робить сортування злиттям ефективним алгоритмом для сортування списків. Ось приклад, як використовується msort:</p>
<pre class="prettyprint linenums language-scala">scala&gt; msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 1, 3))
res31: List[Int] = List(1, 3, 5, 7)</pre>
        <p>Функція msort є класичним прикладом концепції карування, що обговорюється в Розділі 9.3. Карування робить простішим уточнити функцію до окремих функцій порівняння. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val intSort = msort((x: Int, y: Int) =&gt; x &lt; y) _
intSort: (List[Int]) =&gt; List[Int] = &lt;function1&gt;</pre>
        <p>Змінна intSort посилається на функцію, що приймає список цілих, та сортирує їх за значенням. Як описано в Розділі 8.6, підкреслення означає відсутній список аргументів. В цьому випадку відсутній артумент є список, що має бути відсортований. Як інший приклад, ось як ви можете визначити функцію, що сортує список цілих в зворотньому порядку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val reverseIntSort = msort((x: Int, y: Int) =&gt; x &gt; y) _
reverseIntSort: (List[Int]) =&gt; List[Int] = &lt;function&gt;</pre>
        <p>Оскільки завдяки каруванню ви вже надали функцію порівняння, тепер вам треба тільки надати список для сортування, коли ви викликаєте функції intSort або reverseIntSort. Ось деякі приклади: </p>
<pre class="prettyprint linenums language-scala">scala&gt; val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
mixedInts: List[Int] = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
<br>scala&gt; intSort(mixedInts)
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
<br>scala&gt; reverseIntSort(mixedInts)
res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</pre>
        <h3>16.7&nbsp; Методи вищого порядка на класі List</h3><p>Багато операторів зі списками мають подібну структуру. Деякі шаблони з'являються раз за разом. Ось деякі приклади: трансформація кожного елемента зі списка в деякий спосіб, перевірка, чи справджується деяка властивість для всіх елементів зі списку, виділення зі списку елементів, що задовільняють деякому критерію, або комбіювання елементів списка за допомогою деякого оператора. В Java такі шаблони звичайно виражені в ідиоматичних комбінаціях циклів for або while. В Scala вони можуть бути виражені більш стисло, на напряму використовуючи оператори вищіх порядків, що реалізовані як методи класа List. Ці оператори вищого порядка обговорюються в цьому розділі.</p><h4>Відображення списків: map, flatMap та foreach</h4><p>Операція xs map f приймає в якості операндів список xs типу List[T], та функцію f типу T =&gt; U. Вона повертає список, що утворений через застосування функції f до кожного елементу списка xs. Наприклад: </p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) map (_ + 1)
res32: List[Int] = List(2, 3, 4)
<br>scala&gt; val words = List("the", "quick", "brown", "fox")
words: List[java.lang.String] = List(the, quick, brown, fox)
<br>scala&gt; words map (_.length)
res33: List[Int] = List(3, 5, 5, 3)
<br>scala&gt; words map (_.toList.reverse.mkString)
res34: List[String] = List(eht, kciuq, nworb, xof)</pre>
        <p>Оператор flatMap подібний до map, але він приймає функцію, що повертає список елементів в якості правого операнда. Він застосовує функцію до кожного елемента списка, та повертає конкатенацію всіх результатів функції. Різниця між map та flatMap проілюстрована в наступному прикладі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; words map (_.toList)
res35: List[List[Char]] = List(List(t, h, e), List(q, u, i,
c, k), List(b, r, o, w, n), List(f, o, x))
<br>scala&gt; words flatMap (_.toList)
res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w,
n, f, o, x)</pre>
        <p>Ви бачите, що коли map повертає список списків, flatMap повертає один список, в якому всі списки-елементи конкатеновані. Різниця та взаємовідносини між map та flatMap також продемонстровані в наступному виразі, що конструює список з усіх пар, що (i, j), де 1 ≤ j &lt; i &lt; 5:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List.range(1, 5) flatMap (
i =&gt; List.range(1, i) map (j =&gt; (i, j)))
res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),
(4,2), (4,3))</pre>
        <p>List.range є допоміжним методом, що створює список з усіх цілих в деякому диапазоні. Він використовується двічі в цьому прикладі: один раз для генерації списка цілих від 1 (включно) до 5 (виключно), та другий раз для генерації списка цілих від 1 до i, для кожного значення i, взтого з першого списка. Метод map в цьому виразі генерує список кортежів (i, j), де j &lt; i. Зовнішній flatMap в цьому прикладі генерує цей список для кожного i між 1 та 5, та потім конкатенує всі результати. </p><p>Зауважте, що той же список альтернативно може бути зконкатенований за допомогою вираза for:</p>
<pre class="prettyprint linenums language-scala">for (i &lt;- List.range(1, 5); j &lt;- List.range(1, i)) yield (i, j)</pre>
        <p>Ви пізнаєте більше щодо взаємодії виразів for та оперцій зі списками в Главі 23. Третя подібна до map операція є foreach. Однак на відміну від map та flatMap, foreach приймає процедуру (функцію з результатом Unit) в якості правого операнда. Вона просто застосовує процедуру до кожного елемента. Результатом самої операції є знову Unit; новий список не збирається з результатів. Як приклад, ось стислий шлях підсумку всіх чисел в списку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; var sum = 0
sum: Int = 0
scala&gt; List(1, 2, 3, 4, 5) foreach (sum += _)
scala&gt; sum
res39: Int = 15</pre>
        <h4>Фільтрація списків: filter, partition, find, takeWhile, dropWhile, та span</h4><p>Операція xs filter p приймає як операнди список xs типу List[T], та функцію-предикат p типу T =&gt; Boolean. Вона дає список з усіх елементів x з xs, для яких which p(x) є true. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) filter (_ % 2 == 0)
res40: List[Int] = List(2, 4)
scala&gt; words filter (_.length == 3)
res41: List[java.lang.String] = List(the, fox)</pre>
        <p>Метод partition подібний до filter, але він повертає пару списків. Один список містить всі for, для яких предикат є true, тодя як інший список містить всі елементи, для яких предикат є false. Це визначається такою еквівалентністю:</p><p>xs partition p ~ (xs filter p, xs filter (!p(_)))</p><p>Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) partition (_ % 2 == 0)
res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))</pre>
        <p>Метод find також подібний до filter, але він повертає перший елемент, що задовільняє предикату, скоріше, ніж всі такі елементи. Операція xs find p приймає список xs та предикат p в якості операндів. Він повертає опціональне значення. Якщо є елемент x в xs, для якого p(x) є true, повертається Some(x). Інакше p є false для всіх елементів, та повертається None. Ось деякі приклади:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) find (_ % 2 == 0)
res43: Option[Int] = Some(2)
scala&gt; List(1, 2, 3, 4, 5) find (_ &lt;= 0)
res44: Option[Int] = None</pre>
        <p>Оператори takeWhile та dropWhile також приймають предикат як свій правий операнд. Операція xs takeWhile p вибирає найдовший префікс зі списка xs, так що кожний елемент з цього префікса задовільняє p. Аналогічно, операція xs dropWhile p видаляє найбільший префікс зі списка xs, де кожний елемент з цього префікса задовільняє p. Ось деякі приклади:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, -4, 5) takeWhile (_ &gt; 0)
res45: List[Int] = List(1, 2, 3)
<br>scala&gt; words dropWhile (_ startsWith "t")
res46: List[java.lang.String] = List(quick, brown, fox)</pre>
        <p>Метод span комбінує takeWhile та dropWhile в одній операції, так само, як splitAt комбінує take та drop. Він повертає пару з двох списків, що визначені еквівалентністю:</p><p>xs span p ~ (xs takeWhile p, xs dropWhile p)</p><p>Як і splitAt, span уникає перебігу списка xs двічі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, -4, 5) span (_ &gt; 0)
res47: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))</pre>
        <h4>Предикати над списками: forall та exists</h4><p>Операція xs forall p приймає в якості аргументів список xs та предикат p. Її результат є true, якщо всі елементи в списку задовільняють p. Відповідно, операція xs exists p повертає true, якщо існує елемент в xs, що задовільняє предикату p. Наприклад, щоб знайти, чи матриця, представлена як список списків, має рядок з тільки нульовими елементами:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def hasZeroRow(m: List[List[Int]]) =
m exists (row =&gt; row forall (_ == 0))
hasZeroRow: (m: List[List[Int]])Boolean
scala&gt; hasZeroRow(diag3)
res48: Boolean = false</pre>
        <h4>Згортання списків: /: та :\</h4><p class="prettyprint linenums language-scala">Інша загальна категорія операцій комбінує всі елементи зі списку за допомогою деякого оператора. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">sum(List(a, b, c)) ~ 0 + a + b + c</pre>
        <p class="prettyprint linenums language-scala">Це спеціальний примірник операції fold:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def sum(xs: List[Int]): Int = (0 /: xs) (_ + _)
        sum: (xs: List[Int])Int</pre>
        <p class="prettyprint linenums language-scala">Подібно до цього:</p><p class="prettyprint linenums language-scala">product(List(a, b, c)) ~ 1 * a * b * c</p><p
class="prettyprint linenums language-scala">є спеціальним примірником цієї операції:</p><p
class="prettyprint linenums language-scala">scala&gt; def product(xs: List[Int]): Int = (1 /: xs) (_ * _)<br>product: (xs: List[Int])Int</p><p
class="prettyprint linenums language-scala">Згортання вліво, операція (z /: xs) (op), включає три об'єкти: початкове значення z, список xs, та двомісну операцію op. Результат fold є op, застосований між сусідніми елементами списка, де з початку стоїть z. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">(z /: List(a, b, c)) (op) ~ op(op(op(z, a), b), c)</pre>
        <p>Ось інший приклад, що ілюструє, як використовується /:. Щоб канкотенувати всі слова в списку рядків через проміжок між ними та попереду, ви можете записати це:</p>
<pre class="prettyprint linenums language-scala">scala&gt;
&nbsp;("" /: words) (_ +" "+ _)
res49: java.lang.String =
&nbsp;the quick brown fox</pre>
<p class="prettyprint linenums language-scala">Це дає додатковий проміжок на початку. Щоб видалити цей проміжок, ви можете використати невелику варіацію:</p>
<pre class="prettyprint linenums language-scala">scala&gt; (words.head /: words.tail)
&nbsp;(_ +" "+ _)
res50: java.lang.String = the quick brown fox</pre>
        <p class="prettyprint linenums language-scala">Оператор /: продукує ліво-орієнтовані дерева операцій (його синтаксис з косою, що здимається вперед, має бути відображенням цього). Оператор має аналог :\, що продукує право-орієнтовані дерева операцій. Наприклад: </p>
<pre class="prettyprint linenums language-scala">(List(a, b, c) :\ z) (op)&nbsp; ~&nbsp; op(a, op(b, op(c, z)))</pre>
        <p>Операція :\ промовляється як права згортка. Це включає ті ж три операнди, що і ліва згортка, але перші два виступають в зворотньому порядку: першим іде список, що буде згортатись, другим початкове значення. </p><p
class="prettyprint linenums language-scala">Для асоціативних операцій права та ліва згортки є еквівалентними, але може бути різниця в продуктивності. Розглянемо, наприклад, операцію, що відповідає методу спрямлення, що конкатенує всі елементи в списку списків. Це може бути реалізовано або зі згортанням вліво, або вправо:</p>
<pre class="prettyprint linenums language-scala">def flattenLeft[T](xss: List[List[T]]) =
&nbsp; (List[T]() /: xss) (_ ::: _)
def flattenRight[T](xss: List[List[T]]) =
(xss :\ List[T]()) (_ ::: _)</pre>
<p>Оскільки конкатенація списків xs ::: ys забирає час, пропорційний до його першого аргумента xs, реалізація в термінах правої згортки в flattenRight більш ефктивна, ніж реалізація через згортку вліво в flattenLeft. Проблема в тому, що flattenLeft(xss) копіює перший елемент списку xss.head n−1 разів, де n є довжиною списка xss.</p>
        <p>Зауважете, що обидві версії require потребують анотацій типу на порожньому списку, що є початковим значенням згортання. Це відбувається через обмеженість в виводі типів Scala, що не може вивести коректний тип списка автоматично. Якщо ви спробуєте відкинути ці анотації, ви отримаєте наступне:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def flattenRight[T](xss: List[List[T]]) =
(xss :\ List()) (_ ::: _)
&lt;console&gt;:5: error: type mismatch;
found<br>&nbsp;: scala.List[T]
required: List[Nothing]
(xss :\ List()) (_ ::: _)
ˆ</pre>
<p class="prettyprint linenums language-scala">Щоб з'ясувати, що трапилось з виводом типів, вам треба знати щодо типів методів згортки, та як вони реалізовані. Більше про це в Главі 22.</p>
<p>Нарешті, хоча оператори /: та :\ мають перевагу через те, що напрямок косої надає графічний образ їх відповідних правого та лівого дерева, та асоціативність двох крапок покладає початкове значення в ту ж позицію в виразі що і в дереві, дехто може винайти отриманий код не дуже інтуітивним. Якщо ви бажаєте, в якості альтернативи використовувати методи foldLeft та foldRight, що також визначені в класі List.</p>
<p>Приклад: реверс List за допомогою fold. Раніше в главі ви бачили реалізацію метода reverse, що називався rev, чий час виконання був квадратичним до довжини списку, що обертався. Ось інша реалізація reverse, що має лінійну ціну. Ідея в використанні операції лівого згортання, на основі наступної схеми:</p>
<pre class="prettyprint linenums language-scala">def reverseLeft[T](xs: List[T]) = (startvalue /: xs)(operation)</pre>
        <p>Тільки залишається заповнити стартове значення та операцію. Фактично ви можете спробувати вивести ці частини з деяких простих прикладів. Щоб вивести коректні значення для startvalue, ви можете почати з найменьшого можливого списка, List(), та обчислити наступне:</p><p>List() ~ (за властивістю reverseLeft) </p><p>reverseLeft(List()) ~ (за шаблоном для reverseLeft)</p><p>(startvalue /: List())(operation) ~ (за визначенням /:)&nbsp; startvalue</p><p>Таким чином, startvalue має бути List(). Щоб вивести другий операнд, ви можете взяти другий найменьший список як випадок для приклада. Ви вже знаєте, що startvalue є List(), так що ви можете обчислити наступне:</p><p>List(x) ~ (за властивістю reverseLeft)<br>reverseLeft(List(x)) ~ (за шаблоном для reverseLeft, коли startvalue = List())<br>(List() /: List(x)) (operation) ~ (за визначенням /:) operation(List(), x)</p><p>Таким чином, operation(List(), x) ~ List(x), що може також бути записане як x :: List(). Це підказує брати в якості операції оператор :: з переставленими операндами (ця операція іноді називається snoc, по відношенню до ::, що називається cons). Тоді ми приходимо до такої реалізації reverseLeft:</p>
        <pre class="prettyprint linenums language-scala">def reverseLeft[T](xs: List[T]) = (List[T]() /: xs) {(ys, y) =&gt; y :: ys}</pre>
        <p>(Знову, анотація в List[T]() потрібна, щоб зробити виведення типів дієздатним). Якщо ви проаналізуєте складність reverseLeft, ви винайдете, що вона застосовує операцію зі сталим часом, snoc, n разів, де n є довжиною списка аргументів. Таким чином, складність reverseLeft є лінійною, як ми і сподівались.&nbsp;</p><h4>Сортування списків: sortWith</h4><p>Операція xs sortWith before, де “xs” є списком, та “before” є функцією, що може використовуватись для порівняння двох елементів, сортує елементи списку xs. Вираз x before y має повертати true, якщо x має бути попереду y в потрібному порядку сортування. Наприклад: </p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, -3, 4, 2, 6) sortWith (_ &lt; _)
res51: List[Int] = List(-3, 1, 2, 4, 6)
scala&gt; words sortWith (_.length &gt; _.length)
res52: List[java.lang.String] = List(quick, brown, the, fox)</pre>
        <p>Зауважте, що sortWith виконує сортування злиттям, подібне до алгоритма msort, показаного в останньому розділі, але sortWith є методом класа List, тоді як msort був визначений за межами списків. </p><h3>16.8 Методи об'єкта List</h3><p>До тепер всі операції, що ми бачили в цій главі, були реалізовані як методи класа List, так що ми викликали їх на окремих об'єктах списків. Також є декілька методів в глобально доступному об'єкті scala.List, що є об'єктом-компанйоном до List. Деякі з ціх операцій є методи-фабрики, що створюють списки. Інші є операціями, що роблять зі списками певним чином. Обоє типи методів будуть представлені в цьому розділі. Створити список з його елементів: List.apply, що ви вже бачили при деякій нагоді як літерали списків, List(1, 2, 3). В їх синтаксисі немає нічого особливого. Літерал як List(1, 2, 3) є простим застосуванням об'єкта List до елементів 1, 2, 3. Тобто, це еквівалентно до List.apply(1, 2, 3):</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List.apply(1, 2, 3)<br>res53: List[Int] = List(1, 2, 3)</pre>
      <h4>Створення списку цілих: List.range</h4><p>Метод range, що ви бачили похапцем в цій главі, коли дискутували map та flatmap, створює список, що складається з диапазону чисел. Його найпростіша форма List.range(from, until), що створює списк з усіх чисел, починаючи з from, та ідучи далі до until мінус один. Так що останнє значення, until, не є частиною диапазона. Також є версія range, що приймає довжину кроку як третій параметр. Ця операція буде давати список елементів, що стоять на крок один від одного, починаючи з from. Крок може бути додатний або від'ємний:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List.range(1, 5)
res54: List[Int] = List(1, 2, 3, 4)
scala&gt; List.range(1, 9, 2)
res55: List[Int] = List(1, 3, 5, 7)
scala&gt; List.range(9, 1, -3)
res56: List[Int] = List(9, 6, 3)</pre>
        <h4>Створення одноманітних списків: List.fill</h4><p>Метод fill створює лист, що складається з нуля або більше копій того ж самого елемнета. Він прикмає два параметри: довжину списку, що треба створити, та елемент, що треба повторювати. Кожний параметр надається в окремому списку:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List.fill(5)('a')
res57: List[Char] = List(a, a, a, a, a)
scala&gt; List.fill(3)("hello")
res58: List[java.lang.String] = List(hello, hello, hello)</pre>
        <p>Якщо fill отримує більше ніж два аргументи, тоді він створює багатовимірні списки. Тобто він створює список списків, і так далі. Додаткові аргументи ідуть до першого списку аргументів.</p>
<pre class="prettyprint linenums language-scala">scala&gt; List.fill(2, 3)('b')
res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))</pre>
        <h4>Функція табуляції: List.tabulate</h4><p>Метод tabulate створює список, чиї елементи обчислюються відповідно до наданої функції. Вона має такі ж аргументи, що і List.fill: перший аргумент надає розміри створюваного списку, та другий описує елементи списку. Єдиною відмінністю є те, що замість сталих елементів вони обчислюються через функцію:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val squares = List.tabulate(5)(n =&gt; n * n)
squares: List[Int] = List(0, 1, 4, 9, 16)
scala&gt; val multiplication = List.tabulate(5,5)(_ * _)
multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))</pre>
        <h4>Конкатенація декількох списків: List.concat</h4><p>Метод concat конкатенує декілька елементів списків. Списки, що мають конкатенуватись, надаються як прямі аргументи до concat:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List.concat(List('a', 'b'), List('c'))
res60: List[Char] = List(a, b, c)
scala&gt; List.concat(List(), List('b'), List('c'))
res61: List[Char] = List(b, c)
scala&gt; List.concat()
res62: List[Nothing] = List()</pre>
        <h3>16.9&nbsp; Одночасна обробка декількох списків</h3><p>Метод zipped над кортежами поєднує декілька загальних операцій для роботи з декількоми списками, замість одного. Одна така операція є map. Метод&nbsp; map для двох поєднаних списків відображує пари елементів, замість окремих елементів. Одна пара є для першого елемента кожного списка, інша пара для другого елемента кожного списка, і так далі&nbsp; — стільки пар, яка довжина списків. Ось приклад її використання:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; (List(10, 20), List(3, 4, 5)).zipped.map(_ * _)
res63: List[Int] = List(30, 80)</pre>
        <p>Зауважте, що третій елемент в другому списку відкинутий. Метод zipped поєднує тільки стільки елементів, скільки існує в обох списках. Всі зайві елементи в кінці будуть відкинуті. Є також поєднуючі алалоги для exists та forall. Вони такі самі, як і версії ціх методів для одного списка, за тим винятком, що вони роблять з декількома спискми, замість одного:</p>
<pre class="prettyprint linenums language-scala">scala&gt; (List("abc", "de"), List(3, 2)).zipped.
|<br>&nbsp;forall(_.length == _)
res64: Boolean = true
scala&gt; (List("abc", "de"), List(3, 2)).zipped.|
&nbsp;exists(_.length != _)
res65: Boolean = false</pre>
        <h4>Швидка орієнтація</h4><p>В наступному (та заключному) розділі цієї глави ми надамо погляд на алгоритм інтерфейсу типів Scala. Ви можете безпечно пропустити цілий розділ, якщо вас наразі не цікавлять такі деталі, та прямо перейти до висновків.</p><h3>16.10&nbsp; Розуміння алгоритму інтерфейсу типів Scala</h3><p>Одна різниця між попередніми використаннями sortWith, та msort, стосується&nbsp; прийнятних синтаксичних форм функції порівняння. Порівняйте: </p>
<pre class="prettyprint linenums language-scala">scala&gt; msort((x: Char, y: Char) =&gt; x &gt; y)(abcde)
res66: List[Char] = List(e, d, c, b, a)</pre>
        <p>з:</p>
<pre class="prettyprint linenums language-scala">scala&gt; abcde sortWith (_ &gt; _)
res67: List[Char] = List(e, d, c, b, a)</pre>
        <p>Два вирази еквівалентні, але перший використовує довшу форму функції порівняння з іменованими параметрами та явними типами, тоді як друга використовує стислу форму, (_ &gt; _), де іменовані параметри замінені на підкреслення. Звичайно, ви також можете використовувати першу, довшу форму разом з sortWith. Однак коротша форма не може використовуватись з msort:</p>
<pre class="prettyprint linenums language-scala">scala&gt; msort(_ &gt; _)(abcde)
&lt;console&gt;:12: error: missing parameter type for expanded
function ((x$1, x$2) =&gt; x$1.$greater(x$2))
msort(_ &gt; _)(abcde)
ˆ</pre>
        <p>Щоб зрозуміти чому, вам треба знати деякі деталі алгоритмі виведення типів Scala. Виведеня типів в Scala базується на потоці. В застосуванні метода&nbsp; m(args), алгоритм виводу спочатку перевіряє, чи метод m має знаний тип. Якщо це так, цей тип використовується для виведення очікуваного типу аргументів. Наприклад, в abcde.sortWith(_ &gt; _), тип abcde є List[Char], і, таким чином, sortWith заздалегідь буде методом, що приймає аргумент типу (Char, Char) =&gt; Boolean, та продукує результат типу List[Char]. Оскільки, таким чином, відомі параметри типів аргументів функції, їх можна не писати явно. З тим, що відомо про sortWith, алгоритм може дійти висновку, що (_ &gt; _) повинно розширюватись до ((x: Char, y: Char) =&gt; x &gt; y), де x та y є деякі довільні нові імена.</p><p>Тепер розглянемо другий випадок, msort(_ &gt; _)(abcde). Тип msort є карований, поліморфний тип методу, що приймає аргумент типу (T, T) =&gt; Boolean до функції від List[T] до List[T], де T є деякий, ще невідомий тип. Метод msort потребує бути втілений з параметром типа, перед тим, як зможе застосовуватись до своїх аргументів. Оскільки точний тип примірника msort в застосуванні все ще невідомий, він не може бути використаний для виведення типу його першого аргументу. Вивід типів змінює свою стратегія в цьому випадку; він спочатку перевіряє типи аргументів метода, щоб визначити відповідний примірник типів метода. Однак, маючи завдання перевірити типи скороченого функціонального літерала, (_ &gt; _), він схибить, оскільки він не має інформації щодо типів неявний параметрів функції, що вказані як підкреслення. Одним способом розрішити проблему є передати явні типи параметрів до msort:</p>
<pre class="prettyprint linenums language-scala">scala&gt; msort[Char](_ &gt; _)(abcde)
res68: List[Char] = List(e, d, c, b, a)</pre>
        <p class="prettyprint linenums language-scala">Оскільки коректний тип msort тепер відомий, він може бути використаний для виведення типів аргументів. Інше можливе рішення є переписати метод msort, так щоб його параметри обмінялись місцями:</p>
        <pre class="prettyprint linenums language-scala">def msortSwapped[T](xs: List[T])(less:
        (T, T) =&gt; Boolean): List[T] = {
        // та ж реалізація msort,
        // але з перестановкою аргументів
        }</pre>
        <p class="prettyprint linenums language-scala">Тепер виведення типів спрацює:</p>
<pre class="prettyprint linenums language-scala">scala&gt; msortSwapped(abcde)(_ &gt; _)
res69: List[Char] = List(e, d, c, b, a)</pre>
        <p class="prettyprint linenums language-scala">Що трапилось, це те, тепер вивід знає тип першого параметра, abcde, щоб визначити параметр типу msortSwapped. Коли стає відомий точний тип msortSwapped, він може використовуватись в свою чергу для виведення типу другого параметру, (_ &gt; _).</p>
        <p>Загалом, коли стоїть завдання вивести тип параметрів поліморфного метода, алгоритм виведення консультується з типами усіх значень аргументів в першому списку параметрів, але не в аргументфх за його межами. Оскільки msortSwapped є карованим методом з двома списками параметрів, другий аргуент, (тобто, значення функції) не буде братись до уваги для визначення параметра типу метода.</p>
        <p>Ця схема виведення підказує наступний принцип розробки бібліотек: при розробці поліморфних методів, що приймають деякі нефункціональні аргументи, розміщуйте функціональні аргументи останніми в карованому списку параметрів, окремо. Таким чином коректний примірник метода може бути виведений з нефункціональних аргументів, та цей тип, в свою чергу,&nbsp; може бути використаний для перевірки функціонального аргумента. Нетто ефект полягає в тому, що користувачі метода будуть в змозі надати меньше інформації про тип, та записати функціональні літерали в більш компактний спосіб.</p>
        <p>Далі перейдемо до більш складного випадку операції fold. Чому тут є потреба в явному параметрі типу, в виразі, як тіло метода flattenRight?</p>
<pre class="prettyprint linenums language-scala">(xss :\ List[T]()) (_ ::: _)</pre>
        <p>Тип операції правої згортки поліморфний в двох змінних типу. Маючи вираз:</p>
<pre class="prettyprint linenums language-scala">(xs :\ z) (op)</pre>
      <p>тип xs має бути списком дефкого довільного типу A, скажімо, xs: List[A]. Початкове значення z може бути деякого іншого типу B. Операція op потім має приймати два аргументи типу A та B, та мусить повертати результат типу B, тобто, op: (A, B) =&gt; B. Оскільки тип z не пов'язаний з типом списку xs, вивід типу не має контекстної інформації щодо z. Тепер розглянемо вираз в помилковій версії flattenRight:</p>
<pre class="prettyprint linenums language-scala">(xss :\ List()) (_ ::: _)
&nbsp;// це не компілюється</pre>
<p>Початкове значення z в цій згортці є пустий список, List(), так що без додаткової інформації типу його тип виводиться з як List[Nothing]. Таким чином, вивід буде виводити цей тип B згортки як List[Nothing]. Таким чином, операція (_ ::: _) згортки очікується наступного типу: </p>
<pre class="prettyprint linenums language-scala">(List[T], List[Nothing]) =&gt; List[Nothing]</pre>
        <p>Хоча це можливий тип для операції, такої як fold, але він не дуже корисний! Він каже, що операція завжди приймає пустий список в якості другого аргумента, та завжди продукує пустий список, як результат. Іншими словами, вивід типів дуже рано пристав щодо типу List(), він би мав зачекати, доки не побачив би тип операції op. Таким чином (інакше дуже корисне правило) розглядати тільки перший розділ аргументів застосування карованого метода для визначення типу метода тут полягає як корінь проблеми. З іншого боку, навіть якщо це правило послабити, вивід не зможе виступити з типом щодо op, тому що типи її параметрів все ще не надані. Тобто це замкнене коло, що можна розрішити тільки через явну анотацію типу від програміста.</p><p
class="prettyprint linenums language-scala">Цей приклад підкреслює деякі обмеження локальної, базованої на потоці, схеми виведення Scala. Їх немає в більш глобальному стилі виводу Хіндлі-Мілнера, що використовується в мовах як ML або Haskell. Однак локальний вивід типів Scala робить значно добріше з об'єктно-орієнтовними підтипами, ніж це робить стиль Хіндлі-Мілнера. На щастя, показані обмеження виявляють себе тільки в в деяких граничних випадках, та зазавичай просто ладнаються додаванням явних анотацій типу.</p><p>Додавання анотацій типу також є корисним прийомом налагодження, коли ви спантеличені помилками невірних типів, пов'язаних з поліморфними методами. Якщо ви не певні щодо того, що спричиняє певну помилку типу, просто додайте деякі аргументи типів, або інші анотації типів, що ви вважаєте за коректні. Потім ви будете в змозі швидко побачити, де є реальна проблема.</p><h3>16.11 Висновок</h3><p>Тепер ви побачили багато способів роботи зі списками. Ви бачили базові операції, як head та tail, операції першого порядка, як reverse, операції вищого порядка, як map, та допоміжні методи в об'єкті List.</p><p>Поміж тим ви трохи вивчили щодо того, як роблять типізовані інтерфейси Scala. Списки є дійсно робочою конячкою в Scala, так що ви виграєте від знання, як їх використовувати. З цієї причини ця глава глибоко занурилась в використання списків. Однак списки є тільки одним різновидом колекцій, що підтримує&nbsp;Scala. Наступна глава є ширшою, скоріше, ніж глибокою, та показує вам, як використовувати різновидь типів колекцій в Scala. </p><h3>Глава 17</h3><h2>Колекції</h2><p>Scala має багату бібліотеку колекцій. Ця глава надає тур по найбільш загально уживаних типах та операцій колекцій, показаних як частини, що ви будете уживати найбільш часто. Глава 24 надасть більш повний тур того, що доступне, та Глава Chapter 25 покаже, як використовуються конструкції композиції Scala, щоб провадити таке багате API.</p><h3>17.1&nbsp; Послідовності</h3><p>Типи послідовностей дозволяють вам робити з групами даних, що вистроєні в порядок. Оскільки ві елементи впорядковані, ви можете запитати перший елемент, другий елемент, 103й елемент, і таке інше. В цьому розділі ви отримаєте швидкий тур по найбільш важливим послідовностям. </p><h4>Списки</h4><p>Можливо, найбільш важливий тип послідовності, про який слід знати, є клас List, незмінний пов'язаний список, детально описаний в попередній главі. Списки підтримують швидке додавання та видалення елементів зпереду списка, але вони не провадять швидкого доступа до довільних індексів, бо реалізація має лінійно ітерувати по всьому списку.</p><p>Ця комбінація можливостей може видатись безглуздою, але вони підпадають в солодке поєднання, що гарно робить для більшості алгоритмів. Швидке додавання та видалення перших елементів означає, що гарно робить також і порівняння шаблонів, як описано в Главі 15. Незмінність списків допомагає вам розробляти коректні, ефективні алгоритми, оскільки вам ніколи не потрібно робити копії списків. Ось простий приклад, що показує, як ініціалізувати список, та отримати доступ до голови та хвоста:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val colors = List("red", "blue", "green")
colors: List[java.lang.String] = List(red, blue, green)
scala&gt; colors.head
res0: java.lang.String = red
scala&gt; colors.tail
res1: List[java.lang.String] = List(blue, green)</pre>
        <p>Для вступу до списків дивіться Крок 8 в Главі 3, та щодо деталей по використанню списків, дивіться Главу 16. Списки також будуть обговорюватись в Главі 22, що провадить погляд на те, як списки реалізовані в Scala.</p><h4>Масиви</h4><p>Масиви дозволяють вам утримувати послідовність елементів, та ефективно мати доступ до елемента в довільній позиції, отримуючи доступ або оновлюючи елемент, з індексом починаючи з одиниці. Ось як ви можете створити масив, чий розмір ви знаєте, але для якого ви ще не знаєте значень елементів: </p>
<pre class="prettyprint linenums language-scala">scala&gt; val fiveInts = new Array[Int](5)
fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)</pre>
        <p>Ось як ви ініціалізуєте масив, коли ви знаєте значення елементів:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val fiveToOne = Array(5, 4, 3, 2, 1)
fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)</pre>
        <p>Як вже зазначалось, доступ до масивів в Scala виконується заданням індекса в дужках, не в квадрантих дужкак, я в Java. Ось приклад обох, доступу та оновлення елементів масива:</p>
<pre class="prettyprint linenums language-scala">scala&gt; fiveInts(0) = fiveToOne(4)
scala&gt; fiveInts
res3: Array[Int] = Array(1, 0, 0, 0, 0)</pre>
        <p>Масиви Scala представлені так само, як і масиви Java. Так що ви можете безпомилково використовувати методи Java, що повертають масиви. Різниця в варіації масивів Scala та Java — тобто, коли Array[String] є підтипом Array[AnyRef] — буде обговорено в Розділі 19.3.</p><p>Ви вже бачили масиви в дії багато разів в попередніх главах. Основи надаі в Кроці 7 Глави 3. Декілька прикладів ітерування по елементах списку за допомогою вираза for показані в Розділі 7.3. Масиви також яскраво фігурують в бібліотеці двовимірного розташування в Главі 10.</p><h4>Буфери списків</h4><p>Клас List провадить швидкий доступ до голови списка, але не до кінця. Таким чином, коли вам треба побудувати список через додавання в кінець, ви маєте розглянути побудову списку навпаки, додаючи елементи в початок, докі не скінчите, викликаючи reverse, для отримання елементів в потрібному для вас порядку. Інша альтернатива, що уникає операції реверсу, є використання ListBuffer. ListBuffer є змінним об'єктом (що міститься в пакунку&nbsp; scala.collection.mutable), що може допомогти вам побудувати списки більш ефективно, коли вам треба додавати. ListBuffer провадить сталий час для операцій append та prepend. Ви додаєте елементи за допомогою оператора +=, та передставляєте за допомогою оператора +=:. Коли ви завершуєте побудову, ви можете отримати List через виклик toList на ListBuffer. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer
<br>scala&gt; val buf = new ListBuffer[Int]
buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()
<br>scala&gt; buf += 1
res4: buf.type = ListBuffer(1)
<br>scala&gt; buf += 2
res5: buf.type = ListBuffer(1, 2)
<br>scala&gt; buf
res6: scala.collection.mutable.ListBuffer[Int]
= ListBuffer(1, 2)
<br>scala&gt; 3 +=: buf
res7: buf.type = ListBuffer(3, 1, 2)
<br>scala&gt; buf.toList
res8: List[Int] = List(3, 1, 2)</pre>
        <p>Інша причина для використання ListBuffer замість List є запобігти потенціальному ризику переповнення стека. Якщо ви будуєте список в бажаному порядку через передстанову, але рекурсивний алгоритм, що вам потрібен, не є кінцево-рекурсивним, ви можете замість цього використовувати вираз for або цикл while, та ListBuffer. Ви побачите ListBuffer, що використовується в такий спосіб, в Розділі 22.2.</p><h4>Буфери масивів</h4><p>ArrayBuffer подібні до масивів, за тим винятком, що ви додатково можете додавати та видаляти елементи з початку та кінці послідовності. Доступні всі операції Array, хоча вони трохи повільніші, через шар огортки в реалізації. Нові операції додавання та видалення в середньому мають сталий час, але часом потребують лінійний час, через те, що реалізація має розміщувати новий масив, що утримує вміст буфера. Щоб використовувати ArrayBuffer вам треба спершу імпортувати пакунок змінних колекцій:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.ArrayBuffer</pre>
        <p>Коли ви створюєте ArrayBuffer, ви маєте задати параметр типу, але не повинні задавати довжину. ArrayBuffer буде підлаштовувати розміщений простір автоматично, по мірі потреби:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val buf = new ArrayBuffer[Int]()
buf: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer()</pre>
        <p>Ви можете додавати до ArrayBuffer за допомогою метода +=:</p>
<pre class="prettyprint linenums language-scala">scala&gt; buf += 12
res9: buf.type = ArrayBuffer(12)
<br>scala&gt; buf += 15
res10: buf.type = ArrayBuffer(12, 15)
<br>scala&gt; buf
res11: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer(12, 15)</pre>
        <p>Доступні всі методи звичайних масивів. Наприклад, ви можете запитати довжину ArrayBuffer, але ви можете отримати елемент за його індексом:</p>
<pre class="prettyprint linenums language-scala">scala&gt; buf.length
res12: Int = 2
scala&gt; buf(0)
res13: Int = 12</pre><h4>Рядки (через StringOps)</h4><p>Одна інша послідовність, про яку треба знати, є StringOps, що реалізує багато методів послідовностей. Оскільки Predef має неявне перетворення з String на StringOps, ви можете трактовати любий рядок як послідовність. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpper)
hasUpperCase: (s: String)Boolean
<br>scala&gt; hasUpperCase("Robert Frost")
res14: Boolean = true
<br>scala&gt; hasUpperCase("e e cummings")
res15: Boolean = false</pre>
        <p>В цьому прикладі метод exists викликається для рядка на ім'я s в тілі метода hasUpperCase. Оскільки немає метода з назвою “exists”, задекларованого для самого класа String, компілятор Scala буде неявно конвертувати s на StringOps, що має такий метод. Метод exists розглядає рядок як послідовність символів, та буде повертати true, якжо любий з символів в верхньому реєстрі.</p><h3>17.2 Множини та мапи</h3><p>Ви вже бачили основи множин та мап в попередніх главах, починаючи з Кроку 10 в Главі 3. В цьому розділі ми отримаємо більше розуміння щодо їх використання, та покажемо трохи більше прикладів. Як вже зазначалось, бібліотека колекцій Scala пропонує обоє, змінні та незмінні версії множин та мап. Ієрархія для множин показана на Малюнку 3.2, та ієрархія для мап показана на Малюнку 3.3. Як показують ці діаграми, прості імена Set та Map використовуються в трьох трейтах кожне, що знаходяться в різних пакунках.</p><p>По замовчанню, коли ви пишете “Set” або “Map”, ви отримуєте незмінний об'єкт. Якщо ви бажаєте змінний варіант, вам треба виконати явний імпорт. Scala дає вам простіший доступ до незмінних варіантів, в якості м'якого заохочення до їх використання, ніж змінних варіантів. Простий дступ провадяться через об'єкт Predef, що неявно імпортований в кожний файл&nbsp; програми Scala. Лістинг 17.1 показує відповідні визначення:</p>
<pre class="prettyprint linenums language-scala">object Predef {
  type Map[A, +B] = collection.immutable.Map[A, B]
  type Set[A] = collection.immutable.Set[A]
  val Map = collection.immutable.Map
  val Set = collection.immutable.Set
// ...
}</pre>
        <p>Лістинг 17.1 Мапи та множини по замовчанню, визначення в Predef.</p><p>Ключове слово “type”, що використовується в Predef для визначення псевдонимів Set та Map для довших, більш повно кваліфікованих імен трейтів незмінних множин та мап. Змінні val на ім'я Set та Map ініціалізовані для посилання на об'єкти-синглтони для незмінних Set та Map. так що Map є те ж саме, що Predef.Map, що визначене бути тим самим, що і scala.collection.immutable.Map. Це дійсне для типа Map, та об'єкта Map.</p><p>Якщо ви бажаєте використати обоє, змінні та незмінні множини та мапи в одному файлі, один підхід є імпортувати ім'я пакунку, що містить змінні варіанти:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable</pre>
        <p>Ви можете продовжувати посилатись на незмінні множини як Set, як і раніше, але можете тепер посилатись на змінні множини, як mutable.Set. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val mutaSet = mutable.Set(1, 2, 3)
mutaSet: scala.collection.mutable.Set[Int] = Set(3, 1, 2)</pre>
        <h3>Розділ 17.2 Використання множин</h3><p>Ключова характеристика множин полягає в тому, що вони дають впевненість, що кожний окремий об'єкт, як визначається ==, буде міститись в множині в кожний проміжок часу. Як приклад, ми будемо використовувати множину для підрахунка різних слів в рядку.&nbsp;</p><p>Метод split в String може розділити рядок на слова, якщо ви зададете проміжки та знаки пунктуації як роздільники. Регулярний вираз “[ !,.]+” буде достатній: він вказує, що рядок має бути розбитий в кожному місці, де стоїть проміжок або символи пунктуації:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val text = "See Spot run. Run, Spot. Run!"
text: java.lang.String = See Spot run. Run, Spot. Run!
scala&gt; val wordsArray = text.split("[ !,.]+")
wordsArray: Array[java.lang.String]
= Array(See, Spot, run, Run, Spot, Run)</pre>
        <p>Щоб порахувати різні слова, ви можете перевести їх в один реєстр, та потім доодати до множини. Оскільки множина виключає дублювання, кожне окреме слово буде з'являтись в множині рівно один раз. Спершу ви можете створити порожню множину, з використанням порожнього метода, що провадить об'єкт-компан'он Set:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val words = mutable.Set.empty[String]
words: scala.collection.mutable.Set[String] = Set()</pre>
        <p>Потім просто ітеруємо по словах за допомогою вираза for, конвертуючи кожне слово в змінний набір за допомогою оператора +=:</p>
<pre class="prettyprint linenums language-scala">scala&gt; for (word &lt;- wordsArray)
words += word.toLowerCase
scala&gt; words
res17: scala.collection.mutable.Set[String]
= Set(spot, run, see)</pre>
        <p>Таким чином, текст містить рівно три різні слова: spot, run, та see. Найбільш загально уживані методи на обох, змінних та незмінних множинах показані в Таблиці 17.1.</p><h4>Використання мап</h4><p>Мапи дозволяють вам асоціювати значення з кожним елементом колекції. Використання мап подібне до використання масива, за тім винятком, що замість індексації цілими починаючи з нуля, ви можете використовувати любий тип ключа. Якщо ви імпортуєте пакунок scala.collection.mutable, ви можете створити пусту змінну мапу:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val map = mutable.Map.empty[String, Int]
map: scala.collection.mutable.Map[String,Int] = Map()</pre>
        <p>Таблиця 17.1 Загальні операції для множин</p><table style="width: 674px; height: 327px;"
border="1"><tbody><tr><td>val nums = Set(1, 2, 3)</td><td>Створює незмінну множину<br>(nums.toString повертає Set(1, 2, 3))</td></tr><tr><td>nums + 5</td><td>Додає елемент (повертає<br>Set(1, 2, 3, 5))</td></tr><tr><td>nums - 3</td><td>Видаляє елемент (повертає Set(1, 2))</td></tr><tr><td>nums ++ List(5, 6)</td><td>Додає декілька елементів (повертає<br>Set(1, 2, 3, 5, 6))</td></tr><tr><td>nums -- List(1, 2)</td><td>Видаляє декілька елементів (повертає<br>Set(3))</td></tr><tr><td>nums &amp; Set(1, 3, 5, 7)</td><td><br>Приймає перетин двох множин (повертає Set(1, 3))</td></tr><tr><td>nums.size</td><td>Повертає розмір множини (повертає 3)</td></tr><tr><td>nums.contains(3)</td><td>Перевіряє включення (повертає true)</td></tr><tr><td>import scala.collection.mutable</td><td>Робить змінну колекцію простою для доступу</td></tr><tr><td>val words = mutable.Set.empty[String]</td><td><br>Створює пусту змінну множину<br>(words.toString returns Set())</td></tr><tr><td>words += "the"</td><td>Додає елемент (words.toString<br>повертає Set(the))</td></tr><tr><td>words -= "the"</td><td>Видаляє елемент, якщо він існує<br>(words.toString повертає Set())</td></tr><tr><td>words ++= List("do", "re", "mi")</td><td><br>Додає декілька елементів (words.toString повертає Set(do, re, mi))</td></tr><tr><td>words --= List("do", "re")</td><td>Видаляє декілька елементів (words.toString повертає Set(mi))</td></tr><tr><td>words.clear</td><td>Видаляє всі елементи (words.toString<br>повертає Set())</td></tr></tbody></table><p>Зауважте, що коли ви створюєте мапу, ви маєте задати два типа. Перший тип для ключів мапи, другий для значень. В цьому випадку ключі є рядками та цілими значеннями. Всатновлення елементів для мап виглядають подібними до встановлення значень масиву:</p>
<pre class="prettyprint linenums language-scala">scala&gt; map("hello") = 1
scala&gt; map("there") = 2
scala&gt; map
res20: scala.collection.mutable.Map[String,Int] =
Map(hello -&gt; 1, there -&gt; 2)</pre>
        <p>Подібним чином, читання мапи подібне до читання масива:</p>
<pre class="prettyprint linenums language-scala">scala&gt; map("hello")
res21: Int = 1</pre>
        <p>Складаючи все до купи, ось метод, що підраховує число разів, що кожне слово трапляєтсья в рядку:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def countWords(text: String) = {
  val counts = mutable.Map.empty[String, Int]
  for (rawWord &lt;- text.split("[ ,!.]+")) {
    val word = rawWord.toLowerCase
    val oldCount =
      if (counts.contains(word)) counts(word)
      else 0
    counts += (word -&gt; (oldCount + 1))
  }
  counts
}
countWords: (text: String)scala.collection.mutable.Map[String,Int]
<br>scala&gt; countWords("See Spot run! Run, Spot. Run!")
res22: scala.collection.mutable.Map[String,Int]
= Map(see -&gt; 1, run -&gt; 3, spot -&gt; 2)</pre>
        <p>Маючи цей підрахунок, ви можете бачити, що цей текст каже багато про біг, але не дуже багато про те, щоб бачити. Спосіб, в який робить цей текст, це змінна мапа на ім'я counts, що відображує кожне слово на число разів, яке вона трапляється в тексті. Для кожного слова в тексті переглядається старе значення в мапі, потім лічильник збільшується на один, на нове значення зберігається знову в counts. Зауважете викорастання contains для перевірки, чи слово вже зустрічалось, або ні. Якщо counts.contains(word) не дорівнює true, тоді слово ще не зустрічалось, та лічильник встановлюється в нуль.</p><p>Більшість з найбільш використовуваних методів, загальних для змінних та незмінних мап, показані в Таблиці 17.2.</p><p>Таблиця 17.2 Загальні операції для мап</p><table
style="width: 674px; height: 202px;" border="1"><tbody><tr><td>val nums = Map("i" -&gt; 1, "ii" -&gt; 2)</td><td>Створює незмінну мапу<br>(nums.toString повертає Map(i -&gt; 1, ii -&gt; 2))</td></tr><tr><td>nums + ("vi" -&gt; 6)</td><td>Додає елемент (повертає Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6))</td></tr><tr><td>nums - "ii"</td><td>Видаляє елемент (повератє Map(i -&gt; 1))</td></tr><tr><td>nums ++ List("iii" -&gt; 3, "v" -&gt; 5)</td><td>Додає декілька елементів (повертає<br>Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5))</td></tr><tr><td>nums -- List("i", "ii")</td><td>Видаляє декілька елементів (повертає Map())</td></tr><tr><td>nums.size</td><td>Повертає розмір мапи (повертає 2)</td></tr><tr><td>nums.contains("ii") </td><td>Перевіряє входження (повертає true)</td></tr><tr><td>nums("ii")</td><td>Повертає значення ключа (повертає 2)</td></tr><tr><td>nums.keys</td><td>Повертає ключі (повертає Iteratable по рядках "i" та "ii")</td></tr><tr><td>nums.keySet</td><td><br>Повертає ключі як множину (повертає Set(i, ii))</td></tr><tr><td>nums.values</td><td>Повертає значення (повертає Iterable по цілих 1 та 2)</td></tr><tr><td>nums.isEmpty</td><td>Вказує, чи мапа порожня (повертає false)</td></tr><tr><td>import scala.collection.mutable</td><td><br>Робить змінну колекцію простішою для доступу</td></tr><tr><td>val words = mutable.Map.empty[String, Int]</td><td><br>Створює пусту змінну мапу</td></tr><tr><td>words += ("one" -&gt; 1)</td><td><br>Додає елемент мапи від "one" до 1<br>(words.toString повертає Map(one -&gt; 1))</td></tr><tr><td>words -= "one"</td><td>Видаляє елемент мапи, якщо він існує (words.toString повертає Map())</td></tr><tr><td>words ++= List("one" -&gt; 1, "two" -&gt; 2, "three" -&gt; 3)</td><td>Додає декілька елементів мапи (words.toString повертає<br>Map(one -&gt; 1, two -&gt; 2, three -&gt; 3))</td></tr><tr><td>words --= List("one", "two")</td><td>Видаляє декілька об'єктів (words.toString повертає Map(three -&gt; 3))</td></tr></tbody></table><h4>Множини та мапи по замовчанню</h4><p>Для більшості застосувань реалізації змінних та незмінних множин та мап, що провадяться фабриками Set(), scala.collection.mutable.Map(), тощо, вірогідно буде достатнім. Реалізації, що провадяться ціма фабриками, використовують алгоритм швидкого перегляду, що звичайно включає хеш таблиця, так що вони можуть швидко визначити, є чи нема об'єкта в колекції. Метод-фабрика scala.collection.mutable.Set(), наприклад, повертає scala.collection.mutable.HashSet, що використовує хеш таблицю зсередини. Подібним чином фабрика scala.collection.mutable.Map() повертає scala.collection.mutable.HashMap. <br>
</p><p>Таблиця 17.3 Загальні реалізації множин</p><p>Число елементів <br>0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.EmptySet<br>1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set1<br>2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set2<br>3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set3<br>4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set4<br>5 або більше&nbsp; scala.collection.immutable.HashSet</p>Історія з незмінними множинами та мапами трохи складніша. Клас, що повертається методом-фабрикою scala.collection.immutable.Set(), наприклад, залежить від того, як багато елементів ви передаєте в нього, як показане в Таблиці 17.3. Для множин з меньше ніж п'ять елементів виділений спеціальний клас для множин кожного певного розміру, задля підвищення продуктивності. Як тільки ви запитали множину, що має п'ять або більше елементів, метод-фабрика буде повертати реалізацію, що використовує хеші. Подібним чином, метод-фабрика scala.collection.immutable.Map() буде повертати інший клас, в залежності від того, скільки пар ключ-значення ви передаєте йому, як показано в Таблиці 17.4. Як і з множинами, для незмінних мап з меньше ніж п'ятьма елементами виділений спеціальний клас, ексклюзивно для мап з заданим числом елементів, щоб підвищити продуктивність. Однак коли мапа має п'ять або більше пар ключ-значення, використовується незмінна реалізація HashMap.<p>Таблиця 17.4 Реалізації по замовчанню незмінних мап</p><p>Число елементів<br>0 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.EmptyMap<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map1<br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map2<br>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map3<br>4 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map4<br>5 або більше&nbsp; scala.collection.immutable.HashMap</p><p>Незмінні реалізації класів по замовчанню показані в Таблиці 17.3 та 17.4 роблять разом, щоб надати вам максимальну продуктивність. Наприклад, якщо ви додасте елемент до EmptySet, він повернеться як Set1. Якщо ви додасте елемент до цього Set1, він повернеться як Set2. Якщо ви видалите елемент з Set2, ви отримаєте новий Set1.</p><h4>Впорядковані множини та мапи</h4><p>Час від часу вам може знадобитись множина або мапа, чий ітератор повертає елементи в певному порядку. Для цього бібліотека колекцій Scala провадить трейти SortedSet та SortedMap. Ці трейти реалізовані через класи TreeSet та TreeMap, що використовують дерева червоне-чорне для зберігання елементів (в випадку TreeSet) або ключів (в випадку TreeMap) впорядковано. Порядок визначається трейтом Ordered, тип елементів якого для множини або тип ключа для мапи, має бути або підмішаний, або до якого є неявна конвертація. Ці класи ідуть тільки в незмінних варіаціях. Ось деякі приклади TreeSet:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
<br>scala&gt; val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
ts: scala.collection.immutable.TreeSet[Int]
= TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
<br>scala&gt; val cs = TreeSet('f', 'u', 'n')
cs: scala.collection.immutable.TreeSet[Char]
= TreeSet(f, n, u)</pre>
        <p>Та ось деякі приклади TreeMap:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeMap
import scala.collection.immutable.TreeMap
<br>scala&gt; var tm = TreeMap(3 -&gt; 'x', 1 -&gt; 'x', 4 -&gt; 'x')
tm: scala.collection.immutable.TreeMap[Int,Char]
= Map(1 -&gt; x, 3 -&gt; x, 4 -&gt; x)
<br>scala&gt; tm += (2 -&gt; 'x')
<br>scala&gt; tm
res30: scala.collection.immutable.TreeMap[Int,Char]
= Map(1 -&gt; x, 2 -&gt; x, 3 -&gt; x, 4 -&gt; x)
</pre>
        <h3>17.3 Обрання змінних проти незмінних колекцій</h3><p>Для деяких проблем змінні колекції роблять краще, та для інших краще роблять незмінні колекції. Коли ви маєте сумнів, краще почати з незмінної колекції, та змінити її пізніше, якщо буде потреба, оскільки незмінні колекції можуть бути простіше зрозуміти, ніж змінні. Також часом варте того пійти зворотнім шляхом. Якщо ви бачите, що код, що використовує змінні колекції, стає ускладненим та складним для промислення, розгляньте, чи не допоможе змінити деякі з колекцій на незмінні альтернативи. Зокрема, якщо ви починаєте турбуватись щодо роблення копій змінних колекцій тільки в певних місцях, або забагато міркуєте щодо “володіє” або “містить” змінна колекція, розгляньте перехід деяких з колекцій до їх незмінних колекцій. </p><p>Окрім того, що про них краще продумувати, незмінні колекції звичано можуть зберігатись більш компактно, ніж змінні, якщо кількість зберігаємих в колекції елементів мале. Наприклад, пуста змінна мапа в своїй репрезентації по замовчанню HashMap займає приміром 80 байт, та на 16 більше додається для кожного елемента, що ви додаєте до неї. Пуста незмінна мапа Map є єдиний об'єкт, що поділяється між всіма посиланнями, так що посилання на неї в основному коштує тільки одного поля посилання. Що більше, бібліотека колекцій Scala наразі зберігає незмінні мапи та множини до п'яти елементів в одному об'єкті, що, зазвичай займає від 16 до 40 байтів, в залежності від числа елементів, що зберігаються в колекції. Так що для малих мар та множин незмінні версії також значно компакніші, ні змінні. Беручи до уваги, що багато колекцій є малими, перехід на незмінні може надати важливу економію простору, та вигоди продуктивності.&nbsp;</p><p>Щоб легше переходити на незмінні колекції, та навпаки, Scala провадить деякий синтаксичний цукор. Навіть хоча незмінні множини та мапи не підтримують справжніх методів +=, Scala дає корисну альтернативну інтерпретацію +=. Коли ви пишете a += b, та a не підтримує метод з назвою&nbsp; +=, Scala буде намагатись інтерпретувати це як a = a + b. Наприклад, незмінні множини не підтримують оператора +=:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane)</pre>
        <p>Цей “єдиний об'єкт” є примірником від Set1 до Set4, або Map1 до Map4, як показане в Таблиці 17.3 та 17.4.</p>
<pre class="prettyprint linenums language-scala">scala&gt; people += "Bob"
&lt;console&gt;:11: error: reassignment to val
people += "Bob"
ˆ
</pre><p>Однак якщо ви визначите people як var, замість val, тоді колекція може бути "оповлена" за допомогою операції +=, не зважаючи, що вона незмінна. Спершу буде створена нова колекція, та потім people присвоєно до нової колекції:</p>
<pre class="prettyprint linenums language-scala">scala&gt; var people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane)
scala&gt; people += "Bob"
scala&gt; people
res34: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane, Bob)</pre>
        <p>Після цієї серії тверджень, змінна people посилається на новий незмінний набір, що містить доданий рядок, "Bob". Та ж ідея стосується кожного метода, що завершується на =, не тільки метод +=. Це той же синтаксис, що і використовується для оператора -=, що видаляє елемент з множини, та оператор ++=, що додає до множини елементи колекції:</p>
<pre class="prettyprint linenums language-scala">scala&gt; people -= "Jane"
scala&gt; people ++= List("Tom", "Harry")
scala&gt; people
res37: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Bob, Tom, Harry)</pre>
        <p>Щоб побачити, наскільки це важливо, розглянемо наступну мапу з Розділу 1.1:</p>
<pre class="prettyprint linenums language-scala">var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
capital += ("Japan" -&gt; "Tokyo")
println(capital("France"))</pre>
        <p>Цей код використовує незмінні колекції. Якщо ви бажаєте замість цього використати змінні колекції, все, що вам потрібно, це імпортувати змінну версію Map, та, таким чином, перевизначити імпорт незмінної Map по замовчанню:</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.Map
&nbsp;// все що треба зробити!
var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
capital += ("Japan" -&gt; "Tokyo")
println(capital("France"))</pre>
        <p>Не всі приклади такі прості для конвертації, але особливе трактування методів, що закінчуються на знак рівності, часто буде зменшувати кількість кода, що треба змінювати.</p><p>Поміж іншим, це синтаксичне трактування діє також на частину значень, не тільки на колекції. Наприклад, ось як це робить для чисел з плаваючою крапкою:</p>
<pre class="prettyprint linenums language-scala">scala&gt; var roughlyPi = 3.0
roughlyPi: Double = 3.0
<br>scala&gt; roughlyPi += 0.1
<br>scala&gt; roughlyPi += 0.04
<br>scala&gt; roughlyPi
res40: Double = 3.14</pre>
        <p>Ефект від цього розширення подібний до операторів присвоєння Java, +=, -=,<br>*=, тощо, але він більш загальний, оскільки кожний оператор, що завершується на =, може бути конвертований.</p><h3>17.4&nbsp; Ініціалізація колекцій</h3><p>Як ви бачили напередодні, найбільш загальний шлях створити та ініціалізувати колекцію є передати початкові елементи до метода-фабрики об'єкта-компанйона вашої обраної колекції. Ви тільки кладете елементи в дужки після імені о'бєкта-компанйона, та компілятор Scala буде трансформувати це як виклик метода apply на цьому об'єкті-компанйоні:</p>
<pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3)
res41: List[Int] = List(1, 2, 3)
<br>scala&gt; Set('a', 'b', 'c')
res42: scala.collection.immutable.Set[Char] = Set(a, b, c)
<br>scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; mutable.Map("hi" -&gt; 2, "there" -&gt; 5)
res43: scala.collection.mutable.Map[java.lang.String,Int] =
Map(hi -&gt; 2, there -&gt; 5)
<br>scala&gt; Array(1.0, 2.0, 3.0)
res44: Array[Double] = Array(1.0, 2.0, 3.0)</pre>
        <p>Хоча більше часто ви можете дозволити компілятору Scala вивести тип елемента колекції з елементів, переданих до його метода-фабрики, іноді ви можете побажати створити колекцію, але вказати інший тип, відмміний від того, який обирає компілятор. Це особливо проблематично для змінних колекцій. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; val stuff = mutable.Set(42)
stuff: scala.collection.mutable.Set[Int] = Set(42)
<br>scala&gt; stuff += "abracadabra"
&lt;console&gt;:15: error: type mismatch;
found
&nbsp;: java.lang.String("abracadabra")
required: Int
stuff += "abracadabra"
ˆ
</pre><p>
Тут проблема в тому, що персонал взяв тип елемента за Int. Якщо ви бажаєте мати тип елемента Any, вам треба сказати це явно, поклавши тип елемента в квадратні дужки:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val stuff = mutable.Set[Any](42)
stuff: scala.collection.mutable.Set[Any] = Set(42)</pre>
        <p>Інша особлива ситуація - це коли ви бажаєте ініціалізувати колекцію іншою колекцією. Наприклад, уявіть, що ви маєте список, але ви бажаєте TreeSet, що містить елементи в списку. Ось список:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val colors = List("blue", "yellow", "red", "green")
colors: List[java.lang.String]
= List(blue, yellow, red, green)</pre>
        <p>Ви не можете передати список colors до метода-фабрики TreeSet:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
<br>scala&gt; val treeSet = TreeSet(colors)
&lt;console&gt;:15: error: could not find implicit value for
parameter ord: Ordering[List[java.lang.String]]
val treeSet = TreeSet(colors)
ˆ
</pre><p>Замість цього, вам треба створити пустий TreeSet[String], та додати до його елементи списку за допомогою оператора ++ TreeSet:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val treeSet = TreeSet[String]() ++ colors
treeSet: scala.collection.immutable.TreeSet[String]
= TreeSet(blue, green, red, yellow)</pre>
        <h4>Перетворення масива на список</h4><p>З іншого боку, якщо ви бажаєте ініціалізувати список або масив за допомогою іншої колекції, це досить прямолінійно. Як ви вже бачили, щоб ініціалізувати новий список іншою колекцією, просто викличте toList на цій колекції:</p>
<pre class="prettyprint linenums language-scala">scala&gt; treeSet.toList
res50: List[String] = List(blue, green, red, yellow)
</pre>
<p>Або, якщо вам потрібен масив, викличте toArray:</p>
<pre class="prettyprint linenums language-scala">scala&gt; treeSet.toArray
res51: Array[String] = Array(blue, green, red, yellow)</pre>
        <p>Зауважет, що хоча оригінальний список colors не був відсортирований, елементи в списку, що спродукований викликом toList на TreeSet знаходяться в алфавітному порядку. Коли ви викликаєте toList або toArray на колекції, порядок елементів в отриманому списку буде той самий, що і порядок елементів, що продукує ітератор, отриманий від виклику елементів на цій колекції. Оскільки ітератор TreeSet[String] буде продукувати рядки в алфавітному порядку, ці рядки будуть з'являтись в алфавітному порядку в списку, що утвориться в результаті виклику toList на цьому TreeSet.</p><p>Майте на увазі, що перетворення на список або масив зазвичай потребує копіювання всіх елементів колекції, та, таким чином, може бути повільним для великих колекцій. Однак іноді вам треба зробити це через існуюче API. Більше того, багато колекцій мають тільки декілька елементів, в якому разі це тільки невелике пенальті по швидкості.</p><h4>Перетворення між змінними та незмінними множинами та мапами</h4><p>Інша ситуація, що часом постає, це потреба конвертувати змінну множину або мапу до незмінної, або навпаки. Щоб досягти цього, ви можете використовувати прийом, показаний на попередній сторінці, де ініціалізуємо TreeSet елементами списка. Створіть колекцію нового типа, з використанням пустого метода, та потім додайте нові елементи з використанням ++ або ++=, як потрібно для цільового типу колекції. Ось як ви конвертуєте незмінний TreeSet з попереднього приклада на змінну множину, та знову назад, до незмінної:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; treeSet
res52: scala.collection.immutable.TreeSet[String] =
TreeSet(blue, green, red, yellow)
<br>scala&gt; val mutaSet = mutable.Set.empty ++= treeSet
mutaSet: scala.collection.mutable.Set[String] =
Set(yellow, blue, red, green)
<br>scala&gt; val immutaSet = Set.empty ++ mutaSet
immutaSet: scala.collection.immutable.Set[String] =
Set(yellow, blue, red, green)</pre>
        <p>Ви можете використовувати той самий прийом для перетвореня між змінними та незмінними мапами:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val muta = mutable.Map("i" -&gt; 1, "ii" -&gt; 2)
muta: scala.collection.mutable.Map[java.lang.String,Int] =
  Map(ii -&gt; 2, i -&gt; 1)
<br>scala&gt; val immu = Map.empty ++ muta
immu: scala.collection.immutable.Map[java.lang.String,Int] =
  Map(ii -&gt; 2, i -&gt; 1)</pre>
        <h3>17.5 Кортежі</h3><p>Як описане в Кроці 9 в Главі 3, кортеж комбінує фіксоване число елементів разом, так що вони можуть бути передані далі як одне ціле. На відміну від масивів або списків, кортеж може містити об'єкти різних типів. Ось приклад кортежу, що містить ціле, рядок та консоль:</p>
<pre class="prettyprint linenums language-scala">(1, "hello", Console)</pre>
        <p>Кортежі зберігають вас від нудьги визначеня простих класів для збереження даних. Навіть не зважаючи на те, що визначення класів просте, воно вимагає певного мінімального зусилля, що іноді нічому не служить. Кортежі зберігають вас від зусиль по іменуванню класів, обрання поля зору для визначення класа, та обрання імен для членів класа. Якщо клас просто містить ціле та рядок, ніякої ясності не додається, якщо цей клас названий AnIntegerAndAString.</p><p>Оскільки кортежі можуть поєднувати об'єкти різних типів, кортежі не походять від Traversable. Якщо ви бажаєте групувати саме одне ціле і один рядок, тоді ви бажаєте кортеж, не List або Array. Загальне застосування кортежів - повертати декілька значень з метода. Наприклад, ось метод, що шукає найдовше слово в колекції, та також повертає його індекс:</p>
<pre class="prettyprint linenums language-scala">def longestWord(words: Array[String]) = {
  var word = words(0)
  var idx = 0
  for (i &lt;- 1 until words.length)
    if (words(i).length &gt; word.length) {
      word = words(i)
      idx = i
    }
  (word, idx)
}</pre>
        <p>Ось приклад використання цього метода:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val longest =
longestWord("The quick brown fox".split(" "))
longest: (String, Int) = (quick,1)</pre>
        <p>Функція longestWord обчислює тут две елемента: слово, найбільше в масиві idx, та індекс цього слова. Щоб утримувати речі протсішими, функція вважає, що в списку є щонайменьше одне слово, та вона облишає спроби, обираючи слово, що іде раніше в списку. Як тільки функція обрала, яке слово з яким індексом повертати, вона повертає обоє разом, використовуючи синтаксис кортежа (word, idx).</p><p>Щоб отримати доступ до елемента в кортежі, ви можете використовувати метод _1 для доступу до першого елемента, _2 для доступа до другого, і так далі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; longest._1
res53: String = quick
scala&gt; longest._2
res54: Int = 1</pre>
        <p>Додатково, ви можете призначити кожний елемент кортежа до власної змінної, ось так:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val (word, idx) = longest
word: String = quick
idx: Int = 1
scala&gt; word
res55: String = quick</pre>
        <p>Проміж іншим, якщо ви лишите дужки, ви отримаєте інший результат:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val word, idx = longest
word: (String, Int) = (quick,1)
idx: (String, Int) = (quick,1)</pre>
        <p>Цей синтаксис надає декільком визначенням один вираз. Кожна змінна ініціалізується власним обчисленням з правої сторони. Те, що вираз обчислюється до кортежу, в данному випадку не має значення. Обі змінні ініціалізовані до цілого кортежу. Дивіться Главу 18 щодо деяких прикладів, де множинні визначення є зручними.&nbsp;</p><p>В якості застереження, використання кортежів є дуже простим. Кортежі величні, коли ви комбінуєте дані, що не мають значення, окрім “це A та B”. Однак, коли комбінація має деяке значення, або ви бажаєте додати деякі методи до комбінації, краще піти далі, та створити клас. Наприклад, не використовуйте 3-кортеж для комбінації дня, місяця та року. Створіть клас Date. Це зробить ваші наміри очевидними, що однаково, прояснює код для людей-читачів, та дає компілятору та мові нагоду допомоготи вам виявити помилки.&nbsp;</p><h3>17.6 Висновок</h3><p>Ця глава надала огляд бібліотеки колекцій Scala, на найбільш важливих класів, що складають її. З цім підгрунтям ви повинні бути в змозі ефективно робити з колекціями Scala, та знати, де дивитись в Scaladoc, коли вам треба більше інформації. Щодо додаткових деталей відносно колекцій Scala дивіться далі в Главі 24 та главі 25. Наразі, в наступній главі, ми звернемо нашу увагу знову з бібліотек Scala на саму мову, та обсудимо підтримку в Scala змінних об'єктів.
</p><h3>
      
      Глава 18</h3><h2>Об'єкти зі станом</h2>В попередніх главах ми фокусувались на функціональних (незмінних) об'єктах. Ми робили так, тому що ідея об'єктів без любого змінного стану заслуговує кращого ознайомлення. Однак в Scala також цілком можливо визначати об'єкти зі змінним станом. Такі об'єкти зі станом часто виглядають природними, коли ви бажаєте змоделювати об'єкти реального світу, що змінюються з часом. <br><br>Ця глава пояснює, що таке о'бєкти зі станом, та що провадить Scala в термінах синтаксису, щоб виражати їх. Друга частина цієї глави вводить бульше дослідження щодо симуляції дискретних подій, що включає об'єкти зі станом, так само, як внутрішню галузеву мову (DSL) для визначення симульованих цифрових пристроїв.<br><br><h3>18.1 Що робить об'єкт об'єктом зі станом?</h3>Ви можете дослідити принципову різницю між чисто функціональним об'єктом, та об'єктом зі станом, навіть без погляду на реалізацію об'єкта. Коли ви викликаєте метод або отримуєте поле для деякого чистого функціонального об'єкта, ви завжди будете отримувати той самий результат. Наприклад, маючи список символів:<br>
<pre class="prettyprint linenums language-scala">val cs = List('a', 'b', 'c')</pre>
        <p>застосування ancs.head буде завжди повертає 'a'. Це буде так, навіть якщо є довільне число операцій зі списком cs між точкою, де він визначений, та точкою, де здійснюється доступ до cs.head. З іншого боку, для об'єкта зі станом результат виклику метода або доступ до поля може залежати від операцій, що до цього виконувались з о'бєктом. Гарний приклад о'бєкта зі станом є банківській рахунок. Лістинг 18.1 показує спрощену реалізацію банківського рахунку:</p>
<pre class="prettyprint linenums language-scala">class BankAccount {<br>  private var bal: Int = 0
  def balance: Int = bal
  def deposit(amount: Int) {
    require(amount &gt; 0)
    bal += amount
  }
  def withdraw(amount: Int): Boolean =
    if (amount &gt; bal) false
    else {
      bal -= amount
      true
    }
  }</pre><p>Лістинг 18.1 Змінний клас банковського рахунку.</p><p>Клас BankAccount визначає приватну змінну bal, та три публічні методи: balance повертає поточний баланс; deposit додає надане значення до bal; та withdraw, що намагаєтсья відняти надану суму з bal, при цьому переконавшись, що залишений баланс не від'ємний. З withdraw повертається результат типу Boolean, що вказує, чи запрошені фонди були успішно списані.</p><p>Навіть якщо ви нічого не знаєте щодо внутрішньої роботи класа BankAccount, ви все ще можете сказати, що BankAccount є об'єктами зі станом:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val account = new BankAccount
account: BankAccount = BankAccount@bf5bb7
<br>scala&gt; account deposit 100
scala&gt; account withdraw 80
res1: Boolean = true
<br>scala&gt; account withdraw 80
res2: Boolean = false</pre>
        <p>Зауважте, що два фінальні списання в попередній взаємодії повертали різні значення. Перша операція списання повертала true, оскільки банківський рахунок містив досить грошей щоб дозволити списання. Друга операція, хоча вона й така сама, як перша, повертає false, оскільки баланс рахунку був зменшений, так що він більше не покриває запитані витрати. Так, банківський рахунок напевне має змінний стан, оскільки деякі операції можуть повертати різні результати в різний час.</p><p>Ви можете думати, що наявність стану BankAccount безпосередньо очевидне, оскільки він містить визначення var. Стан та var звичайно ідуть поряд, але речі не завжди такі прості. Наприклад, клас може мати стан без визначення або наслідування будь яких var, оскільки він передає виклики методів до інших об'єктів, що мають змінний стан. Зворотнє також можливе: клас може містити var, та бути при цьому чисто функціональним. Прикладом може бути клас, що кешує результат коштовної операції в полі задля цілей оптимізації. Щоб мати приклад, розглянемо наступний неоптимізований клас Keyed з коштовною операцією computeKey :</p>
<pre class="prettyprint linenums language-scala">class Keyed {
  def computeKey: Int = ... // це займе деякий час
  ...
}</pre>
        <p>Вважаємо, що computeKey ані читає, ані записує жодних var, ви можете зробити Keyed більш ефективним за допомогою кеша:</p>
<pre class="prettyprint linenums language-scala">class MemoKeyed extends Keyed {
  private var keyCache: Option[Int] = None
  override def computeKey: Int = {
    if (!keyCache.isDefined) keyCache = Some(super.computeKey)
    keyCache.get
  }
}</pre>
        <p>Використання MemoKeyed замість Keyed може прискорити речі, оскільки други раз запитується результат операції computeKey, може бути повернено значення, збережене в полі keyCache, замість виконання computeKey ще один раз. Але за винятком цього прискорення, поведінка класа Keyed та MemoKeyed така ж сама. Концептуально, якщо Keyed чисто функціональний, тоді також і MemoKeyed, навіть якщо він і містить змінну, яку можна переприсвоювати.</p><h3>18.2 Переприсвоювані змінні та властивості</h3><p>Ви можете виконувати дві фундаментальні операції на переприсвоюваних змінних: отримати їх значення, на встановити нове значення. В бібліотеках, таких, як JavaBeans, ці операції часто інкапсульовані в окремі геттери та сеттери, що треба визначати явно. В Scala кожна var, що не є приватним членом деякого об'єкта, неявно визначає геттер та сеттер. Ці геттери та сеттери, однак, називаються інакше, ніж прийнято в Java. Геттер var x називається просто “x”, коли її сеттер називається “ x_= ”. </p><p>Наприклад, якщо в класі визначена така змінна var:</p>
<pre class="prettyprint linenums language-scala">var hour = 12</pre>
        <p>генеруєтсья геттер “hour”, та сеттер “hour_=”, на додаток до перевизначеного поля. Поле завжди марковане як private[this], що означає, що до нього може отримувати доступ тільки об'єкт, що містить його. Геттер та сеттер, з іншого боку, має ту ж видимість, що і оригінальна var. Якщо визначення var є public, такаж видимість в геттера та сеттера, якщо protected, вони також protected, і так далі.</p><p>Наприклад, розглянемо клас Time, показаний в Лістингу18.2, що визначає дві public var на ім'я hour та minute :</p>
<pre class="prettyprint linenums language-scala">class Time {
  var hour = 12
  var minute = 0
}</pre>
        <p>Лістинг 18.2 Клас з&nbsp;public var.</p><p>Ця реалізація точно еквівалентна до визначень класа, показаного в Лістингу 18.3. Визначенні, показаному в Лістингу 18.3, імена локальних полів h та m вибрані довільно, щоб не перетинатись з любими іменами, що вже в ужитку.</p>
<pre class="prettyprint linenums language-scala">class Time {
  private[this] var h = 12
  private[this] var m = 0
  def hour: Int = h
  def hour_=(x: Int) { h = x }
  def minute: Int = m
  def minute_=(x: Int) { m = x }
}
</pre>
        <p>Лістинг 18.3 · How public var s are expanded into getter and setter methods.</p>
<p>Цікавий аспект щодо ціх розширень var до геттерів та сеттерів в тому, що ви можете також обрати визначити геттер та сеттер напряму, замість визначення var. Визначаючи ці методи доступу напряму, ви можете інтерпретувати операції доступу та присвоєння до змінної за власним бажанням. Наприклад, варіант класа в Лістингу 18.4 містить вимоги, що перехоплюють все присвоєння до годин та хвилин з неможливими значеннями.</p>
<pre class="prettyprint linenums language-scala">class Time {
  private[this] var h = 12
  private[this] var m = 0
  def hour: Int = h
  def hour_= (x: Int) {
    require(0 &lt;= x &amp;&amp; x &lt; 24)
    h = x
  }
  def minute = m
  def minute_= (x: Int) {
    require(0 &lt;= x &amp;&amp; x &lt; 60)
    m = x
  }
}</pre>
        <p>Listing 18.4 Визначення методів геттерів та сеттерів напряму.</p><p>Деякі мови мають специфічні синтаксичні конструкції для ціх змінно-подібних сутностей, що не є простими змінними, в тій частині, що їх геттери та сеттери можуть бути перевизначені. Наприклад, C# має властивості, що служать цій ролі. Домовленість Scala<br>завжди інтерпретувати змінну як пару з методів геттера та сеттера ефективно дає ті ж можливості, що і властивості C#, без потреби в спеціальному синтаксисі. Властивості можуть служити багатьом різним цілям. В прикладі, показаному в Лістингу 18.4, сеттери змушують до інваріантності, і, таким чином, захищають від присвоєння недопустимих значень. Ви також можете використовувати властивість для журналювання всього доступу до геттерів та сеттерів змінної. Або ви можете інтегрувати змінні з подіями, наприклад, через повідомлення деякого підписчика кожного разу, коли змінна модифікується (ви побачите приклади цього в Главі 35).</p><p><br>Також можливо, та підчас корисно, визначити геттер та сеттер без асоційованого поля. Прикладом є наступний клас Thermometer, що інкапсулює змінну температури, що може бути прочитана та оновлена. Температура може бути вираженою в за Цельсієм, або за Фаренгейтом. Клас нижче дозволяє отримувати або встановлювати температуру за кожним способом. </p>
<pre class="prettyprint linenums language-scala">class Thermometer {
  var celsius: Float = _
  def fahrenheit = celsius * 9 / 5 + 32
  def fahrenheit_= (f: Float) {
    celsius = (f - 32) * 5 / 9
  }
  override def toString = fahrenheit +"F/"+ celsius +"C"
}</pre>
        <p>Лістинг 18.5 Визначення геттера та сеттера без асоційованого поля.</p><p>Перший рядок в тілі цього класа визначає змінну var, celsius, що буде містити температуру за Цельсієм. Змінна celsius смочатку встановлена в значення по замовчанню, вказавши ‘_’ як “значення ініціалізації” для змінної. Більш точно, ініціалізатор “ = _ ” поля присвоює значення нуль до поля. Значення нуля залежить від типа поля. Це 0 для числових типів, false бля логічних, та null для типів-посилань. Це те ж саме, що якби та ж змінна була визначена в Java без ініціалізатора. Зауважте, що ви не можете просто відкинути ініціалізатор “= _” в Scala. Якщо в запишете:</p>
<pre class="prettyprint linenums language-scala">var celsius: Float</pre>
        <p>це декларує абстрактну змінну, не просто неініціалізовану. Після визначення змінної celsius іде геттер “fahrenheit”, та сеттер “fahrenheit_=”, що має доступ до тієї ж температури, але за градусами Фаренгейта. Немає окремого поля, що містить поточну температуру за Фаренгейтом. Замість цього, методи геттера та сеттера для Фаренгейта конвертують значення в обі сторони для Цельсія, відповідно.</p><p>Ось приклад взаємодії з об'єктом Thermometer:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val t = new Thermometer
t: Thermometer = 32.0F/0.0C
<br>scala&gt; t.celsius = 100
scala&gt; t
res3: Thermometer = 212.0F/100.0C
<br>scala&gt; t.fahrenheit = -40
scala&gt; t
res4: Thermometer = -40.0F/-40.0C</pre>
        <h3>18.3 Дослідження проблеми: симуляція дискретних подій</h3><p>Залишок цієї глави показує розширений приклад того, як об'єкти зі станом можуть бути скомбіновані зі значеннями&nbsp; першокласних функцій в цікавий спосіб. Ви побачите дизайн та реалізацію симулятора цифрових cхем. Це завдання розділене на декілька субпроблем, кожна з яких індивідуально цікава: зпершу, ви побачите малу мову для цифрових схем. Визначення цієї мови покаже головний метод для вбудовування галузевих мов в мову як Scala. Друге, ми прежентуємо простий, але загальний фреймворк, що буде відстежувати дії, що виконуються в симульованому часі. Нарешті, ми покажемо, як програми дискретної симуляції можуть бути структуровані та побудовані. Ідея такої симуляції є моделювання фізичних симульованими, та використання фреймворка симуляції для моделювання фізичного часу. </p><p>Приклад взятий з класичної книги Структура та інтерпретація комп'ютерних програм від Абельсона та Зусмана [Abe96]. Що тут відрізняється, що мова інтерпретації тут Scala замість Scheme, та що різні аспекти структуровані на чотирьох програмних рівнях: один для фреймворка симуляції, другий для пакунку базових схем, третій для бібліотеки визначених користувачем схем, та останній рівень для самої кожної симульованої схеми. Кожний рівень визначений як клас, та більш специфічні рівні наслідують від більш загальних.</p><img
alt="Basic Gates" src="18.1.png"><p>Малюнок 18.1 Базові вентілі</p><h4>Швидка орієнтація</h4><p>Розуміння приклада симуляції дискрентих подій, представлених в цій главі, займе деякий час. Якщо замість цього ви бажаєте швидше повернутись до вивчекння Scala, буде безпечним перейти далі до наступної глави.</p><h3>18.4 Мова для цифрових схем</h3><p>Ми почнемо з "малої мови" для опису цифрових схем. Цифрові пристрої складаються з дротів та функціональних блоків. Дроти передають сигнали, що трансформуються функціональними блоками. Сигнали представлені як логічні рівні: true коли сигнал є, та false коли немає. Малюнок 18.1 показує три базові функціональні блоки (або вентилі):</p><p>• Інвертор, що обертає сигнал.<br>• Блок ТА, що встановлює вихід в кон'юкцію своїх входів<br>• Блок АБО, що встановлює вихід в діз'юкцію своїх входів.</p><p>Ціх блоків достатньо для побудови любих інших функціональних блоків. Вентилі мають затримкм, так що вихід буде змінюватись тільки через деякий час після зміни входу. Ми опишемо елементи цифрових схем наступним набором класів та функцій Scala. Першим буде клас Wire для дротів. Ми можемо конструювати дроти таким чином:</p>
<pre class="prettyprint linenums language-scala">val a = new Wire
val b = new Wire
val c = new Wire</pre>
        <p>або, еквівалентно, але коротше, таки чином:</p>
<pre class="prettyprint linenums language-scala">val a, b, c = new Wire</pre>
        <p>Друге, є три прод'юсера що “виробляють” потрібні нам базові вентилі:</p>
<pre class="prettyprint linenums language-scala">def inverter(input: Wire, output: Wire)
def andGate(a1: Wire, a2: Wire, output: Wire)
def orGate(o1: Wire, o2: Wire, output: Wire)</pre>
        <p>Що є незвичним, беручи до уваги функціональний нахил Scala, в тому, що ці процедури конструюють вентилі як побічний ефект, замість щоб повертати сконструйовані блоки як результат. Наприклад, виклик inverter(a, b) покладає інвертор між дротами a та b. Як з'ясувалось, ця конструкція через побічний ефект робить простішою поступову побудову складних лінцюжків. Також, хоча більш часто методи мають імена дієслів, ці мають імена іменників, що вказує на той вузол, який вони будують. Це відображує декларативну природу DSL: вона повинна декларувати схему, не дії, що виробляють її. Більш складні функціональні блоки можуть бути побудовані з базових вентилів. Наприклад, метод, показаний в Лістингу 18.6 конструює напів-додавач. Метод halfAdder приймає два входи, a та b, та продукує суму s, визначену як s = (a + b) % 2 та біт переносу c , визначене як c = (a + b) / 2. Діаграма напів-додавача показана на Малюнку 18.2.</p><p><img
alt="Half-addded circuits" src="file:///home/ac2epsilon.github.io/TRANS/SCALA/18.2.png"><br>
Малюнок 18.2 Схама папів-додавача.</p>
<pre class="prettyprint linenums language-scala">def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
  val d, e = new Wire
  orGate(a, b, d) 
  andGate(a, b, c)
  inverter(c, e)
  andGate(d, e, s)
}</pre>
        <p>&nbsp;Лістинг 18.6 Метод halfAdder.</p><p>Зауважте, що halfAdder є параметризованим функціональним блоком, так само, як три методи, що конструюють примітивні вентилі. Ви можете використовувати метод halfAdder для конструювання більш складних схем. Наприклад, Лістинг 18.7 визначає повний однобітний додавач, показаний на Малюнку 18.3, що приймає два входи, a та b, так само, як перенос cin, та що продукує вихідну суму, що визначена як sum = (a + b + cin) % 2, та вихід переносу, визначений як cout = (a + b + cin) / 2.</p><pre
class="prettyprint linenums language-scala">def fullAdder(a: Wire, b: Wire, cin: Wire,
sum: Wire, cout: Wire) {
  val s, c1, c2 = new Wire
  halfAdder(a, cin, s, c1)
  halfAdder(b, s, sum, c2)
  orGate(c1, c2, cout)
}</pre>
        <p>Лістинг 18.7 Метод fullAdder.</p><p>Клас Wire та функції inverter, andGate та orGate представляють невелику мову, за допомогою якої користувачі можуть визначати цифрові схеми. Це гарний приклад інутрішньої DSL, галузевої мови, визначеної як бібліотеки в базовій мові, замість бути реалізованою сама по собі. Реалізація схемної DSL все ще потребує бути проробленою. Оскільки призначення визначення схеми в DSL є симуляція присторою, має сенс базувати реалізацію DSL на загальному API для симуляції дискретних подій. Наступні два розділи будуть презентувати зпершу симуляцію API, та потім реалізацію DSL зверху нього.</p><img
alt="Full-adder circuit" src="18.3.png"><p>Малюнок 18.3 Схема повного додавача.</p><h3>18.5 API симуляції</h3><p>API симуляції показане в Лістингу 18.8. Воно складається з класа Simulation в пакунку org.stairwaybook.simulation. Конкретні бібліотеки симуляції наслідують цей клас, та доповнюють &nbsp;&nbsp;&nbsp; його за допомогою галузевої функціональності. Елементи класа Simulation представлені в цьому розділі. Симуляція дискретних подій виконує визначені користувачем дії у вказаний час. Дії, що визначені через конкретні субкласи симуляції, всі поділяють загальний тип:
</p><pre class="prettyprint linenums language-scala">type Action = () =&gt; Unit</pre>
        <p>Це твердження визначає Action, що є псевдонімом типу процедури, що приймає пустий список параметрів, та повертає Unit. Action є членом типу класа Simulation. Ви можете думати про це, як про більш читабельне ім'я для типа () =&gt; Unit. Члени типів будуть описані більш детально в Розділі 20.6. Час, коли викликається дія, є симульованим часом; він не має нічого загального з дійстним часом "часів на стіні". Симульований час представлений просто як ціле. Поточний симульований час утримується в приватній змінній:
        </p><pre class="prettyprint linenums language-scala">private var curtime: Int = 0</pre>
<p> Змінна має матод для доступу, що повертає поточний час:
  </p><pre class="prettyprint linenums language-scala">def currentTime: Int = curtime</pre>
        <p>Ця комбінація приватної змінної з публічним доступом використовується, щоб переконатись, що поточний час не може бути модифікований за межами класа Simulation. Кінець кінцес, ви звичайно не хочете, щоб об'єкти вашої симуляції маніпулювали поточним часом, можливо, за винятком якщо ваші моделі симуляції подорожують в часі. </p>
<pre class="prettyprint linenums language-scala">abstract class Simulation {
  type Action = () =&gt; Unit
  case class WorkItem(time: Int, action: Action)
  private var curtime = 0
  def currentTime: Int = curtime
  private var agenda: List[WorkItem] = List()
  private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
      if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag
      else ag.head :: insert(ag.tail, item)
  }
  def afterDelay(delay: Int)(block: =&gt; Unit) {
    val item = WorkItem(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }
  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =&gt;
      agenda = rest
      curtime = item.time
      item.action()
    }
  }
  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
      currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
}</pre>
        <p>Лістинг 18.8 Клас Simulation.</p><p>Акція, що має бути виконана у вказаний час, викликається робочим елементом. Робочі елементи&nbsp; реалізовані як наступний клас:
</p><pre class="prettyprint linenums language-scala">case class WorkItem(time: Int, action: Action)</pre><p>Ми зробили клас WorkItem кейс класом, оскільки це надає синтаксичних зручностей: ви можете використовувати метод-фабрику, WorkItem, щоб створити примірники класа, та ви можете отримати доступ до параметрів конструктора, time та action, задарма. Також зауважте, що клас WorkItem вкладений в клас Simulation. Вкладені класи в Scala розглядаютсья подібно до Java. Розділ 20.7 надасть вам більше деталей.&nbsp;</p><p><br>Клас Simulation зберігає порядок денний всіх інших робочих елементів, що ще не були виконані. Робочі елеменрти впорядковані по симульованому часу, коли вони мають виконуватись:</p>
<pre class="prettyprint linenums language-scala">private var agenda: List[WorkItem] = List()</pre>
        <p>Список розкладу буде утримуватись в відповідному відсортованому порядку методом insert, що оновлює його. Ви можете бачити, як insert викликаєтсья з afterDelay, що є єдиним шляхом додати робочий елемент до розкладу:</p>
<pre class="prettyprint linenums language-scala">def afterDelay(delay: Int)(block: =&gt; Unit) {
  val item = WorkItem(currentTime + delay, () =&gt; block)
  agenda = insert(agenda, item)
}</pre>
        <p>Як натякає ім'я, цей метод вставляє дію (задану як блок) в розклад, так що він планується на заадний час затримки після поточного симульованого часу. Наприклад, наступний виклик буде створювати новий робочий елемент, що буде виконаний в симульованому часі currentTime + delay :
        </p><pre class="prettyprint linenums language-scala">afterDelay(delay) { count += 1 }</pre>
        <p>Код, що буде виконаний, міститься в другому аргументі метода. Формальний параметр для цього аргумента має тиа “=&gt; Unit”, тобто, це обчислення типу Unit, що передане за ім'ям. Згадайте, що переаметри за-ім'ям не обчислюються, коли передаються в метод. Так що в виклику вище count буде виконано, тільки коли фреймворк симуляції викликає дію, збережену в робочому елементі. Зауважте, що afterDelay є курованою функцією. Це гарний приклад принципу, встановленому заздалегідь в Розділі 9.5, що карування може бути використане щоб зробити виклик метода подібним на вбудований синтаксис. </p><p>Створений робочий елемент все ще потребує бути вставленим в розклад. Це робиться методом insert, що підтримує інваріант, що розклад впорядкований за часом:</p>
<pre class="prettyprint linenums language-scala">private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
  if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag 
  else ag.head :: insert(ag.tail, item)
}</pre>
        <p>The core of the Simulation class is defined by the run method:</p>
<pre class="prettyprint linenums language-scala">def run() {
  afterDelay(0) {
    println("*** simulation started, time = "+
    currentTime +" ***")
  }
  while (!agenda.isEmpty) next()
}</pre>
        <p>Цей метод постійно бере перший елемент в розкладі, видаляє його з розклада, та виконує його. Він робить це, доки не буде більше елементів, що залишились в розкладі, що очікують виконання. Кожний крок виконується через виклик метода next, що визначений таким чином:</p>
<pre class="prettyprint linenums language-scala">private def next() {
  (agenda: @unchecked) match {
    case item :: rest =&gt;
     agenda = rest
     curtime = item.time
     item.action()
  }
}</pre>
        <p>Метод next декомпонує поточний розклад за допомогою порівняння шаблону в перший елемент item, та залишок списку робочих елементів. Він видаляє передній елемент з поточного розкладу, встановлює симульований час на час робочого елемента, та виконує дію робочого елемента.</p><p>Зауважте, що next може бути викликаний тільки якщо розклад не порожній. Для порожнього списка немає випадка, так що ви можете отримати виключення MatchError, якщо ви спробуєте виконати next на порожньому розкладі. </p><p>Фактично, компілятор Scala звичайно буде попереджати вас, що ви пропустили один з можливих шаблонів:</p>
<pre class="prettyprint linenums language-scala">Simulator.scala:19: warning: match is not exhaustive!
missing combination
Nil
agenda match {
ˆ
one warning found</pre>
        <p>В цьому випадку відсутній case не є проблемою, оскільки ви знаєте, що next викликаний на непустому розкладі. Такиим чином ви можете забажати відключити попередження. Ви бачили в Розділі 15.5, що це можна зробити через додавання анотації @unchecked до виразу селектора порівняння шаблона. Ось чому кож Simulation використовує “(agenda: @unchecked) match ” замість “agenda match”.</p><p>Ось і все. Це виглядаючий дивовижно коротким код для фреймворка симуляції. Ви можете поцікавитись, як цей фреймворк може підтримувати цікаві симуляції, якщо все, що він робить, це виконує список з робочих елементів? Фактично, потужність фреймворка симуляції походить від факту, що дії, збережені в робочих елементах, самі можуть встановлювати подальші робочі елементи в розклад, коли вони виконуються. Це робить можливим мати довготривалі симуляції, що розвиваються з простих початків.</p><h3>18.6 Симуляція схеми</h3><p>Наступний крок є використання фреймворка симуляції для реалізації галузевої мови для схем, показаної в Розділі 18.4. Згадайте, що наш DSL складається з класа для дротів, та методів, що створюють та-вентилі, або-вертилі та інвертори. Вони містяться в класі BasicCircuitSimulation, що розширює фреймворк симуляції. Цей клас показаний в Лістингах 18.9 та 18.10.</p><p>Клас BasicCircuitSimulation декларує три абстрактні методи, що представляють затримки базових вентелів: InverterDelay, AndGateDelay та OrGateDelay. Справжні затримки невідомі на рівні цього класа, оскільки вони залежать від техногії з'єднань, що ми симулюємо. Ось чому затримки залишені абстрактнимив класі BasicCircuitSimulation, так що їх конкретні визначення делеговані до субкласів. Реалізація інших методів класа BasicCircuitSimulation слідує далі.</p>
<pre class="prettyprint linenums language-scala">package org.stairwaybook.simulation
<br>abstract class BasicCircuitSimulation extends Simulation {
  def InverterDelay: Int
  def AndGateDelay: Int
  def OrGateDelay: Int
<br>  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()
    def getSignal = sigVal
    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }
    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }
  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig &amp; a2Sig)
      } 
    }
    a1 addAction andAction
    a2 addAction andAction
  }
  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }
  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
        " new-value = "+ wire.getSignal)
    }
     wire addAction probeAction
  }
}</pre>
        <p>Лістинг 18.9-10 Клас BasicCircuitSimulation.</p><h4>Клас Wire</h4><p>ЛґДріт потрібний, щоб підтримувати три базові операції:</p><p>getSignal: Boolean : повертає поточний сигнал на дроті.<br>setSignal(sig: Boolean) : встановлює сигнал на дроті в sig .<br>addAction(p: Action) : приєднує вказану процедуру p до дій на дроті. </p><p>Ідея в тому, що всі процедури дій, приєднані до деякого дрота, будуть викликатись кожного разу, коли сигнал на дроті змінюється. </p><p>Типово дії додаються до дрота через компоненти, під'єднані до дрота. Приєднана дія виконується один раз, коли вона приєднується до дрота, та після цього кожного разу, коли сигнал на дроті змінюється. Ось реалізація класа Wire:</p>
<pre class="prettyprint linenums language-scala">class Wire {
  private var sigVal = false
  private var actions: List[Action] = List()
  def getSignal = sigVal
  def setSignal(s: Boolean) =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_ ())
    }
  def addAction(a: Action) = {
    actions = a :: actions
    a()
  }
}</pre>
        <p>Назви ціх методів “затримки” починаються з заглавної літери, бо вони представляють константи. Це ті методи, що можуть бути переписані в субкласах. Ви знайдете, як робити ті самі речі в Розділі 20.3.</p><p>Дві приватні змінні займаються станом на дроті. Змінна sigVal представляє поточний сигнал, та змінна actions представляє процедури дій, що наразі приєднані до дроту. Єдина цікава реалізація метода для setSignal: коли сигнал на дроті змінюється, нове значення зберігається в змінній sigVal. Більше того, виконуються всі дії, приєднані до дроту. Зауважте скорочений синтаксис для того, щоб зробити це: “actions foreach (_ ()) ” застосовує функцію “_() ” до кожного елемента списка дій. Як описано в Розділі 8.5, функція “_ ()” є скороченням для “f =&gt; f ()”, тобто, вона приймає функцію (назовемо її f), та застосовує її до пустого списка параметрів.</p><h4>Метод inverter</h4><p>Єдиний ефект від створення інвертора в тому, що на його вхідному дроті встановлена дія. Ця дія виконується один раз, коли дія встановлена, та після цього кожного разу, коли змінюється вхідний рівень. Ефект дії в тому, що значення вихідного значення встановлюється (через setSignal) до інверсії вхідного значення. Оскільки інвертор має затримку, ця зміна повинна набрати чинності тільки через InverterDelay одиниць симульованого часу після того, як вхідне значення було змінене, та дія була викликана. Ц епідказує таку реалізацію:</p>
<pre class="prettyprint linenums language-scala">def inverter(input: Wire, output: Wire) = {
  def invertAction() {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) {
      output setSignal !inputSig
    }
  }
  input addAction invertAction
}</pre>
        <p>Ефект метода inverter є додавання invertAction до вхідного дроту. Ця дія, коли викликається, отримує вхідний сигнал, та встановлює іншу дію, що інвертує вихідний сигнал в симульований розклад. Ця інша дія буде виконана тільки після InverterDelay одиниць симульованого часу. Зауважте, як метод використовує метод afterDelay фреймворка симуляції для створення нового робочого елемента, що буде виконаний в майбутньому.</p><h4>Методи andGate та orGate</h4><p>Реалізація and-вентилів аналогічна до реалізації інверторів. Призначення та-вентилів є вивід кон'юкції своїх вхідних сигналів. Це повинно трапитись через AndGateDelay одиниць симульованого часу після зміну любого з двох вхідних значень. Таким чином ось і наступна реалізація:</p>
<pre class="prettyprint linenums language-scala">def andGate(a1: Wire, a2: Wire, output: Wire) = {
  def andAction() = {
&nbsp;&nbsp;&nbsp; val a1Sig = a1.getSignal
&nbsp;&nbsp;&nbsp; val a2Sig = a2.getSignal
&nbsp;&nbsp;&nbsp; afterDelay(AndGateDelay) {
&nbsp;&nbsp; &nbsp;&nbsp; output setSignal (a1Sig &amp; a2Sig)
&nbsp;&nbsp;&nbsp; } 
  }
  a1 addAction andAction
  a2 addAction andAction
}</pre>
        <p>Ефект від метода andGate є додавання andAction до обох з їх вхідних дротів, a1 та a2. ця дія, коли викликається, отримує обоє вхідні сигнали, та встановлює іншу дію, що встановлює вихідний сигнал до кон'юкції обох вхідних сигналів. Ця інша дія буде виконана після AndGateDelay одиниць симульованого часу. Зауважте, що вихід має бути переобчислений якщо жодних вхід зміниться. ось чому andAction встановлена на кожному з двох входів, a1 та a2 . Метод orGate реалізований подібним чином, за винятком того, що він виконує логічне АБО замість ТА.</p><h4>Вивід симуляції</h4><p>Щоб виконати симулятор, вам треба спосіб перевірити зміни сигналів на дротах. Щоб досягти цього, ви можете симулювати дії через розміщення на дротах контрольних точок:</p>
<pre class="prettyprint linenums language-scala">def probe(name: String, wire: Wire) {
  def probeAction() {
    println(name +" "+ currentTime +
    " new-value = "+ wire.getSignal)
  }
  wire addAction probeAction
}</pre>
        <p>Ефектом від процедури проби буде встановлення probeAction на даному дроті. Як звичано, дія виконуєтсья кожного разу, коли змінюється сигнал на дроті. В цьому випадку вона просто друкує ім'я дрота (що передається першим параметром до probe), а також поточний симульований час, та нове значення на дроті.</p><h4>Виконання симулятора</h4><p>Після всіх ціх підготувань прийшов час побачити симуляцію в дії. Щоб визначити конкретну симуляцію, вам треба наслідувати від класа фреймворка симуляції. Щоб побачити щось цікаве, ми створимо абстракту симуляцію, що розширює BasicCircuitSimulation, та містить визначення методів для напів-додавача, та повного-додавача, як вони були презентовані раніше в цій главі на Лістингу 18.6 та 18.7. Цей клас, що ми назвемо CircuitSimulation, показаний на Лістингу 18.11:</p>
<pre class="prettyprint linenums language-scala">package org.stairwaybook.simulation
<br>abstract class CircuitSimulation extends BasicCircuitSimulation {
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
  def fullAdder(a: Wire, b: Wire, cin: Wire,
    sum: Wire, cout: Wire) {
    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}</pre>
        <p>Лістинг 18.11 Клас CircuitSimulation.</p><p>Симуляція конкретної схеми буде об'єктом, що наслідує від класа CircuitSimulation. Об'єт все ще потребує полагодження затримок вентилів, відповідно до технології реалізації схеми, що симулюється. Нарешті, вам також буде потрібно визначити конкретну схему, що буде симулюватись. Ви можете зробити ці кроки в інтерпретаторі Scala:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import org.stairwaybook.simulation._
import org.stairwaybook.simulation._</pre>
        <p>Зпочатку затримки вентилів. Визначимо о'єкт (назвемо його MySimulation), що провадить деякі числа:</p>
<pre class="prettyprint linenums language-scala">scala&gt; object MySimulation extends CircuitSimulation {
  def InverterDelay = 1
  def AndGateDelay = 3
  def OrGateDelay = 5
}<br>defined module MySimulation</pre>
        <p>Оскільки ви збираєтесь отримувати доступ до членів об'єкта MySimulation неодноразово, імпорт об'єкта утримує наступний код коротшим:</p>
<pre class="prettyprint linenums language-scala">scala&gt; import MySimulation._
import MySimulation._</pre>
        <p>Далі схема. Визначимо чотири дроти, та поставимо на два з них контрольні точки (проби):</p>
<pre class="prettyprint linenums language-scala">scala&gt; val input1, input2, sum, carry = new Wire
input1: MySimulation.Wire =
BasicCircuitSimulation$Wire@111089b
input2: MySimulation.Wire =
BasicCircuitSimulation$Wire@14c352e
sum: MySimulation.Wire =
BasicCircuitSimulation$Wire@37a04c
carry: MySimulation.Wire =
BasicCircuitSimulation$Wire@1fd10fa
<br>scala&gt; probe("sum", sum)
sum 0 new-value = false
<br>scala&gt; probe("carry", carry)
carry 0 new-value = false</pre>
        <p>Зауважте, що проби безпосередньо друкують вихід. Це наслідки факту, що кожна дія, встановлена на дроті, виконується перший раз, коли встановлюється дія.&nbsp;</p><p>Тепер визначимо напів-додавач, підключений до дротів:</p>
<pre class="prettyprint linenums language-scala">scala&gt; halfAdder(input1, input2, sum, carry)</pre>
        <p>Нарешті, один за одним, ввімкнемо обидва вхідні дроти та почнемо симуляцію:</p>
<pre class="prettyprint linenums language-scala">scala&gt; input1 setSignal true
scala&gt; run()
*** simulation started, time = 0 ***
sum 8 new-value = true
scala&gt; input2 setSignal true
scala&gt; run()
*** simulation started, time = 8 ***
carry 11 new-value = true
sum 15 new-value = false</pre>
        <h3>18.7 Висновок</h3><p>Ця глава зібрала разом дві технологіїї, що виглядають окремими: змінний стан та функції вищих порядків. Змінний стан був використаний для симуляції фізичних сутностей, чий стан змінюється з часом. Функції вищого порядка були використані у фреймворці симуляції для виконання дій в задані точки в симульованому часі. Вони також були використані в симуляції схеми як тригери, що асоціюють дії зі зміном стану. В продовж цього ви бачили простий спосіб для визначення галузевої мови як бібліотеки. Це, здається, досить для однієї глави!</p><p>Якщо ви бажаєте зупинитись на цьому довше, ви можете спробувати більше прикладів симуляції. Ви можете комбінувати напів-додавач та повний додавач для створення довшої схеми, або розробити власні схеми з базових вентилів, що вже визначені, та симулювати їх. В наступній главі ви навчитесь щодо параметризації типів в Scala, та побачите приклад, в якому комбінація функціональних та імперативних підходів дає гарне рішення.</p><h3>Глава 19</h3><h2>Параметризація типів</h2><p>В цій главі я поясню деталі параметризації типів в Scala. Крім цього вона демонструє деякі з прийомів для приховування інформації, введеної в Главі 13, шляхом конкретного прикладу: розробки класа для повністю функціональних черг. Ми представляємо параметризацію типів та приховання інформації разом, оскільки приховання інформації може бути використана для отримання більш загального типа параметризації через анотації варіацій. Параметризація типів дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними, та сприймають параметр типу: вони визначені як Set[T]. Як результат, любий окремий примірник множини може бути Set[String], Set[Int], тощо — але це має бути множина чогось. На відміну від Java, яка дозволяє голі типи, Scala вимагає вказати параметр типу. Варіація визначає відношення наслідування параметризованих типів, так що, наприклад, Set[String], є субтипом до Set[AnyRef] .</p><p>Ця глава містить три частини. Перша частина розробляє структуру даних для чисто функціональної черги. Друга частина розробляє прийоми для приховання деталей внутрішнього представлення цієї структури. Заключна частина пояснює варіації параметрів типу, та як це взаємодіє з прихованням інформації.</p><h3>19.1 Функціональні черги</h3><p>Функціональна черга є структурою даних з трьома операціями:</p><p>head - повертає перший елемент черги<br>tail - повертає чергу без першого елемента<br>enqueue - повертає нову чергу з даним елементом, доданим до кінця<br><br>На відміну від змінної черги, функціональна черга не змінює власний зміст, коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль ціїє глави буде створити клас, що ми назвемо Queue, що робить таки чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val q = Queue(1, 2, 3)
q: Queue[Int] = Queue(1, 2, 3)
<br>scala&gt; val q1 = q enqueue 4
q1: Queue[Int] = Queue(1, 2, 3, 4)
<br>scala&gt; q
res0: Queue[Int] = Queue(1, 2, 3)</pre>
        <p>Якщо Queue було б змінною реалізацією, операції в другому рядку впливали б на q; фактично обоє результати, q1 та оригільнае q, будуть містити послідовність 1, 2, 3, 4 після цієї операції. Але для функціонального запиту додане значення показується тільки в результаті q1, та не в черзі q, на якій операція застосована.</p><p>Чисто функціональні черги також мають деяку подібність до списків. Обоє є так звані повністю стійки структури даних, де нові версії залишаються доступні, навіть після розширення або модифікацій. Обоє підтримують операції head та tail. Але де список звичайно розширюється з початку, використовуючи операцію ::, черга розширюється з кінця, використовуючи enqueue.</p><p>Як це може бути реалізовано ефективно? В ідеалі, функціональна (незмінна) черга не повинна мати фундаментально вищі накладні розходи, ніж імперативна (змінна). Тобто, всі три операції, head, tail та enqueue повинні оперувати за сталий час.</p><p>Один простий підхід до реалізації функціональної черги може бути використання списка як представницького типа. Тоді head та tail можуть просто транслюватись в такі ж операції зі списком, тоді як enqueue може бути конкатенацією. Це може тати таку реалізацію:</p>
<pre class="prettyprint linenums language-scala">class SlowAppendQueue[T](elems: List[T]) { // Не ефективно
  def head = elems.head
  def tail = new SlowAppendQueue(elems.tail)
  def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
}</pre>
        <p>Проблема з цією реалізацією знаходиться в операції enqueue. Вона займає час, пропорційний до числа зберігаємих в черзі елементів. Якщо ви бажаєте додавання за сталий час, ви можете також спобувати обернути порядок елементів в представницькому списку, так що перший елемент, що був доданий, піде першим в списку. Це може призвести до наступної реалізації:</p>
<pre class="prettyprint linenums language-scala">class SlowHeadQueue[T](smele: List[T]) { // Не ефективно
// smele є обернене elems
  def head = smele.last
  def tail = new SlowHeadQueue(smele.init)
  def enqueue(x: T) = new SlowHeadQueue(x :: smele)
}</pre><p>Тепер enqueue має сталий час, але не head та tail. Тепер вони займають час, пропорційний до числа елементів, що зберігаються в черзі. Дивлячись на ці два приклади, видається непростим запропонувати реалізацію, де всі три операції матимуть сталий час. Фактично, навіть виглядає сумнівним, що це взагалі можливо! Однак, комбінуючи дві операції, можна наблизитись дуже близько. Ідея в представленні черги двома списками, що називаються leading та trailing. Список leading містить елементи починаючи з початку, тоді як список trailing містить елементи починаючи з кінця, в зворотньому порядку. Вміст всієї черги на кожному кроці є “leading ::: trailing.reverse”.</p><p>Тепер, щоб додати елемент, ви просто cons його до списку trailing з використанням оператора ::, так що enqueue буде мати сталий час. Це означає, що коли спочатку пуста черга конструююється з послідовних операцій enqueue, список trailing буде зростати, тоді як список leading буде залишатись пустим. Потім, перед першим виконанням операцій head або tail на пустому списку leading, цілий список trailing копіюється до leading зі зміною порядка елементів. Це робиться в операції, що називається mirror. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.</p><p>Яка складність цієї реалізації черги? Операція mirror може мати час, пропорційний до числа елементів, але тільки якщо список leading є пустим. Вона повертається напряму, якщо leading не порожнє. Оскільки head та tail викликають mirror, їх складність може бути лінійною до розміру черги, також. Однак, чим далі стає черга, тим рідше викликається mirror. Наприклад, розгляньте чергу довжини n з порожнім списком leading. Тоді&nbsp; mirror має скопіювати обернений список довжини n. Однак наступного часу mirror не матиме виконати жодну роботу, коли список leading знову порожній, що відбудеться після n операцій tail. Це означає, що ви можете “зарядити” кожний з ціх n операцій tail однією, зі складністю одна n-нна від mirror, що означає сталий обсяг роботи. Вважаючи, що операції head, tail, та enqueue з'являються з приблизно однаковою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж ефективні, як і змінні.</p>
<pre class="prettyprint linenums language-scala">class Queue[T](
  private val leading: List[T],
  private val trailing: List[T]
) {<br>  private def mirror =
    if (leading.isEmpty)
      new Queue(trailing.reverse, Nil)
    else
      this
  def head = mirror.leading.head
  def tail = {
    val q = mirror
    new Queue(q.leading.tail, q.trailing)
  }
  def enqueue(x: T) =
    new Queue(leading, x :: trailing)
}</pre>
        <p>Лістинг 19.1 Базовий функціонал черги.</p><p>Тепер є деякі тонкощі, що треба додати до ціх аргументів. Перше, ця дискусія була тільки щодо асимптотичної поведінки, сталі фактори можуть буди зовсім іншими. Друге, аргумент покладається на факт, що head, tail та enqueue викликаються з тою ж частотою. Якщо head викликається значно частіше, ніж інші дві операції, цей досвід не діє, бо кожний head може включати коштовну реорганізацію списка за допомогою mirror. Другої пастки можна уникнути: можливо розробити функціональні черги таким чином, щоб коли є послідовність вдалих операцій head, тільки перша призводила до реорганізації. Ви знайдете те, як це робиться, в кінці цієї глави.</p><h3>19.2 Приховання інформації</h3><p>Реалізація Queue, показана в Лістингу 19.1, тепер є досить гарна з точки зору ефективності. Однак ви можете помітити, що ця ефективність оплачена показом непотрібних деталей реалізації. Конструктор Queue, доступний глобально, приймає два списка як параметри, де один є реверсований&nbsp; — навряд чи інтуітивне представлення для черги. Що потрібне, це спосіб приховати цей конструктор від клієнтського кода. В цьому розділі ми покажемо вам деякі шляхи досягти цього в Scala.</p><h4>Приватні конструктори та методи-фабрики</h4><p>В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначається неявно, через параметри та тіло класа. Тим не менш все ще можливо приховати первинний конструктор через додавання модифікатора private перед списком параметрів класа, як показано в Лістингу 19.2:</p>
<pre class="prettyprint linenums language-scala">class Queue[T] private (
  private val leading: List[T],
  private val trailing: List[T]
)</pre>
        <p>Лістинг 19.2 Приховання первинного конструктора через маркування його як приватний.</p><p>Модифікатор приватності між іменем класа, та його параметрами, індикує, що конструктор Queue є приватним: він може бути доступний тільки з самого класа, та його об'єкта-компанйона. Ім'я класа Queue є все ще публічним, так що ви можете використовувати його як клас, але ви не можете викликатий його конструктор:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Queue(List(1, 2), List(3))
&lt;console&gt;:6: error: constructor Queue cannot be accessed in
object $iw
new Queue(List(1, 2), List(3))
ˆ</pre>
        <p>Тепер, коли первинний конструктор класа Queue більше не може бути викликаний з клієнтського кода, повинен бути деякий інший спосіб створити нові черги. Одна можливість є додати додатковий конструктор, таким чином:</p>
<pre class="prettyprint linenums language-scala">def this() = this(Nil, Nil)</pre>
        <p>Додатковий конструктор, показаний в попередньому прикладі, будує порожню чергу. Як покращення, додатковий конструктор може приймати список початкових елементів черги:</p>
<pre class="prettyprint linenums language-scala">def this(elems: T*) = this(elems.toList, Nil)</pre><p>Згадайте, що T* є нотацією для повторюваних параметрів, як описано в Розділі 8.8.</p><p>Інша можливість є додати метод-фабрику, що будує чергу з такої послідовності початкових елементів. Милий спосіб зробити це є додати об'єкт Queue, що має те є ім'я, що і визначений клас, та містить метод apply, як показано в Лістингу 19.3:</p>
<pre class="prettyprint linenums language-scala">object Queue {
// конструює чергу за початковими елементами ‘xs’
  def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}</pre>
        <p>Лістинг 19.3 ·Метод-фабрика apply в об'єкті-компанйоні.</p><p>Покладаючи цей об'єкт в той же файл, що і клас Queue, ви робите об'єкт о'бєктом-компанйоном класа. Ви бачили в Розділі 13.5, що о'бєкт-компанйон має ті самі права доступа, що і клас. Завдяки цьому, метод apply об'єкта Queue може створити новий об'єкт Queue, навіть якщо конструктор класа Queue є приватним.</p><p>Зауважте, що оскільки метод-фабрика має назву apply, клієнти можуть створювати черги за допомогою виразів, таких, як Queue(1, 2, 3). Цей вираз розширюється до Queue.apply(1, 2, 3), оскільки Queue є об'єктом, а не функцією. Як результат, Queue вигладає для клієнта, як якщо це була б глобально визначена метод-фабрика. Насправді, Scala не має глобально видімих методів; кожний метод повинен міститись в об'єкті або класі. Однак використання методів з назвою apply в глобальних об'єктах, ви можете підтримувати шаблони використання, що виглядають як виклики глобальних методів.</p><h4>Альтернатива: приватні класи</h4>
<pre class="prettyprint linenums language-scala">trait Queue[T] {
  def head: T
  def tail: Queue[T]
  def enqueue(x: T): Queue[T]
}
object Queue {
  def apply[T](xs: T*): Queue[T] =
    new QueueImpl[T](xs.toList, Nil)
  private class QueueImpl[T](
  private val leading: List[T],
  private val trailing: List[T]
) extends Queue[T] {
  def mirror =
    if (leading.isEmpty)
      new QueueImpl(trailing.reverse, Nil)
    else
      this
  def head: T = mirror.leading.head
  def tail: QueueImpl[T] = {
    val q = mirror
    new QueueImpl(q.leading.tail, q.trailing)
  }
  def enqueue(x: T) =
    new QueueImpl(leading, x :: trailing)
  }
}</pre>
        <p>Лістинг 19.4 Абстракція типа для функціональних черг.</p><p>Приватні конструктори та приватні члени є одним шляхом для приховання ініціалізації та репрезентації классів. Інший, більш радикальний шлях є приховати сам клас, та тільки експортувати трейт, що демонструє публічний інтерфейс класа. Код в Лістингу 19.4 реалізує цей дизайн. Існує трейт Queue, що декларує методи head, tail та enqueue. Всі три методи реалізовані в субкласі QueueImpl, що сам є приватним внутрішнім класом об'єкта Queue. Це показує клієнту ту ж саму інформацію як і раніше, але використовує інший прийом. Замість приховання індивідуальні конструктори та методи, ця версія приховує повну реалізацію класа.</p><h3>19.3 Анотації варіацій</h3><p>Черга, що визначена в Лістингу 19.4, є трейтом, але не типом. Черга не є типом, оскільки приймає параметр типа. Як результат, ви не не можете створити змінні типу Queue :</p>
<pre class="prettyprint linenums language-scala">scala&gt; def doesNotCompile(q: Queue) {}
&lt;console&gt;:5: error: trait Queue takes type parameters
def doesNotCompile(q: Queue) {}
ˆ</pre>
        <p>Замість цього трейт Queue дозвоялє вам задати параметр типа, такий, як Queue[String], Queue[Int] , або Queue[AnyRef] :</p>
<pre class="prettyprint linenums language-scala">scala&gt; def doesCompile(q: Queue[AnyRef]) {}
doesCompile: (Queue[AnyRef])Unit</pre>
        <p>Таким чином, Queue є трейтом, та Queue[String] є типом. Queue також називається конструктором типа, оскільки з ним ви можете конструювати тип, задавши параметр типу. (Це аналогічно до конструювання примірника об'єкта за допомогою старого-звичайного конструктора, перадавши значення параметра). Конструктор типу Queue “генерує” сімейство типів, що включає Queue[Int], Queue[String] та Queue[AnyRef] .</p><p>Ви також можете скзати, що Queue є трейтом-дженеріком. (Класи та трейти, що приймають параметри типу є “дженеріками”, але типи, що вони генерують, є “параметризованими”, не загальними). Термін “дженерік” означає, що ви визначаєте багато окремих типів з одного, загально написаного, класа або трейта. Наприклад, трейт Queue в лістингу 19.4 визначає загальну чергу. Queue[Int] та Queue[String], тощо, будуть спецефічними чергами.</p><p>Комбінація параметрів типу та субтіпів викриває деякі цікаві питання. Наприклад, чи є любі особливі віношення субтипів між членами сім'ї типів, згенерованих Queue[T]. Більш точно, чи має Queue[String] розглядатись субтипом до Queue[AnyRef]? Або більш загально, якщо S є підтипом типа T, тоді чи має Queue[S] розглядатись як субтип Queue[T]? Якщо так, ви можете сказати, що трейт Queue є коваріантним (або “гручким”) в своєму параметрі типа T. Або, оскільки він має тільки один параметр типа, можна просто сказати, що Queue є коваріантом. </p><p>Коваріантність Queue може, наприклад, означати, що ви можете передати Queue[String] до метода doesCompile, показаний раніше, що приймає значення параметра типу Queue[AnyRef] .</p><p>Інтуітивно, все це виглядає добре, оскільки черга String виглядає як окремий випадок черги AnyRef. Однак в Scala узагальнені типи мають по замовчанню нонваріантну (або “ригідну”) субтипізацію. Тобто, коли Queue визначене як в Лістингу 19.4, черги з різними типами елементів ніколи не будуть в відношенні субтипів. Queue[String] не буде корисним в якості Queue[AnyRef]. Однак ви можете вимагати коваріантної (гнучкої) субтипізації черг, через зміну першого рядка визначення класа Queue таким чином:</p>
<pre class="prettyprint linenums language-scala">trait Queue[+T] { ... }</pre>
        <p>Префікс формального параметра типа в вигляді + вказує, що субтипізація є коваріантною (гнучкою) для цього параметра. Через додавання цього єдиного символа, ви кажете Scala, що ви бажаєте, щоб Queue[String], наприклад, розглядалось як субтип для Queue[AnyRef]. Компілятор буде перевіряти, що Queue визначений в спосіб, що ця субтипізація має сенс. Окрім + є також префікс -, що індикує контрваріантну типізацію. Якщо Queue було визначене таким чином:</p>
<pre class="prettyprint linenums language-scala">trait Queue[-T] { ... }</pre>
        <p>тоді якщо T є субтипом типа S, це означає, що Queue[S] є субтипом Queue[T] (що в випадку черг було б скоріше сюрпризом)! Коли параметр є коваріантним, контрваріантним, або нонваріантним, це називається варіантністю параметрва. Символи + та -, які ви можете поставити поряд з параметрами типів, називаються анотаціями варіації.</p><p>В повністю функціональному світі багато типів є природно коваріантними (гнучкими). Однак ситуація змінюється, коли ви вводите змінні дані. Щоб зрозуміти чому, розглянемо простий тип з одноелементних клітин, що можуть бути прочитані або записані, показанй на Лістингу 19.5.</p>
<pre class="prettyprint linenums language-scala">class Cell[T](init: T) {
  private[this] var current = init
  def get = current
  def set(x: T) { current = x }
}</pre>
        <p>Лістинг 19.5 Нонваріантний (ригідний) клас Cell.</p><p>Тип Cell на Лістингу 19.5 декларований як нонваріантний (рігидний). Для цілей аргументації, уявіть на момент, що Cell був би, навпаки, декларований як коваріантний — тобто, він був декларований як клас Cell[+T] — та що це б пройшло через компілятор Scala. (Цього не буде, і ми через мить пояснимо чому). Тоді ви б могли сконструювати наступну проблематичну послідовність тверджень:</p>
<pre class="prettyprint linenums language-scala">val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get</pre>
        <p>Взяті поодинці, кожна з ціх чотирьох рядків виглядає добре. Перший рядок створює клітину рядків, та зберігає її в val на ім'я c1. Друий рядок визначає нову val c2, типу Cell[Any], що ініційований c1. Це можливо, оскільки Cell розглядається як коваріант. Третій рядок встановлює значення клітини c2 в 1. Це також можливе, оскільки присвоєне значення 1 є примірником типа елемента c2, Any. Нарешті, останнє присвоєння значення елемента c1 до рядка. Тут нічого дивного, бо обоє частини є одного типа. Але взяті разом, ці три рядка завершуються присвоєнням цілого 1 рядку s. Це явне порушення міцності типів.</p><p>Яка операція призведе до відмови часу виконання? Це має бути друга, що використовує коваріантну субтипізацію. Інші твердження дуже прості та фундаментальні. Таким чином, Cell з String не є також Cell з Any, оскільки є речі, що ви можете робити з Cell з Any, що ви не можете робити з Cell зі String. Наприклад, ви не можете використовувати set з аргументом Int на Cell зі String.</p><p>Фактично, коли ви передасте коваріантну версію Cell до компілятора&nbsp; Scala, ви отримаєте помилку часу компіляці:</p>
<pre class="prettyprint linenums language-scala">Cell.scala:7: error: covariant type T occurs in
contravariant position in type T of value x
def set(x: T) = current = x
ˆ</pre>
        <h4>Варіації та масиви</h4><p>Цікаво порівняти цю поведінку з масивами в Java. В принципі масиви є тільки клітини, за тим винятком, що вони можуть зберігати більше одного елемента. Тим не менш, масиви трактуються як коваріантні в Java. Ви можете спробувати приклад, подібний до взаємодії з клітиною вище з масивами Java:</p>
<pre class="prettyprint linenums language-scala">// це Java
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];</pre>
         <p>Якщо ви спробуєте цей приклад, ви будете бачити, що це компілюється, але виконання програми спричинить виключення ArrayStore під час, коли до a2[0] присвоюється Integer :</p>
<pre class="prettyprint linenums language-scala">Exception in thread "main" java.lang.ArrayStoreException:
java.lang.Integer
at JavaArrays.main(JavaArrays.java:8)</pre>
        <p>Що тут відбуваєтсья, це те, що Java зберігає stores the element type of the array at run-<br>time. Then, every time an array element is updated, the new element value<br>is checked against the stored type. If it is not an instance of that type, an<br>ArrayStore exception is thrown.</p><p>You might ask why Java adopted this design, which seems both unsafe<br>and expensive. When asked this question, James Gosling, the principal in-<br>ventor of the Java language, answered that they wanted to have a simple<br>means to treat arrays generically. For instance, they wanted to be able to<br>write a method to sort all elements of an array, using a signature like the<br>following that takes an array of Object :</p><p>void sort(Object[] a, Comparator cmp) { ... }</p><p>Covariance of arrays was needed so that arrays of arbitrary reference types<br>could be passed to this sort method. Of course, with the arrival of Java<br>generics, such a sort method can now be written with a type parameter, so<br>the covariance of arrays is no longer necessary. For compatibility reasons,<br>though, it has persisted in Java to this day.</p><p>Scala tries to be purer than Java in not treating arrays as covariant. Here’s<br>what you get if you translate the first two lines of the array example to Scala:</p><p>scala&gt; val a1 = Array("abc")<br>a1: Array[java.lang.String] = Array(abc)<br>scala&gt; val a2: Array[Any] = a1<br>&lt;console&gt;:5: error: type mismatch;<br>found<br>: Array[java.lang.String]<br>required: Array[Any]<br>val a2: Array[Any] = a1<br>ˆ<br>What happened here is that Scala treats arrays as nonvariant (rigid), so an<br>Array[String] is not considered to conform to an Array[Any] . However,<br>sometimes it is necessary to interact with legacy methods in Java that use an<br>Object array as a means to emulate a generic array. For instance, you might<br>want to call a sort method like the one described previously with an array<br>of String s as argument. To make this possible, Scala lets you cast an array<br>of T s to an array of any supertype of T :</p><p>scala&gt; val a2: Array[Object] =<br>a1.asInstanceOf[Array[Object]]<br>a2: Array[java.lang.Object] = Array(abc)</p><p>The cast is always legal at compile-time, and it will always succeed at run-<br>time, because the JVM’s underlying run-time model treats arrays as covari-<br>ant, just as Java the language does. But you might get ArrayStore excep-<br>tions afterwards, again just as you would in Java.</p><h4>19.4 Checking variance annotations</h4><p>Now that you have seen some examples where variance is unsound, you may<br>be wondering which kind of class definitions need to be rejected and which<br>can be accepted. So far, all violations of type soundness involved some re-<br>assignable field or array element. The purely functional implementation of<br>queues, on the other hand, looks like a good candidate for covariance. How-<br>ever, the following example shows that you can “engineer” an unsound situ-<br>ation even if there is no reassignable field.</p><p>To set up the example, assume that queues as defined in Listing 19.4 are<br>covariant. Then, create a subclass of queues that specializes the element type<br>to Int and overrides the enqueue method:</p><p>class StrangeIntQueue extends Queue[Int] {<br>override def enqueue(x: Int) = {<br>println(math.sqrt(x))<br>super.enqueue(x)<br>}<br>}</p><p>The enqueue method in StrangeIntQueue prints out the square root of its<br>(integer) argument before doing the append proper. Now, you can write a<br>counterexample in two lines:</p><p>val x: Queue[Any] = new StrangeIntQueue<br>x.enqueue("abc")</p><p>The first of these two lines is valid, because StrangeIntQueue is a subclass<br>of Queue[Int] , and, assuming covariance of queues, Queue[Int] is a sub-<br>type of Queue[Any] . The second line is valid because you can append a<br>String to a Queue[Any] . However, taken together these two lines have the<br>effect of applying a square root method to a string, which makes no sense.<br>Clearly it’s not just mutable fields that make covariant types unsound.</p><p>The problem is more general. It turns out that as soon as a generic parameter<br>type appears as the type of a method parameter, the containing class or trait<br>may not be covariant in that type parameter. For queues, the enqueue method<br>violates this condition:</p><p>class Queue[+T] {<br>def enqueue(x: T) =<br>...<br>}</p><p>Running a modified queue class like the one above through a Scala compiler<br>would yield:</p><p>Queues.scala:11: error: covariant type T occurs in<br>contravariant position in type T of value x<br>def enqueue(x: T) =<br>ˆ</p><p>Reassignable fields are a special case of the rule that disallows type parame-<br>ters annotated with + from being used as method parameter types. As men-<br>tioned in Section 18.2, a reassignable field, “ var x: T ”, is treated in Scala as<br>a getter method, “ def x: T ”, and a setter method, “ def x_=(y: T) ”. As you<br>can see, the setter method has a parameter of the field’s type T . So that type<br>may not be covariant.</p><h4>The fast track</h4><p>In the rest of this section, we’ll describe the mechanism by which the<br>Scala compiler checks variance annotations. If you’re not interested in<br>such detail right now, you can safely skip to Section 19.5. The most<br>important thing to understand is that the Scala compiler will check any<br>variance annotations you place on type parameters. For example, if you try<br>to declare a type parameter to be covariant (by adding a + ), but that could<br>lead to potential runtime errors, your program won’t compile.</p><p>To verify correctness of variance annotations, the Scala compiler classi-<br>fies all positions in a class or trait body as positive, negative, or neutral. A<br>“position” is any location in the class (or trait, but from now on we’ll just<br>write “class”) body where a type parameter may be used. Every method<br>value parameter is a position, for example, because a method value parame-<br>ter has a type, and therefore a type parameter could appear in that position.<br>The compiler checks each use of each of the class’s type parameters. Type<br>parameters annotated with + may only be used in positive positions, while<br>type parameters annotated with - may only be used in negative positions.<br>A type parameter with no variance annotation may be used in any position,<br>and is, therefore, the only kind of type parameter that can be used in neutral<br>positions of the class body.</p><p>To classify the positions, the compiler starts from the declaration of a<br>type parameter and then moves inward through deeper nesting levels. Po-<br>sitions at the top level of the declaring class are classified as positive. By<br>default, positions at deeper nesting levels are classified the same as that at<br>enclosing levels, but there are a handful of exceptions where the classifica-<br>tion changes. Method value parameter positions are classified to the flipped<br>classification relative to positions outside the method, where the flip of a pos-<br>itive classification is negative, the flip of a negative classification is positive,<br>and the flip of a neutral classification is still neutral.</p><p>Besides method value parameter positions, the current classification is<br>also flipped at the type parameters of methods. A classification is sometimes<br>flipped at the type argument position of a type, such as the Arg in C[Arg] ,<br>depending on the variance of the corresponding type parameter. If C ’s type<br>parameter is annotated with a + then the classification stays the same. If<br>C ’s type parameter is annotated with a - , then the current classification is<br>flipped. If C ’s type parameter has no variance annotation then the current<br>classification is changed to neutral.</p><p>As a somewhat contrived example, consider the following class defini-<br>tion, where the variance of several positions is annotated with + (for positive)<br>or − (for negative):</p><p>abstract class Cat[-T, +U] {<br>def meow[W − ](volume: T − , listener: Cat[U + , T − ] − )<br>: Cat[Cat[U + , T − ] − , U + ] +<br>}</p><p>The positions of the type parameter, W , and the two value parameters,<br>volume and listener , are all negative. Looking at the result type of meow ,<br>the position of the first Cat[U, T] argument is negative, because Cat ’s first<br>type parameter, T , is annotated with a - . The type U inside this argument is<br>again in positive position (two flips), whereas the type T inside that argument<br>is still in negative position.</p><p>You see from this discussion that it’s quite hard to keep track of variance<br>positions. That’s why it’s a welcome relief that the Scala compiler does this<br>job for you.</p><p>Once the variances are computed, the compiler checks that each type<br>parameter is only used in positions that are classified appropriately. In this<br>case, T is only used in negative positions, and U is only used in positive<br>positions. So class Cat is type correct.</p><h3>19.5 Lower bounds</h3><p>Back to the Queue class. You saw that the previous definition of Queue[T]<br>shown in Listing 19.4 cannot be made covariant in T because T appears as a<br>type of a parameter of the enqueue method, and that’s a negative position.<br>Fortunately, there’s a way to get unstuck: you can generalize enqueue<br>by making it polymorphic (i.e., giving the enqueue method itself a type pa-<br>rameter) and using a lower bound for its type parameter. Listing 19.6 shows<br>a new formulation of Queue that implements this idea.</p><p>class Queue[+T] (private val leading: List[T],<br>private val trailing: List[T] ) {<br>def enqueue[U &gt;: T](x: U) =<br>new Queue[U](leading, x :: trailing) // ...<br>}</p><p>Listing 19.6 · A type parameter with a lower bound.</p><p>The new definition gives enqueue a type parameter U , and with the syntax,<br>“ U &gt;: T ”, defines T as the lower bound for U . As a result, U is required to be a<br>supertype of T . 1 The parameter to enqueue is now of type U instead of type<br>T , and the return value of the method is now Queue[U] instead of Queue[T] .<br>As an example, suppose there is a class Fruit with two subclasses,<br>Apple and Orange . With the new definition of class Queue , it is possible to<br>append an Orange to a Queue[Apple] . The result will be a Queue[Fruit] .<br>This revised definition of enqueue is type correct. Intuitively, if T is a<br>more specific type than expected (for example, Apple instead of Fruit ), a<br>call to enqueue will still work, because U ( Fruit ) will still be a supertype of<br>T ( Apple ). 2</p><p>The new definition of enqueue is arguably better than the old, because<br>it is more general. Unlike the old version, the new definition allows you to<br>append an arbitrary supertype U of the queue element type T . The result is<br>then a Queue[U] . Together with queue covariance, this gives the right kind<br>of flexibility for modeling queues of different element types in a natural way.<br>This shows that variance annotations and lower bounds play well to-<br>gether. They are a good example of type-driven design, where the types of<br>an interface guide its detailed design and implementation. In the case of<br>queues, you would probably not have thought of the refined implementation<br>of enqueue with a lower bound, but you might have decided to make queues<br>covariant. In that case, the compiler would have pointed out the variance<br>error for enqueue . Correcting the variance error by adding a lower bound<br>makes enqueue more general and queues as a whole more usable.</p><p>1 Supertype<br>and subtype relationships are reflexive, which means a type is both a super-<br>type and a subtype of itself. Even though T is a lower bound for U , you could still pass in a T<br>to enqueue .<br>2 Technically, what happens is a flip occurs for lower bounds. The type parameter U is in<br>a negative position (1 flip), while the lower bound ( &gt;: T ) is in a positive position (2 flips).</p><p>This observation is also the main reason that Scala prefers declaration-<br>site variance over use-site variance as it is found in Java’s wildcards. With<br>use-site variance, you are on your own designing a class. It will be the clients<br>of the class that need to put in the wildcards, and if they get it wrong, some<br>important instance methods will no longer be applicable. Variance being a<br>tricky business, users usually get it wrong, and they come away thinking that<br>wildcards and generics are overly complicated. With definition-side vari-<br>ance, you express your intent to the compiler, and the compiler will double<br>check that the methods you want available will indeed be available.</p><h3>19.6 Contravariance</h3><p>So far in this chapter, all examples you’ve seen were either covariant or non-<br>variant. But there are also cases where contravariance is natural. For in-<br>stance, consider the trait of output channels shown in Listing 19.7:<br>trait OutputChannel[-T] {<br>def write(x: T)<br>}</p><p>Listing 19.7 · A contravariant output channel.</p><p>Here, OutputChannel is defined to be contravariant in T . So an output chan-<br>nel of AnyRef s, say, is a subtype of an output channel of String s. Al-<br>though it may seem non-intuitive, it actually makes sense. To see why, con-<br>sider what you can do with an OutputChannel[String] . The only sup-<br>ported operation is writing a String to it. The same operation can also<br>be done on an OutputChannel[AnyRef] . So it is safe to substitute an<br>OutputChannel[AnyRef] for an OutputChannel[String] . By contrast,<br>it would not be safe to substitute an OutputChannel[String] where an<br>OutputChannel[AnyRef] is required. After all, you can send any object<br>to an OutputChannel[AnyRef] , whereas an OutputChannel[String] re-<br>quires that the written values are all strings.</p><p>This reasoning points to a general principle in type system design: it<br>is safe to assume that a type T is a subtype of a type U if you can sub-<br>stitute a value of type T wherever a value of type U is required. This is<br>called the Liskov Substitution Principle. The principle holds if T supports the<br>same operations as U and all of T ’s operations require less and provide more</p><p>trait Function1[-S, +T] {<br>def apply(x: S): T<br>}</p><p>Listing 19.8 · Covariance and contravariance of Function1 s.</p><p>than the corresponding operations in U . In the case of output channels, an<br>OutputChannel[AnyRef] can be a subtype of an OutputChannel[String]<br>because the two support the same write operation, and this operation re-<br>quires less in OutputChannel[AnyRef] than in OutputChannel[String] .<br>“Less” means the argument is only required to be an AnyRef in the first case,<br>whereas it is required to be a String in the second case.</p><p>Sometimes covariance and contravariance are mixed in the same type.<br>A prominent example is Scala’s function traits. For instance, whenever you<br>write the function type A =&gt; B , Scala expands this to Function1[A, B] . The<br>definition of Function1 in the standard library uses both covariance and<br>contravariance: the Function1 trait is contravariant in the function argument<br>type S and covariant in the result type T , as shown in Listing 19.8. This<br>satisfies the Liskov substitution principle, because arguments are something<br>that’s required, whereas results are something that’s provided.<br>As an example, consider the application shown in Listing 19.9. In this<br>example, class Publication contains one parametric field, title , of type<br>String . Class Book extends Publication and forwards its string title<br>parameter to the constructor of its superclass. The Library singleton object<br>defines a set of books and a method printBookList , which takes a function,<br>named info , of type Book =&gt; AnyRef . In other words, the type of the lone<br>parameter to printBookList is a function that takes one Book argument and<br>returns an AnyRef . The Customer application defines a method, getTitle ,<br>which takes a Publication as its lone parameter and returns a String , the<br>title of the passed Publication .</p><p>Now take a look at the last line in Customer . This line invokes Library ’s<br>printBookList method and passes getTitle , wrapped in a function value:<br>Library.printBookList(getTitle)</p><p>This line of code type checks even though String , the function’s result type,<br>is a subtype of AnyRef , the result type of printBookList ’s info param-<br>eter. This code passes the compiler because function result types are de-</p><p>class Publication(val title: String)<br>class Book(title: String) extends Publication(title)<br>object Library {<br>val books: Set[Book] =<br>Set(<br>new Book("Programming in Scala"),<br>new Book("Walden")<br>)<br>def printBookList(info: Book =&gt; AnyRef) {<br>for (book &lt;- books) println(info(book))<br>}<br>}<br>object Customer extends Application {<br>def getTitle(p: Publication): String = p.title<br>Library.printBookList(getTitle)<br>}</p><p>Listing 19.9 · Demonstration of function type parameter variance.</p><p>clared to be covariant (the +T in Listing 19.8). If you look inside the body of<br>printBookList , you can get a glimpse of why this makes sense.<br>The printBookList method iterates through its book list, and invokes<br>the passed function on each book. It passes the AnyRef result returned by<br>info to println , which invokes toString on it and prints the result. This<br>activity will work with String as well as any other subclass of AnyRef ,<br>which is what covariance of function result types means.</p><p>Now consider the parameter type of the function being passed to the<br>printBookList method. Although printBookList ’s parameter type is de-<br>clared as Book , the getTitle we’re passing in takes a Publication , a su-<br>pertype of Book . The reason this works is that since printBookList ’s pa-<br>rameter type is Book , the body of the printBookList method will only be<br>allowed to pass a Book into the function. And because getTitle ’s parameter<br>type is Publication , the body of that function will only be able to access on<br>its parameter, p , members that are declared in class Publication . Because<br>any method declared in Publication is also available on its subclass Book ,<br>everything should work, which is what contravariance of function parameter types means. You can see all this graphically in Figure 19.1.</p><p>argument type<br>Book =&gt; AnyRef<br>Book<br>Publication 441<br>result type AnyRef<br>Publication =&gt; String<br>String </p><p>Малюнок 19.1 Коваріантність та контрваріантність в параметрах типу функції.</p><p>Код в Лістингу 19.9 компілюється, бо Publication =&gt; String є субтипом до Book =&gt; AnyRef , як показано по центру Малюнка 19.1. Оскільки результуючий тип Function1 визначений я коваріантний, відношення наслідування двох отриманих типів, показаних зправа діаграми, в тому ж напрямку, що і для двох функцій, показаних по центру. І навпаки, оскільки параметр типу Function1 визначений як коваріантний, відношення наслідування двох параметрів типу, показаних зліва діаграми, є в протилежних напрямках, ніж для двох функцій.</p><h3>19.7 Об’єкт-приватні дані</h3><p>Клас Queue, що ми вже бачили, має проблему в тому, що&nbsp; операція mirror може повторно копіювати залишок trailing в список leading, якщо вона викликається декілька разів поспіль на списку, де leading. Марного копіювання можна уникнути через додавання деякого розважливого побічного ефекту. Лістинг 19.10 представляє нову реалізацію Queue, що виконує щонайменьше одне вирівнювання trailing до leading для кожної послідовності операцій head.</p><p>Що змінилось з точки зору попередньої версії, це те, що тепер leading та trailing є переприсвоювані значення, та mirror виконує зворотнє копіювання з trailing до leading як побічний ефект на поточній черзі, замість повертати нову чергу. Цей побічний ефект повністю внутрішній до реалізації операцій Queue; оскікльи leading та trailing є приватними змінними, ефект не видимий для клієнтів Queue. Так що за термінологією, встановленою в Главі 18, нова версія Queue все ще виражає чисто функціональні об’єкти, не зважаючи на факт, що тепер вони містять перепризначувані поля.</p>
<pre class="prettyprint linenums language-scala">class Queue[+T] private (
  private[this] var leading: List[T],
  private[this] var trailing: List[T]
) {
  private def mirror() =
    if (leading.isEmpty) {
      while (!trailing.isEmpty) {
        leading = trailing.head :: leading
        trailing = trailing.tail
      }
    }
  def head: T = {
    mirror()
    leading.head
  }
  def tail: Queue[T] = {
    mirror()
    new Queue(leading.tail, trailing)
  }
  def enqueue[U &gt;: T](x: U) =
    new Queue[U](leading, x :: trailing)
}</pre>
        <p>Лістинг 19.10 Оптимізована функціональна черга.</p><p>Ви можете поцікавитись, чи цей код пройде первірку типів Scala. В кінці кінців, тепер він містить два перепризначувані поля коваріантного параметра типу T. Чи це не порушення правил варіації? Це могло б бути так, за винятком деталі, що leading та trailing мають модифікатор private[this], і, таким чином, визначені як приватні до об’єкта.</p><p>Як згадувалось в Розділі 13.5, об’єктно-праватні члени можуть отримати доступ тільки з середини об’єкта, в якому вони визначені. Виявляється, що доступ до змінних з того ж об’єкта, в якому вони визначені, не викликає проблеми з варіантністю. Інтуітивним поясненням до цього в тому, що щоб сконструювати випадок, де варіантність може призвести до помилок типу, вам треба мати посилання на містячий об’єкт, що має статично слабший тип, ніж тип об’єкта, в якому він визначений. Однак для об’єкт-приватних значень це не можливо.&nbsp;</p><p>Правила перевірки варіацій Scala містять спеціальний випадок для об’єктно-приватних визначень. Такі визначення опускаються, коли перевірено, що параметр типу з анотацією + або - з’являється тільки в позиціях, що мають ту ж класифікацію варіації. Таким чином, код в Лістингу 19.10 компілюється без помилок. З іншого боку, якщо ви відкинете кваліфікатори [this] з двох приватних модифікаторів, ви побачите длві помилки типу:</p>
<pre class="prettyprint linenums language-scala">Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter leading_=
class Queue[+T] private (private var leading: List[T],
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter trailing_=
private var trailing: List[T]) {
ˆ</pre>
        <h3>19.8 Верхня межа</h3><p>В Лістингу 16.1 ми показалу функцію сортування злиттям для списків, що приймають функцію порівняння як перший аргумент, та список для сортування як другий, карований, аргумент. Інший шлях, як ви можете організувати таку функцію sort є вимагати від типу списка підміксувати трейт Ordered. Як згадувалось в Розділі 12.4, міксуючи Ordered до класа та реалізуючи один абстрактний метод, compare, ви дозволяєте клієнтам порівнювати примірники цього класа за допомогою &lt; , &gt; , &lt;= , та &gt;= . Наприклад, Лістинг&nbsp; 19.11 показує, як Ordered домішується до класа Person. Як результат, ви можете порівнювати особи таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val robert = new Person("Robert", "Jones")
robert: Person = Robert Jones
scala&gt; val sally = new Person("Sally", "Smith")
sally: Person = Sally Smith
scala&gt; robert &lt; sally
res0: Boolean = true

class Person(val firstName: String, val lastName: String)
extends Ordered[Person] {
  def compare(that: Person) = {
    val lastNameComparison =
      lastName.compareToIgnoreCase(that.lastName)
    if (lastNameComparison != 0)
      lastNameComparison
    else
      firstName.compareToIgnoreCase(that.firstName)
  }
  override def toString = firstName +" "+ lastName
}</pre>
        <p>Лістинг 19.11 Клас Person, що міксується&nbsp; з трейтом Ordered.</p>
<pre class="prettyprint linenums language-scala">def orderedMergeSort[T &lt;: Ordered[T]](xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) =&gt; ys
      case (_, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (x &lt; y) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
    val n = xs.length / 2
    if (n == 0) xs
    else {
      val (ys, zs) = xs splitAt n
      merge(orderedMergeSort(ys), orderedMergeSort(zs))
    }
}</pre>
        <p>Лістинг 19.12 Функція сортування злиттям з верхньою межою.</p><p>Щоб вимагати, щоб тип списка, переданого до вашої нової функції sort міксувався з Ordered, вам треба використати верхню межу. Верхня межа виглядає подібно до нижньої межі, за винятком того, що замість симовла&nbsp; &gt;: для нижньої межі ви використовуєте символ &lt;:, як показано в Лістингу 19.12. З синтаксисом "T &lt;: Ordered[T] ” ви вказуєте, що параметр типу T має верхню межу, Ordered[T]. Це означає, що елемент типу списку, переданого до orderedMergeSort має бути субтипом до Ordered. Таким чином, ви можете передати List[Person] до orderedMergeSort, оскільки Person підмішує Ordered. Наприклад, розглянемо цей список:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val people = List(
new Person("Larry", "Wall"),
new Person("Anders", "Hejlsberg"),
new Person("Guido", "van Rossum"),
new Person("Alan", "Kay"),
new Person("Yukihiro", "Matsumoto")
)
people: List[Person] = List(Larry Wall, Anders Hejlsberg,
Guido van Rossum, Alan Kay, Yukihiro Matsumoto)</pre>
        <p>Оскільки&nbsp; тип елемента цього списка, Person, підмішується (та є, таким чином, підтипом) Ordered[People], ви можете передати список до orderedMergeSort :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val sortedPeople = orderedMergeSort(people)
sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
Yukihiro Matsumoto, Guido van Rossum, Larry Wall)</pre>
        <p>Тепер, хоча функція sort, показана в Лістингу 19.12 прислуговується як корисна ілюстрація верньої межі, насправді це не найбільш загальний спосіб в Scala розробити функцію sort, що приймає вигоду трейта Ordered. Наприклад, ви не можете використовувати функцію orderedMergeSort для сортування списка цілих, оскільки клас Int не є субтипом Ordered[Int] :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val wontCompile = orderedMergeSort(List(3, 2, 1))
&lt;console&gt;:5: error: inferred type arguments [Int] do
not conform to method orderedMergeSort's type
parameter bounds [T &lt;: Ordered[T]]
val wontCompile = orderedMergeSort(List(3, 2, 1))
ˆ</pre>
        <p>В Розділі 21.6 ми покажемо вам, як використовувати неявні параметри та межі поля зору для досяження більш загального рішення.</p><h4>19.9 Висновок</h4><p>В цій главі ви бачили декілька прийомів для приховання інформації: приватні конструктори, методи-фабрики, абстракції типів приватні члени об’єктів. Ви також вивчили, як вказати варіантність типів даних, та що це накладає на реалізації класів. Нарешті, ви бачили два прийоми, що допомагають в отриманні гнучких анотацій варіації: нижчі межі для параметрів типів метода, та анотації private[this] для локальних полів та методів.&nbsp;
</p></body></html>