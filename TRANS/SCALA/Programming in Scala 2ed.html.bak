<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Програмування на Scala 2ed Перекладено українською</title>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
          .refer {
            color: darkgrey; 
            font-size: small;
          }
          h1{ color: white; }
          h2{ color: white; }
          h3{ color: white; }
          h4{ color: white; }
          body {
           color: #6fcde8; 
 				   background-color: #515151;
           font-family: "Verdana", Arial, sans;
           font-size: 1.2em; 
					}
        </style>
  </head>
  <body>
    <address> Перекладено українською - <a href="mailto:ac2epsilon@gmail.com" style="color:white">Арсеній
        Чеботарьов</a> - Ніжин-Київ 2016-2018</address>
    <h1 style="text-align: center;">Програмування на Scala</h1>
    <h1 style="text-align: center;">Друга редакція</h1>
    <p style="text-align: center;">Martin Odersky - Lex Spoon - Bill Venner</p>
    <h3>Глава 1</h3>
    <h2>Маштабована мова</h2>
    <p>Ім'я Scala означає "маштабована мова". Мова названа так, оскільки вона
      розроблена до зростання за потребами користувача. Ви можете застосувати
      Scala до широкого диапазона програмних завдань, від написання малих
      скриптів, до побудови великих систем. </p>
    <p>До Scala легко дістатись. Вона робить на стандартній платформі Java, та
      взаємодіє без проблем з усіма бібліотеками Java. Це досить гарна мова для
      написання скриптів, що поєднують разом Java компоненти. Але вона може
      застосувати свої сильні сторони навіть більше, при побудові великих систем
      та фреймворків повторно застосованих компонент. </p>
    <p>Технічно, Scala є сумішшю об'єктно-орієнтовної, та функціональної
      концепції статично типізованої мови. Сплав об'єктно-орієнтованого та
      функціонального програмування проявляє себе в багатьох аспектах Scala; це,
      можливо, більш поширено, ніж в інших, широко застосованих, мовах. Два
      програмні стилі мають доповнюючу силу, коли доходить до маштабованості.
      Конструкції функціонального програмування Scala спрощують швидку побудову
      цікавих речей з простих частин. Її об'єктно-орієнтовні конструкції
      спрощують структурування більших систем, та їх адаптацію до нових вимог.
      Комбінація обох стилів в Scala робить можливим виразити нові різновиди
      шаблонів програмування та абстракції компонент. Це також призводить до
      розбірливого та стислого стилю програмування. Та, оскільки це так
      піддатливе, програмування на Scala може буде дуже приємним. </p>
    <p>Перший розділ відповідає на питання "Чому Scala?". Він дає високорівневий
      погляд да дизайн Scala, та на міркування, що стоять за цім. Після читання
      глави ви повинні отримати базове відчуття, для чого створена Scala, та що
      за типи завдань вона може допомогти вам вирішити. Хоча це книга є
      підручникок зі Scala, ця глава насправді не є частиною підручника. Якщо ви
      прагнете почати писати деякий Scala код, ви можете перейти до Глави 2.</p>
    <h3>1.1 Мова, що зростає разом з вами</h3>
    <p>Програми різного розміру мають схильність потребувати різних програмних
      конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p>
    <pre class="prettyprint linenums language-scala"> var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
      capital += ("Japan" -&gt; "Tokyo")
      println(capital("France"))</pre>
    <p>Ця програма встановлює відображення між країнами, та їх столицями,
      модифікує мапу додаванням нової прив'язки ("Japan" -&gt; "Tokyo"), та
      друкує столицю, асоційовану з країною France. Нотація цього прикладу є
      високорівневою, та не захаращена додатковими крапками та комами, або
      анотаціями типів.Таким чином, вона відчувається як "скриптова" мова, як
      Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що
      відноситься до прикладу вище, в тому, що вони всі підтримують конструкцію
      "асоціативної мапи" в синтаксисі самої мови. </p>
    <p>Асоціативні мапи дуже корисні, оскільки вони допомагають утримувати
      програми розбірливими та стислими. Однак, іноді ви можете не погодитись з
      їх філософією "один розмір для всіх", оскільки вам треба контролювати
      властивості мап, що ви використовуєте в вашій програмі, в більш
      гарно-гранульований спосіб. Scala надає вам цей гарно-гранульований
      контроль, якщо він вам потрібен, оскільки мапи в Scala не є синтаксисом
      мови. Вони є бібліотечними абстракціями, що можна розширити та адаптувати.
    </p>
    <p>В програмі вище ви отримаєте реалізацію Map по замовчанню, але ви можете
      легко змінити це. Ви можете, наприклад, вказати певну реалізацію, таку, як
      HashMap або TreeMap, або ви можете вказати, що мапа повинна бути
      потік-безпечною, змішуючи трейт SynchronizedMap. Ви можете вказати
      значення по замовчанню для мапи, або ви можете перевизначити любий інший
      метод мапи, що ви створюєте. В жодному разі, ви можете використовувати той
      же простий синтаксис доступу до мап, як в прикладі вище.</p>
    <p>Цей приклад показує, що Scala може дати вам обоє, зручність та гнучкість.
      Scala має набір зручних конструкцій, що допомагають вам швидко розпочати,
      та дозволяє вам програмувати в приємно узгодженому стилі. В той же час, ви
      маєте гарантції, що ви не переростете мову. Ви завжди можете підкроїти
      програму до ваших вимог, оскільки все базується на бібліотечних модулях,
      що ви можете обирати та адаптувати, як вам треба.</p>
    <h3>Вирощування нових типів</h3>
    <p>Eric Raymond ввів собор та базар як дві метафори розробки програмного
      забезпечення. Собор є майже-досконалою будівлею, що дуже довго будувати.
      Коли побудований, він стоїть незмінним довгий час. Базар, на відміну,
      адаптується та розширюється кожного дня, людьми, що роблять на ньому. В
      роботі Raymond базар є метафорою для розробки софтверу з відкритим кодом.
      Guy Steele зауважив в розмові про "зростаючу мову", що ту ж відмінність
      можна застосувати до розробки мови. Scala є більше схожою на базар, ніж на
      собор, в тому сенсі, що вона розроблена бути розширеною та адаптованою
      людьми, що програмують на ній. Замість провадження всіх конструкцій, що
      вам можуть будь-коли знадобитись в одній, "абсолютно повній" мові, Scala
      надає в ваші руки інструменти для побудови таких конструкцій.</p>
    <p>Ось приклад. Багато застосувань потребують тип цілого, що може ставати
      доволі великим, без переповнень та усічень арифметичних операцій. Scala
      визначає такий тип в бібліотечному типі scala.BigInt. Ось визначення
      методу, що використовує цей тип, який обчислює факторіал переданого цілого
      значення:</p>
    <pre class="prettyprint linenums language-scala">        def factorial(x: BigInt): BigInt =<br>	if (x == 0) 1 else x * factorial(x - 1)</pre>
    <p>Тепер, якщо ми викличемо factorial(30), ми отримаємо:</p>
    <pre class="prettyprint linenums language-scala">	265252859812191058636308480000000</pre>
    <p>BigInt виглядає як вбудований, оскільки ви можете використовувати цілі
      літерали та операції, такі як * та - зі значенями цього типу. Але це
      тільки клас, що був визначений в стандартній бібліотеці Scala. Якщо б
      такого класу не було, було б доцільним кожному програмісту на Scala
      написати реалізацію, наприклад, огорнути Java клас java.math.BigInteger
      (фактично,&nbsp; це те, як реалізовано Scala BigInt).</p>
    <p>Звичайно, ви можете також використовувати Java клас напряму. Але
      результат і близько не такий приємний, оскільки, хоча Java дозволяє вам
      створити нові типи, вони не відчуваються як природно підтримувані мовою:</p>
    <pre class="prettyprint linenums language-scala">import java.math.BigInteger
def factorial(x: BigInteger): BigInteger =
  if (x == BigInteger.ZERO)
    BigInteger.ONE
  else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))</pre>
    <p>BigInt є представником значно більшого переліку число-подібних типів —
      великих з десятичною крапкою, комплексних чисел, дійсних чисел, довірчих
      інтервалів, многочленів&nbsp; — це список можна продовжувати. Деякі мови
      програмування реалізують деякі з ціх типів природно. Наприклад, Lisp,
      Haskell, Python реалізують великі цілі; Fortran та Python реалізують
      комплексні числа. Але жодна мова, що намагалась реалізувати всі ці
      абстракції одночасно буде просто завеликою, щоб бути керованою. Що
      найбільше, навіть, якщо застосування будуть напевне мати вигоду від інших
      число-подібних типів, що не підтримуються. Так що підхід намагання
      провадити все в рамках мови не буде маштабуватись дуже гарно. </p>
    <p>Замість цього, Scala дозволяє користувачам зростати та адаптувати мову в
      потрібному їм напрямку, визначаючи прості для використання бібліотеки, що
      відчуваються як природна підтримка мовою.</p>
    <h3>Вирощування нових структур керування</h3>
    <p>Попередній приклад демонструє, що Scala дозволяє вам додавати нові типи,
      що можуть бути використані&nbsp; як зручні вбудовані типи. Той же принцип
      розширення також стосуєтсья до структур керування. Цей різновид
      розширюваності проілюстровано в Scala API для конкурентного програмування
      "на акторах".</p>
    <p>Позаяк мультиядерні процесори розповсюджуються в останні роки, досягнення
      прийнятної продуктивності може все більше потребувати, щоб ви
      використовували більше паралелізму в ваших застосуваннях. Часто це означає
      переписування вашого кода, так, щоб обчислення були розпорошені між
      декільками конкурентними потоками. На жаль, створення надійних
      багато-поточних застосувань на практиці було визнане неабияким викликом.
      Модель потоків&nbsp;Java побудована коло розділеної пам'яті та блокувань,
      модель, що часто складно продумати, особливо з тим, як система
      маштабується в розмірі та складності. Складно впевнитись, що ви не маєте
      стану гонок або не притаїлося глухе блокування — іноді це неможливо
      показати під час тестувань, але може проявити себе під час використання.
      Доказово безпечнішою альтернативою є передача повідомлень, така, яку мова
      програмування Erlang використовує за допомогою "акторів".</p>
    Java іде з багатою, базованою на потоках, бібліотекою конкурентності.
    Програми Scala можуть використовувати її, як і інші Java API. Однак, Scala
    також пропонує додаткову бібліотеку, що в основному реалізує модель акторів
    Erlang.
    <p> Актори є абстракціями конкурентності, що можуть бути реалізовані зверху
      потоків. Вони комунікіють, надсилаючи повідомлення один одному. Актор може
      виконувати дві базові операції, надсилання та отримання повідомлення.
      Операція надсиланя, що виглядає як наголос (!), надсилає повідомлення до
      актора. Ось приклад, в якому актор названий recipient: </p>
    <pre class="prettyprint linenums language-scala">recipient ! msg</pre>
    <p>Надсилання є асинхронним; тобто, відсилаючий актор може продовжувати
      безпосередньо, без очікування, що повідомлення було отримане та оброблене.
      Кожний актор має поштову скриньку, де входящі повідомлення ставляться в
      чергу. Актор обробляє прибувше до поштової скриньки через блок receive: </p>
    <pre class="prettyprint linenums language-scala">receive {<br>  case Msg1 =&gt; ... // обробляємо Msg1
  case Msg2 =&gt; ... // обробляємо Msg2<br>// ...
        }</pre>
    <p>Блок receive складається з декількох випадків, що ставить запити до
      поштової скриньки з шаблоном повідомлення. Перше повідомлення в поштовій
      скриньці, що співпаде з любим з випадків, та відповідний актор, що виконує
      його. Якщо поштова скринька не містить жодних повідомлень, що співпадають
      з наданою умовою, актор призупиняється, та очікує на подальші входящі
      повідомлення.</p>
    <p>Як приклад, ось простий актор Scala, що реалізує сервіс калькулятора
      контрольної суми:</p>
    <pre class="prettyprint linenums language-scala">actor {
var sum = 0
loop {
  receive {
    case Data(bytes)
		  =&gt; sum += hash(bytes)<br>case GetSum(requester) =&gt; requester ! sum
    }
  }
}</pre>
    <p>Цей актор спочатку визначає локальну змінну, на ім'я sum, з початковим
      значенням нуль. Потім він постійно очікує в циклі надходження повідомлень,
      використовуючи твердження. Якщо він отримує повідомлення Data, він додає
      хеш надісланих байтів да змінної суми. Якщо він отримує повідомлення
      GetSum, він надсилає поточне значення суми назад, до запитуючого,
      використовуючи повідомлення через requester ! sum. Поле requester
      вбудоване в повідомлення GetSum; воно звичайно посилається на актора, що
      зробив запит.</p>
    <p>Ми не очікуємо, що ви повністю розумієте приклад з актором в цій точці.
      Скоріше, що важливе щодо цього приклада для теми маштабовності, це те, що
      ні актор, ні цикл, ні надсилання повідомлення (!) не є вбудованими
      операціями Scala. Навіть не зважаючи на те, що актор, цикл, та receive
      виглядають та діють як керівні вбудовані структури, як цикли while або
      for, вони, фактично, є методами, визначеними в бібліотеці акторів Scala.
      Таким же чином, навіть якщо ‘!’ виглядає як вбудований оператор, це також
      тільки метод, визначений в бібліотеці акторів. Всі ці чотири конструкції є
      повністю незалежні від мови програмування Scala.</p>
    <p>Блок receive та синтаксис (!) виглядає в Scala більше як в Erlang, але в
      Erlang ці конструкції вбудовані в мову. Scala також реалізує більшість з
      інших конструкцій конкурентності Erlang, таких, як моніторинг схибивших
      акторів та тайм-аути. </p>
    <p>Так чи інакше, актори перетворились на дуже приємні умови для виразу
      конкурентних та розподілених обчислень. Навіть зважаючи, що вони визначені
      в бібліотеці, актори відчуваються як невід'ємна частина мови Scala.</p>
    <p>Цей приклад ілюструє, що ми можете "зростити" мову Scala в нових
      напрямках, навіть таких специфічних, як конкурентне програмування.
      Безумовно, вам знадобляться гарні архитектори та програмісти, щоб зробити
      це. Але наріжна річ в цьому є розробка та реалізація абстракцій в Scala,
      що адресують радикально нові галузі застосування, що все ще відчуваються
      як природна підтримка мови.</p>
    <h3>1.2&nbsp; Що робить Scala маштабованою?</h3>
    <p>Маштабованість складається з багатьох факторів, починаючи з деталей
      синтаксису, до конструктивів абстракції компонентів. Однак, якщо ви
      змушені назвати тільки один аспект Scala, що допомагає маштабованості, ми
      обираємо комбінацію з об'єктно-орієнтованого та функціонального
      програмування (гаразд, ми прибрехали, це насправді два аспекта, але вони
      пов'язані).</p>
    <p>Scala іде далі, ніж всі інші, гарно відомі, мови, в гуртуванні
      програмування в одноманітний дизайн мови. Наприклад, там, де інші мови
      можуть мати об'єкти та функції, як дві різні концепції, в Scala значення
      функції є об'єктом. Функціональне значення є об'єктом. Функціональні типи
      є класами, що можуть наслідуватись суб-класами. Це може виглядати як не
      більше, ніж академічна тонкість, але це має глибокі наслідки для
      маштабовності. Фактично, концепція акторів, показана раніше, не може бути
      реалізована без уніфікації функцій та об'єктів. Цей розділ дає огляд
      спсобу Scala змішування об'єктно-орієнтовної та функціональної концепцій.
    </p>
    <h4>Scala є об'єктно-орієнтованою</h4>
    <p>Об'єктно-орієнтовано програмування було дуже успішним. Починнаючи з
      Simula в середині 60х, та Smalltalk в 70х, тепер воно доступне для
      більшості мов. В деяких галузях об'єкти захопили все повністю. Хоча немає
      точного визначення, що значить об'єктно-орієнтований, напевне є щось щодо
      об'єктів, що приваблює програмістів. </p>
    <p>В принципі, мотивація для об'єктно-орієнтованого програмування є дуже
      простою: всі, окрім найбільш тривіальних програм, потребують деякий
      різновид структури. Найбільш прямолінійний шлях зробити це, є покласти
      дані та операції в деяку форму контейнера. Велика ідея
      об'єктно-орієнтованого програмування є зробити ці контейнери повністю
      загальними, так що вони можуть містити операції, так само, як дані, та що
      вони сами по собі є значеннями, що можуть зберігатись в інших контейнарах,
      або передані як параметри до операцій. Такі контейнери називаются
      об'єктами. Alan Kay, розробник Smalltalk, зауважив, що, таким чином,
      простіший об'єкт має ту ж принципіальну конструкцію, що і цілий комп'ютер:
      він комбінує дані з операціями під формалізованим інтерфейсом. Так що
      об'єкти мають безпосереднє відношення до маштабованості мови: ті ж прийоми
      стосуються до конструкції малих, так само як і великих, програм.</p>
    Навіть хоча об'єктно-орієнтоване програмування було головним напрямком на
    протязі довгого часу, є відносно небагато мов, що послідували за Smalltalk в
    просуванні принципу побудови до його логічного завершення. Наприклад, багато
    мов визнають значення, що не є об'єктами, такі, як примітивні типи в Java.
    Або вони дозволяють статичні поля та методи, що не є членами жодного
    об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтованого програмування
    на перший погляд виглядають нешкідливими, але вони мають надокучливу
    тенденцію ускладнювать речі та обмежувати маштабованість.
    <p>На відміну, Scala є об'єктно-орієнтованою мовою в чистій формі: кожне
      значення є об'єктом, та кожна операція є виклик метода. Наприклад, коли ви
      кажете 1 + 2 в Scala, ви, насправді, викликаєте метод&nbsp; +, визначений
      на класі Int. Ви можете визначити методи з іменами, схожими на оператори,
      що клієнти вашого API потім можуть використовувать в операторній нотації.
      Це той спосіб, як API акторів Scala дозволяють вам використовувати вирази,
      такі як requester ! sum, показаний в попередньому прикладі: ‘!’ є методом
      класа Actor.</p>
    <p>Scala є більш просунутою, ніж більшість інших мов, коли йдеться до
      компонування об'єктів. Прикладом є трейти Scala. Трейти як інтерфейси в
      Java, але вони також можуть мати реалізації методів, та навіть поля.
      Об'єкти конструюються через міксування композицій, що бере члени класа, та
      додає до них члени декількох трейтів. Таким чином, різні аспекти класів
      можуть бути інкапсульовані в різних трейтах. Це виглядає трохи подібним на
      множинне наслідування, але починає відрізнятись, коли доходить до деталей.
      На відміну від класа, трейт може додати деяку нову функціональність до
      невизначеного класа. Це робить трейт більш "плугабельним", ніж класи.
      Зокрема це виключає класичну проблему "діамантового наслідування"
      множинного наслідування, що постає, коли той же клас наслідується через
      декілька різних шляхів. </p>
    <h4>Scala є функціональною</h4>
    <p>На додаток до того, що це об'єктно-орієнтована мова, Scala є також
      повноцінною функціональною мовою. Ідеї функціонального програмування є
      старіші, ніж (електронні) комп'ютери. Їх основи були покладені в
      лямбда-численні Alonzo Church, що розроблене в 1930х. Перша функціональна
      мова програмування була Lisp, що датується пізніми 50ми. Інші популярні
      функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. На
      протязі довгого часу, функціональне програмування було дещо на уздоріжжі,
      популярне в академічному середовищі, але широко не використовувалось в
      індустрії. Однак, останні роки показують зростаючу зацікавленість в мовах
      функціонального програмування та технологіях.</p>
    <p>Функціональне програмування керується двома ідеями. Перша ідея полягає в
      тому, що функції є першокласними значеннями. В функціональній мові функція
      є значенням з таким же статусом, що і, скажімо, цілі або рядки. Ви можете
      передати функцію як аргумент до інших функцій, повернути як результат з
      функції, або зберігти в змінінй. Ви також можете визначити функцію в іншій
      функції, так, як ви можете визначити ціле значення в функції. Та ви можете
      визначити функції, давши їм ім'я. Зрошування вашого кода функціональними
      літералами таке просте, як ви можете записати літерал 42. </p>
    <p>Функції, що є першокласними значеннями, провадять зручний спосіб для
      абстрагування над операціями, та створення нових структур керування. Це
      узагальнення провадить величезну виразність, що часто приводить до дуже
      виразних та стислих програм. Це також грає важливу роль для
      маштабованості. Як приклад, конструкція receive, показана вище, в прикладі
      актора, є викликом метода, що приймає функцію як аргумент. Код всередині
      конструкції receive є функція, що передається без виконання в метод
      receive.</p>
    <p>В більш традиційних мовах, на відміну від цього, функції не є значеннями.
      Мови, що мають значення функцій, часто зводять їх до другорядного статуса.
      Наприклад, вказівники на функцію в C та C++ не мають того ж статуса, що і
      не-функціональні значення в ціх мовах: вказівники на функції можуть
      посилатись лише на глобальні функції, вони не дозволяють вам визначати
      першокласні вкладені функції, що посилаються на деякі значення зі свого
      оточення. Також вони не дозволяють вам визначати безіменні функціональні
      літерали.&nbsp;</p>
    <p>Друга головна ідея функціонального програмування полягає в тому, що
      операції програми повинні відображати вхідні значення на вихідні значення,
      скоріше, ніж змінювати дані на місці. Щоб побачити різницю, розглянемо
      реалізацію рядків в Ruby та Java. В Ruby рядок є масивом символів. Символи
      в рядку можна змінити індивідуально. Наприклад, ви можете змінити символ
      крапки з комою в рядку та одну крапку, в тому ж об'єкті рядка. В Java та
      Scala, з іншого боку, рядок є послідовність символів в математичному
      сенсі. Заміна символа в рядку з використання виразу, як s.replace(';',
      '.') дає новий об'єкт рядка, що відрізняється від s. Інший шлях виразити
      це - сказати, що рядки є незмінні в Java, хоча вони змінні в Ruby. Так що
      дивлячись лише на рядки, Java є функціональною мовою, тоді як Ruby - ні.
      Незмінні структури даних є одним з наріжних каменів функціонального
      програмування. Бібліотеки Scala визначають багато незмінних типів даних,
      зверху тих, що можна знайти в Java API. Наприклад, Scala має незмінні
      списки, кортежі, мапи та набори.</p>
    <p>Інший шлях викласти цю другу ідею функціонального програмування, це те,
      що метод не повинен мати жодних побічних ефектів. Вони мають комунікувати
      зі своїм оточенням, тільки приймаючи аргументи, та повертаючи результати.
      Наприклад, метод заміни в класі&nbsp; Java String підходить до цього
      критерію. Він приймає рядок та два символа, та дає новий рядок, де всі
      входження одного символа замінені на інший. Немає іншого ефекту при
      виклику replace. Методи, як replace, називаються референтно прозорими, що
      означає, що кожний наданий вхід при виклику метода може бути замінений
      результатом, без валиву на семантику програми.</p>
    <p>Функціональні мови заохочують незмінні структури даних та референтно
      прозорі методи. Деякі функціональні мови навіть потребують їх. Scala дає
      вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є
      програмуванням зі змінним станом та побічними ефектами. Але Scala загалом
      робить легким уникати імперативних конструкцій, за вашим бажанням,
      оскільки існують гарні функціональні альтернативи. </p>
    <h3>1.3 Чому Scala?</h3>
    <p>Чи є Scala для вас? Ви можете зрозуміти та вирішити для себе. Ми
      винайшли, що насправді є багато причин, окрім маштабованості, щоб
      вподобати програмування на Scala. Ми в цьому розділі обсудимо чотири
      найбільш важливі акпекти: сумісність, стислість, високорівневі абстракції,
      та просунута статична типізація.</p>
    <h4>Scala є сумісною</h4>
    <p>Scala не потребує, щоб ви зістрибували з Java платформи, щоб піти далі
      від мови Java. Вона дозволяє вам додати вартість до існуючого кода —
      будувати на тому, що ви вже маєте — оскільки вона була розроблена для
      безтурботної взаємодії з Java. Програми Scala компілюються в байткоди JVM.
      Їх швидкість виконання звичайно на рівних з програмами Java. Код Scala
      може викликати методи Java, мати доступ до полів Java, наслідувати від
      класів Java, та реалізувати Java інтерфейси. Жодне з цього не потребує
      спеціального синтаксису, явних дескрипторів інтерфейсу або зкліючого коду.
      Фактично, майже весь код Scala потужно використовує біблиотеки Java, часто
      без того, щоб ставити до відома програміста про цей факт.</p>
    <p>Інший аспект повної сумісності в тому, що Scala потужно використовує типи
      Java. Scala Int представлені як примітивні цілі Java типу int, Float
      представлені як float, Boolean як boolean, і так далі. Масиви Scala
      відображуються на масиви Java. Scala також використовує багато стандартних
      бібліотечних типів Java. Наприклад, тип рядка "abc" в Scala є
      java.lang.String, та викликане виключення має бути субкласом
      java.lang.Throwable.</p>
    <p>Scala не тільки використовує типи Java, але також "принаряджає їх", щоб
      зробити їх кращими. Наприклад, рядки Scala підтримують методи, як toInt
      або toFloat, що конвертують рядок на ціле число або число з плаваючою
      крапкою. Так що ви можете писати str.toInt, замість Integer.parseInt(str).
      Як це може бути досягнуто без поломки сумісності? Клас Java String напевне
      не має методу toInt! Фактично, Scala має дуже загальне рішення, щоб
      вирішити це напруження між просунутим дизайном бібліотеки, та сумісністю.
      Scala дозволяє вам визначити неявні перетворення, що завжди
      застосовуються, коли типи не співпадають в природний спосіб, або коли
      обираються неіснуючі члени. В випадку вище, коли поглянете на метод toInt
      на рядкові, компілятор Scala не знайде такого члена в класі String, але
      він знайде неявне перетворення, що конвертує Java String в примірник класу
      Scala StringOps, що визначає такий член. Перетворення буде застосоване
      неявно перед викоранням операції toInt.</p>
    <p>Код Scala може бути викликаний з кода Java. Це іноді трохи тонкіше,
      оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш
      просунутих можливостей Scala повинні бути закодовані, перед тим, як вони
      можуть бути відображені на Java. Глава 31 пояснює деталі.</p>
    <h4>Scala є стислою</h4>
    <p>Програми Scala схильні бути короткими. Програмісти Scala повідомляли про
      зменшення числа рядків до десяти разів, порівняно з&nbsp; Java. Це може
      бути екстремальним випадком. Більш консервативне очікування може полягати
      в тому, що типова програма на Scala повинна мати половину чила рядків, для
      тієї ж програми, написаної на Java. Менше рядків кода означає не тільки
      менше друку, але також менше зусиль при читанні та розумінні програм, та
      менше можливостей для дефектів. Є декілька факторів, що мають причетність
      до цього зменшення числа рядків.&nbsp;</p>
    <p>Перше, синтаксис Scala уникає деяких шаблонів, що захаращують Java
      програми. Наприклад, крапка з комою опціональні в Scala, та, зазвичай,
      відкидаються. Є також декілька інших областей, де синтакис Scala менш
      галасливий. Для прикладу порівняйте, як ви пишете класи та конструктори в
      Java та Scala. В Java, клас з конструктором часто виглядає подібно до
      наступного:</p>
    <pre class="prettyprint linenums language-java">// це Java<br>class MyClass {
    private int index;
    private String name;
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    }
}</pre>
    В Scala, ви, напевне, замість цього напишите таке:
    <pre class="prettyprint linenums language-scala">class MyClass(index: Int, name: String)</pre>
    <p>Маючи цей код, компілятор Scala спродукує клас, що має дві приватні
      змінні примірника, Int з іменем index, String з іменем name, та
      конструктор, що приймає початкові значення для ціх змінних в якості
      параметрів. Код цього констректора буде ініціалізувати дві змінні
      екземпляра значеннями, переданими як параметри. Коротко кажучи, ви
      отримаєте в основному ту ж функціональність, що і більш балакуча версія на
      Java. Клас Scala швидше написати, простіше читати, та, що більше важливо,
      меньше схильний до помилок, ніж клас Java.</p>
    <p>Вивід типів Scala є іншим фактором, що докладається до стислості.
      Повторювана інформація про типи може бути відкинута, так що програми
      стають менш захаращені, та біль читабельні.</p>
    <p>Але, можливо, найбільш важливий ключ до компактного коду є те, що вам не
      треба писати, бо воно вже реалізоване в бібліотеці за вас. Scala дає вам
      багато інструментів для визначення потужних бібліотек, що дозволяють вам
      захопити та примножити загальну поведінку. Наприклад, різні аспекти
      бібліотечних класів можуть бути виділені в трейти, що потім можуть бути
      зміксовані разом в гнучкий спосіб . Або бібліотечні методи можуть бути
      параметризовані операціями, що дозволяє визначити конструкції, які
      ефективно є вашими структурами керування. Разом ці конструкції дозволяють
      визначати бібліотеки, що обоє, високорівневі, та гнучкі у використанні.</p>
    <h4>Scala є високорівневою</h4>
    <p>Програмісти постійно стикаються зі складністю. Для продуктивного
      програмування ви повинні розуміти код, з яким працюєте. Дуже складний код
      спричинив повалення багатьох софтверних проектів. На жаль, важливі
      програми часто мають складні вимоги. Такої складності не можна уникнути;
      замість цього єю можна керувати. </p>
    <p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень
      абстракцій в інтерфейсах, що ви розробляєте та використовуєте. Як приклад,
      уявіть, що ви маєте змінну String name, та ви бажаєте знайти, чи містить,
      чи ні, ця змінна типу String великі літери. В Java ви можете написати
      таке:</p>
    <pre class="prettyprint linenums language-java">// це Java
boolean nameHasUpperCase = false;
for (int i = 0; i &lt; name.length(); ++i) {
   if (Character.isUpperCase(name.charAt(i))) {
       nameHasUpperCase = true;
       break;
   }
}</pre>
    <p>На Scala це можна записати так:</p>
    <pre class="prettyprint linenums language-scala">val nameHasUpperCase = name.exists(_.isUpper)</pre>
    <p>Код Java сприймає рядки як низькорівневі сутності, що проходяться в циклі
      символ за символом. Код Scala трактує той же рядок як послідовність вищого
      порядку, що може бути опитаний за допомогою предикатів. Ясно, що код Scala
      більш короткий, та, для треновоного ока, простіший для розуміння, ніж код
      Java. Так що код Scala менше тисне на загальний бюджет складності. Він
      також дає вам менше можливостей зробити помилку.&nbsp;</p>
    <p>Предикат _.isUpper є прикладом функціонального літерала в Scala. Він
      описує функцію, що приймає символьний аргумент (представлений символом
      підкреслення), та перевіряє, чи він є великою літерою.</p>
    <p>В принципі, такі керівні абстракції також можливі і в Java. Вам треба
      визначити інтерфейс, що містить метод з абстрактною функіональністю.
      Наприклад, якщо ми бажаємо підтримувати запити до рядків, ви можете ввести
      інтерфейс, названий CharacterProperty, що має тільки один метод,
      hasProperty:</p>
    <pre class="prettyprint linenums language-java">// це Java
interface CharacterProperty {
   boolean hasProperty(char ch);
}</pre>
    <br>
    З таким інтерфейсом ви можете зформулювати на Java метод exists: він приймає
    рядок та CharacterProperty, та повертає true, якщо символ в рядку
    задовільняє властивості. Ви можете потім викликати exists наступним чином:
    <pre class="prettyprint linenums language-java">// це Java
exists(name, new CharacterProperty() {
    public boolean hasProperty(char ch) {
    	return Character.isUpperCase(ch);
    }
});</pre>
    <p>Але все це, скоріше, заважке. Таке заважке, фактично, що більшість Java
      програмістів не будуть з цім поратись. Вони тільки напишуть цикли, та
      полишать це з додатковою складністю кода. З іншого боку, літеральні
      функції в Scala є теж легковажними, так що вони часто використовуються. По
      мірі, як ви пізнаватимете Scala краще, ви винайдете більше і більше
      можливостей визначати та використовувати свої власні абстракції керування.
      Ви найдете, що це дозволяє уникати дублікації кода, і, таким чином,
      утримувати ваші програми коротшими та яснішими. </p>
    <h4>Scala є статично типізованою</h4>
    <p>Статична система типів класифікує змінні та вирази, відповідно до
      властивостей значень, що вони містять та обчислюють. Scala вирізняється як
      мова з дуже просунутою системою статичних типів. Починаючи з системи
      вкладених типів класів, здебільшого як в Java, вона дозволяє
      параметризувати типи дженеріками, комбінувати типи з використанням
      перетинів, та приховувати деталі типів, використовуючи абстрактні типи. Це
      покладає сильне підгрунтя для побудови та компнування ваших власних типів,
      так що ви можете розробити інтерфейси, що, одночасно, безпечні, та гнучкі
      до використання.</p>
    <p>Якщо ви вподобали динамічні мови, як Perl, Python, Ruby або Groovy, ви
      можете знайти це досить дивним, що система статичних типів в Scala
      перелічується як одна з її сильних сторін. В кінці кінців, відсутність
      статичної системи типізації визначається деякими як найбільша перевага
      динамічних мов. Найбільш загальні аргументи проти статичних типів в тому,
      що вони роблять програми дуже балакучими, заважають програмістам виражати
      себе в бажаний спосіб, та роблять неможливим деякі шаблони динамічних
      модифікацій програмних систем. Однак, часто ці аргументи не ідуть в розріз
      з ідеєю статичних типів загалом, але проти окремих систем типів, що
      сприймаються як дуже балакучі та дуже негнучкі. Наприклад, Alan Kay,
      винахідник мови Smalltalk, колись зауважив: "Я не проти типів, але я не
      знаю про жодну систему типів, що не є суцільною біллю, так що мені
      подобається динамічна типізація". Ми сподіваємось переконати вас в цій
      книзі, що система типів Scala є далекою від "суцільної болі". Фактично,
      вона гарно адресована до двох звичайних занепокоєнь щодо статичної
      типізації: галасливість уникається через вивід типів, та гнучкість
      досягається через співпадіння шаблонів, та декілька нових способів писати
      та компонувати типи. Коли прибрані ці перешкоди, класичні вигоди статичних
      систем типів можуть бути краще оценені. Серед найбільш важливих з ціх
      переваг є перевірка властивостей програмних абстракцій, безпечний
      рефакторинг, та краща документація.</p>
    <p><em><strong>Перевірка властивостей. </strong></em>Статичні системи типів
      можуть довести відсутність окремих помилок часу виконання. Наприклад, вони
      можуть підтвердити властивості, як: логічні ніколи не додаються до цілих;
      приватні змінні не отримуються доступ поза меж їхнього класу; функції
      застосовуються до вірного числа аргументів; до набору рядків додаються
      тільки рядки.</p>
    <p>Інші типи помилок не визначаютьсь сучасними системами статичних типів.
      Наприклад, вони, звичайно, не помічають не-терміновані функції, порушення
      меж масиву, або ділення на нуль. Вони також не помічають, що ваша програма
      не відповідає своїй специфікації (будемо вважати, що така специфікація
      є!). Статичні системи типів мають, таким чином, розвінчані деякими, як ті,
      що не є дуже корисними. Аргумент, що слідує за цим, полягає в тому, що
      системи типів можуть детектувати тільки прості помилки, тоді як юніт тести
      провадять більш екстенсивне охоплення, то чому взагалі поратись зі
      статичними типами? Ми вважаємо, що ці аргументи не мають сенсу. Хоча
      статичні системи типів, безумовно, не можуть замінити юніт тести, вони
      можуть зменшити число потрібних юніт тестів, турбуючись про деякі
      властивості, що в іншому випадку потребували б тестування. Так само, як і
      юніт тести не можуть замінити статичні типи. В кінці кінців, як сказав
      Edsger Dijkstra, тестування може лише довести наявність помилок, але
      ніколи їх відсутність. Так що гарантії, що дає статична типізація, можуть
      бути простими, але це реальні гарантії, в формі, що не можуть дати купа
      тестів. </p>
    <p><em><strong>Безпечний рефакторинг.</strong></em> Статична система типів
      провадить строховочну сітку, що дозволяє вам робити зміни в кодовій базі,
      з високою ступінню довіри. Уявімо, наприклад, рефакторинг, що додає
      додатковий параметр до метода. В статично типізованій мові ви можете
      зробити зміну, перекомпілювати вашу систему, та просто виправити всі
      рядки, що спричинили помилку. Коли ви скінчите з цім, ви будете впевнені,
      що знайшли всі місця, що потребували змін. Те ж вірно для багатьох інших
      простих рефакторингів, як зміна імені метода, або переміщення метода з
      одного класа до іншого. В усіх випадках перевірка статичного типу буде
      провадити досить страховки, що нова система буде робити, як стара.</p>
    <p><em><strong>Документація.</strong></em> Статичні типи є документацією
      програми, що перевірена компілятором на коректність. На відміну від
      звичайних коментарів, анотація типу ніколи не буде простроченою
      (щонайменьше, ні, якщо початковий файл, що містить її, нещодавно проходив
      через компілятор). Більше того, компілятори та інтегровані середвища
      розробки можуть використовувати анотації типів, щоб провадити кращу
      контекстну допомогу. Наприклад, інтегроване середовище розробки може
      відображати всі члени, доступні для вибору, визначаючи статичний тип
      виразу, на якому зроблений вибір, та переглядаючи всі члени цього типу.</p>
    <p>Навіть зважаючи, що статичні типи загалом корисні для документації
      програми, вони можуть іноді бути надокучливими, коли вони привносять
      безлад в програму. Типово, корисна документація є те, що читачі програми
      не можуть просто вивести самі. В визначені метода, як:</p>
    <pre class="prettyprint linenums language-scala">def f(x: String) = ...</pre>
    <p>є корисним знати, що аргумент f повинний бути String. З іншого боку,
      щонайменьше одна з двох анотацій в наступному прикладі є зайвою:</p>
    <pre class="prettyprint linenums language-scala">val x: HashMap[Int, String] = new HashMap[Int, String]()</pre>
    <p>Зрозуміло, що достатньо сказати тільки один раз, що x є HashMap, з Int в
      якості ключа, та Strings в якості значень; немає потреби повторювати те ж
      саме двічі.</p>
    <p>Scala має дуже витончену систему виводу типів, що дозволяє вам уникати
      всієї інформації щодо типів, що звичайно здається надокучливою. В
      попередньому прикладі наступні дві менш надокучливі альтернативи також
      можуть виконувати свою справу:</p>
    <pre class="prettyprint linenums language-scala">val x = new HashMap[Int, String]()
<br>val x: Map[Int, String] = new HashMap()</pre>
    <p>Вивід типів в Scala може піти значно далі. Фактично, не є незвичним для
      користувацького коду не мати явних типів взагалі. Таким чином, програми
      Scala часто виглядають як написані на динамічно типізованій мові. Це
      вірно, зокрема, для клієнтського кода застосування, що зкліює разом
      попередньо написані бібліотечні компоненти. Це меньш вірно для самих
      бібліотечних компонент, оскільки вони часто використовують досить складні
      типи, що дозволяють гнучкі шаблони використання. Це просто природно.
      Кінець кінцем, всі сігнатури типів членів, що складають інтерфейс повторно
      використовуваних компонент, повинні бути надані явно, оскільки вони
      складають головну частину контракту між компонентами та їх клієнтами.</p>
    <h3>1.4&nbsp; Витоки Scala</h3>
    <p>На дизайн Scala вплинули багато мов програмування, та ідей розробки мов
      програмування. Фактично, тільки декілька можливостей Scala є чисто новими;
      більшість вже були застосовані в деякій формі в інших мовах. Іновації
      Scala походять в основному з її конструкцій, що покладаються разом. В
      цьому розділі ми перелічимо головні джерела впливу на дизайн Scala. Цей
      список не може бути вичерпним — просто є дуже багато розумних ідей щодо
      дизайну мови програмування, щоб перелічити тут їх всіх.</p>
    <p>На поверхні Scala адаптує широку частину синтаксису Java та C#, що, в
      свою чергу, запозичили більшість з їх синтксичних домовленостей з C та
      C++. Вирази, твердження, та блоки в основному як в Java, так само, як
      синтаксис класів, пакунків та імпортів. Окрім синтаксиса Scala переймає
      інші елементи Java, такі як базові типи, її бібліотеки типів, та її модель
      виконання.</p>
    <p>Scala також багато запозичає з інших мов. ЇЇ однорідна об'єктна модель
      була освоєна в Smalltalk, та згодом розвинена в Ruby. Її ідея
      універсального вкладення (майже кожна конструкція в Scala може бути
      вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та,
      останнім часом, в Beta та gbeta. Її принцип одноманітного досупу для
      викликів методів та вибору полів прийшов з Eiffel. Її підхід до
      функціонального програмування досить подібне по духу до свмейства мов ML,
      що включає SML, OCaml, та F# в якості помітних членів. Багато функцій
      вищого порядку в стандартній бібліотеці Scala, також присутні в ML або
      Haskell. Неявні параметри Scala&nbsp; були мотивовані класами типів
      Haskell; вони досягають аналогічних результатів в більш класичному,
      об'єктно-орієнтовному налаштуванні. Бібліотека базованої на акторах
      конкурентності Scala значною мірою надихалась Erlang.</p>
    <p>Scala не є першою мовою, що робить наголос на маштабованості та
      розширюваності. Історичні корені розширюваних мов, що можуть
      перевизначивати різні області застосувань, є папір від Peter Landin 1966
      "Наступні 700 мов програмування". (Мова, що описана в цьому документі,
      Iswim, стоїть разом з Lisp, як одна з новаторських функціональних мов).
      Специфічну ідею трактувати інфіксні оператори, як функції, можна
      відслідити до Iswim та Smalltalk.</p>
    <p>Інша важлива ідея є дозволити використання функціонального літерала (або
      блока) як параметра, що дозволяє бібліотекам визначати структури
      керування. Знову, це веде до Iswim та Smalltalk. Smalltalk та Lisp, обоє
      мали гнучкий синтаксис, що був екстенсивно застосований для побудови
      внутрішніх домен-специфічних мов.&nbsp; C++ є іншою мовою програмування,
      що може бути адаптований та розширений через перевантаження операторів, та
      систему шаблонів; порівняно з Scala вона побудована на низькорівневому,
      більш системно-орієнтованому ядрі.</p>
    <p>Scala також не є першою мовою, що інтегрує функціональне та
      об'єктно-орієнтоване програмування, хоча вона, можливо, іде далі в цьому
      напрямку. Інші мови, що що інтегрували деякі елементи функціонального
      програмування в ООП включають Ruby, Smalltalk та Python. На платформі Java
      мови Pizza, Nice та Multi-Java розширюють Java-подібне ядро
      функціональними ідеями. Також є в основному функціональні мови, що
      отримали систему об'єктів; прикладами є OCaml, F# та PLT-Scheme.</p>
    <p>Scala також доклала деяких інновацій до області мов програмування.
      Наприклад, її абстрактні типи провадять більш об'єктно-орієнтовану
      альтернативу до загальних типів (дженеріків), її трейти дозволяють гнучке
      складання компонентів, та її екстрактори провадять незалежний від
      репрезентації шлях до співпадіння шаблонів. Ці інновації були представлені
      останніми роками в паперах на конференціях з мов програмування.</p>
    <h3>1.5&nbsp; Висновок</h3>
    <p>В цій главі ми надали вам побіжне враження, що таке Scala, та як вона
      може допомогти вам в вашому програмуванні. Будьте певні, що Scala не є
      срібною кулею, що магічним чином зробить вас більш продуктивним. Щоб
      просуватись, вам треба застосовувати <br>
      Scala мистецьки, та це потребуватиме деякого навчання та практики. Якщо ви
      прийшли до Scala з Java, найбільш складні аспекти вивчення Scala можуть
      включати систему типів Scala (що багатша, ніж в Java), та її підтримка
      функціонального програмування. Ціль цієї книги є лагідно провести вас по
      кривій засвоєння Scala, крок за кроком. Ми вважаємо, що ви отримаєте
      винагороду в вигляді інтелектуального досвіду, що розширисть ваші
      горизонти, то змусить вас думати інакше щодо розробки програм. На щастя,
      ви також отримаєте задоволення та натхнення від програмування на Scala. </p>
    <p>В наступній главі ми з вами почнемо писати деякий код Scala.</p>
    <h3>Глава 2</h3>
    <h2>Перші кроки в Scala</h2>
    <p>Прийшов час написати деякий код на Scala.Перед тим, як ми розпочнемо
      глибинне вивчення Scala, ми покладемо дві глави, що дадуть вам ширшу
      картину Scala, та, що більше важливо, почнемо писати код. Ми закликаємо
      вас насправді спробувати всі приклади кода, представлені в цій та
      наступній главах, по мірі просування. Кращий спосіб почати вивчати Scala -
      це програмувати на ній. </p>
    <p>Щоб виконувати приклади, ви маєте встановити стандартну інсталяцію Scala.
      Щоб отримати її, завітайте на http://www.scala-lang.org/downloads, та
      слідуйте настановам для вашої платформи. Ви також можете використовувати
      плагін Scala для Eclipse, IntelliJ, або NetBeans, але для кроків в цій
      главі ми вважаємо, що ви використовуєте дистрибутив Scala зі
      scala-lang.org.</p>
    <p>Якщо ви ветеран програмування, новий до Scala, наступні дві глави повинні
      дати вам досить розуміння, щоб ви змогли почати писати корисні програми на
      Scala. Якщо ви менш досвідчений, деякий з матеріала може здатись вам
      незбагненним. Але не турбуйтесь. Щоб ви швидко набрали швидкість, ми
      опустимо деякі деталі. Все буде пояснено в менш "пожежному" режимі в
      подальших главах. На додаток, ми вставили в наступні дві глави деякі
      примітки, щоб спрямувати вас на подальші розділи книги, де ви знайдете
      більш детальні пояснення.</p>
    <h4>Крок 1. Навчимось використовувати інтерпретатор Scala</h4>
    <p>Найлегший шлях почати зі Scala - це використати інтерпретатор Scala,
      інтерактивну "оболонку" для написання виразів та програм Scala. Просто
      наберіть вираз в інтерпретаторі, та він обчислить вираз та надрукує
      результуюче значення. Інтерактивна оболонка для Scala називається просто
      scala.</p>
    <p>Ви можете використати її, набравши scala в командному рядку:</p>
    <pre class="prettyprint linenums language-bash">$ scala
Welcome to Scala version 2.8.1.
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</pre>
    <p>Після цього надрукуйте вираз, такий, як 1 + 2, та нажміть Enter:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1 + 2</pre>
    <p>The interpreter will print:</p>
    <pre class="prettyprint linenums language-scala">res0: Int = 3</pre>
    <p>Цей рядок включає:<br>
      • автоматично згенероване, або визначене користувачем ім'я, що посилається
      на обчислене значення (res0, що означає result 0),<br>
      • двокрапку (:), за якою слідує тип виразу (Int),<br>
      • Знак рівняння (=),<br>
      • значення результата від обчислення виразу (3).</p>
    <p>Тип Int іменує клас Int в пакунку scala. Пакунки в Scala подібні до
      пакунків в Java: вони розділяють глобальний простір імен, та провадять
      механізм для приховування інформації. Значення класу Int відповідають
      значенням Java int. Більш загально, всі з примітивних типів Java мають
      відповідні класи в пакунку scala. Наприклад, scala.Boolean відповідає до
      Java boolean. scala.Float відповідає Java float. Та коли ви компілюєте ваш
      код Scala в байткоди Java, компілятор Scala буде використовувати
      примітивні типи Java, де це можливо, щоб надати вам переваги швидкості
      примітивних типів.</p>
    <p>Ідентифікатор resX може використовуватись в наступних рядках. Наприклад,
      оскільки&nbsp; res0 було попередньо встановлено в&nbsp; 3, res0 * 3 буде
      9:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; res0 * 3
res1: Int = 9</pre>
    <p>Щоб надрукувати необхідне, але недостатнє Hello, world! greeting,
      надрукуйте: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; println("Hello, world!")
Hello, world!</pre>
    Функція println друкує переданий рядок на стандартний вивід, подібно
    до&nbsp; System.out.println в Java.<br>
    <br>
    <h4>Крок 2. Визначимо деякі змінні</h4>
    Scala має два типи змінних, val та var. val подібне до final змінних в Java.
    Після ініціалізації val не може бути повторно присвоєна. На відміну від
    цього, var подібна до не-final змінної в Java. var може бути повторно
    присвоєна на протяжі життєвого циклу. Ось визначення val:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; val msg = "Hello, world!"
msg: java.lang.String = Hello, world!</pre>
    Це твердження вводить msg як ім'я для рядка "Hello, world!". Типом msg є
    java.lang.String, оскільки рядки Scala ралізовані через Java String. Якщо ви
    декларували змінні в Java, ви помітили тут одну вражаючу відмінність: ні
    java.lang.String, ні String не з'являються ніде в визначенні val. Цей
    приклад ілюструє вивод типу, здатність Scala визначає типи, що ви не
    вказали. І цьому випадку, оскільки ви ініціалізували msg літералом рядка,
    Scala виводить, що тип msg буде String. Коли інтерпретатор Scala (або
    компілятор) може вивести типи, часто краще дозволити йому зробити це,
    скоріше, ніж заповнювати код непотрібними явними анотаціями типу. Однак ви
    можете вказати тип явно, якщо бажаєте, та індоі ви, можливо, маєте це
    зробити. Явна анотація типу може як переконати компілятор Scala вивести
    потрібний вам тип, та також прислуговується як корисна документація для
    майбутніх читачів кода. На відміну від Java, де ви вказуєте тип змінної
    перед ім'ям, в Scala ви вказуєте тип змінної після імені, відокреплюючи
    двома крапками. Наприклад:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: java.lang.String = Hello again, world!</pre>
    Або, оскільки типи java.lang видимі зі своїми простими іменами в програмах
    Scala, просто:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</pre>
    Повертаючись до оригінального msg, тепер, коли вона визначена, ви можете
    використовувати її, як і очікували, наприклад:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; println(msg)
Hello, world!</pre>
    Що ви не можете робити з msg, зважаючи що це val, а не var, це переприсвоїти
    її. Наприклад, подивіться, як буде скаржитись інтерпретатор, коли ви
    спробуєте наступне:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; msg = "Goodbye cruel world!"
:6: error: reassignment to val
msg = "Goodbye cruel world!</pre>
    ˆ <br>
    Якщо перепризначення це те, що вам потрібне, вам треба var, як нижче:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; var greeting = "Hello, world!"
greeting: java.lang.String = Hello, world!</pre>
    <br>
    Оскільки greeting є var, не val, ви можете переприсвоїти її пізніше. Якщо ви
    пізніше почуватиметесь буркотливим, наприклад, ви можете змінити ваше
    побажання світові:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; greeting = "Leave me alone, world!"
greeting: java.lang.String = Leave me alone, world!</pre>
    <br>
    Щоб ввести дещо в інтерпретатор, що обіймає декілька рядків, просто
    продовжуйте набирати після першого рядка. Якщо код, що ви набрали до цього,
    ще не завершений, інтерпретатор буде відповідати вертикальним стовпчиком на
    наступному рядку.
    <pre class="prettyprint linenums language-scala">scala&gt; val multiLine =
      | "This is the next line."
multiLine: java.lang.String = This is the next line.</pre>
    <p>Якщо ви зрозумієте, що ви використали тип невірно, але інтерпретаор все
      ще очікує додаткового вводу, ви можете вийти, двічи нажавши enter:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val oops =
   |
   |
You typed two blank lines.&nbsp;Starting a new command.
scala&gt;</pre>
    В решті цієї книги, ми відкидатимо вертикальні риски, щоб зробити код
    простішим для читання (та простішим для копіювання та вставки з електронної
    книги PDF eBook в інтерпретатор).
    <h4>Крок 3. Визначимо деякі функції</h4>
    <p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте
      написати деякі функції. Ось як ви робите це в Scala:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
  }
max: (x: Int,y: Int)Int</pre>
    <p>Визначення функції починається з def, далі ім'я функції, в цьому випадку
      max, за яким іде розділений комами список параметрів в дужках. Кожний
      параметр функції має включати анотацію типу через дві крапки, оскільки
      компілятор Scala (та інтерпретатор, але відтепер ми казатимо тільки про
      компілятор) не виводить типи параметрів функції. В цьому прикладі функція
      з ім'ям max приймає два параметри, x та y, обоє типу Int. Після закриття
      дужок за списком параметрів max, ви знайдете іншу анотацію типу ": Int".
      Це визначає тип результата самої функції max. </p>
    <pre class="prettyprint linenums language-scala">"def" починає визначення функції
 |  ім'я функції
 |   |  список параметрів в дужках
 |   |   |              тип результата функції
 |   |   |               |  знак рівності
 |   |   |               |   | тіло функції в фігурних дужках<br> |   |   |               |   |  |<br><br>def max(x: Int, y: Int): Int = {
  if (x &gt; y)
    x
  else
    y
}</pre>
    <p>Малюнок 2.1 Базова форма визначення функції в Scala.</p>
    <p>Після типу результату функції іде знак рівності та пара фігурних дужок,
      що містять тіло функції. В цьому випадку тіло містить єдиний вираз if, що
      обирає x або y, більший з двох, в якості результата функції max. Як тут
      продемонстровано, вираз if в Scala може мати знечення результата, подібно
      до тернарного оператора Java. Наприклад, вираз Scala "if (x &gt; y) x else
      y"&nbsp; поводиться подібно до "(x &gt; y) ? x : y" в Java. Знак рівності,
      що передує тілу функції, дає підказку, що, з точки зору функціонального
      світу, функція визначає вираз, що має закінчується значенням. Базова
      структура функції проілюстрована на Малюнку 2.1.</p>
    <p>Іноді компілятор Scala буде потребувати, щоб ви вказали тип результату
      функції. Наприклад, якщо функція рекурсивна (викликає сама себе), ви
      мусите явно вказати тип результату функції. Однак в випадку max, ви можете
      відкинути тип результата, та компілятор виведе його. Також, якщо функція
      складається тільки з одного твердження, ви можете опіціонально відкинути
      фігурні дужки. Таким чином, ви можете альтернативно записати функцію max
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def max2(x: Int, y: Int) = if (x &gt; y) x else y
max2: (x: Int,y: Int)Int</pre>
    <p>Коли ви визначили функцію, ви можете викликати її по імені, ось так:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; max(3, 5)<br>res4: Int = 5</pre>
    <p>Ось визначення функції, що не приймає жодних параметрів, та не повертає
      ніякого цікавого результата:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</pre>
    <p>Коли ви визначаєте функцію greet(), інтерпретатор відповість
      greet():&nbsp;Unit, де "greet" це, звичайно, ім'я функції. Пусті дужки
      вказують, що функція не сприймає параметрів. Та Unit є типом результата
      greet. Тип результата Unit вказує, що функція не повертає цікавого
      значення. Тип Scala Unit подібний до типу Java void, та, фактично, кожний
      метод, що повертає void в Java відзеркалюється на метод, що повертає Unit
      в Scala. Методи з типом результата Unit, таким чином, виконуються тільки
      заради побічних ефектів. В випадку greet(), побічний ефект є друк
      дружнього привітання на стандиртний вивід.</p>
    <p>В наступному кроці, ви покладете код Scala в файл, та виконаєте його як
      скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, або
      ввівши :quit або :q.</p>
    <pre class="prettyprint linenums language-scala">scala&gt;$<br>:quit</pre>
    <h4>Крок 4. Напишемо деякі Scala скрипти</h4>
    <p>Хоча Scala розроблена щоб допомогти програмістам будувати велико-маштабні
      системи, вона також гарно маштабується донизу, до скриптингу. Скрипт - це
      просто послідовність тверджень в файлі, що будуть виконуватись послідовно.
      Покладіть його в файл hello.scala:</p>
    <pre class="prettyprint linenums language-scala">println("Hello, world, from a script!")</pre>
    <p>потім виконайте:</p>
    <pre class="prettyprint linenums language-scala">$ scala hello.scala</pre>
    <p>Та ви отримаєте ще одне привітання:</p>
    <pre class="prettyprint linenums language-scala">Hello, world, from a script!</pre>
    <p>Аргументи командного рядка до скрипта Scala доступні через масив Scala на
      ім'я args. В Scala масиси починаються з нуля, та ви отримуєте доступ до
      елемента, вказуючи індекс в дужках. Так що перший елемент в масиві Scala
      на ім'я steps є steps(0), не steps[0], як в Java. Щоб спробувати це,
      неберіть наступне в новому файлі на ім'я helloarg.scala:</p>
    <pre class="prettyprint linenums language-scala">// Скажіть hello першому аргументу<br>println("Hello, "+ args(0) +"!")</pre>
    <p>потім виконайте:</p>
    <pre class="prettyprint linenums language-scala">$ scala helloarg.scala planet</pre>
    В цій команді "planet" передається як аргумент командного рядка, що
    доступний в скрипті як args(0). Таким чином ви маєте побачити:
    <pre class="prettyprint linenums language-scala">Hello, planet!</pre>
    <p>Зауважте, що цей скрипт включає коментар. Компілятор Scala буде
      ігнорувати символи між // та наступним кінцем рядка, та всі символи між /*
      та */. Цей приклад також показує Strings, конкатеновані за допомогою
      оператора +. Це робить як ви очікуєте. Вираз "Hello, "+"world!"
      завершиться рядком "Hello, world!".</p>
    <p>Крок 5. Цикли while; рішення з if</p>
    <p>Щоб спробувати while, наберіть наступне в файлі printargs.scala:</p>
    <pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {<br>  println(args(i))
  i += 1
}</pre>
    <h4>Зауваження. </h4>
    <p>Хоча приклади в цьому розділі допомагають пояснити деякі цикли, вони не
      демонструють кращий стиль Scala. В наступному розділі ми побачимо кращі
      підходи, що уникають ітерації по масивам за допомогою індексів.</p>
    <p>Цей скрипт стартує з визначення змінної, var i = 0. Вивід типу надає i
      тип scala.Int, оскільки це тип її початкового значення, 0. Конструкція
      while в наступному рядку спричиняє що блок (код між фігурними дужками)
      буде повторно виконуватись, доки логічний вираз i &lt; args.length на
      стане фальшивим. args.length дає довжину масива args. Блок містить два
      твердження, кожний зсунутий на два проміжки, рекомендований стиль
      відступів для Scala. Перше твердження, println(args(i)), друкує i-й
      аргумент комадного рядка. Друге твердження, i += 1, інкрементує i на один.
      Зауважте, що Java ++i та i++ не роблять в Scala. Щоб інкрементувати в
      Scala, вам треба сказати або i = i + 1, або i += 1. Виконайте цей скрипт
      за допомогою наступної команди:</p>
    <pre class="prettyprint linenums language-scala">$ scala printargs.scala Scala is fun</pre>
    <p>Ви маєте побачити таке:</p>
    <pre class="prettyprint linenums language-scala">Scala
is
fun</pre>
    Для ще більшої розваги наберіть наступний код в новий файл на ім'я
    echoargs.scala:<br>
    <pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()
</pre>
    <p>В цій версії ви замінили виклик println на виклик print, так що всі
      аргументи будуть надруковані в одному рядку. Щоб зробити це читабельним ми
      вставили проміжок перед кожним аргументом, за винятком першого, через
      конструкцію if (i != 0). Оскільки i != 0 буде false для першого оберту
      циклу while, проміжок не надрукується перед першим аргументом. В кінці ми
      додаємо ще один println, щоб отримати новий рядок після друку всіх
      аргументів. Ваш результат буде дійсно дуже красивим. Якщо ви виконаєте цей
      скрипт за допомогою наступної команди:</p>
    <pre class="prettyprint linenums language-scala">$ scala echoargs.scala Scala is even more fun</pre>
    <p>Ви отримаєте:</p>
    <pre class="prettyprint linenums language-scala">Scala is even more fun</pre>
    <p>Зауважте, що в Scala, як і в Java, ви мусите покладати логічниі вирази
      для while або if в дужки. (Іншими словами, ви не можете сказати в Scala
      речі, як if i &lt; 10, як ви можете зробити в таких мовах, як Ruby. Ви
      мусите казати if (i &lt; 10) в Scala). Інша подібність до Java в тому, що
      якщо блок if має тільки одне твердження, ви можете опціонально відкинути
      фігурні дужки, як це демонструється в твердженні if в echoargs.scala. Та
      хоча ви не бачите жодних з них, Scala використовує крапку з комою для
      розділення тверджень, як в Java, за тим виключенням, що в Scala крапки з
      комою дуже часто опціональні, що надає полегшення вашому правому мізинцю.
      Одже, якщо ви в дещо більш балакучому настрої, ви можете записати скрипт
      echoargs.scala наступним чином:</p>
    <pre class="prettyprint linenums language-scala">var i = 0;
while (i &lt; args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();</pre>
    <h4>Крок 6. Ітерація за допомогою foreach та for</h4>
    <p>Хоча ви можете ще не розуміти цього, коли ви пишете цикл while на
      попередньому кроці, ви програмуєте в імперативному стилі. В імперативному
      стилі, що є стилем, який ви використовуєте в мовах як Java, C++ та C, ви
      отримуєте одну імперативну команду за раз, ітеруєте за допомогою циклів,
      та часто змінюєте стан, що розподілений між різними функціями. Scala
      дозволяє вам програмувати імперативно, але коли ви краще пізнаєте Scala,
      ви, вірогідно, винайдете, що почали програмувати в більш функціональному
      стилі. Фактично, однією з головних цілей цієї книги є допомогти вам стати
      настільки ж комфортабельним з функціональним стилем, як і з імперативним
      стилем.</p>
    <p>Однією з головних характеристик функціональної мови є те, що функції є
      першокласними конструкціями, і це дуже вірно в Scala. Наприклад, інший,
      (значно більш стислий) шлях надрукувати аргумент командного рядка, є:</p>
    <pre class="prettyprint linenums language-scala">args.foreach(arg =&gt; println(arg))</pre>
    <p>В цьому коді ви викликаєте метод foreach на args, та передаєте результат
      в фукнцію. В цьому випадку ви передаєте в функцію літерал, що приймає один
      аргумент на ім'я arg. Тіло функції є println(arg). Якщо ви наберете код
      вище в новому файлі на ім'я pa.scala, та виконаєте його за допомогою
      команди:</p>
    <pre class="prettyprint linenums language-scala">$ scala pa.scala Concise is nice</pre>
    <p>Ви побачите:</p>
    <pre class="prettyprint linenums language-scala">Concise
is
nice</pre>
    <p>В попередньому прикладі інтерпретатор Scala виводить тип arg як String,
      оскільки String є типом елементів масива, на якому ви викликаєте foreach.
      Якщо ви схильні бути більш явним, ви можете вказати ім'я типу, але тоді
      там треба огорнути артументи в дужки (що в жодному разі є нормальною
      формою синтаксиса):</p>
    <pre class="prettyprint linenums language-scala">args.foreach((arg: String) =&gt; println(arg))</pre>
    Виконання цього скрипта має ту ж поведінку, що і попереднього. Якщо ви в
    настрої для більшої стислості, замість більшої відкритості, ви можете
    отримати вигоду спеціального скорочення в Scala. Якщо функціональний літерал
    складається з одного твердження, що приймає один аргумент, вам не треба явно
    називати та вказувати цей аргумент. Таким чином, наступний код також буде
    робити:<br>
    <pre class="prettyprint linenums language-scala">args.foreach(println)</pre>
    <p>параметри функції в дужках</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      стрілка<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      |&nbsp;&nbsp;&nbsp;&nbsp; тіло функції<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>
      (x: Int, y: Int) =&gt; x + y</p>
    <p>Малюнок 2.2 Синтаксис функціонального літерала в Scala.</p>
    <p>Щоб підсумувати, синтаксис для функціонального літерала є списком
      поіменованих параметрів в дужках, права стрілка, та потім тіло функції.
      Цей синтаксис проілюстрована на Малюнку 2.2.</p>
    <p>Тепер, в цій точці, ви можете здивуватись, що відбувається з тіма
      випробовуваними циклами for, що ви звикли використовувати в імперативних
      мовах, як Java або C. В спробі вести вас в фукнціональному напрямку, в
      Scala існує тільки функціональний родич імперативного for (що називається
      for виразом). Ви не побачите його повну потужність та виразність, доки не
      дійдете (або не перестрибнете) до Розділу 7.3, але ми дамо вам можливість
      поглянути вже тут. В новому файлі з назвою forargs.scala, наберіть
      наступне:</p>
    <pre class="prettyprint linenums language-scala">for (arg &lt;- args)
  println(arg)</pre>
    <p>Дужки після "for" містять arg &lt;- args. Зправа до символа &lt;- є
      знайомий масив args. Зліва від &lt;- стоїть "arg", ім'я val, не var.
      (Оскільки це завжди val, ви просто пишете поодиноке "arg", не "val arg".)
      Хоча arg може виглядати як var, тому що вона отримуватиме нове значення на
      кожній ітерації, насправді це val: arg не може бути переприсвоєна в тілі
      for виразу. Замість цього, для кожного елементу масива args буде створена
      нова arg val, та ініціалізована значенням елемента, після чого буде
      виконане тіло for.</p>
    <p>Якщо ви виконаєте скрипт forargs.scala за допомогою команди:</p>
    <pre class="prettyprint linenums language-scala">$ scala forargs.scala for arg in args</pre>
    <p>Ви побачите: </p>
    <pre class="prettyprint linenums language-scala">for
arg
in
args</pre>
    For вирази Scala можуть робити значно більше від цього, але цей приклад є
    достатнім для початку. Ми покажемо більше щодо for в Розділі 7.3 та Главі
    23.<br>
    <h3>Висновок</h3>
    <p>В цій главі ви навчились деяким основам Scala, та, маємо надію, отримали
      перевагу від написання деякого кода Scala. В наступній главі ми продовжимо
      цей вступний огляд, та розглянемо більш просунуті теми.&nbsp;</p>
    <h3>Глава 3</h3>
    <h2>Наступні кроки в Scala</h2>
    <p>Ця глава продовжує попередні вступ до Scala в попередніх главах. В цій
      главі ви введемо деякі більш просунуті можливості. Коли ви завершите цю
      главу, ви матемите досить знань, що дозволять вам почати писати корисні
      скрипти на Scala. Як і в попередній главі, ми рекомендуємо вам перевіряти
      приклади по мірі просування. Кращий шлях отримати відчуття Scala є почати
      писати код на Scala.</p>
    <h4>Крок 7. Параметризація масивів за допомогою типів</h4>
    <p>В Scala ви можете створювати об'єкти, або примірники класів,
      використовуючи new. Коли ви створюєте об'єкт в Scala, ви можете
      параметризувати його значеннями та типами. Параметризація означає
      "конфігурацію" примірника, коли ви створюєте його. Ви параметризуєте
      примірник за допомогою значень, що передаються об'єктам в конструктор в
      дужках. Наприклад, наступний код Scala створює примірник нового
      java.math.BigInteger, та параметризує його значенням "12345":</p>
    <pre class="prettyprint linenums language-scala">val big = new java.math.BigInteger("12345")</pre>
    <p>Ви параметризуєте примірник типом, через вказання одного або більше типів
      в квадратних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі
      greetStrings є значення типу Array[String] ("масив рядків"), що
      ініціалізований довжиною 3, що параметризує його в першому рядку кода
      значенням 3. Якщо ви виконаєте код з Лістингу 3.1 як скрипт, ви побачите
      інше привітання <br>
      Hello, world!. Зауважте, що ви параметризуєте примірник обоє, типом та
      значенням, тип іде першим в квадратних дужках, за ним слідує значення в
      дужках.</p>
    <pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
    <p>Лістинг 3.1 Параметризація масива типом.</p>
    <h4><span style="font-weight: bold;">Зауваження</span></h4>
    <p><span style="font-weight: bold;"></span>Хоча код в Лістингу 3.1
      демонструє важливі концепції, він не показує рекомендований спосіб
      створювати та ініціалізувати масиви в Scala. Ви побачите кращий спосіб в
      Лістингу 3.2.</p>
    <p>Якщо ви в дещо більш явному настрої, ви можете явно вказати тип
      greetStrings наступним чином:</p>
    <pre class="prettyprint linenums language-scala">val greetStrings: Array[String] = new Array[String](3)</pre>
    <p>Маючи вивід типів Scala, цей рядок кода семантично еквівалентний до
      справді першого рядка Лістингу 3.1. Але ця форма демонструє, що хоча
      чистина параметризації типу (імена типів в квадратних дужках) формує
      частину типу примірника, частина параметризації значення (значення в
      дужках) - ні. Тип greetStrings є Array[String], та не Array[String](3).</p>
    <p>Наступні три рядка кода в Лістингу 3.1 ініціалізують кожний елемент
      масива <br>
      greetStrings:</p>
    <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"</pre>
    <p>Як ми вже зазначали, масиви в Scala отримують доступ, розміщуючи індекс в
      дужки, не в квадратні дужки, як в Java. Таким чином, нульовий елемент
      масива є greetStrings(0), не greetStrings[0].</p>
    <p>Ці три рядка кода ілюструють важливу для розуміння концепцію щодо
      розуміння Scala значення val. Коли ви визначаєте змінну за допомогою val,
      змінна не може бути перепризначена, але об'єкт, на який вона посилається,
      потенційно все ще може бути змінений. Так що в цьому випадку ви не можете
      переприсвоїти greetStrings до іншого масиву; greetStrings буде завжди
      посилатись на той же примірник Array[String], яким він був
      ініціалізований. Але ви можете з часом змінювати елементи цього
      Array[String], так що сам масив є змінним.</p>
    <p>Два заключні рядки Лістингу 3.1 містять вираз for, що друкує кожний
      елемент масиву greetStrings по порядку:</p>
    <pre class="prettyprint linenums language-scala">for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
    <p>Перший рядок кода в цьому виразі ілюструє інше головне правило Scala:
      якщо метод приймає тільки один параметр, ви можете викликати його без
      крапки та дужок. Метод to в цьому прикладі насправді є методом, що приймає
      один аргумент Int. Код 0 to 2 перетворюється в виклик метода (0).to(2).1
      Зауважте, що цей синтаксис робить тільки якщо ви вказали отримувача
      виклику метода. Ви не можете записати "println 10", але ви можете записати
      "Console println 10".</p>
    <p>Scala технічно не має перевантаження операторів, оскільки вона не має
      операторів в традиційному сенсі. Замість цього такі символи, як +, -, *,
      та / можуть використовуватись як імена методів. Таким чином, коли ви
      друкуєте 1 + 2 в інтерпретаторі Scala на Кроці 1, ви насправді викликали
      метод з ім'ям + на Int об'єкті 1, передавши йому 2 в якості параметра. Як
      проілюстровано на Малюнку 3.1, ви можете альтернативно записати 1 + 2,
      використовуючи традиційний синтаксис виклику метода, (1).+(2).</p>
    <p>Інша важлива ідея, проілюстрована в цьому прикладі, надасть вам погляд на
      те, чому доступ до масивів в Scala виконується за допомогою дужок. Scala
      має меньше особливих випадків, ніж Java. Масиви є просто примірниками
      класів, як любі ішні класи в Scala. Коли ви застосовуєте дужки, що
      оточують одне або більше значень до змінної, Scala перетворить код в
      виклик метода, що називається apply, до цієї змінної. Так що
      greetStrings(i) буде трансформовано в greetStrings.apply(i). Таким чином,
      доступ до елементів в масиві Scala є простим викликом метода, як любого
      іншого. Це принцип не обмежується масивами: любе застосування деякого
      об'єкту до деяких аргументів в дужках буде трансформовано в виклик метода
      apply. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкту дійсно
      визначає метод apply. Так що це не спеціальний випадок, а загальне
      правило.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1&nbsp;&nbsp;
      +&nbsp;&nbsp;&nbsp; 2</p>
    <p>Об'єкт Int зі значенням 1 &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      на 1 викликається метод ‘+’<br>
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      &nbsp;&nbsp; якому передається параметр Int 2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (1).+(2)</p>
    <p>Малюнок 3.1 В Scala всі оператори є викликами методів.</p>
    <p>Подібно до цього, коли виконується присвоєння до змінної, до якої
      застосовуються дужки, та один або більше аргументів, компілятор
      трансформує це в виклик метода update, що приймає аргументи в дужках, а
      також об'єкт зправа від знаку присвоєння. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"</pre>
    <p>буде трансформоване в:</p>
    <pre class="prettyprint linenums language-scala">greetStrings.update(0, "Hello")</pre>
    <p>Таким чином, наступне буде семантичним еквівалентом кода Лістинга 3.1:</p>
    <pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
 greetStrings.update(0, "Hello")
 greetStrings.update(1, ", ")
 greetStrings.update(2, "world!\n")
 for (i &lt;- 0.to(2))
   print(greetStrings.apply(i))</pre>
    <p>Scala досягає концептуальної простоти, розглядаючи все, від масивів до
      виразів, як об'єкти з методами. Вам не треба запам'ятовувати особливі
      випадки, такі як відмінності в Java між примітивами, та їх відповідними
      огортками, або між масивами та регулярними об'єктами. Більше того, ця
      одноманітність не стає в помітну ціну. Компілятор Scala використовує
      масиви Java, примітивні типи та природну арифметику, коли це можливо, в
      скомпільованому коді.</p>
    <p>Хоча приклади, що ви бачили до тепер на цьому кроці, компілюються та
      виконуються досить гарно, Scala провадить більш стислий шлях створювати та
      ініціалізувати масиви, що ви будете зазвичй використовувати. Це виглядає
      як в Лістингу 3.2. Цей код створює новий масив довжиною три, та
      ініціалізує його переданими рядками, "zero", "one" та "two". Компілятор
      виводить тип масива як Array[String], оскільки ви передали йому рядки.</p>
    <pre class="prettyprint linenums language-scala">val numNames = Array("zero", "one", "two")</pre>
    <p>Лістинг 3.2 Створення та ініціалізація масива.</p>
    <p>Що ви насправді робите в Лістингу 3.2, це виклик метода-фабрики, що
      називається apply, що створює та повертає новий масив. Цей метод apply
      приймає змінне число аргументів, та визначений на об'єкті-компанйоні
      Array. Ви пізнаєте більше про об'єкти-компанйони в Розділі 4.3. Якщо ви
      програміст на Java, ви можете думати про це як про виклик статичного
      метода з іменем apply на класі Array. Більш галасливий шлях викликати той
      же метод apply є наступним:</p>
    <pre class="prettyprint linenums language-scala">val numNames2 = Array.apply("zero", "one", "two")</pre>
    <h4>Крок 8. Використання списків</h4>
    <p>Одна з великих ідей функціонального стилю програмування полягає в тому,
      що методи не повинні мати побічних ефектів. Єдиною дією повинне бути
      обчислення та повернення значення. Деякі вигоди, отримані при прийнятті
      цього підоходу, є те, що методи стають менш заплутані, та, таким чином,
      більш надійними та використовуваними. Інша вигода (в статично типізованій
      мові) є та, що все, що іде в, та з, метода, перевіряється контролем типу,
      так що логічні помилки більш вірогідно проявлять себе, як помилки типу.
      Застосовуючи цю функціональну філософію до світу об'єктів означає зробити
      об'єкти незмінними.</p>
    <p>Як ви бачили, масиви Scala є змінними послідовостями об'єктів, що всі
      поділяють один тип. Наприклад, Array[String] містить тільки рядки. Хоча ви
      не можете змінити довжину масива, після того, як він був створений, ви
      можете змінити значення його елементів. Таким чином, масиви є змінними
      об'єктами.</p>
    <p>Для незмінної послідовності об'єктів, що розділяють один тип, ви можете
      використовувати клас Scala List. Як і з масивами, List[String] містить
      тільки рядки. В Scala List, scala.List, відрізняється від типу
      java.util.List, в тій частині, що Scala List завжди незмінні (тоді як Java
      List може бути змінені). Більш загально, Scala List розроблений щоб
      дозволити функціональний стиль програмування. Створення списку просте.
      Лістинг 3.3 показує, як: </p>
    <pre class="prettyprint linenums language-scala">val oneTwoThree = List(1, 2, 3)</pre>
    <p>Лістинг 3.3 Створення та ініціалізація списка.</p>
    <p>Код в Лістингу 3.3 встановлює нову val&nbsp; на ім'я oneTwoThree,
      ініціалізованою за допомогою new List[Int] з числовими елементами 1, 2 та
      3. Оскільки списки List незмінні, вони поводяться трохи подібно до рядків
      Java: коли ви викликаєте метод на списку, що, згідно з ім'ям, виглядає як
      такий, що мав би змінювати список, він, замість цього, повертає нове
      значення. Наприклад, List має метод на ім'я ':::' для конкатенації
      списків. Ось як ви використовуєте його:</p>
    <pre class="prettyprint linenums language-scala">val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(oneTwo +" and "+ threeFour +" were not mutated.")
println("Thus, "+ oneTwoThreeFour +" is a new list.")</pre>
    <p>Якщо ви виконаєте цей список, ви побачите: </p>
    <pre class="prettyprint linenums language-scala">List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</pre>
    <p>Можливо, найбільш загальним оператором, що ви будете використовувати зі
      списками, є ‘::’, що вимовляється як "cons". Cons ствить новий елемент в
      початок існуючого списку, та повертає отриманий список. Наприклад, якщо ви
      виконаєте цей скрипт:</p>
    <pre class="prettyprint linenums language-scala">val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)</pre>
    <p>Ви побачите:</p>
    <pre class="prettyprint linenums language-scala">List(1, 2, 3)</pre>
    <h4>Зауваження</h4>
    <p>В виразі "1 :: twoThree", :: є методом свого правого операнда, списка
      twoThree. Ви можете запідозрити, що щось негарне з асоциативністю метода
      ::, але насправді це просте правило, що легко запам'ятати: якщо метод
      використовується в нотації оператора, такій, як a * b, метод викликається
      на лівому операнді, як в a.*(b) — за винятком, коли метод закінчується на
      дві крапки. Якщо це так, метод викликається на правому операнді. Таким
      чином, в 1 :: twoThree, метод :: викликається для twoThree, передаючи 1: </p>
    <pre class="prettyprint linenums language-scala">twoThree.::(1).</pre>
    <p>Асоциативність операторів буде описана більш детально в Розділі 5.8.</p>
    <p>Зважаючи, що скорочений спосіб для вказання пустого списку є Nil, одним
      шляхом для ініціалізації нових списків є рядок елементів з оператором
      cons, та з Nil в якості останнього елемента. Наприклад, наступний скрипт
      буде продукувати той ж вивід, що і попередній, "List(1, 2, 3)":</p>
    <pre class="prettyprint linenums language-scala">val oneTwoThree = 1 :: 2 :: 3 :: Nil
println(oneTwoThree)</pre>
    <p>Scala List оздоблений корисними методвами, багато з яких перелічені в
      Таблиці 3.1. Повна потужність списків буде розкритою в Главі 16.</p>
    <p><span style="font-weight: bold;">Чому ми не додаємо до списків?</span><br>
      Клас List надає операцію "append" — вона записується як :+ та пояснюється
      в Главі 24 — але ця операція рідко використовується, оскільки час, що
      займає додавання до списку, зростає лінійно з розміром списку, тоді як
      додавання зпереду :: займає сталий час. Вашими опціями, якщо бажаєте
      побудувати список ефективно додаванням елементів, є ставити їх зпереду, та
      потім, коли скінчите, виконати реверс; або використовуйте ListBuffer,
      змінний список, що пропонує операцію додавання, та коли скінчите,
      виконайте toList. ListBuffer буде описаний в Розділі 22.2.</p>
    <p>Таблиця 3.1 Деякі методи List та їх використання</p>
    <table style="width: 100%" border="0">
      <tbody>
        <tr>
          <td><span style="font-weight: bold;">Що це</span></td>
          <td><span style="font-weight: bold;">Що робить</span></td>
        </tr>
        <tr>
          <td style="width: 269.717px;">List() or Nil</td>
          <td style="width: 382.25px;">Пустий список</td>
        </tr>
        <tr>
          <td>List("Cool", "tools", "rule")</td>
          <td>Створює новий List[String] з трьох значень, "Cool", "tools" та
            "rule"</td>
        </tr>
        <tr>
          <td>val thrill = "Will" :: "fill" :: "until" :: Nil</td>
          <td style="margin-left: -27.7778px;">Створює новий List[String] з
            трьох елементів "Will", "fill" та "until"</td>
        </tr>
        <tr>
          <td>List("a", "b") ::: List("c", "d")</td>
          <td>Конкатенує два списки (повертає новий List[String] зі значень "a",
            "b", "c", "d")</td>
        </tr>
        <tr>
          <td>thrill(2)</td>
          <td>Повертає елемент з індексом 2 (від нуля) зі списку thrill
            ("until")</td>
        </tr>
        <tr>
          <td>thrill.count(s =&gt; s.length == 4)</td>
          <td>Рахує число рядків в thrill з довжиною 4 (повертає 2)</td>
        </tr>
        <tr>
          <td>thrill.drop(2)</td>
          <td>Повертає список thrill без перших двох елементів (List("until"))</td>
        </tr>
        <tr>
          <td>thrill.dropRight(2)</td>
          <td>Повертає список thrill без його двох правих елементів
            (List("Will"))</td>
        </tr>
        <tr>
          <td>thrill.exists(s =&gt; s == "until")</td>
          <td>Визначає, чи існує в thrill елемент-рядок "until" (true)</td>
        </tr>
        <tr>
          <td>thrill.filter(s =&gt; s.length == 4)</td>
          <td>Повертає список всіх елементів thrill, по порядку, з довжиною 4 (<br>
            List("Will", "fill"))</td>
        </tr>
        <tr>
          <td>thrill.forall(s =&gt; s.endsWith("l"))</td>
          <td>Вказує, чи всі елементи списка thrill завершуються на літеру "l"<br>
            (true)</td>
        </tr>
        <tr>
          <td>thrill.foreach(s =&gt; print(s))</td>
          <td>Виконує твердження print для кожного елемента в списку thrill
            (друкує "Willfilluntil")</td>
        </tr>
        <tr>
          <td>thrill.foreach(print)</td>
          <td>Те саме, але стисліше (друкує "Willfilluntil")</td>
        </tr>
        <tr>
          <td>thrill.head</td>
          <td>Повертає перший елемент в списку thrill ("Will")</td>
        </tr>
        <tr>
          <td>thrill.init</td>
          <td>Повертає список з усіх елементів списку, крім останнього
            (List("Will", "fill"))</td>
        </tr>
        <tr>
          <td>thrill.isEmpty</td>
          <td>Вказує, чи список thrill є пустим (false) </td>
        </tr>
        <tr>
          <td>thrill.last</td>
          <td>Повертає останній елемент списку thrill ("until")</td>
        </tr>
        <tr>
          <td>thrill.length</td>
          <td>Повертає число елементів в списку (3)</td>
        </tr>
        <tr>
          <td>thrill.map(s =&gt; s + "y")</td>
          <td>Повертає список, що утворений додаванням"y" до кожного
            елемента-рядка списка thrill (List("Willy", "filly", "untily"))</td>
        </tr>
        <tr>
          <td>thrill.mkString(", ")</td>
          <td>Робить рядок з елементів списку ("Will, fill, until")</td>
        </tr>
        <tr>
          <td>thrill.remove(s =&gt; s.length == 4)</td>
          <td>Повертає список з елементів, по порядку, окрім тих, що мають
            довжину 4 (List("until"))</td>
        </tr>
        <tr>
          <td>thrill.reverse</td>
          <td>Повертає список з усіх елементів, в зворотньому порядку
            (List("until", "fill", "Will"))</td>
        </tr>
        <tr>
          <td>thrill.sort((s, t) =&gt; s.charAt(0).toLower &lt;
            t.charAt(0).toLower)</td>
          <td>Повертає список, що містить всі елементи списку thrill list в
            алфавітному порядку за першою літерою в нижньому реєстрі
            (List("fill", "until", "Will"))</td>
        </tr>
        <tr>
          <td>thrill.tail</td>
          <td>Повертає список thrill без першого елемента (List("fill",
            "until"))</td>
        </tr>
      </tbody>
    </table>
    <h4>Крок 9. Використання кортежів</h4>
    <p>Інший корисний контейнерний об'єкт є кортеж. Як і списки, кортежі
      незмінні, але на відміну від списків, кортежі можуть містити різні типи
      елементів. Тоді як список може бути List[Int] або List[String], кортеж
      може містити обоє, і цілі і рядки, одночасно. Кортежі є дуже корисними,
      наприклад, якщо ви бажаєте повернути незмінні об'єкти з метода. Тоді як в
      Java ви повинні часто створити JavaBean-подібний клас, щоб утримувати
      декілька повернутих значень, в Scala ви можете просто повернути кортеж. Та
      це просто: щоб створити новий кортеж, що містить декілька об'єктів, просто
      розмістіть об'єкти в дужках, розділивши їх комами. Коли ви маєте створений
      примірник кортежу, ви можете отримати доступ до його елементів за
      допомогою крапки, підкреслення, та базованому на одиниці індексу
      елементів. Приклад показаний в Лістингу 3.4:</p>
    <pre class="prettyprint linenums language-scala">val pair = (99, "Luftballons")
 println(pair._1)
 println(pair._2)</pre>
    <p>Лістинг 3.4 Створення та використання кортежу.</p>
    <p>В першому рядку Лістингу 3.4, ви створюєте новий кортеж, що містить ціле
      99, в якості першого елемента, та рядок "Luftballons", як другий елемент.
      Scala виводить тип кортежу як Tuple2[Int, String], та дає цей тип також і
      змінній pair. В другому рядку ви отримуєте доступ до поля _1, що поверне
      перший елемент, 99. "." в другому рядку є тою ж крапкою, що ви
      використовували для доступу до полів, або викликали метод. В цьому випадку
      ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте цей скрипт, ви
      побачите:</p>
    <pre class="prettyprint linenums language-scala">99<br>Luftballons</pre>
    <p>Справжній тип кортежу залежить від числа елементів, що він містить, та
      типів ціх елементів. Таким чином, тип (99, "Luftballons") є Tuple2[Int,
      String]. Тип ('u', 'r', "the", 1, 4, "me") є Tuple6[Char, Char, String,
      Int, Int, String].</p>
    <p><br>
      <span style="font-weight: bold;">Доступ до елементів кортежу</span></p>
    <p>Ви можете зацікавитись, чому ви не можете отримати доступ до елементів
      кортежу як до елементів списку, наприклад, через "pair(0)". Причина в
      тому, що метод списку apply завжди повертає той самий тип, але кожний
      елемент кортежу може мати різний тип: _1 може мати один тип результату, _2
      інший, і так далі. Ці _N чисел базуються на одиниці, замість нуля,
      оскільки починати з 1 є традицією, що встановлена іншими мовами зі
      статично типізованими кортежами, як Haskell та ML.</p>
    <h4>Крок 10. Використання множин та мап</h4>
    <p>Оскільки Scala націлена допомогти вам отримати переваги з обох,
      функціонального та імперативного стилю, його бібліотеки колекцій
      наголошують на різниці між змінними та незмінними колекціями. Наприклад,
      масиви є завжди змінними; списки завжди незмінні. Scala також провадить
      змінні та незмінні альтернативи для множин та мап, але використовує ті ж
      прості імена для обох версій. Для множин та мап Scala моделює змінність в
      ієрархії класів.&nbsp;</p>
    <p>Наприклад, Scala API містить базовий трейт для множин, де трейт є дещо
      подібним до інтерфейсу Java. (Ви винайдете більше щодо трейтів в Главі
      12). Потім Scala провадить два субтрейти, один для змінних наборів, інший
      для незмінних наборів. Як ви можете бачити на Малюнку 3.2, ці три трейти
      всі поділяють те ж просте ім'я, Set. Їх повністю кваліфіковані імена,
      однак, відрізняються, оскільки кожен знаходиться в окремому пакунку.
      Конкретні класи множин в Scala API, такі як класи HashSet, показані на
      Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java
      ви "реалізуєте" інтерфейси, в Scala ви "розширююте" або "домішуєте"
      трейти). </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Set<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      «trait»<br>
      scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection.mutable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Set<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; «trait»<br>
      <br>
      <br>
      scala.collection.immutable&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      HashSet&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashSet<br>
      <br>
      Малюнок 3.2 Ієрархія класів для множин Scala. </p>
    <p>Таким чином, якщо ви бажаєте використати HashSet, ви можете обрати між
      змінними та незмінними різновидами, в залежності від ваших потреб. Спосіб
      по замовчанню для створення множини показаний в Лістингу 3.5:</p>
    <pre class="prettyprint linenums language-scala">var jetSet = Set("Boeing", "Airbus")
jetSet += "Lear"
println(jetSet.contains("Cessna"))</pre>
    <p>Лістинг 3.5 Створення, ініціалізація та використання незмінної множини.</p>
    <p>В першому рядку кода Лістингу 3.5, ви визначаєте нову var на ім'я jetSet,
      та ініціалізуєте її незмінною множиною, що містить два рядки, "Boeing" та
      "Airbus". Як показує цей приклад, ви можете створити множини в Scala
      подібно до того, як ви створюєте масиви: викликаючи метод-фабрику на ім'я
      apply на об'єкті-компанйоні Set. В Лістингу 3.5 ви викликаєте apply на
      об'єкті-компанйоні для scala.collection.immutable.Set, що повертає
      примірник незмінного Set по замовчанню. Компілятор Scala виводить тип
      jetSet’s як незмінний Set[String].</p>
    <p>Щоб додати новий елемент до множини ви викликаєте + на множині, передаючи
      новий елемент. Обоє, зминна та незмінна множина, пропонують метод +, але
      їх поведінка відрізняється. В той час, коли змінна множина буде додавати
      елемент до себе, незмінна множина створить, та поверне нову множину з
      доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною, так що
      виклик + дасть повністю нову множину. Хоча змінні множини пропонують
      справжній метод +=, незмінні множини - ні. В цьому випадку, другий рядок
      коду, jetSet += "Lear", є в основі скороченням для:</p>
    <pre class="prettyprint linenums language-scala">jetSet = jetSet + "Lear"</pre>
    <p>Таким чином, другий рядок Лістингу 3.5 ви перевизначаєте var jetSet новою
      множиною, що містить "Boeing", "Airbus" та "Lear". Нарешті, останній рядок
      Лістингу 3.5 друкує те, чи множина містиь рядок "Cessna". (Як ви можете
      очікувати, вона друкує false). Якщо ви бажаєте змінну множину, вам треба
      використовувати імпорт, як показане в Лістингу 3.6:</p>
    <pre class="prettyprint linenums language-scala">import scala.collection.mutable.Set
val movieSet = Set("Hitch", "Poltergeist")
movieSet += "Shrek"
println(movieSet)</pre>
    <p>Лістинг 3.6 Створення, ініціалізація, та використання змінної множини.</p>
    <p>В першому рядку Лістингу 3.6 ви імпортуєте змінний Set. Як і в Java,
      твердження імпорту дозволяє вам використовувати просте ім'я, як Set,
      замість довшого, повністю кваліфікованого імені. Як результат, коли ви
      кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі
      scala.collection.mutable.Set. На цьому рядку ви ініціалізуєте movieSet за
      допомогою змінної множини, що містить рядки "Hitch" та "Poltergeist".
      Наступний рядок додає "Shrek" до змінної множини, викликаючи метод += на
      множині, та передаючи рядок "Shrek". Як вже зазначалось, += є насправді
      методом, визначеним на змінних множинах. Коли ви побажаєте, замість писати
      movieSet += "Shrek", ви можете записати movieSet.+=("Shrek").</p>
    <p>Хоча показана реалізація множини по замовчанню, що продукується змінною
      та незмінною методом-фабрикою Set, показаною тут, вірогідно, буде
      достатньою для більшості ситуацій, іноді ви можете побажати явно задати
      клас. На щастя, синтаксис подібний. Просто імпортуйте клас, що вам
      потрібний, та використовуєте метод-фабрику на об'єкті-компанйоні.
      Наприклад, якщо вам треба незмінний HashSet, ви можете зробити таке:</p>
    <pre class="prettyprint linenums language-scala">import scala.collection.immutable.HashSet
val hashSet = HashSet("Tomatoes", "Chilies")
println(hashSet + "Coriander")</pre>
    <p>Іншим корисним класом колекції в Scala є Map. Як і з множинами, Scala
      провадить змінні та незмінні версії Map, використовуя ієрархію класів. Як
      ви можете бачити на Малюнку 3.3, ієрархія класів для мап виглядає
      здебільшого як така ж для множин. Є базовий трейт Map в пакунку
      scala.collection, та два субтрейта Map: змінний Map в
      scala.collection.mutable, та незмінний в <br>
      scala.collection.immutable.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp; Map<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      «trait»<br>
      scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection.mutable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Map<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      «trait»<br>
      <br>
      scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection.mutable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      HashMap&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      HashMap<br>
      <br>
      Малюнок 3.3 Ієрархія класів для мап Scala.</p>
    <p>Реалізації Map, такі як HashMap, показані в ієрархії класів на Малюнку
      3.3, розширює або змінний, або незмінний трейт. Ви можете створити та
      ініціалізувати мапи, використовуючи методи-фабрики, подібні до тих, що
      використовуютсья для масивів, списків та множин. Наприклад, Лістинг 3.7
      показує змінну мапу в дії.</p>
    <pre class="prettyprint linenums language-scala">import scala.collection.mutable.Map
val treasureMap = Map[Int, String]()
treasureMap += (1 -&gt; "Go to island.")
treasureMap += (2 -&gt; "Find big X on ground.")
treasureMap += (3 -&gt; "Dig.")
println(treasureMap(2))</pre>
    <p>Лістинг 3.7 Створення, ініціалізація та використання змінної мапи.</p>
    <p>В першому рядку Лістингу 3.7 ви імпортуєте змінну Map. Потім ви
      визначаєте val з іменем treasureMap, та ініціалізуєте її пустою змінною
      Map, що має цілі ключі, та рядки як значення. Мапа порожня, бо ви нічого
      не передали в метод-фабрику (дужки в "Map[Int, String]()" порожні). В
      насупних трьох рядках ви додаєте пари ключ/значення до мапи,
      використовуючи методи -&gt; та +=. Як вже було проілюстровано, компілятор
      Scala трансформує двомісні вирази-оператори, як 1 -&gt; "Go to island." на
      (1).-&gt;("Go to island."). Таким чином, коли ви кажете 1 -&gt; "Go to
      island.", ви насправді викликаєте метод на ім'я -&gt; на цілому зі
      значенням 1, якому передається рядок зі значенням "Go to island.". Цей
      метод -&gt;, який ви можете викликати для любого об'єкта в програмі Scala,
      повертає двоелементий кортеж, що містить ключ та значення. Потім ви
      передаєте цей кортеж до метода += об'єкта мапи, на який посилається
      treasureMap. Нарешті, останній рядок друкує значення, що відповідає ключю
      2 в treasureMap. Якщо ви виконаєте цей код, він надрукує:</p>
    <pre class="prettyprint linenums language-scala">Find big X on ground.</pre>
    <p>Якщо ви бажаєте незмінну мапу, вам не потрібен імпорт, оскільки незмінні
      мапи по замовчанню. Приклад показаний в Лістингу 3.8:</p>
    <pre class="prettyprint linenums language-scala">val romanNumeral = Map(
  1 -&gt; "I", 2 -&gt; "II", 3 -&gt; "III", 4 -&gt; "IV", 5 -&gt; "V"
)
println(romanNumeral(4))</pre>
    <p>Лістинг 3.8 Створення, ініціалізація та використання незмінної мапи.</p>
    <p>Приймаючи до уваги, що ми не маємо імпортів, коли ми кажемо Map в першому
      рядку Лістинга 3.8, ви отримаєте по замовчанню
      scala.collection.immutable.Map. Ви передаєте п'ять кортежів ключ/значення
      до метода-фабрики мапи, що повертає незмінну Map, що містить передані пари
      ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p>
    <h4>Крок 11. Навчаемось розпізнавати функціональний стиль</h4>
    <p>Як зазначено в Главі 1, Scala дозволяє вам програмувати в імперативному
      стилі, але заохочує вас адоптуватись до більш функціонального стилю. Якщо
      ви прийшли до Scala з імперативного підгрунтя — наприклад, якщо ви
      прогаміст на Java — один з найбільших викликів, на який ви можете
      натрапити при вивченні Scala, це зрозуміти, як програмувати в
      фукнціональному стилі. Ми розуміємо, що цей стиль спершу може здатись
      незвичним, але в цій книзі ми докладаємо зусиль, щоб провести вас через це
      перетворення. Це потребуватиме деякої роботи з вашого боку, та ми
      заохочуємо вам докласти зусуль. Якщо ви прийшли з імперативного підгрунтя,
      ми віримо, що навчання програмування в фукнціональному стилі не тільки
      зробить вас кращим програмістом на Scala, та також розширить ваші
      горизонти, та зробить вас кращим програмістом взагалі.</p>
    <p>Перший крок до розпізнання різниці між двома стилями в коді. Одним
      натяком може бути, чи код містить будь-які var, він, можливо, є в
      імперативному стилі. Якщо код не містить жодних var взагалі — тобто, він
      містить тільки val — він, можливо, є в функціональному стилі. Одним шляхом
      просунутись далі в функціональному стилі, таким чином, є спробувати
      програмувати без var.</p>
    <p>Якщо ви походите з імперативного підгрунтя, такого, як Java, C++, або C#,
      ви можете думати про var, як про звичайну змінну, та val як про
      спеціальний тип змінної. З іншого боку, якщо ви прийшли з функціонального
      підгрунтя, такого, як Haskell, OCaml, або Erlang, ви можете думати про val
      як про звичайні змінні, та var як різновид богохульства. Точка зору Scala,
      однак, в тому, що val та var є тільки двома різними інструментами в вашому
      наборі, обоє корисні, та жодний не є природним злом. Scala заохочує вас
      вивчити щодо val, але кінець кінцем ви маєте обрати кращий інструмент для
      завдання, що вирішується. Однак, навіть коли ви згодні з цією
      збалансованою філософією, вам все ще буде спочатку складно визначитись, як
      подолати var в вашому коді.</p>
    <p>Розлянемо, наприклад, такий приклад цикла while, адаптований з Глави 2,
      що використовує var, та є, таким чином, в імперативному стилі:</p>
    <pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  var i = 0
  while (i &lt; args.length) {
    println(args(i))
    i += 1
  }
}</pre>
    <p>Ви можете трансформувати цей шматок кода в більш функціональний стиль,
      прибравши var, наприклад, таким чином:</p>
    <pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  for (arg &lt;&lt;- args)<br>    println(arg)
}</pre>
    <p>або так:</p>
    <pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  args.foreach(println)
}</pre>
    <br>
    Цей приклад ілюструє одну перевагу програмування з меньшим числом var.
    Рефакторений (більш функціональний) код більш чистий, більш стислий, та менш
    схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з
    якої Scala заохочує функціональний стиль, фактично, полягає в тому, що
    функціональний стиль може допомогти вам писати більш зрозумілий, менш
    схильний до помилок, код.<br>
    <br>
    Ви можете навіть піти далі. Рефакторений метод printArgs не є повністю
    функціональним, оскільки він має побічний ефект&nbsp; — в цьому випадку його
    побічний ефект є друк в стандартний потік. Натякаюча ознака фукнції з
    побічним ефектом є те, що тип, якій вона повертає, є Unit. Якщо функція не
    повертає ніякого цікавого значення, що саме те, що означає тип Unit, єдиним
    шляхом, яким функція може вплинути на цей світ, є деякий різновид побічного
    ефекту. Більш функціональний підхід може полягати в визначенні методів, що
    форматують передані аргументи для друку, але тільки повертають форматований
    рядок, як показано в Лістингу 3.9:<br>
    <br>
    <pre class="prettyprint linenums language-scala">def formatArgs(args: Array[String]) = args.mkString("\n")</pre>
    <br>
    Лістинг 3.9 Функція без побічних ефектів або var.<br>
    <br>
    Тепер вона дійсно функціональна: не має жодних споминів про побічні ефекти
    або var. Метод mkString, що ви можете викликати на любій ітерабельній
    колекції (включаючи масиви, списки, множини та мапи), повертаючи рядок, що
    складається з результата виклика toString на кожному елементі, розділених
    переданим рядком. Таким чином, якщо args містить три елементи, "zero",
    "one", та "two", formatArgs поверне "zero\none\ntwo". Звичайно, ця функція
    насправді нічого не друкує, як це робив метод printArgs, але ви можете
    просто передати його результат до println, щоб досягти цього:<br>
    <pre class="prettyprint linenums language-scala">println(formatArgs(args))
</pre> <br>
    Здається, кожна корисна програма має мати побічний ефект в деякій формі,
    оскільки інакше вона б не змогла запровадити значення до зовнішнього світу.
    Схиляння до методів без побічних ефектів заохочує вас розробляти програми,
    де код побічних ефектів мінімальний. Однією з переваг цього підходу є те, що
    він може допомогти зробити ваші програми простішими для тестування.
    Наприклад, щоб протестувати любий з трьох методів printArgs, показаних вище
    в цьому розділі, вам треба перевизначити println, захопити вивід кожнього з
    них, та переконатись, що він такий, як ви очікували. На відміну від цього,
    ви можете протестувати функцію formatArgs, просто перевіривши її результат:<br>
    <pre class="prettyprint linenums language-scala">val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")</pre>
    <br>
    Метод Scala assert перевіряє передане Boolean, та якщо це false, підіймає
    AssertionError. Якщо передане Boolean є true, assert просто тихо
    завершується. Ви вивчите більше про допущення в Главі 14.
    <p>Кажучи це, майте на увазі, що ні var, ні побічні ефекти не є злом по
      суті. Scala не є чистою функціональною мовою, що змушує вас програмувати
      все в функціональному стилі. Scala є гіблидною, імперативно/функціональною
      мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще
      пасує до вирішуваних проблем, та в таких випадках ви не повинні вагатись,
      та використосувати його. Однак, щоб допомогти вам програмувати без var, ми
      покажемо багато специфічних прикладів коду з var, та як трансформувати ці
      var в val в Главі 7.</p>
    <p><br>
      <span style="font-weight: bold;">Збалансована настанова для Scala
        програмістів</span></p>
    <p>Схиляйтесь до val, незмінних об'єктів, та методів без побічних ефектів.
      Спочатку опануйте їх. Використовуйте var, змінні об'єкти ти методи з
      побічними ефектами, коли ви маєте особливі потреби, та можете це
      обгрунтувати. </p>
    <h4>Крок 12. Читання рядків з файлу</h4>
    <p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробляти
      рядки в файлах. В цьому розділі ми побудуємо скрипт, що читає рядки з
      файлу, та друкує їх, ставлячи зпереду число символів в кожному рядку.
      Перша версія показана на Лістингу 3.10:</p>
    <pre class="prettyprint linenums language-scala">import scala.io.Source
if (args.length &gt; 0) {
  for ( line &lt;- Source.fromFile(args(0)).getLines())
    println(line.length +" "+ line)
}
else
  Console.err.println("Please enter filename")
</pre>
    <p>Лістинг 3.10 Читання рядків з файла.</p>
    <p>Цей скрипт починається з імпорту класа на ім'я Source з пакунка scala.io.
      Потім він перевіряє, чи вказані додаткові аргументи в командному рядку.
      Якщо це так, перший аргумент інтерпретується як ім'я файла, що треба
      відкрити та обробтити. Вираз Source.fromFile(args(0)) намагається відкрити
      вказаний файл, та повертає об'єкт Source, на якому ви викликаєте. Метод
      getLines повертає Iterator[String], що провадить один рядок за ітерацію,
      за винятком символа нового рядка. Вираз for ітерує по ціх рядках, та
      друкує для кожного довжину рядка, та сам рядок. Якщо немає аргументів,
      наданих в командному рядку, завершальне твердження else буде друкувати
      повідомлення на стандартний вивід помилок. Якщо ви покладете цей код в
      файл з назвою countchars1.scala, та виконаєте його з самим собою:</p>
    <pre class="prettyprint linenums language-scala">$ scala countchars1.scala countchars1.scala</pre>
    <p>Ви побачите:</p>
    <pre class="prettyprint linenums language-scala">22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51&nbsp;&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())
35&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)
1 }
4 else
46 &nbsp; Console.err.println("Please enter filename")</pre>
    <p>Хоча скрипт в його теперішній формі друкує потрібну інформацію, ви можете
      захотіти пронумеровати рядки, зробити праве вирівнювання, та додати символ
      стовпчика, так щоб вивід виглядав замість цього так:</p>
    <p>22 | import scala.io.Source<br>
      0&nbsp;&nbsp; |<br>
      22 | if (args.length &gt; 0) {<br>
      0&nbsp;&nbsp; |<br>
      51 |&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())<br>
      35 |&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)<br>
      1&nbsp;&nbsp; | }<br>
      4&nbsp;&nbsp; | else<br>
      46 |&nbsp;&nbsp; Console.err.println("Please enter filename")</p>
    <p>Щоб досягти цього, вам треба ітерувати по рядках двічі. Перший раз ви
      визначатимите максимальну ширину, потрібну для лічильника символів. Другий
      раз ви будете друкувати вивід, використовуючи максимальну ширину, що була
      обчислена перед цім. Оскільки ви будете ітерувати по рядках двічі, ви
      можете також присвоїти їх до змінної:</p>
    <pre class="prettyprint linenums language-scala">val lines = Source.fromFile(args(0)).getLines().toList</pre>
    <p>Заключний toList потрібен, бо метод getLines повертає ітератор. Коли ви
      проітерували по ітератору, він вичерпався. Трансформуючи його на список
      через виклик toList, ви отримуєте можливість ітерувати стільки разів,
      скільки побажаєте, ціною зберігання всіх рядків з файла в пам'яті,
      одночасно. Змінна lines, таким чином, посилається на список рядків, що
      містить вміст файла, вказаного в командному рядку.</p>
    <p>Далі, оскільки ми будемо обчислювати довжину лічильника символів кожного
      рядка двічі, один раз на ітерацію, ви можете виділити цей вираз в маленьку
      функцію, що обчислює довжину лічильника символів кожного наданого рядка:</p>
    <pre class="prettyprint linenums language-scala">def widthOfLength(s: String) = s.length.toString.length</pre>
    <p>З цією функцією ви можете обчислити максимальну довжину таким чином:</p>
    <pre class="prettyprint linenums language-scala">var maxWidth = 0
for (line &lt;- lines)
  maxWidth = maxWidth.max(widthOfLength(line))</pre>
    <p>Тут ви ітеруєте по кожному рядку за допомогою виразу for, обчислюєте
      довжину символів довжини рядка, та, якщо вона більша, ніж поточний
      максимум, присвоюєте її до maxWidth, var, що була ініціалізована як 0.
      (Метод max, що ви можете викликати для кожного Int, повертає більше
      значення, з того, на якому він викликаний, та того, який йому переданий).
      Альтернативно, якщо ви схильні знайти максимум без var, ви можете спочатку
      знайти найдовший рядок, ось так:</p>
    <pre class="prettyprint linenums language-scala">val longestLine = lines.reduceLeft(
  (a, b) =&gt; if (a.length &gt; b.length) a else b
)</pre>
    <p>Метод reduceLeft застосовує передану функцію до перших двох елементів, та
      потім застосовує її до результату першого застосування, та наступного
      елемента в lines, в так далі, по всьому списку. На кожному такому
      застосуванні результатом буде найдовший зустрічний рядок, оскільки
      передана функція, (a, b) =&gt; if (a.length &gt; b.length) a else b,
      повертає найдовший з двох переданих рядків. "reduceLeft" поверне результат
      останнього застосування функції, що, в цьому випадку, буде найдовшим
      елементом рядка в lines.</p>
    <p>Маючи цей результат, ви можете обчислити максимальну довжину, передаіши
      найдовший рядок до widthOfLength:</p>
    <pre class="prettyprint linenums language-scala">val maxWidth = widthOfLength(longestLine)</pre>
    <p>Все що залишається, це надрукувати рядкі в потрібному форматі. Ви можете
      зробити це так:</p>
    <pre class="prettyprint linenums language-scala">for (line &lt;- lines) {
  val numSpaces = maxWidth - widthOfLength(line)
  val padding = " " * numSpaces
  println(padding + line.length +" | "+ line)
}</pre>
    <p>В цьому прикладі ви ще раз ітеруєте по рядках. Для кожного рядка ви
      спочатку обчислюєте часло проміжків, потрібних перед довжиною рядка, та
      присвоюєте його до numSpaces. Тоді ви створюєте рядок, що містиь numSpaces
      проміжків, за допомогою виразу " " * numSpaces. Нарешті, ви роздруковуєте
      інформацію в бажаному форматі. Цілий скрипт виглядає, як показано в
      Лістингу 3.11:</p>
    <pre class="prettyprint linenums language-scala">import scala.io.Source
def widthOfLength(s: String) = s.length.toString.length
if (args.length &gt; 0) {
  val lines = Source.fromFile(args(0)).getLines().toList
  val longestLine = lines.reduceLeft(
    (a, b) =&gt; if (a.length &gt; b.length) a else b
  )
  val maxWidth = widthOfLength(longestLine)
  for (line &lt;- lines) {
    val numSpaces = maxWidth - widthOfLength(line)
    val padding = " " * numSpaces
    println(padding + line.length +" | "+ line)
}}
else
  Console.err.println("Please enter filename")</pre>
    <p>Лістинг 3.11 Друк форматованих підрахунків символів для рядків з файла.</p>
    <h3>Висновок</h3>
    <p>Зі знанням, що ви набули в цій главі, ви повинні вже бути в змозі
      починати використовувати Scala для малих завдань, особливо скриптів. В
      майбутньому ми заглибимось в більші деталі цієї теми, та введемо інші
      теми, з якими ми навіть не перетинались дотепер.</p>
    <h3>Глава 4</h3>
    <h2>Класи та об'єкти</h2>
    <p>Ви вже бачили основи класів та об'єктів в Scala в попередніх двох главах.
      В цій главі ми підемо трохи глибше. Ви навчитесь більше щодо класів, полів
      та методів, та отримаєте огляд виводу краапки з комою. Ви більше навчитесь
      щодо об'єта-синглтона, включаючи, як їх використовувати для написання та
      виконання застосування Scala. Якщо ви добре знайомі з Java, ви винайдете
      концепції Scala подібними, але не точно такими. Так що, навіть якщо ви є
      Java гуру, варто прочитати це.</p>
    <h3>4.1 Класи, поля і методи</h3>
    <p>Клас є проектом для об'єктів. Коли ви визначаєте клас, ви можете створити
      об'єкти з цього класу-проекту, за допомогою ключового слова new.
      Наприклад, маючи таке визначення класу:</p>
    <pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
// class definition goes here
}</pre>
    <p>Ви можете створити об'єкти ChecksumAccumulator таким чином:</p>
    <pre class="prettyprint linenums language-scala">new ChecksumAccumulator</pre>
    <p>В визначенні класа ви розміщуєте поля та методи, що разом називаються
      членами. Поля, які ви визначаєте або за допомогою val, або var, є
      змінними, що посилаються на об'єкти. Методи, що визначені за допомогою
      def, містять виконавчий код. Поля містять стан, або дані, об'єкта, тоді як
      методи використовують ці дані&nbsp; для виконання обчислювальної роботи
      об'єкта. Коли ви створюєте примірники класу, середа виконання виділяє
      деяку пам'ять, щоб утримувати образ стану цього образу — тобто, вміст його
      змінних. Наприклад, якщо ви визначили клас ChecksumAccumulator, та надали
      йому поле var з назвою sum :</p>
    <pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  var sum = 0
}</pre>
    <p>та потім створили два екземпляри:</p>
    <pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator</pre>
    <br>
    Образ об'єктів в пам'яті може виглядати так:<br>
    <br>
    <br>
    acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0<br>
    csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum <br>
    <br>
    Оскільки sum, поле, задеклароване в класі ChecksumAccumulator, є var, а не
    val, ви можете пізніше переприсвоїти sum інше значення Int, ось так:<br>
    <br>
    acc.sum = 3<br>
    <br>
    Тепер схема виглядатиме так:<br>
    <br>
    acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
    <br>
    Одна річ, що треба зауважити щодо цього малюнка, щоє є дві змінні sum, одна
    в об'єкті, на який посилається acc, та інша, в об'єкті, на який посилається
    csa. Поля також відомі як змінні примірника, оскільки кожний примірник
    отримує власний набір змінних. Всі разом, змінні примірника об'єкта
    складають його образ в пам'яті. Ви можете бачити це, проілюстроване тут, не
    тільки тому, що ви бачите дві змінні sum, але і тому, що коли ви змінюєте
    одну, це не впливає на іншу.
    <p>Інша річ, яку варто зауважити щодо цього прикладу, є те, що ви в змозі
      змінити об'єкт, на який посилається acc, навіть коли acc є val. Що ви не
      зможете робити з acc (або csa ), зважаючи, що це val, а не var, це
      переприсвоїти їм інший об'єкт. Наприклад, наступна спроба не буде
      успішною:</p>
    <pre class="prettyprint linenums language-scala">// Не буде компілюватись, бо  acc є val
acc = new ChecksumAccumulator</pre>
    <p>Таким чином ви можете розраховувати на те, що acc буде завжди посилатись
      на той самий об'єкт ChecksumAccumulator, яким він був ініціалізований, але
      поля цього об'єкта можуть з часом змінюватись.</p>
    <p>Один важливий спосіб досягти стійкості об'єкта - це переконатись, що стан
      об'єкта — значення змінних примірника — залишаються допустимі на протязі
      всього життєвого циклу. Першим кроком є запобігти безпосередньому доступу
      до полів ззовні, зробивши поля приватними. Оскільки приватні поля можуть
      отримати доступ тільки з методів того ж класа, весь код, що може
      оновлювати стан, буде локалізовано в класі. Щоб декларувати приватне поле
      ви розміщуєте модифікатор приватного доступу спереду поля, таким чином:</p>
    <pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
}</pre>
    <p>Маючи таке визначення ChecksumAccumulator, кожне намагання отримати
      доступ до sum ззовні класа буде хибним:</p>
    <pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
acc.sum = 5 // Не буде компілюватись, бо sum приватне</pre>
    <h4>Зауваження</h4>
    <p>Спосіб, як ви робите члени публічними в Scala - це просто не вказувати
      явно модифікатор доступу. Кажучи інакше, коли ви кажете "public" в Java,
      ви просто нічого не кажете в Scala. Публічний доступ стоїть в Scala по
      замовчанню.</p>
    <p>Тепер, коли sum є приватним, єдиний код, що може отримати доступ до sum,
      є код, визначений в тілі самого класа. Таким чином, ChecksumAccumulator не
      може якось використовуватись будь-ким, якщо ми не визначимо в ньому деякі
      методи:</p>
    <pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = {
    sum += b
  }
  def checksum(): Int = {
    return ~ (sum &amp; 0xFF) + 1
  }
}</pre>
    <p>Тепер ChecksumAccumulator має два методи, add та checksum, обоє з яких
      демонструють базову форму визначення функції, показану на Малюнку 2.1.
      Любі параметри метода можуть бути використані в методі. Одна важлива
      характеристика параметрів метода в Scala в тому, що вони є val, не var.
      Таким чином, якщо ви спробуєте перепризначити параметр зсередини метода в
      Scala, це не буде компілюватись:</p>
    <pre class="prettyprint linenums language-scala">def add(b: Byte): Unit = {
  b = 1
// Це не компілюється, оскільки b є val
  sum += b
}</pre>
    <p>Хоча add та checksum в цій версії ChecksumAccumulator коректно реалізують
      бажану функціональність, ви можете виразити їх з використанням більш
      стислого стилю. Перше, return в кінці метода checksum є надлишковим, та
      може бути відкинутий. За відсутності явного твердження return метод Scala
      повертає останнє значення, обчислене методом.</p>
    <p>Рекомендований стиль для методів фактично полягає в тому, щоб уникати
      явних, а тим більше декількох тверджень return. Замість цього думайте про
      кожний метод як про вираз, що видає одне значення, яке потім повертається.
      Ця філософія буде спонукати вас робити методи досить малими, щоб поділяти
      більші методи на декілька меньших. З іншого боку вибір дизайну залежить
      від контексту розробки, та Scala спрощує написання методів, що мають
      декілька явних return, якщо це те, що вам треба.</p>
    <p>Оскількі все, що робить checksum, є обчислення значення, він не потребує
      явного return. Інше скорочення для методів є те, що ви можете вилучити
      фігурні дужки, якщо метод обчислює тільки єдиний вираз результата. Якщо
      отримуваний вираз короткий, він може навіть розташовуватись в тому ж
      рядку, що і сам def. З ціма змінами клас ChecksumAccumulator виглядає
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = sum += b
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
    <p>Методи з типом результата Unit, такі як метод ChecksumAccumulator add,
      виконуються заради своїх побічних ефектів. Побічний ефект загалом
      визначаєтся як зміна стану десь зовні метода, або виконання дії
      ввода-вивода. В випадку add, наприклад, побічний ефект полягає в тому, що
      перепризначується sum. Інший шлях виразити такі методи є відкинути тип
      результата та знак рівності, та замкнути тіло метода в фігурні дужки. В
      цій формі метод виглядає як процедура, тобто метод, що виконуєтся виключно
      для побічних ефектів. Метод add в Лістингу 4.1 ілюструє цей стиль:</p>
    <pre class="prettyprint linenums language-scala">// In file ChecksumAccumulator.scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte) { sum += b }
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
    <p>Лістинг 4.1 Остаточна версія класа ChecksumAccumulator.</p>
    <p>Один підводний камінь, за яким треба слідити, коли опускаєте знак
      рівняння перед тілом функції, це те, що тип її результата в любому випадку
      буде Unit. Це буде так, і не важливо що міститиме тіло, оскікільки
      компілятор Scala може привести кожний тип до Unit. Наприклад, якщо
      результат метода є String, але тип результата метода задекларований як
      Unit, String буде перетворено на Unit, та його значення буде втрачене. Ось
      приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def f(): Unit = "this String gets lost"
f: ()Unit</pre>
    <p>В цьому прикладі String перетворюється на Unit, оскільки Unit є
      задекларованим результатом функції f. Компілятор Scala трактує функцію,
      визначену в процедурному стилі, тобто в фігурних дужках без знака
      рівняння, загалом так само, як функцію, що явно декларує свій тип
      результата як Unit :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def g() { "this String gets lost too" }
g: ()Unit</pre>
    <p>Таким чином, підводний камінь виникає, якщо ви маєте намір повернути
      значення не-Unit, але забули знак рівняння. Щоб отримати те, що ви
      бажаєте, вам треба вставити пропущений знак рівняння:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def h() = { "this String gets returned!" }
h: ()java.lang.String
scala&gt; h
res0: java.lang.String = this String gets returned!</pre>
    <h3>4.2 Виведення крапки з комою</h3>
    <p>В програмі Scala крапка з комою в кінці твердження зазвичай є
      опціональною. Ви можете набирати її, коли бажаєте, але ви не маєте це
      робити, якщо твердження з'являється одне на рядку. З іншого боку крапка з
      комою потрібна, якщо ви записуєте декілька тверджень на одному рядку:</p>
    <pre class="prettyprint linenums language-scala">val s = "hello"; println(s)</pre>
    <p>Якщо ви бажаєте ввести твердження, що продовжується на декілька рядків, в
      більшості випадків ви можете просто ввести його, та Scala розділить
      твердження в потрібних місціях. Наприклад, наступне трактуєтсья як одне
      твердження на чотирьох рядках:</p>
    <pre class="prettyprint linenums language-scala">if (x &lt; 2)
  println("too small")
else
  println("ok")</pre>
    <p>Однак іноді, тим не менш, Scala буде розділяти твердження на дві частини
      супроти вашого бажання:</p>
    <pre class="prettyprint linenums language-scala">x
+ y</pre>
    <p>Це розглядається як два твердження, x та +y . Якщо ви мали на увазі
      розглядати це як одне твердження x + y, ви завжди можете огорнути його в
      дужки:</p>
    <pre class="prettyprint linenums language-scala">(x
+ y)</pre>
    <p>В якості альтернативи ви можете розмістити + в кінці рядка. Само з цієї
      причини, коли ви зціплюєте інфіксні операції, такі як +, є загальним в
      стилі Scala класти оператори в кінці рядка, але не в началі:</p>
    <pre class="prettyprint linenums language-scala">x +
y +
z</pre>
    <h4>Правила виводу крапки з комою</h4>
    <p>Точні правила для розділення тверджень напрочуд прості, щодо того, як
      вони роблять. Коротко кажучи, кінець рядка розглядається як крапка з
      комою, тільки якщо не виконуються наступні умови:</p>
    <p>1. Рядок, що розглядається, закінчується на терм, що не може бути
      легальним в кінці твердження, такий, як кома або інфіксний оператор.</p>
    <p>2. Наступний рядок починається зі слова, що не може починати твердження.</p>
    <p>3. Рядок завершується в дужках (...) або в прямокутних дужках [...],
      оскільки вони в жодному разі не можуть містити декілька тверджень.</p>
    <h3>4.3 Об'єкти-синглтони</h3>
    <p>Як зазначалось в Главі 1, один спосіб, як Scala є більш
      об'єктно-орієнтовною, ніж Java, є те, що класи Scala не можуть мати
      статичних членів. Замість цього Scala має об'єкти-синглтони. Визначення
      об'єкта-синглтона виглядає як визначення класа, за тим виключенням, що
      замість ключового слова class ви використовуєте ключове слово object.
      Лістинг 4.2 показує приклад.</p>
    <pre class="prettyprint linenums language-scala">// В файлі ChecksumAccumulator.scala
import scala.collection.mutable.Map
object ChecksumAccumulator {
  private val cache = Map[String, Int]()
  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c &lt;- s)
        acc.add(c.toByte)
      val cs = acc.checksum()
      cache += (s -&gt; cs)
      cs
    }
}</pre>
    <p>Лістинг 4.2 Об'єкт-компанйон до класа ChecksumAccumulator.</p>
    <p>Створений об'єкт-синглтон називається ChecksumAccumulator, тобто має те ж
      ім'я, що і клас в попередньому прикладі. Коли о'бєкт-синглтон поділяє те ж
      ім'я, що і клас, він називається об'єктом-компанйоном цього класа. Ви
      повинні визначата обоє, клас та його компанйон-об'єкт в тому ж файлі. Клас
      називаєтсья класом-компанйоном об'єкта синглтона. Клас та об'єкт-компанйон
      можуть отримувати доступ до приватних членів один одного. Синглтон-об'єкт
      ChecksumAccumulator має один метод з назвою calculate, що приймає String,
      та обчислює контрольну суму для символів в String. Він також має одне
      приватне поле, змінну мапу, в якій кешуються попередньо обчислені
      контрольні суми. Перший рядок метода, " if (cache.contains(s))", перевіряє
      кеш, щоб побачити, чи переданий рядок вже є як ключ в мапі. Якщо це так,
      він повертає збережене значення з кешу. Інакше він виконує твердження
      else, що обчислює контрольну суму. Перший рядок твердження else визначає
      val на ім'я acc, та ініціалізує її новим примірником ChecksumAccumulator.
      Наступний рядок є вираз for, що в циклі проходить по кожному символу в
      переданому рядку, перетворює символи на Byte, викликаючи toByte, та
      передає це до метода add примірника ChecksumAccumulator, на який
      посилається acc. Після завершення виразу for, наступний рядок метода
      викликає checksum на acc, що повертає контрольну суму для переданого
      String, та зберігає її в val на ім'я cs. В наступному рядку, cache += (s
      -&gt; cs), переданий рядок в якості ключа відображуєтся на ціле значення
      контрольної суми, та ця пара додається до мапи кешу. Останній вираз
      метода, cs, повертає контрольну суму як результат метода.</p>
    <p>Якщо ви Java програміст, ви можете мислити про об'єкти-синглтони як про
      домівку для статичних методів, що ви писали в Java. Ви можете викликати ці
      методи на об'єктах синглтона, використовуючи подібний синтаксис: ім'я
      об'єкта-синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати
      метод calculate об'єкта-синглтона ChecksumAccumulator таким чином:</p>
    <pre class="prettyprint linenums language-scala">ChecksumAccumulator.calculate("Every value is an object.")</pre>
    <p>Об'єкт-синглтон є більше, ніж утримувач для статичних методів. Це
      першокласний об'єкт. Ви можете думати про ім'я об'єкта-синглтона як про
      "тег імені", приєднаний до об'єкта:</p>
    <p>ChecksumAccumulator - - - &gt; cache - - - &gt; змінна мапа<br>
      <br>
      Визначення об'єкта-синглтона не визначає тип (на рівні абстракції Scala).
      Маючи тільки визначення об'єкта ChecksumAccumulator, ви не можете створити
      змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator
      визначений класом-компанйоном об'єкта-синглтона. Однак об'єкти-синглтони
      розширюють суперклас та можуть домішувати трейти. Зважаючи, що кожний
      об'єкт-синглтон є примірником своїх суперкласів та домішаних трейтів, ви
      можете викликати його методи через ці типи, посилаючись на них зі змінних
      ціх типів, та передаючи його до методів, що очікують ці типи. Ми покажемо
      деякі приклади о'бєктів-синглтонів, що походять від класів та трейтів, в
      Главі 13.</p>
    <p>Одна відмінність між класами та об'єктами-синглтонами полягає в тому, що
      ці об'єкти-синглтони не можуть сприймати параметрів, тоді як класи можуть.
      Оскільки ви не можете створити примірник об'єкта-синглтона за допомогою
      ключового слова new, ви не маєте способа передати йому параметри. Кожний
      об'єкт-синглтон реалізований як примірник синтетичного класу, що
      посилається зі статичної змінної, так що вони мають ту ж симантику
      ініціалізації, що і статичні в Java. Зокрема, об'єкт-синглтон
      ініціалізується тоді, коли деякий код вперше отримує до нього доступ. </p>
    <p>Об'єкт-синглтон, що не поділяє те є ім'я з класом-компанйоном, називаєтся
      окремим об'єктом. Ви можете використовувати окремі о'бєкти для багатьох
      цілей, включаючи збирання пов'язаних допоміжних методів разом, або
      визначення точки входу до застосування Scala. Цей випадок використання
      показаний в наступному розділі.</p>
    <h3>4.4 Застосування Scala</h3>
    <p>Щоб виконати програму Scala, ви повинні надати ім'я окремого
      об'єкта-синглтона з методом main, що приймає один параметр, Array[String],
      та має тип результата Unit. Кожний окремий об'єкт з методом main
      відповідної сигнатури може бути використаний як точка входу в ваше
      застосування. Приклад показаний в Лістингу 4.3:</p>
    <pre class="prettyprint linenums language-scala">// В файлі Summer.scala
import ChecksumAccumulator.calculate
object Summer {
  def main(args: Array[String]) {
    for (arg &lt;- args)
      println(arg +": "+ calculate(arg))
  }
}</pre>
    <p>Лістинг 4.3 Застосування Summer.</p>
    <p>Ім'я об'єкта-синглтона в Лістингу 4.3 є Summer. Його метод main ває
      відповідну сигнатуру, так що ви можете використовувати його як
      застосування. Перше твердження в файлі є імпорт метода calculate,
      визначеного в об'єкті ChecksumAccumulator з попереднього приклада. Це
      твердження import дозволяє вам використовувати прості імена методів в
      залишку файла. Тіло метода main просто роздруковує кожний аргумент, та
      контрольну суму для аргумента, розділяючи їх двома крапками.</p>
    <h4>Зауваження</h4>
    <p>Scala неявно імпортує члени пакунків java.lang та scala, так само, як
      члени об'єкта синглтона на ім'я Predef, в кожний початковий файл кода
      Scala. Predef, що знаходиться в пакунку scala, містить багато корисних
      методів. Наприклад, коли ви кажете println в коді Scala, ви насправді
      викликаєте println з Predef. (Predef.println обертається, та викликає
      Console.println, що робить справжню роботу). Коли ви кажете assert, ви
      викликаєте Predef.assert.</p>
    <p>Щоб викликати застосування Summer, розмістіть код з Лістингу 4.3 в файлі
      з назвою Summer.scala. Оскільки Summer використовує ChecksumAccumulator,
      помістіть код для ChecksumAccumulator, обоє, клас, показаний в Лістингу
      4.1, та його об'єкт-компанйон, показаний в Лістингу 4.2, в файл з назвою
      ChecksumAccumulator.scala.</p>
    <p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви
      покладали публічний клас у файл за назвою класа — наприклад, ви кладете
      клас SpeedRacer в файл SpeedRacer.java — в Scala ви можете іменувати файли
      .scala будь-як, як забажаєте, не важливо, які класи Scala або код ви
      розміщуєте в них. Однак, загалом, в випадку не-скриптів, рекомендованим
      стилем іменування файлів є називати їх за ім'ям класа, як це робить в
      Java, так що програмісти можуть більш швидко знаходити класи, переглядаючи
      імена файлів. Це підхід, що ми приймемо для двох файлів нашого приклада,
      Summer.scala та ChecksumAccumulator.scala .</p>
    <p>Ані ChecksumAccumulator.scala, ані Summer.scala не є скриптами, оскільки
      вони закінчуються визначенням. Скрипт, навпаки, повинен завершуватись
      виразом результата. Таким чином, якщо ви спробуєте виконати Summer.scala
      як скрипт, інтерпретатор Scala буде скаржитись, що Summer.scala не
      зваершується заключним виразом (вважаємо, що ви не додали своїх власних
      виразів після визначення о'бєкта Summer). Замість цього вам буде потрібно
      насправді скомпілювати ці файли за допомогою компілятора Scala, та потім
      виконати отримані файли класів. Одним способом зробити це є використання
      scalac, що є основним компілятором Scala, таким чином:</p>
    <pre class="prettyprint linenums language-scala">$ scalac ChecksumAccumulator.scala Summer.scala</pre>
    <p>Це скомпілює ваші файли коду, але може бути помітна затримка перед тим,
      як компіляція завершиться. Причина в тому, що кожного разу, коли
      компілятор стартує, він витрачає час, скануючи вміст jar файлів, та
      роблячи іншу роботу з ініціалізації, перед тим, як він навіть погляне на
      ваші файли, що ви йому надіслали.&nbsp; З цієї причини дистрибутив Scala
      також включає демон компілятора Scala, що називається fsc (fast Scala
      compiler). Ви використовуєте його таким чином:</p>
    <pre class="prettyprint linenums language-scala">$ fsc ChecksumAccumulator.scala Summer.scala</pre>
    <p>Перший раз, коли ви виконуєте fsc, він створить демон локального сервера,
      приєднаний до порта на вашому комп'ютері. Потім він надішле список файлів
      для компіляції демону через порт, і демон буде компілювати ці файли.
      Наступного разу, коли виконуєтсья fsc, демон вже буде працювати, так що
      fsc просто надішле список файлів демону, що беспосередньо скомпілює ці
      файли. Використовуючи fsc, вам треба зачекати, тільки коли Java стартує
      перший раз. Якщо вам колись знадобиться зупинити демон fsc, ви можете
      зробити це командою fsc -shutdown.</p>
    <p>Виконання ціх команд, scalac або fsc, спродукує файли класів Java, що ви
      потім можете виконати через команду scala, ту ж команду, що ви викликали
      інтерпретатор в попередніх прикладах. Однак замість надавати ім'я файла з
      розширенням .scala, що містить код Scala, до інтерпретатора, що ви робили
      в попередньому прикладі, в цьому випадку ви даєте йому ім'я окремого
      об'єкта, що містить метод main відповідної сигнатури. Таким чином, ви
      можете виконати застосування Summer, набравши:</p>
    <pre class="prettyprint linenums language-scala">$ scala Summer of love</pre>
    <p>Ви побачите контрольні суми, роздруковані для двох аргументів командного
      рядка:</p>
    <pre class="prettyprint linenums language-scala">of: -213
love: -182</pre>
    <h3>4.5 Трейт Application</h3>
    <p>Scala провадить трейт scala.Application, що може зберігти деякий набір
      тексту. Хоча ми не охопили все, що вам треба для розуміння, як саме воно
      робить, ми дійшли висновку, що в любому випадку вам треба знати про це
      саме зараз. Лістинг 4.4 показує приклад:</p>
    <pre class="prettyprint linenums language-scala">import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends Application {
  for (season &lt;- List("fall", "winter", "spring"))
    println(season +": "+ calculate(season))
}</pre>
    <p>Лістинг 4.4 Використання трейта Application.</p>
    <p>Щоб використати трейт, ви спочатку пишете "extends Application" після
      імені вашого об'єкта-синглтона. Потім, замість щоб писати метод main, ви
      розташовуєте код, що ви мали б покласти у метод main, напряму між
      фігурними дужками о'бєкта-синглтона. Ось і все. Ви можете скомпілювати та
      виконати це застосування, як і любе інше.</p>
    <p>Спосіб, яким це робить, полягає в тому, що трейт Application декларує
      метод main з відповідною сигнатурою, що наслідує ваш об'єкт-синглтон,
      роблячи його придатним в якості застосування Scala. Код між фігурними
      дужками збирається в первинний конструктор об'єкта-синглтона, та
      виконується, коли об'єкт ініціалізуєтся. Не турбуйтесь, якщо ви не
      розумієте, що все це означає. Все буде пояснене в наступних главах, і поки
      ви зможете використовувати трейт без повного розуміння деталей.</p>
    <p>Наслідування від Application коротше, ніж написання явного метода main,
      але є і деякі обмеження. Перше, ви не можете використовувати цей трейт,
      якщо вам треба доступ до аргументів командного рядка, оскільки масив args
      не доступний. Наприклад, оскільки застосування Summer використовує
      аргументи командного рядка, воно має бути напиисане з явним методом main,
      як показано в Лістингу 4.3. Друге, завдяки деяким обмеженням моделі
      потоків JVM, вам потрібен явний метод main, якщо ваше застосування
      багатопоточне. Нарешті, деякі реалізації JVM не оптимізують код
      ініціалізації об'єкта, що виконується трейтом Application. Так що ви
      повинні наслідувати від Application тільки коли ваша програма відносно
      проста та однопоточна.</p>
    <h4>Висновок</h4>
    <p>Ця глава надала вам основи щодо класів та об'єктів в Scala, та показала,
      як компілювати та виконувати застосування. В наступній главі ви навчитесь
      базовим типум Scala, та як їх використовувать.</p>
    <h3>Глава 5</h3>
    <h2>Базові типи та операції</h2>
    <p>Тепер, коли ми побачили класи та об'єкти в дії, настав гарний час
      поглянути на базові типи та операції Scala більш глибоко. Якщо ви добре
      знайомі з Java, ви будете раді винайти, що базові типи та оператори Java
      мають те ж значення в Scala. Однак є деякі цікаві відмінності, що роблять
      цю главу варту читання, навіть якщо ви досвідчений Java розробник.
      Оскільки деяки з аспектів Scala, охоплені в цій главі, є в основі такі
      самі, як в Java, ми вставили зауваження, що вказують, що Java розробники
      можуть безпечно пропустити, щоб прискорити ваш прогрес. </p>
    <p>В цьому розділі ви отримаєте огляд базових типів Scala, включаючи String
      та значення типів Int, Long, Short, Byte, Float, Double, Char та Boolean.
      Ви навчитесь операціям, які ви можете виконувати з ціма типами, включаючи,
      як робить старшинство операторів в виразах Scala. Ви також навчитесь, як
      неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи
      вам додаткові операції, за межами тих, що підтримуються Java.</p>
    <h3>5.1 Деякі базові типи</h3>
    <p>Декілька фундаментальних типів Scala, разом з диапазонами значень
      примірників ціх типів, яки вони можуть мати, показані в Таблиці 5.1.
      Загалом, типи Byte, Short, Int, Long та Char називають цілими, або
      інтегральними, типами. Інтегральні типи, плюс Float та Double, називають
      числовими типуми. Окрім String, що міститься в пакунку java.lang&nbsp; всі
      з типів, що показані в Таблиці 5.1, є членами пакунку scala. </p>
    <p>Таблиця 5.1 Деякі базові типи</p>
    <table style="width: 672px; height: 142px;" border="0">
      <tbody>
        <tr>
          <td style="width: 142.85px; text-align: center;">
            <h5>Значення типу</h5>
          </td>
          <td style="width: 519.15px; text-align: center;">
            <h5>Диапазон</h5>
          </td>
        </tr>
        <tr>
          <td>Byte<br>
          </td>
          <td>8-біт зі знаком двокомпонентне ціле</td>
        </tr>
        <tr>
          <td>Short</td>
          <td>16-біт зі знаком двокомпонентне ціле</td>
        </tr>
        <tr>
          <td>Int</td>
          <td>32-біт зі знаком двокомпонентне ціле </td>
        </tr>
        <tr>
          <td>Long</td>
          <td>64-біт зі знаком двокомпонентне ціле</td>
        </tr>
        <tr>
          <td>Char</td>
          <td>16-біт деззнаковий символ Unicode</td>
        </tr>
        <tr>
          <td>String</td>
          <td>Послідовність Char</td>
        </tr>
        <tr>
          <td>Float</td>
          <td>32-біт IEEE 754 з плаваючою крапкою одинарної точності</td>
        </tr>
        <tr>
          <td>Double</td>
          <td> 64-біт IEEE 754 з плаваючой крапкою подвійної точності</td>
        </tr>
        <tr>
          <td>Boolean</td>
          <td>true або false</td>
        </tr>
      </tbody>
    </table>
    <p>Наприклад, повне ім'я Int є scala.Int. Однак, зважаючи на те, що всі
      члени пакунку scala та java.lang автоматично імпортується в кожний файл
      Scala, ви можете просто використовувати прості імена (тобто, імена як
      Boolean, Char або String) будь-де.</p>
    <p>Уважні Java розробники помітять, що базові типи Scala мають точно такі ж
      диапазони, що і відповідні типи в Java. Це дозволяє компілятору Scala
      трансформувати в байткодах примірники значення типів Scala, такі як Int
      або Double, в примітивні типи Java.</p>
    <h3>5.2 Літерали</h3>
    <p>Всі базові типи, перелічені в Таблиці 5.1, можуть бути записані за
      допомогою літералів. Літерал є спосіб записати значення-константу напряму
      в коді. </p>
    <h4>Швидке орієнтування для Java програмістів</h4>
    <p>Синтаксис більшості літералів, показаних в цьому розділі, точно таке, як
      в Java, так що якщо ви майстер Java, ви можете безпечно пропустити
      більшість цього розділу. Дві розбіжності, про які вам треба прочитати, є
      літерали Scala для необроблених рядків та символів, що описане десь нижче.</p>
    <h4>Цілі літерали</h4>
    <p>Цілі літерали для типіів Int, Long, Short та Byte, ідуть в трьох формах:
      десятичні, шіснадцятирічні та восьмиричні. Те, як починається літерал,
      визначає його основу. Якщо число починається з 0x або 0X, це
      шіснадцятиричне (основа 16), та може містити символи від 0 до 9, а також
      від A до F, в нижньому або верхньому реєстрі . Деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val hex = 0x5
hex: Int = 5
scala&gt; val hex2 = 0x00FF
hex2: Int = 255
scala&gt; val magic = 0xcafebabe
magic: Int = -889275714</pre>
    <p>Зауважте, що Scala буде завжди друкувати цілі по основі 10, не важливо,
      яку літеральну форму ви використовуєте для ініціалізації. Таким чином,
      інтерпретатор відображує значення змінної hex2, що ви ініціалізували
      літералом 0x00FF, як десятичне 255. (Звичайно, вам не треба сприймати це
      на слово. Гарний спосіб почати відчувати мову є спробувати ці твердження в
      інтерпретаторі по ходу читання цієї глави). Якщо число починається з нуля,
      воно є восьмиричним (основа 8), та може, таким чином, містити цифри від 0
      до 7 . Деякі приклади цього:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val oct = 035
// (35 восьмиричне є 29 десятичне)
oct: Int = 29
scala&gt; val nov = 0777
nov: Int = 511
scala&gt; val dec = 0321
dec: Int = 209</pre>
    <p>Якщо число починається з не-нульової цифри, та&nbsp;не декороване ще
      будь-як, це десятичне (основа 10). Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val dec1 = 31
dec1: Int = 31
scala&gt; val dec2 = 255
dec2: Int = 255
scala&gt; val dec3 = 20
dec3: Int = 20</pre>
    <p>Якщо цілий літерал завершується на L або l, це є Long, інакше це Int.
      Деякі приклади цілих літералів Long:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val prog = 0XCAFEBABEL
prog: Long = 3405691582
scala&gt; val tower = 35L
tower: Long = 35
scala&gt; val of = 31l
of: Long = 31</pre>
    <p>Якщо літерал Int присвоєний типу Short або Byte, літерали трактуються як
      вони б були типу Short або Byte, докі значення літералу належить до
      диапазону цього типу. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val little: Short = 367
little: Short = 367
scala&gt; val littler: Byte = 38
littler: Byte = 38</pre>
    <h4>Літерали з плаваючою крапкою</h4>
    <p>Літерали з плаваючою крапкою зроблені з десятичних цифер, опціонально
      містять десятичну крапку, та опціонально за ними слідує E або e, та
      значення експоненти. Деякі приклади літералів з плаваючою крапкою:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val big = 1.2345
big: Double = 1.2345
scala&gt; val bigger = 1.2345e1
bigger: Double = 12.345
scala&gt; val biggerStill = 123E45
biggerStill: Double = 1.23E47</pre>
    <p>Зауважте, що частина експоненти означає ступінь десяти, на яку
      домножується друга частина. Таким чином, 1.2345e1 є 1.2345 разів по 10, що
      є 12.345. </p>
    <p>Якщо літерал з плаваючою крапкою закінчується на F або f, це є Float,
      інакше це Double. Опціонально, літерали з плаваючою крапкою Double можуть
      завершуватись на D або d. Деякі приклади літералів Float:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val little = 1.2345F
little: Float = 1.2345
scala&gt; val littleBigger = 3e5f
littleBigger: Float = 300000.0</pre>
    <p>Останнє значення, представлене як Double, може приймати ці (та інші)
      форми:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val anotherDouble = 3e5
anotherDouble: Double = 300000.0
scala&gt; val yetAnother = 3e5D
yetAnother: Double = 300000.0</pre>
    <h4>Символьні літерали</h4>
    <p>Character literals are composed of any Unicode character between single<br>
      quotes, such as:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val a = 'A'
a: Char = A</pre>
    <p>На додаток до провадження явного символа між одинарними лапками, ви
      можете надати восьмиричне або шіснадцятиричне число для кодової точки
      символа після зворотньої косої. Восьмиричне число має бути від '\0' до
      '\377'. Наприклад кодова точка Unicode для літери A є восьмиричне 101.
      Таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val c = '\101'
c: Char = A</pre>
    <p>Символьний літерал також може бути наданий як загальний символ Unicode,
      що складається з чотирьох шіснадцятеричних цифер, якім передує \u, як тут:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val d = '\u0041'
d: Char = A
scala&gt; val f = '\u0044'
f: Char = D</pre>
    <p>Фактично, такі символи Unicode можуть з'являтись будь-де в програмі
      Scala. Наприклад, ви можете також записати ідентифікатор таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val B\u0041\u0044 = 1
BAD: Int = 1</pre>
    <p>Ідентифікатор трактується як ідентичний до BAD, результат розширення двох
      символів Unicode в коді нижче. Загалом, це є поганою ідеєю іменувати
      ідентифікатори таким чином, оскільки їх важче читати. скоріше цей
      синтаксис призначений для того, щоб дозволити первинним файлам Scala, що
      містять не-ASCII символи Unicode бути представленими в ASCII.</p>
    Нарешті, є також декілька символьних літералів, представлених спеціальними
    екранованими послідовностями, показаними в Таблиці 5.2. <br>
    <p>Таблиця 5.2 Спеціальні літеральні екрановані послідовності </p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td style="width: 116.817px; text-align: center;">Літерал</td>
          <td style="width: 519.3px; text-align: center; ">Значення</td>
        </tr>
        <tr>
          <td>\n</td>
          <td>новий рядок ( \u000A )</td>
        </tr>
        <tr>
          <td>\b</td>
          <td>забій ( \u0008 )</td>
        </tr>
        <tr>
          <td style="height: 20.35px;">\t</td>
          <td>табуляція ( \u0009 )</td>
        </tr>
        <tr>
          <td>\f</td>
          <td>нова сторінка ( \u000C )</td>
        </tr>
        <tr>
          <td>\r</td>
          <td>на початок рядка ( \u000D )</td>
        </tr>
        <tr>
          <td>\"</td>
          <td>подвійні лапки ( \u0022 )</td>
        </tr>
        <tr>
          <td>\'</td>
          <td>одиночні лапки ( \u0027 )</td>
        </tr>
        <tr>
          <td>\\</td>
          <td>зворотня коса ( \u005C )</td>
        </tr>
      </tbody>
    </table>
    <p>Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val backslash = '\\'
backslash: Char = \</pre>
    <h4>Рядкові літерали</h4>
    <p>Рядкові літерали складаються з символів, оточених подвійними лапками:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val hello = "hello"
hello: java.lang.String = hello</pre>
    <p>Синтаксис символів в лапках є такий же, як і для символьних літералів.
      Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val escapes = "\\\"\'"
escapes: java.lang.String = \"'</pre>
    <p>Оскільки синтаксис для рядків з багатьма екранованими послідовностями або
      для рядків на декількох рядках є незграбним, Scala сключає спеціальний
      синтаксис для чистих рядків. Ви починаєте та закінчуєте чистий рядок
      трьома подвійними лапками поспіль ( """ ). Всередині чистого рядка може
      міститсь будь-що, включаючи повністю довільні символи, включаючи нові
      рядки, знаки лапок та спеціальні символи, зрозуміло, за винятком потрійних
      лапок поспіль. Наприклад, наступна програма роздруковує повідомлення з
      використанням чистого рядка:</p>
    <pre class="prettyprint linenums language-scala">println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")</pre>
    <p>Однак, виконання цього кода не видасть саме того, що було бажано:</p>
    <pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
           Type "HELP" for help.</pre>
    <p>Проблема в тому, що проміжки на початку другого рядка включені в рядок!
      Щоб допомоготи в цій загальній ситуації, ви можете викликати stripMargin
      для рядка. Щоб виконати цей метод, покалдіть символ стовпчика ( | ) на
      початку кожного рядка, та потім викличте stripMargin на цілому рядку:</p>
    <pre class="prettyprint linenums language-scala">println("""|Welcome to Ultamix 3000.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |Type "HELP" for help.""".stripMargin)</pre>
    <p>Тепер код поводиться як було задумано:</p>
    <pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
Type "HELP" for help.</pre>
    <h4>Символічні літерали</h4>
    <p>Символічні літерали записуються як 'ident, де ident може бути любим
      літерно-числовим ідентифікатором. Такі літерали відзеркалюються на
      примірники попередньо визначеного класа scala.Symbol. Точніше,
      літерал&nbsp; 'cymbal буде розширений компілятором до виклику
      метода-фабрики: Symbol("cymbal"). Символічні літерали типово
      використовуються в ситуаціях, коли ви використувуєте просто ідентифікатор
      в динамічно типізованій мові. Наприклад, ви можете побажати визначити
      метод, що оновлює запис в базі даних:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def updateRecordByName(r: Symbol, value: Any) {
// code goes here
}
updateRecordByName: (Symbol,Any):Unit</pre>
    <p>Метод сприймає в якості параметрів символ, що вказує на ім'я запису поля,
      та значення, з яким поле повинне бути оновлене в запису. В динамічно
      типізованих мовах ви можете викликати цю операцію, передавши
      незадекларований ідентифікатор поля до методу, але в Scala це не буде
      компілюватись:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName(favoriteAlbum, "OK Computer")
:6: error: not found: value favoriteAlbum
&nbsp;&nbsp;&nbsp;&nbsp; updateRecordByName(favoriteAlbum, "OK Computer")
&nbsp;&nbsp;&nbsp;&nbsp; ^</pre>
    <p>Замість цього, і при тому майже так же стисло, ви можете передати
      символічний літерал:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName('favoriteAlbum, "OK Computer")</pre>
    <p>С символами немає чого багато робити, окрім з'ясувати його ім'я:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol
scala&gt; s.name
res20: String = aSymbol</pre>
    <p>Інша річ, що варто зауважити, це що символи інтерновані. Якщо ви запишете
      той же літерал двічі, обоє вирази будуть посилатись на той самий об'єкт
      Symbol.</p>
    <h4>Логічні літерали</h4>
    <p>Лолгічний тип Boolean має два літерала, true та false :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val bool = true
bool: Boolean = true
scala&gt; val fool = false
fool: Boolean = false</pre>
    <p>Це все що потрібно знати. Тепер ви, літерально, є експертом в Scala.</p>
    <h3>5.3 Оператори та методи</h3>
    <p>Scala провадить багатий набір операторів для своїх базових типів. Як
      зазначалось в попередніх главах, ці оператори насправді є тільки милим
      синтаксисом для звичайних викликів методів. Наприклад, 1 + 2 насправді
      означає те ж, що і (1).+(2). Іншими словами, клас Int містить метод з
      ім'ям&nbsp; +, що сприймає Int, та повертає Int як результат. Цей метод +
      викликається, коли ви додаєте два Int:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val sum = 1 + 2
// Scala викликає (1).+(2)
sum: Int = 3</pre>
    <p>Щоб самому перевірити це, ви можете записати вираз явно, як виклик
      метода:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val sumMore = (1).+(2)
sumMore: Int = 3</pre>
    <p>Фактично, Int містить декілька перевантажених методів +, що сприймають
      різні типи параметрів. Наприклад, Int має інший метод, також з назвою +,
      що приймає та повертає Long. Якщо ви додасте Long до Int, буде визваний
      цей альтернативний метод +:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val longSum = 1 + 2L
// Scala викликає (1).+(2L)
longSum: Long = 3</pre>
    <p>Символ + є оператором — точніше, інфіксним оператором. Операторна нотація
      не обмежується методами як +, що виглядають як оператори в інших мовах. Ви
      можете використовувати любий метод в операторній нотації. Наприклад, клас
      String має метод indexOf, що приймає один параметр Char. Метод indexOf
      шукає перше входження вказаного символу в рядку, та повертає його індекс,
      або -1, якщо він не може знайти символ. Ви можете використовувати indexOf
      як оператор, таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s indexOf 'o'
// Scala викликає s.indexOf(’o’)
res0: Int = 4</pre>
    <p>На додаток String пропонує перевантажений метод indexOf, що приймає два
      параметри, символ, що треба шукати, та індекс, з якого потрібно починати
      пошук. (Інший метод indexOf, показаний раніше, починає з індекса ноль,
      тобто, з початку String). Навіть не зважаючи, що цей метод indexOf приймає
      два аргументи, ви можете використовувати його в операторній нотації. Але
      коли ви викликаєте метод, що приймає декілька аргументів, використовуючи
      операторну нотацію, ви маєте покласти ці аргументи в дужки. Наприклад, ось
      як ви використовуєте цю іншу форму indexOf як оператор (продовження
      попереднього приклада):</p>
    <pre class="prettyprint linenums language-scala">scala&gt; s indexOf ('o', 5) // Scala викликає s.indexOf(’o’, 5)
res1: Int = 8</pre>
    <h4>Кожний метод є оператором</h4>
    <p>В Scala оператори не є окремим синтаксисом мови: кожний метод може бути
      оператором. Що робить метод оператором, це те, як ви його використовуєте.
      Коли в и пишете " s.indexOf('o') ", indexOf не є оператором. Але коли ви
      пишете " s indexOf 'o' ", indexOf є оператором, тому що ви використовуєте
      його в операторній нотації.</p>
    <p>До сих пір ви бачили приклади операторів в інфіксній нотації, що означає,
      що метод сидить між об'єктом, та параметром або параметрами, що ви бажаєте
      передати в метод, як в " 7 + 2 ". Scala також має інші операторні нотації:
      префіксну та постфіксну. В префіксній нотації ви ставите ім'я метода перед
      об'єктом, на якому ви виконуєте метод, наприклад, ‘ - ’ в -7. В
      постфіксній нотації ви ставите метод після об'єкта, наприклад, " toLong "
      в "7 toLong ".</p>
    <p>На відміну від інфіксної операторної нотації — в якій оператори мають два
      операнди, один зліва та інший зправа — префіксні та постфіксні оператори є
      унарними: вони сприймають тільки один операнд. В префіксній нотації
      операнд є справа від оператора. Деякі приклади префіксних операторів
      є&nbsp; -2.0, !found, та ~0xFF. Як і з інфіксними операторами, ці
      префіксні оператори є скороченим шляхом виклику методів. Однак в цьому
      випадку ім'я метода має "unary_" перед символом оператора. Наприклад,
      Scala трансформує вираз -2.0 в виклик метода "(2.0).unary_-". Ви можете
      продемонструмати це собі, набравши виклик метода через операторну нотацію,
      та напряму:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; -2.0
// Scala викликає (2.0).unary_-
res2: Double = -2.0
scala&gt; (2.0).unary_-
res3: Double = -2.0</pre>
    <p>Єдині ідентифікатори, що можуть бути використані як префіксні оператори,
      це +, -, ! та ~. Таким чином, якщо ви визначаєте метод на ім'я unary_!, ви
      можете викликати цей метод на значенні або на змінній відповідного типу з
      використанням префіксної операторної нотації, такої, як !p. Але якщо ви
      визначите метод з назвою unary_*, ви не будете в змозі використовувати
      префіксну операторну нотацію, оскільки * не є одним з чотирьох
      ідентифікаторів, що можуть бути використані як префіксні оператори. Ви
      можете викликати метод звичаним чином, як p.unary_*, яле якщо ви спробуєте
      викликати його через *p, Scala розбере це як би ви написали *.p, що,
      можливо, не те, що ви мали на увазі!</p>
    <p>Постфіксні оператори є методами, що не приймають аргументів, коли вони
      викликаються без клапки або дужок. В Scala ви можете відкинути пусті дужки
      на викликах методів. За домовленістю ви включаєте дужки, якщо метод має
      побічні ефекти, такі, як println(), але ви можете відкинути їх, якщо метод
      не має побічних ефектів, як в toLowerCase, викликаному на String:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s.toLowerCase
res4: java.lang.String = hello, world!</pre>
    <p>В цьому останньому випадку методу, що не потребує аргументів, ви можете
      альтернативно відкинути крапку, та використовувати постфіксну операторну
      нотацію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; s toLowerCase
res5: java.lang.String = hello, world!</pre>
    <p>В цьому випадку toLowerCase використовується як постфіксний оператор на
      операнді s. Таким чином, щоб побачити, які оператори ви можете
      використовувати з базовими типуми Scala, все що вам потрібно, це
      подивитись на методи, задекларовані в класах типів в документації Scala
      API. Однак приймаючи до уваги, що це Scala туторіал, ми зробимо швидкий
      тур по більшості з ціх методів в декількох наступних розділах.</p>
    <h4>Швидке орієнтування для Java програмістів</h4>
    <p>Багато аспектів Scala, описаних в залишку цієї глави такі ж самі, що і в
      Java. Якщо ви є Java гуру, що поспішає, ви можете безпечно пропустити все
      до Розділу 5.7, що описує, як Scala відрізняється від Java стосовно
      рівності об'єктів.</p>
    <h3>5.4 Алгебраїчні оператори</h3>
    <p>Ви можете визивати алгебраїчні методи через інфіксну операторну нотацію
      для додавання ( + ), віднімання ( - ), множення ( * ), ділення ( / ), та
      отримання залишку (%), на любому числовому типі. Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1.2 + 2.3
res6: Double = 3.5
scala&gt; 3 - 1
res7: Int = 2
scala&gt; 'b' - 'a'
res8: Int = 1
scala&gt; 2L * 3L
res9: Long = 6
scala&gt; 11 / 4
res10: Int = 2
scala&gt; 11 % 4
res11: Int = 3
scala&gt; 11.0f / 4.0f
res12: Float = 2.75
scala&gt; 11.0 % 4.0
res13: Double = 3.0</pre>
    <p>Коли обоє, лівий та правий операнди є цілими (інтегральними) типами (
      Int, Long, Byte, Short або Char), оператор / буде повертати цілу частину
      без залишку. Оператор % вказує залошок від цілого ділення. Залишок з
      плаваючою крапкою, отриманий за допомогою %, не є таким, що визначений в
      стандарті IEEE 754. Залишок IEEE 754 використовує округлене ділення, не
      ділення з відкиданням при обчисленні залишку, так що це досить різне з
      операцією знаходження цілого залишку. Якщо ви дійсно бажаєте залишок IEEE
      754, ви можете викликати IEEEremainder зі scala.math:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0</pre>
    <p>Числові типи також пропонують унарні префіксні оператори + (метод
      unary_+), та - (метод unary_- ), що дозволяє вам вказувати літеральні
      числа як позитивні або негативні, як -3 або +4.0. Якщо ви не вкажете
      унарний + або -, літеральне число розглядається як позитивне. Унарний +
      існує виключно для симетрії з унарним -, але не має ефекту. Унарний -
      також може використовуватись для обернення змінної. Ось приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val neg = 1 + -3
neg: Int = -2
scala&gt; val y = +3
y: Int = 3
scala&gt; -neg
res15: Int = 2</pre>
    <h3>5.5 Операції відношення та логічні операції</h3>
    <p>Ви можете порівняти числові типи за допомогою методів відношення: бульше
      ніж ( &gt; ), меньше ніж ( &lt; ), більше або дорівнює ( &gt;= ), та
      меньше або дорівнює ( &lt;= ), що дає логічній результат типу Boolean. На
      додаток ви можете використовувати унарний оператор ‘ ! ’ (метод unary_!)
      для обернення значення Boolean. Ось декілька прикладів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1 &gt; 2
res16: Boolean = false
scala&gt; 1 &lt; 2
res17: Boolean = true
scala&gt; 1.0 &lt;= 1.0
res18: Boolean = true
scala&gt; 3.5f &gt;= 3.6f
res19: Boolean = false
scala&gt; 'a' &gt;= 'A'
res20: Boolean = true
scala&gt; val thisIsBoring = !true
thisIsBoring: Boolean = false
scala&gt; !thisIsBoring<br>res21: Boolean = true</pre>
    <p>Логічні методи, ТА ( &amp;&amp; ) та АБО ( || ), приймають операнди
      Boolean в інфіксній нотації, та дають результат Boolean. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val toBe = true
toBe: Boolean = true
scala&gt; val question = toBe || !toBe
question: Boolean = true
scala&gt; val paradox = toBe &amp;&amp; !toBe
paradox: Boolean = false</pre>
    <p>Логічні операції ТА та АБО обчислюються за скороченою схемою, як в Java:
      вирази, побудовані з ціх операторів, обчислюються тільки доти, доки треба
      для визначення результата. Іншими словами, права сторона виразу логічного
      ТА, та логічного АБО не буде обчислюватись, якщо ліва сторона визначає
      результат. Наприклад, якщо ліва сторона логічного виразу ТА обчислюється
      як false, результат виразу буде однозначно false, так що права сторона не
      буде обчислюватись. Подібно, якщо ліва сторона логічного АБО обчислюється
      як true, результат виразу буде однозначно true, так що права сторона не
      обчислюється. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def salt() = { println("salt"); false }
salt: ()Boolean
scala&gt; def pepper() = { println("pepper"); true }
pepper: ()Boolean
scala&gt; pepper() &amp;&amp; salt()
pepper
salt
res22: Boolean = false
scala&gt; salt() &amp;&amp; pepper()
salt
res23: Boolean = false</pre>
    <p>В першому виразі викликаються pepper та salt, але в другому викликається
      тільки salt. Зважаючи, що salt повертає false, немає потреби викликати
      pepper.</p>
    <h4>Зауваження</h4>
    <p>Ви можете здивуватись, як коротке обчислення може робити, якщо оператори
      є тільки методами. Звичайно, всі аргументи обчислюються до входу в метод,
      то як може метод уникнути обчислення другого аргументу? Відповідь в тому,
      що всі методи Scala мають змогу відкласти обчислення своїх аргументів, або
      навіть зовсім відмовитись від їх обчислення. Ця можливість названа
      викликом параметрів за ім'ям, та обговорюється в Розділі 9.5.</p>
    <h3>5.6 Побітові операції</h3>
    <p>Scala дозволяє вам виконувати операції на окремих бітах цілих типів, за
      допомогою декількох побітових методів. Побітові методи такі: побітове-ТА (
      &amp; ), побітове-АБО ( | ), та побітове-АБО_НІ ( ˆ ). Унарний оператор
      доповнення НІ ( ~, метод unary_ ~ ), інвертує кожний біт в операнді.
      Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1 &amp; 2
res24: Int = 0
scala&gt; 1 | 2
res25: Int = 3
scala&gt; 1 ˆ 3
res26: Int = 2
scala&gt; ~ 1
res27: Int = -2</pre>
    <p>Перший вираз, 1 &amp; 2, робить побітове-ТА кожного біта 1 (0001) та 2
      (0010), що дає 0 (0000). Другий вираз, 1 | 2, робить побітове-АБО кожного
      біта тих самих операндів, що дає 3 (0011). Третій вираз, 1 ˆ 3, робить
      побітове-АБО_НІ кожного біта 1 (0001) та 3 (0011), що дає 2 (0010).
      Останній вираз, ~ 1, інвертує кожний біт 1 (0001), даючи -2, що в двоїчній
      системі виглядає як&nbsp;11111111111111111111111111111110.</p>
    <p>Цілі типи Scala також пропонують три методи зсувів: зсув вліво ( &lt;&lt;
      ), зсув вправо ( &gt;&gt; ), та беззнаковий зсув вправо ( &gt;&gt;&gt; ).
      Методи зсувів, коли використовуються в інфіксній операторній нотації,
      зсувають ціле значення зліва операнда на число біт, вказане цілим числом
      зправа. Зсув вліво та беззнаковий зсув вправо заповнюють біти нулями по
      мірі зсуву. Зсув вправо заповнює старший біт (знаковий біт) значенням
      самого лівого біта по мірі зсуву. Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; -1 &gt;&gt; 31
res28: Int = -1
scala&gt; -1 &gt;&gt;&gt; 31
res29: Int = 1
scala&gt; 1 &lt;&lt; 2
res30: Int = 4</pre>
    <p>-1 в двоїчній системі буде 11111111111111111111111111111111. В першому
      прикладі -1 &gt;&gt; 31, -1 зсувається вправо на 31 бітових позицій.
      Оскільки Int має 32 біти, ця операція ефективно пересуває самий лівий біт,
      доки він не стане самим правим. Оскільки метод &gt;&gt; заповню одиницями
      по мірі зсуву вправо, бо найлівішій біт -1 є 1, результат ідентичний до
      оригінального операнад, 32 біт одиниць, або -1. В другому прикладі&nbsp;
      -1 &gt;&gt;&gt; 31, найлівіший біт знову зсувається вправо, доки не стане
      самим правим, але цього разу заповнення іде нулями. Таким чином цього разу
      отримаємо двоїчне 00000000000000000000000000000001, або 1. В останньому
      прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на дві позиції
      (та заповнює нулями), даючи двоїчне 00000000000000000000000000000100, або
      4.</p>
    <h3>5.7 Рівність об'єктів</h3>
    <p>Якщо ви бажаєте порівняти два об'єкти на рівність, ви можете
      використовувати або ==, або його протилежність, !=. Ось декілька
      прикладів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1 == 2
res31: Boolean = false
scala&gt; 1 != 2
res32: Boolean = true
scala&gt; 2 == 2
res33: Boolean = true</pre>
    <p>Ці оператори насправді стосуються до всіх об'єктів, не тільки до базових
      типів. Наприклад, ви можете використовувати == для порівняння списків:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true
scala&gt; List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false</pre>
    <p>Ідучі далі, ви можете порівняти два об'єти, що мають різні типи:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 1 == 1.0
res36: Boolean = true
scala&gt; List(1, 2, 3) == "hello"
res37: Boolean = false</pre>
    <p>Ви можете порівняти навіть з null, або з речами, що можуть бути null.
      Виключення не виникне:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == null
res38: Boolean = false
scala&gt; null == List(1, 2, 3)
res39: Boolean = false</pre>
    <p>Як ви бачите, == було змайстровано на славу, так що якщо вам треба
      порівняння на еквівалентність, ви отримаєте його в більшості випадків. Це
      досягається за допомогою дуже простого правила: зпершу перевіряєтося права
      частина на null, та якщо це не null, викликається метод equals. Оскільки
      equals є методом, точне порівняння, що ви отримаєте, залежить від типу
      аргументу з лівої сторони. Оскількі існує автоматична перевірка на null,
      ви на маєте робити це самому.</p>
    <p>Цей тип порівняння даватиме true на різних об'єктах, доки їх вміст той же
      самий, та їхній метод equals написаний так, щоб базуватись на вмісті.
      Наприклад, ось порівняння двох рядків, що мають ті ж самі&nbsp; п'ять
      літер:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; ("he"+"llo") == "hello"
res40: Boolean = true</pre>
    <h4>Як Scala == відрізняється від Java</h4>
    <p>В Java ви можете використовувати == для порівняння обох, примітивних та
      об'єктних типів. На примітивних типух Java == порівнює еквівалентність
      значень, як і в Scala. Однак, на об'єктних типух, Java == порівнює
      еквівалентність посилань, що означає, що дві змінні вказують на той же
      об'єкт в купі JVM. Scala також провадить здатність порівнювати
      еквівалентність посилань, під ім'ям eq. Однак, eq, та його антонім, ne,
      стосуються тільки до об'єктів, що напряму відзеркалюються на Java об'єкти.
      Всі деталі щодо eq та ne надані в Розділах 11.1 та 11.2. Також дивіться
      Главу 30, щодо того, як писати гарні методи equals.</p>
    <h3>5.8 Преоритети на асоціативність операторів</h3>
    <p>Преоритетність операторів визначає, які частини виразу обчислюються перед
      іншими чистинами. Наприклад, вираз 2 + 2 * 7 обчислюється до 16, не до 28,
      оскільки оператор * має вищий преоритет, ніж оператор +. Таким чином,
      частина виразу множення обчислюється перед додаванням. Ви можете,
      звичайно, використовувати дужки для прояснення порядку обчислення, або для
      зміни преоритетності. Наприклад, якщо ви дійсно бажаєте, щоб результат
      обчислень виразу вище склав 28, ви можете записати вираз таким чином:</p>
    <pre class="prettyprint linenums language-scala">(2 + 2) * 7</pre>
    <p>Зважаючи на те, що Scala не має операторів, як таких, та тільки методіи в
      операторній нотації, ви можете здивуватись, як робить преоритетність
      операторів. Scala визначає преоритет на основі першого символа метода, що
      використовується в операторній нотації (є одне виключення з цього правила,
      що буде обговорене нижче). Якщо ім'я починається на *, наприклад, воно
      буде мати більший преоритет, ніж метод, що починається на + .Таким чином,
      2 + 2 * 7 буде обчислюватись як 2 + (2 * 7), та +++ b *** c (де a, b, c є
      змінними, а +++ та *** є методами) буде обчислюватись як a +++ (b *** c),
      оскільки метод *** має вищий преоритет, ніж метод +++.</p>
    <p>Таблиця 5.3 Преоритети операторів</p>
    <table style="width: 100%" border="1">
      <tbody>
        <tr>
          <td>(інші спец.символи)</td>
          <td>*/% </td>
          <td> +-</td>
          <td> :</td>
          <td>=!</td>
          <td>&lt;&gt;</td>
          <td>&amp;</td>
          <td>ˆ</td>
          <td> |</td>
          <td>(всі літери)</td>
          <td>(всі присвоєння)</td>
          <td><br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>Таблиця 5.3 показує преоритетність на основі першого символа метода, в
      порядку зменшення преоритета, де згруповані разом оператори мають
      однаковий преоритет. Чим лівіший символ в таблиці, тим вищий преоритет
      методів, що починається з цього символа. Ось приклад, що ілюструє вплив
      преоритетів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 2 &lt;&lt; 2 + 2
res41: Int = 32</pre>
    <p>Метод &lt;&lt; починається з символа &lt;, що виявляється нижче за
      преоритетом, ніж символ +, що є першим та єдиним символом метода +. Таким
      чином &lt;&lt; буде мати нижчий преоритет, ніж +, та вираз буде
      обчислюватись, спочатку викликаючи метод +, ніж метод &lt;&lt;, як в <br>
      2 &lt;&lt; (2 + 2) . За нашими підрахунками 2 + 2 є 4, та 2 &lt;&lt; 4 дає
      32. Ось інший приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 2 + 2 &lt;&lt; 2
res42: Int = 16</pre>
    <p>Оскільки перші символи такі ж самі, як і в попередньому прикладі, методи
      будуть викликатись в тому ж порядку. Перший буде викликаний метод +, потім
      метод &lt;&lt;. Так що 2 + 2 знову дає 4, та 4 &lt;&lt; 2 буде 16. </p>
    <p>Одним виключенням до правила преоритетів, що озвучені вище, стосуєтсья
      операторів присвоєння, що закінчуються на символ знака рівності&nbsp; (=),
      та це не один з операторів порівняння &lt;=, &gt;=, ==, або !=. Тоді
      преоритет оператора той самий, що і простого присвоєння (=). Тобто, воно
      менше, ніж преоритет любого іншого оператора. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">x *= y + 1</pre>
    <p>означає те саме, що і:</p>
    <pre class="prettyprint linenums language-scala">x *= (y + 1)</pre>
    <p>оскільки *= класифікується як оператор присвоєння, чий преоритет ніжчий,
      ніж +, не зважаючи, що перший символ оператора є *, що вказує на більший
      преоритет, ніж у +.</p>
    <p>Коли декілька операторів з однаковим преоритетом з'являють пліч-о-пліч у
      виразі, тоді групування операторів визначається асоциативністю.
      Асоциативність операторів визначається останнім символом. Як зазначалось в
      Главі 3, якщо метод завершується на символ ‘:’, він викликається на
      правому операнді, передаючи лівий операнд. Методи, що закінчуються на
      любий інший символ, роблять все навпаки. Вони викликаються на лівому
      операнді, передаючи правий операнд. Так що a * b дає a.*(b), але a ::: b
      дає b.:::(a) .</p>
    <p>Однак не важливо, що за асоціативність в операторів, та їх операнди
      завжди обчислюються зліва направо. Так що якщо вираз, що не є простим
      посиланням на незмінне значення, тоді a ::: b більш точно трактується як
      наступний блок:</p>
    <pre class="prettyprint linenums language-scala">{ val x = a; b.:::(x) }</pre>
    <p>В цьому блоці a все ще обчислюється перед b, та потім результат цього
      обчислення передається як операнд в метод b :::.</p>
    <p>Це правило асоціативності також грає роль, коли декілька операторів тієї
      ж процедури стоять поряд. Якщо метод завершується на ‘:’, вони групуються
      зправа наліво; інакше, вони групуються зліва направо. Наприклад, a ::: b
      ::: c трактується як a ::: (b ::: c). Але a * b * c, навпаки, трактується
      як (a * b) * c.</p>
    <p>Преоритети операторів є частиною мови Scala. Вам не треба боятися
      використовувати їх. Тим не менш є гарним стилем використовувати дужки для
      прояснення, які операнди оперують з якими виразами. Можливо, єдиний
      преоритет, на який ви можете розраховувати, що його без підказок розуміють
      інші розробники, це преоритет мультиплікативних операторів: *, /, %, над
      аддитивними + та&nbsp; -. Таким чином, навіть якщо вам зрозуміло, що a + b
      &lt;&lt; c дає потрібний результат без дужок, додаткова ясність від
      написання (a + b) &lt;&lt; c може зменшити частоту, з якою ваші колеги
      будуть споминати ваше ім'я в операторній нотації, наприклад, плюючи з
      огидою, "bills !*&amp;ˆ % ~ code!".</p>
    <h3>5.9 Збагачені огортки</h3>
    <p>Ви можете викликати значно більше методів на базових типах Scala, ніж
      описано в попередніх розділах. Декілька прикладів надаються в Таблиці 5.4.</p>
    <p>Таблиця 5.4 Деякі збагачені операції </p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td style="text-align: center;">Код</td>
          <td style="text-align: center;">Результат</td>
        </tr>
        <tr>
          <td>0 max 5</td>
          <td>5</td>
        </tr>
        <tr>
          <td>0 min 5</td>
          <td>0</td>
        </tr>
        <tr>
          <td>-2.7 abs</td>
          <td>2.7</td>
        </tr>
        <tr>
          <td>-2.7 round</td>
          <td>-3L</td>
        </tr>
        <tr>
          <td>1.5 isInfinity</td>
          <td>false</td>
        </tr>
        <tr>
          <td>(1.0 / 0) isInfinity</td>
          <td>true</td>
        </tr>
        <tr>
          <td>4 to 6</td>
          <td>Range(4, 5, 6)</td>
        </tr>
        <tr>
          <td>"bob" capitalize</td>
          <td>"Bob"</td>
        </tr>
        <tr>
          <td>"robert" drop 2 5</td>
          <td>"bert"</td>
        </tr>
      </tbody>
    </table>
    <br>
    Ці методи також доступні через неявні приведення типів, прийом, що буде
    детально описаний в Главі 21. Все що вам треба знати, це що для кожного
    базового типу, описаного в цій главі, є також "збагачена огортка", що
    провадить декілька додаткових методів. Таким чином, щоб побачити всі
    доступні методи для базових типів, ви маєте поглянути на документацію API до
    збагаченого типу кожного базового типу. Ці класи перелічені в Таблиці 5.5.<br>
    <br>
    Таблиця 5.5 Збагачені класи-огортки<br>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td style="text-align: center;">Базовий тип</td>
          <td style="text-align: center;">Збагачена огортка</td>
        </tr>
        <tr>
          <td>Byte</td>
          <td>scala.runtime.RichByte</td>
        </tr>
        <tr>
          <td>Short</td>
          <td>scala.runtime.RichShort</td>
        </tr>
        <tr>
          <td>Int</td>
          <td>scala.runtime.RichInt</td>
        </tr>
        <tr>
          <td>Char</td>
          <td>scala.runtime.RichChar</td>
        </tr>
        <tr>
          <td>Float</td>
          <td>scala.runtime.RichFloat</td>
        </tr>
        <tr>
          <td>Double</td>
          <td>scala.runtime.RichDouble</td>
        </tr>
        <tr>
          <td>Boolean</td>
          <td>scala.runtime.RichBoolean</td>
        </tr>
        <tr>
          <td>String </td>
          <td>scala.collection.immutable.StringOps</td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3>5.10 Висновок</h3>
    <p>Головне, що треба взяти з цієї глави, це те, що оператори в Scala є
      викликами методів, та існують неявні перетворення до збагачених варіантів
      для базових типів Scala, що додає навіть більше корисних методів. В
      наступній главі ми покажемо вам, що означає розробляти об'єкти в
      функціональному стилі, та як це дає нові реалізації деяких з операторів,
      що ми бачили в цій главі. </p>
    <h3>Глава 6</h3>
    <h2>Функціональні об'єкти</h2>
    <p>З розумінням основ Scala, які ви отримали в попередніх главах, ви вже
      готові побачити, як розробляти більш дієздатні класи в Scala. Наголос в
      цій главі стоїть на класах, що визначають функціональні об'єкти, тобто,
      об'єкти, що не мають жодного змінного стану. В якості нагального прикладу
      ми створимо клас, що моделює раціональні числа, як незмінні об'єкти. По
      ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного
      програмування в Scala: параметри та конструктори класів, перевизначиття,
      перевірку передумов, перевантаження та посилання на себе.</p>
    <h3>6.1 Специфікація класу Rational</h3>
    <p>Раціональне число є таким, що може бути виражене як відношення d/n, де n
      та d є цілими, за тим винятком, що d не може бути нулем. n називається
      чисельником, d називаєтсья знаменником. Прикладами раціональних чисел є
      1/2, 2/3, 112/239, та 2/1.</p>
    <p>В порівнянні з числами з плававючою крапкою, раціональні числа мають
      перевагу в тому, що дріб представлена точно, без округлень та
      апроксимації. Клас, що ми розробляємо в цій главі повинен моделювати
      поведінку раціонального числа, включаючи додавання, відіймання, множення
      та ділення. Щоб додати два раціональні числа спочатку вам треба знайти
      загальний дільник, та потів додати два чисельника. Наприклад, щоб додати
      1/2 + 2/3, ви множите обі частини лівого операнда на 3, та обі частини
      правого операнда на 2, що дає 3/6 + 4/6. Додавання двох чисельників дає
      7/6. Щоб помножити два раціональні числа, ви просто множите чисельники та
      знаменники. Таким чином, 2/1 ∗ 2/5 дає 2/10, що може бути представлене
      більш компактно в "нормалізованій" формі як 5/1. Ви ділите, переставляючи
      чисельник та займенник правого операнда, та поті виконуючи множення.
      Наприклад, 1/2 / 3/5 те ж саме, що і 1/2 ∗ 5/3, або 6/5.</p>
    <p>Одне, можливо досить тривіальне, дослідження цієї метаматики, дає те, що
      раціональні числа не мають змінного стану. Ви можете додати одне
      раціональне до іншого, але результат буде новим раціональним числом.
      Оригінальні числа не будуть "змінені". Незмінний клас Rational, що ми
      розробляємо в цій главі, буде мати ті ж властивості. Кожне раціональне
      число буде представлене одним об'єктом Rational. Коли ви додаєте два
      об'єкта Rational, ви створюєте новий об'єкт Rational, що міститиме суму.</p>
    <p>Ця глава дасть вам побіжне враження щодо шляхів, як Scala дозволяє вам
      писати бібліотеки, що виглядають як природна підтримка мови. Наприклад,
      наприкінці цієї глави ви будете в змозі зробити наступне з класом Rational
      :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/42</pre>
    <h3>6.2 Побудова Rational</h3>
    <p>Гарним місцем для початку розробки класа Rational є прийняти рішення, як
      програмісти клієнтів будуть створювати новий об'єкт Rational. Приймаючи до
      уваги, що ми прийняли незмінність об'єктів Rational, нам буде треба, щоб
      клієнти провадили всі дані, потрібні для примірника (в цьому випадку
      чисельник да займенник) при створенні примірника. Таким чином, ми почнемо
      розробляти з такого:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int)</pre>
    <p>Одна з перших речей, що треба зазначити щодо цього рядка кода, це те, що
      якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча
      ви можете, звичайно, якщо бажаєте). Ідентифікатори n та d в дужках після
      імені класа Rational, називаються параметрами класа. Компілятор Scala
      збере ці два параметри класа, та створить первинний конструктор, що
      приймає саме два параметри.</p>
    <h4>Недоліки незмінних об'єктів</h4>
    <p>Незмінні об'єкти пропонують декілька переваг над змінними об'єктами, та
      один потенційний недолік. Перше, незмінні об'єкти часто простіші до
      промислення, ніж змінні, оскільки вони не мають складних просторів стану,
      що змінюється з часом. Друге, ви можете передавати незмінні об'єкти
      будь-куди досить вільно, тоді як вам може знадобитись захисні копії
      змінних об'єктів перед передачею їх в інший код. Третє, немає способу для
      двох потоків конкурентно мати доступ до незмінного об'єкту, щоб зіпсувати
      його стан після того, як він був відповідно сконструйований, оскільки
      жодний потік не може змінити стан незмінного. Четверте, незмінні об'єкти
      роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт змінюється після
      того, як він покладений, наприклад, в HashSet, цей об'єкт може бути не
      знайдений наступного разу, коли ви будете його шукати в HashSet .</p>
    <p>Головний недолік незмінних об'єктів в тому, що вони часом потребують
      копіювання великого об'єктного графу, там, де в іншому випадку може
      знадобитись тільки оновлення на місці. В деяких випадках це може бути
      незграбним під час реалізації, та також може призвести до вузьких місць
      продуктивності. Як результат, не є незвичним для бібліотек провадити
      змінні альтернативи до незмінних класів. Наприклад, клас StringBuilder є
      змінною альтернативою до незмінного String. Ми надамо вам більше
      інформації щодо розробки змінних об'єктів в Scala в Главі 18.</p>
    <h4>Зауваження</h4>
    <p>Цей початковий приклад Rational підкреслює різницю між Java та Scala. В
      Java класи мають конструктори, що можуть мати параметри, тоді як в Scala
      класи можуть приймати параметри напряму. Нотація Scala є більш стислою —
      параметри класа можуть використовуватись напряму в тілі класів; немає
      потреби визначати поля та писати присвоєння, що копіюють параметри
      конструктора в поля. Це може дати значні збереження в шаблонному коді,
      особливо для малих класів.</p>
    <p>Компілятор Scala буде компілювати любий код, що ви розмістите в тілі
      класа, що не є частиною визначення поля або метода в первинний
      конструктор. Наприклад, ви можете надрукувати повідомлення таким чином:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  println("Created "+ n +"/"+ d)
}</pre>
    <p>Маючи цей код, компілятор Scala буде розміщувати виклик println в
      первинний конструктор Rational. Виклик println буде, таким чином друкувати
      його повідомлення налаштування при створенні нового примірника Rational:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Rational(1, 2)
Created 1/2
res0: Rational = Rational@90110a</pre>
    <h3>6.3 Перевизначення метода toString</h3>
    <p>Коли ми створили примірник Rational в попередньому прикладі,
      інтерпретатор друкує "Rational@90110a". Інтерпретатор отримує дещо дивно
      виглядаючий рядок, викликаючи метод toString об'єкта Rational. По
      замовчанню клас Rational наслідує реалізацію toString, визначений для
      класа class java.lang.Object, що тільки друкує ім'я класа, знак @, та
      шіснадцятиричне число. Результат toString призначений в першу чергу
      допомагати програмістам, провадячи інформацію, що може використовуватись
      для налаштування тверджень друку, журнальних повідомлень, тестових звітів
      про збої, та вивід інтерпретатора та налагодження. Результат, що наразі
      провадиться toString, не є особливо корисним, оскільки він не дає жодної
      підказки щодо значення раціонального значення. Більш корисна реалізація
      toString буде друкувати значення чисельника та займенника Rational. Ви
      можете переписати реалізацію по замовченню, додаючи метод toString до
      класа Rational, наприклад, таким чином:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  override def toString = n +"/"+ d
}</pre>
    <p>Модифікатор override на початку визначення метода сигналізує, що
      попереднє визначення метода буде перевизначите; більше щодо цього в Главі
      10. Оскільки число Rational тепер буде відображуватись досить мило, ми
      видалимо твердження println, що ми поклали в тіло попередньої версії класа
      Rational. Ви можете протестувати нову поведінку Rational в інтерпретаторі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 3)
x: Rational = 1/3
scala&gt; val y = new Rational(5, 7)
y: Rational = 5/7</pre>
    <h3>6.4 Перевірка передумов</h3>
    <p>В якості наступного кроку ми перемикнемо нашу увагу на проблему поточної
      поведінки первинного конструктора. Як зазначалось на початку цієї глави,
      раціональні числа не можуть мати нуль в якости займенника. Однак наразі
      первинний конструктор приймає нуль в якості d :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Rational(5, 0)
res1: Rational = 5/0</pre>
    <p>Одна з переваг об'єктно-орієнтовного програмування в тому, що воно
      дозволяє вам інкапсулювати дані в об'єктах, так що ви можете переконатись,
      що дані коректні на протязі їх життя. В випадку незмінного об'єкта,
      такого, як Rational, це означає, що ви повинні переконатись в валідності
      даних при конструюванні об'єкта. Маючи на увазі, що нульовий займенник є
      неприпустимим станом для числа Rational, ви не повинні дозволити
      конструювання Rational, якщо в параметрі d переданий нуль.</p>
    <p>Кращим шляхом у підході до цієї проблеми, це визначити передумову в
      первинному конструкторі, що d не повинне бути нулем. Передумова є
      обмеження на значення, передані в метод або конструктор, яким повинні
      задовільняти викликаючі. Одним з шляхів зробити це можна таким чином:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  override def toString = n +"/"+ d
}</pre>
    <p>Метод require приймає одне логічне значення. Якщо передане значення є
      true, require повернеться нормально. Інакше require запобігатиме об'єкт
      від створення, викликаючи виключення IllegalArgumentException.</p>
    <h3>6.5 Додавання полів</h3>
    <p>Тепер, коли первинний конструктор відповідним чином накладає передумову,
      ми перенесемо нашу увагу на реалізацію додавання. Щоб зробити це, ми
      визначимо публічний метод add на класі Rational, що приймає інше Rational
      в якості параметра. Щоб утримувати Rational незмінним, метод add не
      повинен додавати передане раціональне число до себе. Скоріше, він повинен
      створити новий Rational, що міститиме суму. Ви можете думати про це,
      записавши add таким чином:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) { // Це не буде компілюватись
  require(d != 0)
  override def toString = n +"/"+ d
  def add(that: Rational): Rational =
  new Rational(n * that.d + that.n * d, d * that.d)
}</pre>
    <p>Однак надання цього кода призведе до скарги компілятора:</p>
    <pre class="prettyprint linenums language-scala">&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                      ˆ
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                                               ˆ</pre>
    <p>Хоча параметри класа n та d є в полі зору кода вашого метода add, ви
      можете отримувати доступ до них на об'єкті, на якому він викликається.
      Таким чином, коли ви кажете n або d в реалізації add, компілятор щасливий
      провадити вам значення для параметрів цього класа. Але він не дозволить
      вам казати that.n або that.d, оскільки це не посилається на об'єкт
      Rational, на якому він викликаєтсья. Щоб отримати доступ до чисельника та
      займенника на ньому, нам треба перетворити їх на поля. Лістинг 6.1
      показує, як ви можете додати ці поля до класа Rational. </p>
    <p>В цій версії Rational, показаній в Лістингу 6.1 ми додаємо два поля з
      іменами numer та denom, та ініціалізуємо їх значеннями параметрами класів
      n та d. Ми також змінюємо реалізацію toString та add, так що вони
      використовують поля, не параметри класа. Ця версія класа Rational буде
      компілюватись. Ви можете протестувати його, додаючи деякі раціональні
      числа:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}</pre>
    <p>Лістинг 6.1 Rational з полями.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; oneHalf add twoThirds
res3: Rational = 7/6</pre>
    <p>Одна інша річ, що ви можете зробити прямо зараз, та що ви не могли до
      цього, це доступ до значень чисельника та займенника за межами об'єкта.
      Просто отримуйте доступ до полів numer та denom:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(1, 2)
r: Rational = 1/2
scala&gt; r.numer
res4: Int = 1
scala&gt; r.denom
res5: Int = 2</pre>
    <h3>6.6 Посилання на себе</h3>
    <p>Ключове слово this посилається на примірник об'єкта, на якому наразі
      викликається метод, або, якщо використовується в конструкторі, примірник
      об'єкта, що створюється. В якості приклада розглянемо новий метод,
      lessThan, що перевіряє, чи даний Rational меньше, ніж параметр:</p>
    <pre class="prettyprint linenums language-scala">def lessThan(that: Rational) =
&nbsp; this.numer * that.denom &lt; that.numer * this.denom</pre>
    <p>Тут this.numer посилається на чисельник об'єкта, на якому викликається
      lessThan. Ви також можете облишити цей префікс, та просто записати numer;
      дві нотації є еквівалентними. В якості приклада, як ви можете це зробити
      без цього, розгляньте додавання метода max до класа, що повертає більше з
      наданого раціонального числа, та аргумента:</p>
    <pre class="prettyprint linenums language-scala">def max(that: Rational) =
&nbsp; if (this.lessThan(that)) that else this</pre>
    <p>Тут перше this є зайвим. Ви можете точно таким же чином опустити ліву
      частину, та записати lessThan(that). Але другий this представляє результат
      метода в випадку, коли перевірка дає false; коли ви опустите і його, вам
      просто не буде що повертати!</p>
    <h3>6.7 Додаткові конструктори</h3>
    <p>Іноді вам треба декілька конструкторів для класа. В Scala конструктори,
      крім первинного, називають додатковими конструкторами. Наприклад,
      раціональне число з займенником 1 може бути записане більш стисло, як один
      чисельник. Наприклад, замість 5/1, ви можете записати просто 5. Таким
      чином, це може бути милим, якщо замість писати new Rational(5, 1),
      програмісти клієнтів можуть просто записати new Rational(5). Це може
      потребувати створення додаткового конструктора Rational, що приймає тільки
      один аргумент, чисельник, та вважате займенник рівним 1. Лістинг 6.2
      демонструє, як це може виглядати.</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  def this(n: Int) = this(n, 1) // додатковий конструктор
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}
</pre>
    <p>Лістинг 6.2 Rational з додатковим конструктором.</p>
    <p>Додаткові конструктори в Scala починаються з def this(...). Тіло
      зовнішнього конструктора Rational просто викликає первинний конструктор,
      передаючи йому свій один аргумент, n, в якості чисельника, та 1 в яксті
      займенника. Ви можете бачити додатковий конструктор в дії, набравши
      наступне в інтерпретаторі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val y = new Rational(3)
y: Rational = 3/1 </pre>
    <p>В Scala кожний зовнішній конструктор має викликати інший конструктор того
      ж класа в якості першої дії. Іншими словами, перше твердження кожного
      зовнішнього конструктора кожного класа Scala буде мати форму "this( . . .
      ) ". Викликаний конструктор є або первинним конструктором (як в прикладі
      Rational), або іншим додатковим конструктором, що текстуально іде перед
      викликаючого конструктора. Нетто-ефект цього правила полягає в тому, що
      кожний виклик конструктора в Scala раніше чи пізніше завершиться викликом
      первинного конструктора класа. Первинний конструктор, таким чином, є
      єдиною точкою входу в клас.</p>
    <h4>Зауваження</h4>
    <p>Якщо ви добре знайомі з Java, ви можете здивуватись, чому правила Scala
      для конструкторів є дещо більш обмеженними, ніж в Java. В Java конструктор
      має або викликати інший конструктор того ж класа, або напряму викликати
      конструктор для суперкласа, в якості першої дії. В класі Scala тільки
      первинний конструктор може викликати конструктор суперкласа. Підвищене
      обмеження в Scala насправді є компромісом, на який треба піти, а обмін на
      більшу стислість та простоту конструкторів Scala, у порівнянні з Java.
      Суперкласи, та деталі щодо того, як виклик конструктора та наслідування
      взаємодіють муж собою, буде пояснене в Главі 10.</p>
    <h3>6.8 Приватні поля та методи</h3>
    <p>В попередній версії Rational ми просто ініціалізуєте numer за допомогою
      n, та denom за допомогою d. Як результат чисельник та займенник Rational
      можуть бути більші, ніж треба. Наприклад, дріб 66/42 може бути
      нормалізований до нормалізованої скороченої форми 11/7, але первинний
      конструктор Rational наразі не робить цього:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res6: Rational = 66/42</pre>
    <p>Щоб нормалізувати число таким чином, вам треба роділити чисельник та
      займенник на найбільший загальний дільник. Наприклад, найбільший загальний
      дільник для 66 та 42 є 6. (Іншими словами, 6 є більшим цілим, що нарівно
      ділить 66 та 42). Поділівши обоє, чисельник та займенник на 6&nbsp; дасть
      скорочену форму, 11/7. Лістинг 6.3 показує один зі шляхів, як це зробити:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
    <p>Лістинг 6.3 Rational з приватними полем та методом.</p>
    <p>В цій версії Rational ми додаємо приватне поле g, та модифікуємо
      ініціалізатори numer та denom. (Ініціалізатор є код, що ініціалізує
      змінну, наприклад, "n / g", що ініціалізує numer). Оскільки g є приватним,
      до нього є доступ зсередини тіла класа, але не зовні. Ми також додаємо
      приватний метод, gcd, що обчислює найбільший загальний дільник двох
      переданих Int. Наприклад, gcd(12, 8) дає 4. Як ви бачили в Розділі 4.1,
      щоб зробити поле або метод приватними, ви просто ставите ключове слово
      private перед визначенням. Призначення приватного "допоміжного метода" gcd
      є виділення кода, що потрібен для деякої іншої частини класа, в данному
      випадку первинного конструктора. Щоб переконатись, що g є завжди
      позитивним, ми передає абсолютні значення n та d, що ми отримуємо,
      викликаючи abs, метод, що ви можете викликати для любого Int для отримання
      абсолютного значення.</p>
    <p>Компілятор Scala буде розміщувати код для ініціалізаторів трьох полів
      Rational в первинний конструктор, в тому порядку, як вони з'являються в
      коді. Таким чином, ініціалізатор g, gcd(n.abs, d.abs), буде викликаний
      перед іншими двома, оскільки він з'являється першим в початковому коді. В
      результаті поле g буде ініціалізоване більшим загальним дільником
      абсолютного значення параметрів класа, n and d. Потім поле g
      використовується в ініціалізаторі numer та denom. Ділячі n та d на їх
      більший загальний дільник, g, кожне Rational буде сконструйоване в
      нормалізованій формі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res7: Rational = 11/7</pre>
    <h3>6.9 Визначення операторів</h3>
    <p>Поточна реалізація додавання Rational є пристойним, але може бути
      зроблене більш зручним для застосування. Ви можете запитати, чому ми
      можемо просто записати:</p>
    <pre class="prettyprint linenums language-scala">x + y</pre>
    <p>якщо x та y є цілими числами, чи з плаваюсою крапкою, але ми маємо
      писати:</p>
    <pre class="prettyprint linenums language-scala">x.add(y)</pre>
    <p>або щонайменьше:</p>
    <pre class="prettyprint linenums language-scala">x add y</pre>
    <p>якщо вони є раціональними числами. Немає переконливого пояснення, чому це
      має бути саме так. Раціональні числа є числами, так само як будь-які інші.
      В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з
      плаваючою крапкою. Чому ви не можете використовувати арифметичні операції
      з ними? В Scala ви можете це робити. В залишку цієї глави ми покажемо вам,
      як саме. </p>
    <p>Перший крок є заміна add на звичайний математичний спосіб. Це робиться
      прямолінійно, бо + є легальним ідентифікатором в Scala. Ми можемо просто
      визначити метод з + в якості імені. Та коли ми вже беремось до цього, ми
      також можемо реалізувати метод на ім'я *, що виконує множення. Результат
      показаний в Лістингу 6.4:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
    <p>Лістинг 6.4 Rational з методами-операторами.</p>
    <p>Коил клас Rational визначений в такий спосіб, ви тепер можете записати:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 2)
x: Rational = 1/2
scala&gt; val y = new Rational(2, 3)
y: Rational = 2/3
scala&gt; x + y
res8: Rational = 7/6</pre>
    <p>Як і завжди операторний синтаксис в останньому рядку еквівалентний до
      виклику метода. Ви також можете записати:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; x.+(y)
res9: Rational = 7/6</pre>
    <p>але це не читабельне.</p>
    <p>Інша річ, що треба занотувати, це надані правила Scala до преоритетів
      операторів, що були описані в Розділі 5.8, метод * буде асоціюватись більш
      тісно, ніж метод + для Rational. Іншими словами, вирази, що включають
      оператори + та * над Rational будуть поводитись, як очікується. Наприклад,
      x + x * y буде виконуватись як x + (x * y), не як (x + x) * y:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; x + x * y
res10: Rational = 5/6
scala&gt; (x + x) * y
res11: Rational = 2/3
scala&gt; x + (x * y)
res12: Rational = 5/6</pre>
    <h3>6.10 Ідентифікатори в Scala</h3>
    <p>Тепер ви побачили два найбільш важливі способи сформувати ідентифікатор в
      Scala: алфавітно-цифровий, та оператори. Scala має дуже гнучки правила для
      формування ідентифікаторів. Окрім двох форм ви бачили ще два інші. Всі
      чотири форми формування ідентифікаторів описані в цьому розділі.</p>
    <p>Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення,
      за якими можуть слідувати літери, цифри або підкреслення. Сивол ‘$’ також
      вважається за літеру, однак він зарезервований для ідентифікаторів,
      згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах
      не повинні містити символи ‘$’, навіть якщо вони компілюються; не
      дотримання цього може призвести до конфліктів імен з ідентифікаторами,
      згенерованими компілятором Scala.</p>
    <p>Scala слідує домовленостім Java щодо використання ідентифікаторів в
      верблюжому реєстрі, таких,як toString та HashSet. Хоча підкреслення
      допустимі в ідентифікаторах, вони не так часто використовуються в
      програмах Scala, частково для узгодженості з Java, але також оскільки
      підкреслення має багато інших, не-індефікаторних використань в коді Scala.
      Як результат, краще уникати ідентифікаторів як to_string, __init__, або
      name_. Верблюжий реєстр для полів, параметрів методів, локлаьних змінних
      та функцій повинні починатись з малої літери, наприклад: length, flatMap,
      та s. Верблюжий реєстр імен класів та трейтів повинні починатись з літери
      в верхньому реєстрі, наприклад: BigInt, List, та UnbalancedTreeMap.</p>
    <h4>Зауваження</h4>
    <p>Одне зі слідоцтв використання підкреслення в кінці ідентифікатора є те,
      що коли ви спробуєте написати декларацію такого гатунку<br>
      "val name_: Int = 1", ви отримаєте помилку компілятора. Компілятор буде
      думати, що ви намагаєтесь задекларувати val на ім'я "name_:". Щоб
      примусити це компілюватись, вам треба вставити додатковий проміжок перед
      двома крапками: "val name_ : Int = 1".</p>
    <p>Одним шляхом, як домовленості Scala відрізняються від Java, включають
      імена констант. В Scala ключове слово constant означає не тільки val.
      Навіть зважаючи на те, що val залишаєтся незмінним після ініціалізації, це
      все ще змінна. Наприклад, параметри метода є val, але кожного разу, коли
      викликається метод, ці val може містити різні значення. Константи є більш
      сталими. Наприклад, scala.math.Pi визначене є бути значенням double,
      найближчим до дійсного значення π, відношення довжини кола до деаметру. Це
      значення чи навряд колись зміниться, і, таким чином, Pi є дійсною
      константою. Також ви можете використовувати константи для іменування
      значень, що в іншому випадку були б магічними числами в вашому коді:
      літеральні значення без пояснень, що в гіршому випадку з'являються в
      декількох місцях. Також ви можете побажати визначити константи для
      використання в співпадіння шаблонів, випадок використання, що буде
      описаний в Розділі 15.2. В Java по домовленості імена констант отримують
      імена з великих літер, з підкресленнями для розділення слів, як в
      MAX_VALUE або PI. В Scala за домовленостю тільки перший символ має бути
      великою літерою. Таким чином, константи, що названі в стилі Java, такі як
      X_OFFSET, будуть робити як константи в Scala, але домовленість Scala
      використовувати верблюжий реєстр для констант, такі як XOffset .</p>
    <p>Ідентифікатори-оператори складаються з одного або більше операторних
      символів. Операторні символи є друкуємі символи ASCII, такі як +, :, ?, ~
      або #. Ось деякі приклади операторних ідентифікаторів:</p>
    <pre class="prettyprint linenums language-scala">+
++
:::
&lt;?&gt;
:-&gt;</pre>
    <p>Компілятор Scala буде внутрішньо "підмальовувати" операторні
      ідентифікатори, щоб перетворити їх на звичайні ідентифікатори Java з
      вбудованими символвами $. Наприклад, ідентифікатор :-&gt; врутрішньо буде
      представлений як $colon$minus$greater. Якщо ви бажаєте отримати доступ до
      такого ідентифікатора з кода Java, вам буде треба використовувати
      внутрішнє представлення.</p>
    <p>Оскільки операторні ідентифікатори в Scala можуть мати довільну довжину,
      є мала різниця між Java та Scala. В Java x&lt;-y буде розібране як чотири
      лексичні символи, так що це буде еквівалентне до x &lt; - y. В Scala &lt;-
      буде розібране як один ідентифікатор, даючи x &lt;- y. Якщо ви бажаєте
      першу інтерпретацію, вам треба розділити символи &lt; та - за допомогою
      проміжка. Це навряд чи буде проблемою на практиці, бо дуже мало людей
      будуть писати x&lt;-y в Java, без вставки проміжків або дужок між
      операторами.</p>
    <p>Змішані ідентифікатори складаються з алфавітно-цифрового ідентифікатора,
      за яким іде підкреслення та операторний ідентифікатор. Наприклад,
      unary_+використовується як ім'я метода, що визначає оператор +. Або
      myvar_= використовується як ім'я метода, що визначає оператор присвоєння.
      На додаток, змішані ідентифікатори в формі myvar_= генеруються
      компілятором Scala для підтримки властивостей; більше про це ви знайдете в
      Главі 18.</p>
    <p>Літеральний ідентифікатор є довільним рядком, що оточений в зворотні
      лапки ( ` . . . ` ). Деякі приклади літеральних ідентифікаторів:</p>
    <pre class="prettyprint linenums language-scala">`x`
`&lt;clinit&gt;`
`yield`</pre>
    <p>Ідея полягає в тому, що ви можете покласти любий рядок, що доступний під
      час виконання, як ідентифікатор між зворотніми лапками. Результатом завжди
      є ідентифікатор Scala. Це робить навіть якщо ідентифікатор в зворотніх
      лапках буде зарезервованим словом Scala. Типовий приклад використання є
      доступ до статичного метода yield в класі Java Thread. Ви не можете
      написати Thread.yield(), оскільки yield є зарезервованим словом в Scala.
      Однак ви все ще можете назвати метод в зворотніх лапках,
      тобтоThread.`yield`() .</p>
    <h3>6.11 Перевантаження методів</h3>
    <p>Повернемось до класа Rational. З останніми змінами тепер ви можете
      виконувати додавання та множення в природний спосіб на раціональних
      числах. Але одна річ, що нам бракує, є змішана арифметика. Наприклад, ви
      не можете множити раціональне число на ціле, оскільки операнди * мають
      бути Rational. Доки для раціонального числа r ви не можете записати r * 2.
      Ви маєте записати r * new Rational(2), що не є гарним. Щоб зробити
      Rational навіть більш зручним, ми додамо нові методи до класа, що
      виконують змішені додавання та множення на раціональних числах та цілих.
      Доки ми розглядаємо це, ми додамо методи для віднімання та ділення.
      Результат показаний в Лістингу 6.5.</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
        denom * that.denom
    )
  def + (i: Int): Rational =
    new Rational(numer + i * denom, denom)
  def - (that: Rational): Rational =
    new Rational(
      numer * that.denom - that.numer * denom,
      denom * that.denom
    )
  def - (i: Int): Rational =
    new Rational(numer - i * denom, denom)
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  def * (i: Int): Rational =
    new Rational(numer * i, denom)
  def / (that: Rational): Rational =
    new Rational(numer * that.denom, denom * that.numer)
  def / (i: Int): Rational =
    new Rational(numer, denom * i)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
    <p>Лістинг 6.5 Rational з перевантаженими методами.</p>
    <p>Тепер є дві версії кожної арифметичної операції: одна, що приймає
      раціональний аргумент, та інший, що приймає ціле. Іншими словами, кожне з
      ціх імен методів є перевантаженими, оскільки кожне ім'я тепер
      використовується декількома методами. Наприклад, ім'я + використовується
      одним методом, що приймає Rational, та інше, що приймає Int. Коли
      викликається метод компілятор обирає версію перевантаженого метода, що
      коректно співпадає з типами аргументів. Наприклад, якщо аргумент y в
      x.+(y) є Rational, компілятор обере метод +, що приймає параметр Rational.
      Але якщо аргумент ціле, компілятор обере метод, що приймає параметр Int.
      Якщо ви спробуєте таке:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(2, 3)
x: Rational = 2/3
scala&gt; x * x
res13: Rational = 4/9
scala&gt; x * 2
res14: Rational = 4/3</pre>
    <p>Ви побачите, що метод *, що викликається в кожному випадку, буде
      відповідати до типу операнду.</p>
    <h4>Зауваження</h4>
    <p>Процес Scala обробки розрішення перевантажених методів дуже подібний до
      Java. В жодному випадку обрана перевантажена версія буде та, що найкраще
      співпадає зі статичними типами аргументів. Іноді немає унікальної кращої
      співпадаючої версії; в цьому випадку компілятор видасть вам помилку
      "неоднознозначного посилання".</p>
    <h3>6.12 Неявні перетворення</h3>
    <p>Тепер, коли ви можете записати&nbsp; r * 2, ви також можете побажати
      переставити операнди, як в 2 * r. На жаль, це доки не працює:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 2 * r
&lt;console&gt;:7: error: overloaded method value * with
alternatives (Double)Double &lt;and&gt; (Float)Float &lt;and&gt;
(Long)Long &lt;and&gt; (Int)Int &lt;and&gt; (Char)Int &lt;and&gt; (Short)Int
&lt;and&gt; (Byte)Int cannot be applied to (Rational)
2 * r<br>ˆ</pre>
    <p>Тут проблема в тому, що 2 * r еквівалентне до 2.*(r), так що метод
      викликається на числі 2, яке є цілим. Але клас Int не має метода множення,
      що приймає аргумент Rational — він і не може, бо клас Rational не є
      стандартним класом бібліотеки Scala. </p>
    <p>Але є інший шлях до вирішення цієї проблеми в Scala: ви можете створити
      неявне перетворення, що автоматично конвертує цілі в раціональні в разі
      необхідності. Спробуйте додати такий рядок в інтерпретаторі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; implicit def intToRational(x: Int) = new Rational(x)</pre>
    <p>Це додасть метод конвертації з Int до Rational. Модифікатор implicit
      попереду метода каже компілятору автоматично застосовувати його в деяких
      ситуаціях. З визначеним перетворенням тепер ви можете спробувати приклад,
      що раніше давав збій:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(2,3)
r: Rational = 2/3
scala&gt; 2 * r
res16: Rational = 4/3</pre>
    <p>Зауважте, щоб неявне перетворення робило, воно має бути в полі зору. Якщо
      ви покладете визначення неявного метода в клас Rational, він не буде в
      полі зору компілятора. Покі ви маєте визначати його напряму в
      інтерпретаторі. </p>
    <p>Як може промайнути з цього приклада, неявні перетворення є дуже потужним
      прийомом, щоб зробити бібліотеки більш гручкими та більш зручними в
      використанні. Оскільки вони такі потужні, вони можуть бути легко невірно
      застосовуватись. Ви знайдете більше щодо неявних перетворень, включаючи
      шляхи по занесенню їх в поле зору, в Главі 21.</p>
    <h3>6.13 Слово попередження</h3>
    <p>Як демонструє ця глава, створення методів з операторними іменами та
      визначення неявних перетворень можуть допомогти вам розробити бібліотеки,
      для яких клієнтський код буде стислим та простим для розуміння. Scala
      надає вам велику потужність розробляти такі прості для використання
      бібліотеки, але майте на увазі, що ці потужність супроводжується
      відповідальністю. </p>
    <p>При незграбному використанні обоє, операторні методи та неявні
      перетворення можуть дати життя клієнтському коду, що буде важко читати та
      розуміти. Оскільки неявні перетворення неявно застосовуються компілятором,
      а не явно прописані в коді, може бути неочевидним для програмістів
      клієнтськох частини, які неявні перетворення будуть застосовані. Та хоча
      операторні методи будуть звичайно робити клієнтський код більш стислим,
      вони будуть робити його більш читабельним тільки в тій мірі, доки
      програмісти будуть розпізнавати та пам'ятати значення кожного оператора.</p>
    <p>Ціль, що ви маєте утримувати на увазі при розробці бібліотек, це не
      тільки давати стислість клієнтського кода, але також сприяти читабельності
      та розумінню клієнтського кода. Стислість значною мірою буде частиною цієї
      читабельності, але ви можете завести цю стислість надто далеко.
      Розроблюючи бібліотеки, що надають витончено стислий, та, в той же час,
      зрозумілий клієнтський код, ви можете допомогти продуктивній роботі
      програмістам клієнтської частини.</p>
    <h3>6.14 Висновок</h3>
    <p>В цій главі ви побачили більше аспектів класів в Scala. Ви побачили, як
      додавати параметри до класу, визначати декілька конструкторів, визначати
      оператори як методи, та налаштовувати класи, щоб їх було природно
      використовувати. Можливо, найбільш важливо, ви побачили, що визначення та
      використання незмінних об'єктів є досить природним способом кодування в
      Scala.</p>
    <p>Хоча заключна версія Rational, показана в цьому розділі, задовільняє
      вимогам, сформульованим на початку цієї глави, вона все ще може бути
      покращена. Фактично, ми будемо повертатись до цього приклада пізніше в цій
      книзі. Наприклад, в Главі 30 ви навчитесь, як перевизначивати equals та
      hashcode, щоб Rational краще поводились при порівнянні за допомогою ==,
      або при розміщенні в хеш таблицях. В Главі 21 ви навчитесь, як розміщувати
      визначення неявних методів в об'єкті-компанйоні Rational, так що ви більш
      просто зможете заносити його в поле зору, коли програмісти клієнтів будуть
      робити з Rationals.</p>
    <h4>Глава 7</h4>
    <h3>Вбудовані структури керування</h3>
    <p>Scala має тільки декілька вбудованих структур керування. Єдині структури
      є if, while, for, try, match, та виклики функцій. Причина, чому Scala має
      так небагато в тому, що вона включає літерали функцій з самого моменту її
      створення. Замість аккумуляції однієї за одною високорівневих структур
      керування в базовому синтаксисі, Scala акумулює їх в бібліотеках. Глава 9
      покаже в точності, як це робиться. Ця глава покаже декілька структур
      керування, що вбудовані в мову.</p>
    <p>Одна річ, що ви занотуєте, це те, що майже всі структури керування в
      Scala повертають деяке значення. Цей підхід, взятий від функціональних
      мов, в якому програми розглядаються як обчислення значення, так що
      компоненти програми повинні обчислювати значення. Ви також можете
      розглядати цей підхід як логічне довершення тенденції, що вже присутня в
      імперативних мовах. В імперативних мовах виклики функцій можуть повертати
      значення, навіть якщо виклик функції оновлюють вихідну змінну, що передана
      як аргумент, також буде робити. На додаток, імперативні мови часто мають
      тримісний оператор (такий як оператор ?: в&nbsp; C, C++, та Java), який
      поводиться точно як if, але повертає значення. Scala адаптує цю модель
      тримісного оператора, але викликає його як if. Іншими словами, в Scala if
      може продукувати значення. Потім Scala продовжує цей тренд, маючи for,
      try, та match, що також повертають значення.</p>
    <p>Програмісти можуть використовувати ці результати для спрощення свого
      кода, так само, як вони використовують повернуті функціями значення. Без
      цієї можливості програміст змушений створювати тимчасові змінні тільки для
      збереження результатів зсередини керівних структур. Видалення ціх
      тимчасових змінних робить код трохи простішим, та це також уникає багатьох
      помилок, коли ви встановлюєте змінну в одному відгалуженні, але забуваєте
      встановити її в іншому.</p>
    <p>Загалом, базові керівні структури Scala, мінімальні як вони є, достатні
      для провадження всіх основ з імперативних мов. Більше того, вони
      дозволяють вам скоротити ваш код, узгоджено маючи значення результата. Щоб
      показати вам, як все це робить, ця глава надає ближчий погляд на кожну з
      керівних структур Scala.</p>
    <h3>7.1 Вирази if</h3>
    <p>В Scala вираз if робить так само, як і в багатьох інших мовах. Він
      перевіряє умову, та потім виконує одне або двок відгалужень кода, в
      залежності від того, чи умова обчислюється як true. Ось загальний приклад,
      написаний в імперативному стилі:</p>
    <pre class="prettyprint linenums language-scala">var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)</pre>
    <p>Цей код декларує змінну filename, та використовує її як значення по
      замовчанню. Потім використовєуться вираз if, щоб перевірити, чи до
      програми були передані будь-які аргументи. Якщо це так, код змінює змінну,
      щоб вона отримала значення, вказане в списку аргументів. Якщо аргументи не
      надані, він залишає змінну, встановлену в значення по замовчанню.</p>
    <p>Цей код може бути записаний більш гарно, оскільки, як вказано на кроці 3
      в Главі 2, в Scala if є виразом, що продукує значення. Лістинг 7.1
      показує, як ви можете досягти такого ж ефекту, що і приклад вище, але без
      використання жодного var:</p>
    <pre class="prettyprint linenums language-scala">val filename = if (!args.isEmpty) args(0) else "default.txt"</pre>
    <p>Лістинг 7.1 Ідіома Scala для умовної ініціалізації.</p>
    <p>На цей раз if має два відгалуження. Якщо args не пустий, обирається
      елемент ініціалізації args(0). Інакше обирається значення по замовчанню.
      Вираз if дає результат в вигляді обраного значення, та змінна filename
      ініціалізується цім значенням. Цей код трохи коротший, але справжня
      перевага в тому, що він використовує val замість var. Використання val є
      функціональним стилем, та це допомагає вам майже в той же спосіб, що і
      фінальні змінні в Java. Це каже читачам кода, що змінна ніколи не буде
      змінюватись, зберігаючи їх від сканування всього кода в полі зору змінної,
      щоб побачити, чи не змінюється вона де-інде.</p>
    <p>Друга перевага використання val замість var в тому, що це краще підтримує
      міркування рівності. Введене значення є рівним виразу, що обчислює його,
      при умові, що вираз не має побічного ефекту. Таким чином, кожного разу,
      коли ви збираєтесь записати ім'я змінної, ви можете замість цього записати
      вираз. Замість println(filename), наприклад, ви можете записати таке:</p>
    <pre class="prettyprint linenums language-scala">println(if (!args.isEmpty) args(0) else "default.txt")</pre>
    <p>Вибір за вами. Ви можете писати будь-як. Використовуючи val допомагає вам
      безпечно робити цей різновид рефакторингу, кожного разу, коли обчислюється
      ваш код. Шукайте можливості використовувати val. Вони можуть зробити ваш
      код обоє, простішим для читання, та простішим для рефакторингу.</p>
    <h3>7.2 Цикли while</h3>
    <p>Цикл Scala while поводиться як в інших мовах. Він має умову та тіло, та
      це тіло виконується раз за разом, доки умова обчислюється як true. Лістинг
      7.2 показує приклад:</p>
    <pre class="prettyprint linenums language-scala">def gcdLoop(x: Long, y: Long): Long = {
  var a = x
  var b = y
  while (a != 0) {
    val temp = a
    a = b % a
    b = temp
  }
  b
}</pre>
    <p>Scala також має цикл do - while. Це робить як цикл while, за винятком
      того, що умова перевіряється після виконання тіла цикла, а не перед.
      Лістинг 7.3 показує скрипт Scala, що використовує do-while для виводу
      рядків, що читаються зі стандартного вводу, доки не буде введений пустий
      рядок:</p>
    <pre class="prettyprint linenums language-scala">var line = ""
do {
  line = readLine()
  println("Read: "+ line)
} while (line != "")</pre>
    <p>Лістинг 7.3 Читання з стандартного вводу за допомогою do-while.</p>
    <p>Конструкції while та do-while називаються "циклами", не виразами,
      оскільки вони не повертають цікавого значення. Тип результата є Unit.
      Існує тільки одне значення (та, фактично, це дійсно тільки одне значення),
      чий тип є Unit. Це називається значенням блоку, та записується ().
      Існування () є тим, як Scala Unit відрізняється від Java void. Спробуйте
      це в інтерпретаторі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def greet() { println("hi") }
greet: ()Unit
scala&gt; greet() == ()
hi
res0: Boolean = true</pre>
    <p>Оскільки перед тілом не стоїть знак рівності, greet визначена як
      процедура, з типом результата Unit. Таким чином, greet повертає значення
      блока, (). Це підтверджується в наступному рядку: порівнюючи результат
      greet на рівність зі значенням блоку, (), дає true.</p>
    <p>Одна інша конструкція, що повертає значення блоку, що стосується нашої
      теми, є повторне присвоєння до var. Наприклад, коли ви намагаєтесь
      прочитати рядкі в Scala з використанням наступного цикла while,
      ідіоматичного для Java (C та C++), ви натрапите на проблеми:</p>
    <pre class="prettyprint linenums language-scala">var line = ""
while ((line = readLine()) != "") // Це не працює!
  println("Read: "+ line)</pre>
    <p>Коли ви компілюєте цей код, Scala видасть вам попередження, що порівняння
      значень типу Unit та String з використанням != завжди буде повертати true.
      Коли в Java присвоєння повертає присвоєне значення, в цьому випадку рядок
      зі стандартного входу, в Scala присвоєння завжди повертає значення блоку,
      (). Таким чином, значення присвоєння "line = readLine()" завжди буде (),
      та ніколи "". Як результат, умова цього цикла while ніколи не будет false,
      і, таким чином, цикл ніколи не завершиться.</p>
    <p>Оскільки цикл while не повертає значення, він часто не використовується в
      чисто функціональних мовах. Такі мови мають вирази, але не цикли. Scala,
      тим не менш, включає цикли while, оскільки іноді імперативне рішення може
      краще читатись, особливо для програмістів з переважно імперативним
      підгрунтям. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує
      процес, доки не зміниться деяка умова, цикл while може виразити це
      напряму, але функціональна альтернатива, що, вірогідно, включатиме
      рекурсію, може бути менш очевидною для читачів кода.</p>
    <p>Наприклад, Лістинг 7.4 показує альтернативний шлях визначити більший
      загальний дільник двох чисел. Беручи ті самі два значення x та y, що і
      функція gcd, показана в Лістингу 7.4, буде отримано такий самий результат,
      що і в функції gcdLoop, показаній в Лістингу 7.2. Різниця між ціма двома
      підходами в тому, що gcdLoop написаний в імперативному стилі, з
      використанням var s та цикла while, тоді як gcd написана в більш
      функціональному стилі, що включає рекурсію (виклики самої gcd), та не
      потребує var.</p>
    <pre class="prettyprint linenums language-scala">def gcd(x: Long, y: Long): Long = if (y == 0) x else gcd(y, x % y)</pre>
    <p>Лістинг 7.4 Обчислення найбільшого загального дільника за допомогою
      рекурсії.</p>
    <p>Загалом, ми рекомендуємо вам позбуватись від циклів while в вашому коді,
      таким же чином, як ви позбуваєтесь var. Фактично, цикли while та var часто
      ідуть рука в руку. Оскільки цикли while не призводять до значення, щоб
      зробити будь-яку зміну в вашій програмі, цикл while буде звичайно або
      потребувати оновлення var, або виконання I/O. Ви можете бачити це в дії в
      прикладі gcdLoop, що показаний раніше. По мірі того, як цикл while робить
      свою справу, він оновлює var a та b. Таким чином, ми рекомендуємо вам бути
      трохи підозрілим до циклів while в вашому коді. Якщо немає гарного
      обгрунтування для окремого циклу while або do-while, спробуйте знайти
      спосіб зробити ті ж речі без них.</p>
    <h3>7.3 Вирази for</h3>
    <p>Вираз Scala є швейцарським ножем в світі ітерацій. Він дозволяє вам
      комбінувати декілька простих інгредієнтів в різний спосіб, щоб виразити
      різні ітерації. Прості використання дозволяють загальні операції, такі, як
      ітерація по послідовності цілих. Більш складні вирази можуть ітерувати по
      декільком колекціям, різного типу, можуть фільтрувати елементи, базуючись
      на довільних умовах, та можуть продукувати нові колекції.</p>
    <h4>Ітерація по колекціях</h4>
    <p>Найпростіша річ, що ви можете зробити за допомогою for, це ітерація по
      елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що
      роздруковує всі файли в поточному каталозі. I/O виконується за допомогою
      Java API. Перше, ми створюємо java.io.File на поточному каталозі, ".", та
      викликаємо його метод listFiles. Цей метод повертає масив з об'єктів File,
      по одному для кожного каталогу та файла в поточному каталозі. Ми
      зберігаємо отриманий масив в змінній filesHere.</p>
    <pre class="prettyprint linenums language-scala">val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere)
  println(file)</pre>
    <p>Лістинг 7.5 Перелік файлі в каталозі за допомогою виразу for.</p>
    <p>За допомогою синтаксиса "file &lt;- filesHere", що називається
      генератором, ми ітеруємо по елементах filesHere. На кожній ітерації нове
      val на ім'я file ініціалізується значенням елемента. Компілятор виводить
      тип file як File, оскільки filesHere є Array[File]. Для кожної ітерації
      виконується тіло виразу for, println(file). Оскільки метод File toString
      дає ім'я файла або каталога, таким чином будуть надруковані імена всіх
      файлів та каталогів в поточному каталозі. Синтаксис виразів for робить для
      любого різновиду колекцій, не тільки для масивів. Одним зі зручних
      особливих випадків є тип Range, що ми коротко бачили в Таблиці 5.4. Ви
      можете створити Range з використанням синтаксису на кшталт "1 to 5", та
      можете ітерувати по ньому за допомогою for. Ось простий приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; for (i &lt;- 1 to 4)
  println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3
Iteration 4</pre>
    <p>Якщо ви не бажаєте включити верхню межу диапазону в значення, по яких
      відбувається ітерація, використовуйте until замість to :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; for (i &lt;- 1 until 4)
  println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3</pre>
    <p>Ітерація по цілим в такий спосіб є загальною в Scala, але навряд чи так
      само в інших мовах. В інших мовах ви можете використовувати цю можливість
      для ітерації по масиву:</p>
    <pre class="prettyprint linenums language-scala">// Не є загальним в Scala...
for (i &lt;- 0 to filesHere.length - 1)
&nbsp; println(filesHere(i))</pre>
    <p>Цей вираз вводить змінну i, встановлює її на кожному циклі в ціле між 0
      та filesHere.length - 1, та виконує тіло вираза for для кожного
      встановленого i. Для кожної установки i виділяється та обробляється i-тий
      елемент filesHere. Причина, за якої цей тип ітерації менш загальний в
      Scala полягає в тому, що ви можете добре ітерувати по самій колекції. Якщо
      ви так робите, ваш код стає коротшим, та ви обходите багато з численних
      помилок, що можуть виникнути, коли ви ітеруєте по масивах. Повинні ви
      починати з 0 або 1? Повинні ви додавати -1, +1, або нічого до заключного
      індекса? На такі питання легко відповісти, але просто відповісти невірно.
      Безпечніше зовсім уникати таких питань.</p>
    <h4>Фільтрація</h4>
    <p>Іноді ви не бажаєте ітерувати по колекції повністю. Ви бажаєте
      відфільтрувати її до деякої підмножити. Ви можете зробити це за допомогою
      виразу for, додавши фільтр в вигляді твердження if в дужках for.
      Наприклад, код, показаний в Лістингу 7.6 перелічує тільки ті файли в
      поточному каталозі, що закінчуються на ".scala":</p>
    <pre class="prettyprint linenums language-scala">val filesHere = (new java.io.File(".")).listFiles
for (file &lt;- filesHere if file.getName.endsWith(".scala"))
  println(file)</pre>
    <p>Listing 7.6 · Finding .scala files using a for with a filter.</p>
    <p>Ви можете альтернативно досягти тієї ж цілі за допомогою такого кода:</p>
    <pre class="prettyprint linenums language-scala">for (file &lt;- filesHere)
if (file.getName.endsWith(".scala"))
  println(file)</pre>
    <p>Цей код дає той же вивод, що і попередній, та, можливо, виглядає більш
      знайомим для програмістів з імперативним підгрунтям. Імперативна форма,
      однак, є тільки опцією, оскільки цей окремий вираз for виконується тільки
      заради його побічного ефекта, друку, та повертає значення типу блок (). Як
      ми продемонструємо пізніше в цьому розділі, вираз for називається
      "виразом", оскільки він може повертати результат в вигляді цікавого
      значення, колекції, чий тип визначається твердженням виразу &lt;-.</p>
    <p>Ви можете задати більше фільтрів за бажанням. Просто додавайте твердження
      if. Наприклад, для додаткового захисту, код в Лістингу 7.7 друкує тільки
      файли, але не каталоги. Віно робить це, додаючи фільтр, що перевіряє метод
      файла isFile.</p>
    <pre class="prettyprint linenums language-scala">for (
  file &lt;- filesHere
  if file.isFile
  if file.getName.endsWith(".scala")
) println(file)</pre>
    <p>Лістинг 7.7 Використання декількох фільтрів в виразі for.</p>
    <h4>Вкладені ітерації</h4>
    <p>Якщо ви додасте декілька тверджень &lt;-, ви отримаєте вкладені "цикли".
      Наприклад, вираз for, показаний в Лістингу 7.8 має два вкладені цикли.
      Зовнішній цикл ітерує по filesHere, та внутрішній цикл ітерує по
      fileLines(file) для кожного файла, що закінчується на .scala .</p>
    <pre class="prettyprint linenums language-scala">def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
  for (
    file &lt;- filesHere
    if file.getName.endsWith(".scala");
    line &lt;- fileLines(file)
    if line.trim.matches(pattern)
  ) println(file +": "+ line.trim)
grep(".*gcd.*")</pre>
    <p>Лістинг 7.8 Використання декількох генераторів для виразу for.</p>
    <p>Якщо така ваша ласка, ви можете використовувати фігурні дужки замість
      дужок, щоб огортати генератори та фільтри. Одна перевага від використання
      фігурних дужок в тому, що ви можете відкинути декілька крапок з комою, що
      потрібні при викорстанні звичайних дужок, оскільки, як пояснюється в
      Розділі 4.2, компілятор Scala не буде виводити крапки з комою в звичайних
      дужках.</p>
    <h4>Прикріплення змінних посередині потоку обробки</h4>
    <p>Зауважте, що попередній код повторює вираз line.trim. Це нетривіальне
      обчислення, так що можете побажати виконати його тільки один раз. Ви
      можете зробити це, прив'язавши результат до нової змінної з використанням
      знака рівності ( = ). Прив'язана змінна вводиться та використовується як
      val, тільки без самого ключового слова. Лістинг 7.9 показує приклад. В
      Лістингу 7.9 вводиться змінна на ім'я trimmed посередині виразу for. Ця
      змінна ініціалізована результатом line.trim. Залишок виразу використовує
      змінну в двох місцях, один раз в if, та ще раз в println.</p>
    <pre class="prettyprint linenums language-scala">def grep(pattern: String) =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
    line &lt;- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(pattern)
  } println(file +": "+ trimmed)
grep(".*gcd.*")</pre>
    <p>Лістинг 7.9 Присвоєння під час виконання виразу for.</p>
    <h4>Продукування нової колекції</h4>
    <p>Доки всі приклади оперували з отриманими значеннями, та потім забували
      про них, але також можливо генерувати значення, що буде запам'ятовуватись
      на кожній ітерації. Щоб зробити це, поставьте в якості префікса ключове
      слово yield. Наприклад, ось функція, що ідентифікує файли .scala, та
      зберігає їх в масиві:</p>
    <pre class="prettyprint linenums language-scala">def scalaFiles =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
  } yield file</pre>
    <p>Кожного разу, коли виконується тіло виразу for, воно продукує значення, в
      даному випадку просто file. Коли цей вираз закінчується, результат буде
      включати всі отримані значення в вигляді однієї колекції. Тип отриманої
      колекцій базується на типі колекції, що оброблялась в ітерації. В цьому
      випадку результат буде Array[File], оскільки filesHere є масивом, і тип
      отриманих значень є File. До речі, будьте уважні, де розміщати ключове
      слово yield. Синтаксис для виразу for - yield такий:</p>
    <pre class="prettyprint linenums language-scala">for clauses yield body</pre>
    <p>Слово yield іде перед цілим тілом. Навіть якщо тіло є блоком, оточеним
      ффігурними дужками, ставьте yield перед першими фігурними дужками, не
      перед останнім виразом в блоці. Уникайте спокуси писати такі речі:</p>
    <pre class="prettyprint linenums language-scala">for (file &lt;- filesHere if file.getName.endsWith(".scala")) {
  yield file
// Синтаксична помилка!
}</pre>
    <p>Наприклад, якщо вираз, показаний в Лістингу 7.10 спочатку трансформує
      Array[File] на ім'я filesHere, що містить всі файли в поточному каталозі,
      в один, що містить тільки файли .scala. Для кожного з них він генерує
      Iterator[String] (результат метода fileLines, чиє визначення показане в
      Лістингу 7.8). Iterator пропонує методи next та hasNext, що дозволяють вам
      ітерувати по колекції елементів. Цей початковий ітератор трансформується в
      інший, Iterator[String], що містить тільки обрізані рядки, що включають
      підрядок "for". Нарешті, для кожного з них отримується ціла довжина.
      Результат цього виразу Array[Int], що містить ці довжини.</p>
    <pre class="prettyprint linenums language-scala">val forLineLengths =
  for {
    file &lt;- filesHere
    if file.getName.endsWith(".scala")
    line &lt;- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(".*for.*")
  } yield trimmed.length</pre>
    <p>Лістинг 7.10 Трансформація Array[File] до Array[Int] за допомогою for.</p>
    <p>На цей момент ви бачили всі головні можливості Scala щодо виразів for.
      Однак цей розіл пройшов по них досить швидко. Більш щільне покриття
      виразів for надається в Главі 23.</p>
    <h3>7.4 Обробка виключень за допомогою виразів try</h3>
    <p>Виключення Scala поводяться просто як більшість в багатьох інших мовах.
      Замість повернення значення в звичайний спосіб, метод може перервати
      виконання, піднявши виключення. Той, хто викликає метод, може або
      перехопити та обробити це виключення, або він може сам завершитись, в
      якому випадку виключення просувається до того, хто викликав викликаючого.
      Виключення просувається в такий спосіб, розмотуючи стек викликів, доки
      метод не обробить його, або коли не залишиться більше методів. </p>
    <h4>Підняття виключень</h4>
    <p>Підняття виключень виглядає так само, як в Java. Ви створюєте виключення,
      та потім підіймаєте його за допомогою ключового слова throw:</p>
    <pre class="prettyprint linenums language-scala">throw new IllegalArgumentException</pre>
    <p>Хоча це може виглядати трохи парадоксальним, в Scala throw є виразом, що
      має тип повернення. Ось приклад, де тип повернення має значення:</p>
    <pre class="prettyprint linenums language-scala">val half =
  if (n % 2 == 0)
    n / 2
  else
    throw new RuntimeException("n must be even")</pre>
    <p>Що тут відбувається, це те, що коли n парне, half буде ініціалізоване як
      половина n. Якщо n непарне, буде підійняте виключення, перед тим, як half
      взагалі буде ініціалізоване. Завдяки цьому є безпечним трактувати підняті
      виключення як любий тип значення. Любий контекст, що намагається
      використовувати результат після throw, ніколи не отримає можливість
      зробити це, і, таким чином, нічого поганого не відбудеться. Технічно,
      підняття виключення має тип Nothing. Ви можете використовувати throw як
      вираз, навіть не зважаючи на те, що він насправді нічого не обчислює. Цей
      невеликий фрагмент технічної гімнастики може виглядати збоченим, але часто
      є корисним в випадках, схожий не показаний вище приклад. Одна гілка if
      обчислюється до значення, тоді як інша підіймає виключення, та
      обчислюється до Nothing. Тип цілого виразу if потім буде типом тієї гілки,
      що обчислює дещо. Тип Nothing обговорюється в Розділі 11.3.</p>
    <h4>Перехоплення виключень</h4>
    <p>Ви перехоплюєте виключення з використанням синтаксису, показаному в
      Лістингу 7.11. Синтаксис для тверджень catch був обраний за його
      узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння
      шаблонів, потужна можливість, коротко описана в цій главі, та більш
      детально в Главі 15.</p>
    <pre class="prettyprint linenums language-scala">import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException
try {
  val f = new FileReader("input.txt")
  // Використовуємо за зачиняємо файл
} catch {
  case ex: FileNotFoundException =&gt; // Обробка відсутнього файла
  case ex: IOException =&gt; // Обробка інших помилок I/O
}</pre>
    <p>Лістинг 7.11 Твердження try-catch в Scala.</p>
    <p>Поведінка цього виразу try - catch така ж, що і в інших мовах з
      виключеннями. Тіло виконується, та якщо там підіймається виключення,
      перебираються кожне твердження catch один за одним. В цьому прикладі, якщо
      виключення є типу FileNotFoundException, буде викликане перше твердження.
      Якщо тип IOException, буде викликане друге твердження. Якщо виключення не
      одного з перелічених типів, try - catch завершиться, та виключення буде
      передане далі. </p>
    <h4>Зауваження</h4>
    <p>Одна відмінність від Java, що ви швидко помітили, в тому, що Scala, на
      відміну від Java, не змушує вас перехоплювати перевірені виключення, або
      декларувати їх в твердженні throws. Ви можете декларувати твердеження
      throws, якщо ви бажаєте, за допомогою анотації @throws, але це не є
      вимогою. Дивіться Розділ 31.2 для додаткової інформації щодо @throws.</p>
    <h4>Твердження finally</h4>
    <p>Ви можете огорнути вираз в твердження finally, якщо ви бажаєте, щоб
      деякий код виконувався, безвідносно від того, як завершиться деякий вираз.
      Наприклад, ви можете бажати переконатись, що файл буде закритий, навіть
      якщо метод скінчиться підняттям виключення. Лістинг 7.12 показує приклад.</p>
    <pre class="prettyprint linenums language-scala">import java.io.FileReader
val file = new FileReader("input.txt")
try {
  // Використовуємо файл
} finally {
  file.close()
  // Переконались, що файл буде закритий
}</pre>
    <p>Лістинг 7.12 Твердження try-finally в Scala.</p>
    <h4>Зауваження</h4>
    <p>Лістинг 7.12 показує ідеоматичний спосіб переконатись, що ресурс
      не-з-пам'яті, такий, як файл, сокет або з'єднання з базою даних, буде
      закритий. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок try, в
      якому ви використовуєте ресурс. Нарешті, ви закриваєте ресурс в блоці
      finally. Ця ідіома та ж сама в Scala, що і в Java, однак, в Scala ви
      можете альтернативно задіяти прийом, що називаєтсья шаблоном позичання,
      щоб досягти тієї ж цілі більш стисло. Шаблон позичання описаний в Розділі
      9.4.</p>
    <h4>Отримання значення</h4>
    <p>Як і більшість структр керування Scala, try - catch - finally
      завершується отриманням значення. Наприклад, Лістинг 7.13 показує, як ви
      можете спробувати розібрати URL, але використати значення по замовчанню,
      якщо URL погано сформований. Це призводить до того, що дає твердження try,
      якщо виключення не спрацювало. Якщо виключення було підійняте, але не
      перехоплене, вираз зовсім не має результата. </p>
    <pre class="prettyprint linenums language-scala">import java.net.URL
import java.net.MalformedURLException
def urlFor(path: String) =
  try {
    new URL(path)
  } catch {
    case e: MalformedURLException =&gt;
      new URL("http://www.scala-lang.org")
  }
</pre>
    <p>Лістинг 7.13 Твердження catch, що повертає значення.</p>
    <p>Значення, обчислене в твердженні finally, якщо тако є, буде відкинуте.
      Звичайно твердження finally виконують деякий різновид очищення, таке, як
      зачинення файлів; вони зазвичай не змінюють значення, обчислене в
      головному тілі, або в блоці catch конструкції try. Якщо ви добре знайомі з
      Java, стає зрозумілим, що поведінка Scala відрізняється від Java, хоча б
      тому, що в Java try-finally не повертає значення. Як і в Java, якщо блок
      finally включає явне твердження return, або підіймає виключення, це
      повернуте значення або виключення будуть "перемагати" любі попередні, що
      походять з блоку try, або з одного з пунктуів catch. Наприклад, маємо
      таке, трохи надумане, визначення функції:</p>
    <pre class="prettyprint linenums language-scala">def f(): Int = try { return 1 } finally { return 2 }</pre>
    виклик f() дає 2. Для контрасту, маючи таке:
    <pre class="prettyprint linenums language-scala">def g(): Int = try { 1 } finally { 2 }</pre>
    <p>виклик g() повертає 1. Обоє з ціх функцій демонструють поведінку, що може
      здивувати більшість програмістів, і, таким чином, зазвичай краще уникати
      повернення значень з блоку finally. Кращий шлях думати про блок finally,
      як про спосіб переконатись, що відбудеться деякий побічний ефект, такий,
      як закриття відчиненого файла.&nbsp;</p>
    <h3>7.5 Вирази match</h3>
    <p>В Scala вирази match дозволяють вам обирати з декількох альтернатив,
      просто як в твердженнях switch в інших мовах. Загалом, вираз match
      дозволяє вам використовувати довільні шаблони, що будуть описані в Главі
      15. Загальна форма може зачекати. Поки що просто зупинимось на
      використанні співставлення з декількома альтернативами.</p>
    <p>В якості приклада скрипт в Лістингу 7.14 читає назву їжі зі списка
      аргументів, та друкує додаток до цієї їжі. Цей вираз match перевіряє
      firstArg, що був встановлений в значення першого аргументу зі списку
      аргументів. Якщо значення встановлене в "salt", він друкує "pepper", але
      якщо це рядок "chips", він друкує "salsa", і так далі. Випадок по
      замовчанню вказаний підкресленням ( _ ), підстановочним символом, що часто
      використовується в Scala як замінник для повністю невідомого значення.</p>
    <p>Є декілька важливих відмінностей від твердження Java switch. Одна полягає
      в тому, що любий тип констант, а також інших речей, може використовуватись
      в&nbsp;cases Scala, не тільки цілі типи та enum константи, як в
      твердженнях Java case. В Лістингу 7.14 альтернативами є рядки. </p>
    <pre class="prettyprint linenums language-scala">val firstArg = if (args.length &gt; 0) args(0) else ""
firstArg match {
  case "salt" =&gt; println("pepper")
  case "chips" =&gt; println("salsa")
  case "eggs" =&gt; println("bacon")
  case _ =&gt; println("huh?")
}</pre>
    <p>Лістинг 7.14 Вираз match з побічними ефектами.</p>
    <p>Інша різниця в тому, що немає break на кінці кожної альтернативи. Замість
      цього break є неявними, немає провалювання від одної альтернативи до
      наступної. Загальний випадок — не провалюватись — стає коротшим, та
      уникається витока помилок, оскільки програмісти не можуть більше
      провалитись випадково. Найбільш важлива різниця з Java switch, однак. може
      полягати в тому, що вирази match повертають значення. В попередньому
      прикладі кожна альтернатива в виразі match роздруковує значення. Це може
      робити так само, як повернення значення замість його друку, як показує
      Лістинг 7.15. Значення, що повертається з виразу match, зберігається в
      змінній friend. Крім того, що код стає коротшим (щонайменьше в частині
      токенів), тепер код розплутує дві різні турботи: зпершу він обирає їжу, та
      потім друкує її.</p>
    <pre class="prettyprint linenums language-java">val firstArg = if (!args.isEmpty) args(0) else ""
val friend =
  firstArg match {
    case "salt" =&gt; "pepper"
    case "chips" =&gt; "salsa"
    case "eggs" =&gt; "bacon"
    case _ =&gt; "huh?"
  }
println(friend)</pre>
    <p>Лістинг 7.15 Вираз match, що повертає значення.</p>
    <h3>7.6 Життя без break та continue</h3>
    <p>Можливо, ви помітили, що ми не споминали про break або continue. Scala
      живе без ціх команд, оскільки вони не дуже гарно перетинаються з
      функціональними літералами, можливістю, описаною в наступній главі.
      Зрозуміло, що continue означає в циклі while, але що це має значити в
      функціональному літералі?</p>
    <p>Хоча Scala підтримує обоє, імперативний та функціональний стилі
      програмування, в цьому випадку вона трохи схиляється до функціонального
      програмування, в обмін на спрощення мови. Однак не турбуйтесь. Є багато
      способів програмувати без break та continue, та якщо ви приймете переваги
      функціональних літералів, ці альтернативи будуть загалом коротші, ніж
      оригінальний код.</p>
    <p>Простіший підхід є замінити кожне continue на if, та кожний break на
      логічне значення. Логічне значення вказує, чи замикаючий цикл повинен
      продовжуватись. Наприклад, уявіть, що ви шукаєте серед списку аргументів
      рядок, що закінчується на ".scala", але не починається на мінус. В Java ви
      можете, якщо ви прихильник циклів while, break, та continue, написати
      наступне:</p>
    <pre class="prettyprint linenums language-scala">int i = 0;
// Це Java
boolean foundIt = false;
while (i &lt; args.length) {
    if (args[i].startsWith("-")) {
        i = i + 1;
        continue;
    }
    if (args[i].endsWith(".scala")) {
        foundIt = true;
        break;
    }
    i = i + 1;
}</pre>
    <p>Щоб траслювати цей код Java напряму в Scala, замість робити if, та потім
      continue, ви можете написати if, що оточує цілий цикл while. Щоб позбутись
      break, ви можете звичайно додати логічну змінну, що вказує, чи треба
      продовжувати, але в цьому випадку ви можете використати foundIt.
      Використовуючи обоє з ціх трюків, код перетворюється на показаний в
      Лістингу 7.16.</p>
    <pre class="prettyprint linenums language-scala">var i = 0
var foundIt = false
while (i &lt; args.length &amp;&amp; !foundIt) {
  if (!args(i).startsWith("-")) {
    if (args(i).endsWith(".scala"))
      foundIt = true
  }
  i = i + 1
}</pre>
    <p>Лістинг 7.16 Цикл без break та continue.<br>
      <br>
      Цей код Scala в Листингу 7.16 досить подібний до оригінального кода Java.
      Всі базові частини ідуть в тому ж порядку. Є дві обумовлені змінні та цикл
      while. В циклі є перевірка, що i менше ніж args.length, перевірка на "-",
      та перевірка на ".scala". Якщо ви бажаєте прибрати var з Лістингу 7.16,
      один підхід, що ви можете спробувати, це переписати цикл як рекурсивну
      функцію. Ви можете, наприклад, визначити функцію searchFrom, що сприймає
      ціле на вході, шукає далі з цього місця, та потім повертає індекс бажаного
      аргументу. Використовуючи цей прийом код буде виглядати як показано в
      Лістингу 7.17: </p>
    <pre class="prettyprint linenums language-scala">def searchFrom(i: Int): Int =
  if (i &gt;= args.length) -1
  else if (args(i).startsWith("-")) searchFrom(i + 1)
  else if (args(i).endsWith(".scala")) i
  else searchFrom(i + 1)
val i = searchFrom(0)</pre>
    <p>Лістинг 7.17 Рекурсивна альтернатива циклу з var.</p>
    Версія в Лістингу 7.17 отримує зрозуміле людині ім'я того, що робить
    функція, та вона використовує рекурісію для заміни цикла. Кожне continue
    замінене на рекурсивний виклик з i + 1 в якості аргумента, ефективно
    просуваючись до наступного цілого. Багато людей знаходять цей стиль
    програмування простішим до розуміння, коли вони починають використовувати
    рекурсію.
    <h4>Зауваження</h4>
    Компілятор Scala не буде насправді створювати рекурсивну функцію для кода,
    показаного в Лістингу 7.17. Оскільки всі рекурсивні виклики знаходяться в
    самому кінці, компілятор згенерує код, подібний до циклу while. Кожний
    рекурсивний виклик буде реалізовано як стрибок назад до початку функції.
    Оптимізація кінцевих викликів буде обговорюватись в Розділі 8.9.<br>
    <br>
    Якщо після всіх ціх розмов ви все ще потребуєте використання break, на поміч
    прийде стандартна бібліотека Scala. Клас Breaks в пакунку scala.util.control
    пропонує метод break, що може застосовуватись для виходу з оточуючого блоку,
    що помічений як breakable. Ось приклад, як можна застосовувати цей, наданий
    бібліотекою, метод break:<br>
    <pre class="prettyprint linenums language-scala">import scala.util.control.Breaks._
import java.io._
<br>val in = new BufferedReader(new InputStreamReader(System.in))
<br>breakable {<br>  while (true) {
    println("? ")
    if (in.readLine() == "") break
  }
}</pre>
    Це буде постійно читати непорожні рядки зі стандартного входу. Як тільки
    пористувач вводить пустий рядок, потік керування виходить з оточуючого
    breakable, та, разом з цім, з циклу while. Клас Breaks реалізує break через
    підняння виключення, що перехоплюється оточуючим застосуванням метода
    breakable. Таким чином, виклик break не обов'язково повинен бути в тому ж
    методі, що і виклик breakable.<br>
    <h3>7.7 Поле зору змінних</h3>
    Тепер, коли ви побачили вбудовані структури Scala, ми будемо викристовувати
    їх в цьому розділі для пояснення, як робить поле зору змінних в Scala.<br>
    <h4>Швидка орієнтація для Java програмістів</h4>
    Якщо ви Java програміст, ви знайдете, що правила поля зору Scala майже
    ідентичні до Java. Однак існує одна різниця між Java та Scala:&nbsp; Scala
    дозволяє вам визначати змінні з тими ж іменами у вкладених полях зору. Таким
    чином, якщо ви Java програміст, ви маєте хоча б переглянути цей розділ.<br>
    <br>
    Декларації змінних в програмах Scala мають поле зору, що визначає, де ви
    можете використовувати це ім'я. Найбільш загальний приклад поля зору є
    фігурні дужки, що зазвичай визначають нове поле зору, так що все, що
    визначене в фігурних дужках знаходиться за полем зору після замикаючих
    дужок. В якості ілюстрації розглянемо функцію, показану на Лістингу 7.18.<br>
    <pre class="prettyprint linenums language-scala">def printMultiTable() {
  var i = 1
// в полі зору тільки i
  while (i &lt;= 10) {
    var j = 1
// в полі зору i та j
    while (j &lt;= 10) {
      val prod = (i * j).toString
// в полі зору i, j, prod
      var k = prod.length
// в полі зору i, j, prod, k
      while (k &lt; 4) {
        print(" ")
        k += 1
      }
      print(prod)
      j += 1
    }
// в полі зору все ще i та j; prod та k за полем зору
    println()
    i += 1
  }
// i все ще в полі зору; j, prod, k за полем зору
}
</pre>Лістинг 7.18 Поле зору змінних при друкуванні таблиці множення.<br>
    <br>
    Функція printMultiTable, показана в Лістингу 7.18 друкує таблицю множення.
    Перше твердження цієї функції вводить змінну на ім'я i, та ініціалізує її
    цілим 1. Потім ви можете використовувати ім'я i на протязі всієї функції.<br>
    <br>
    Наступне твердження printMultiTable є цикл while:<br>
    <pre class="prettyprint linenums language-scala">while (i &lt;= 10) {
  var j = 1
  ...
}</pre>
    <br>
    Ви можете використовувати тут i, оскільки вона все ще в полі зору. В першому
    твердженні в ціклі while ви вводите іншу змінну, на цей раз з ім'ям j, та
    знову ініціалізуєте її в 1. Оскільки змінна j була визначена в відкриваючих
    фігурних дужках циклу while, вона може використовуватись тільки в циклі
    while. Якщо ви спробуєте зробить будь-що з j після закриваючих фігурних
    дужок цього циклу while, де коментар каже, що&nbsp; j, prod, k за полем
    зору, ваша програма не буде компілюватись.<br>
    <br>
    Всі змінні, визначені в цьому прикладі —&nbsp; i, j, prod, k — є локальними
    змінними. Такі змінні є "локальними" відносно функції, в якій вони
    визначені. Кожного разу, коли викликається функція, використовується новий
    набір локальних змінних.<br>
    <br>
    Коли визначається змінна, ви не можете визначити нову змінну з тим же ім'ям
    в тому ж полі зору. Наприклад, наступний скрипт з двома зміними на ім'я a в
    одному полі зору не будуть компілюватись:<br>
    <pre class="prettyprint linenums language-scala">val a = 1
val a = 2 // не компілюється
println(a)</pre>
    З другого боку ви можете визначити змінну у внутрішньому полі зору.
    Наступний скрипт буде компілюватись і виконуватись:<br>
    <pre class="prettyprint linenums language-scala">val a = 1;
{
  val a = 2 // компілюється дуже добре
  println(a)
}
println(a)</pre>
    При виконанні скрипт, показаний раніше, буде друкувати 2, потім 1, оскільки
    a, визнчаена в фігурних дужках, є окремною змінною, що є в полі зору до
    закриття замикаючих фігурних дужок. Одна відмінність, що треба зауважити,
    між Scala та Java, полягає в тому, що на відмінність від Scala, Java не
    дозволяє вам створювати змінну у внутрішньому полі зору, що має те є ім'я,
    що і змінна у зовнішньому. В програмі Scala кажуть, що внутрішня змінна
    затіняє зовнішню змінну з тією ж назвою, оскікльи зовнішня змінна стає
    невидімою у внутрішньому полі зору. Ви могли помітити щось, що виглядає як
    затінення, в інтерпретаторі:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; val a = 1
a: Int = 1
scala&gt; val a = 2
a: Int = 2
scala&gt; println(a)
2</pre>
    В інтерпретаторі ви можете повторно використовувати імена змінних згідно за
    покликом серця. Поміж інших речей, це дозволяє вам змінювати вашу думку,
    якщо ви зробили помилку під час визначення змінної в перший раз в
    інтерпретаторі. Причина, чому ви можете робити це, концептуально полягає в
    тому, що інтерпретатор створює нові вкладені поля зору для кожного нового
    твердження, що ви набираєте. Таким чином, ви можете візуалізувати попередньо
    інтерпретований код таким чином:<br>
    <pre class="prettyprint linenums language-scala">val a = 1;
{
  val a = 2;
  {
    println(a)
  }
}</pre>
    <br>
    Цей код буде компілюватись і виконуватись як Scala скрипт, та і як код,
    введений в інтерпретатор, буде друкувати 2. Майте на увазі, що такий код
    може бути дуже збентежливим для читачів, оскільки імена отримують нове
    значення у вкладених полях зору. Зазвичай краще обрати нове, значуще ім'я
    змінної, ніж затінювати зовнішню змінну.<br>
    <h3>7.8 Рефакторинг імперативного стилю кода&nbsp;</h3>
    Щоб допомогти вам отримати уявлення щодо функціонального стилю, цей розділ
    буде присвячений рефакторингу&nbsp; імперативного підоходу до друку таблиці
    множення, показаній в Лістингу 7.18. Наша функціональна альтернатива
    показана в Лістингу 7.19.<br>
    <br>
    Імперативний стиль виказує себе в Лістингу 7.18 в два способи. Перше, виклик
    printMultiTable має побічний ефект: друк таблиці множення на стандартний
    вивід. В Лістингу 7.19 ми робимо рефакторинг функції, щоб вона повертала
    таблицю множення як рядок. Оскільки функція більше не друкує, ми
    переіменовуємо її на multiTable. Як ми вже казали, одна з переваг функції
    без побічних ефектів в тому, що вони простіші до юніт тестування. Щоб
    протестувати printMultiTable вам треба дещо перевизначити print та println,
    так що ви можете перевірити вивід на коректність. Ви можете тестувати
    multiTable більш просто, перевіряючи отриманий рядок.<br>
    <br>
    Інша промовиста ознака імперативного стилю printMultiTable є її цикл while
    та var. На відміну, функція multiTable використовує val, вирази for,
    допоміжні функції, та виклики до mkString.<br>
    <pre class="prettyprint linenums language-scala">// Повертає рядок таблиці як послідовність
def makeRowSeq(row: Int) =
  for (col &lt;- 1 to 10) yield {
    val prod = (row * col).toString
    val padding = " " * (4 - prod.length)
    padding + prod
  }
<br>// Повертає рядок таблиці як рядок смволів
def makeRow(row: Int) = makeRowSeq(row).mkString
<br>// Повертає таблицю як рядок сиволів
def multiTable() = {
  val tableSeq = // послідовність рядків таблиці
    for (row &lt;- 1 to 10)
      yield makeRow(row)
  tableSeq.mkString("\n")
}</pre>
    <br>
    Лістинг 7.19 Функціональний спосіб створити таблицю множення.<br>
    <br>
    Ми виділили дві допоміжні функції, makeRow та makeRowSeq, щоб зробити код
    простішим до читання. Функція makeRowSeq використовує вираз for, чий
    генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього for обчислює
    множення номерів рядка і стовпчика, визначає відступ, потірбний для добутку,
    та видає результат конкатенації рядків вирівнювання та добутку. Результатом
    виразу for буде послідовність (деякий субклас scala.Seq), що містить ці
    отримані рядки в якості елементів.<br>
    <br>
    Інша допоміжна функція, makeRow, просто викликає mkString на результаті, що
    повертає makeRowSeq. mkString буде конкатенувати рядки в послідовності, та
    поверне їх як один рядок.<br>
    <br>
    Метод multiTable спершу ініціалізує tableSeq за допомогою результата for
    вираза, чий генератор ітерує по рядках від 1 до 10, та для кожного викликає
    makeRow, щоб отримати результати для цього рядка. Це результати потрапляють
    в yield, і, таким чином, результатом виразу for буде послідовність рядків.
    Одне завдання, що залишилось, є конвертація послідовності рядків в один
    рядок. Виклик mkString забезпечує це, та якщо ми передаємо "\n", ми
    отримуємо вставку вимволів нового рядка між кожними рядками. Якщо ми
    передамо рядок, повернений multiTable, на println, ви побачите, що отримано
    той самий вивід, що і продукує виклик до printMultiTable:<br>
    <br>
    1&nbsp; &nbsp; 2&nbsp;&nbsp; 3 &nbsp; 4 &nbsp; 5 &nbsp; 6 &nbsp; 7 &nbsp; 8
    &nbsp; 9&nbsp; 10 <br>
    2&nbsp; &nbsp; 4 &nbsp; 6 &nbsp; 8&nbsp; 10 12 14 16 18 20<br>
    3 &nbsp;&nbsp; 6&nbsp;&nbsp; 9&nbsp; 12 15 18 21 24 27 30 &nbsp; <br>
    4&nbsp;&nbsp;&nbsp; 8&nbsp; 12 16 20 24 28 32 36 40 <br>
    5&nbsp;&nbsp; 10 15 20 25 <br>
    6 &nbsp; 12 18 24 30<br>
    7&nbsp;&nbsp; 14 21 28 35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . . . . . . <br>
    8 &nbsp; 16 24 32 40<br>
    9&nbsp;&nbsp; 18 27 36 45 <br>
    10 20 30 40 50 <br>
    <h3>Висновок</h3>
    Вбудовані структури управління Scala є мінімальними, але вони виконують свою
    роботу. Вони діють здебільшого як їх імперативні еквіваленти, але оскільки
    вони мають тенденцію повертати значення, вони також підтримують
    функціональний стиль. Так само важливо, вони уважні щодо того, чого вони
    уникають, таким чином залишаючи простір для однієї з найбільш потужних
    можливостей Scala, функціональних літералів, що будуть описані в наступній
    главі.<br>
    <br>
    <h4>Глава 8</h4>
    <h2>Функції та замикання</h2>
    Коли програми стають більшими, вам треба деякий спосіб поділити їх на
    меньші, більш керовані частини. Щоб поділити потік керування Scala пропонує
    підхід, знайомий для всіх досвідчених програмістів: розділити код на
    функції. Фактично, Scala пропонує декілька шляхів для визначення функцій, що
    не присутні в Java. Окрім методів, що є функціями-членами деякого об'єкта, є
    також функції, вкладені в функції, функціональні літерали, та функціональні
    значення. Ця глава запрошує вас в подорож по всіх ціх різновидах функцій в
    Scala.<br>
    <h3>8.1 Методи</h3>
    Найбільш загальним шляхом визначити функцію в вигляді члена деякого об'єкта.
    Така функція називається методом. Як приклад, Лістинг 8.1 показує два
    методи, що разом читають файл з заданим ім'ям, та роздруковують всі рядки,
    чия довжина перебільшуе надану довжину. Кожний наданий рядок зпеерду має
    ім'я файла, де він трапився.<br>
    <br>
    Метод processFile приймає ім'я файла та ширину, як параметри.Він створює
    об'єкт Source з імені файла, та в генератоі виразу for, викликає getLines на
    джерелі рядків. Як зазначалось на Кроці 12 Глави 3, getLines повертає
    ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи
    символи нового рядка.Вираз for обробляє кожний з ціх рядків, викликаючи
    допоміжний метод, processLine.<br>
    <br>
    Метод processLine приймає три параметри: ім'я файла, ширину, та рядок.
    Він&nbsp; перевіряє, чи довжина рядка більша, ніж надана ширина, та, якщо
    так, він друкує ім'я файла, двокрапку, та рядок.
    <pre class="prettyprint linenums language-scala">import scala.io.Source
object LongLines {
  def processFile(filename: String, width: Int) {
    val source = Source.fromFile(filename)
    for (line &lt;- source.getLines())
      processLine(filename, width, line)
  }
  private def processLine(filename: String,
    width: Int, line: String) {
    if (line.length &gt; width)
      println(filename +": "+ line.trim)
  }
}</pre>
    Лістинг 8.1 LongLines з приватним методом processLine.<br>
    <br>
    Щоб використати LongLines з командного рядка, ми створимо застосування, що
    очікує ширину рядка в якості першого аргумента командного рядка, та
    інтерпретує наступні аргументи як імена файлів:
    <pre class="prettyprint linenums language-scala">object FindLongLines {
  def main(args: Array[String]) {
    val width = args(0).toInt
    for (arg &lt;- args.drop(1))
      LongLines.processFile(arg, width)
  }
}</pre>
    Ось як ви використовуєте це застосування для пошуку рядків в
    LongLines.scala, що більше 45 символів в довжину (він там тільки один):
    <pre class="prettyprint linenums language-scala">$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) {</pre>
    До цього моменту все дуже подібне до того, що ви можете зробити в
    об'єктно-орієнтованій мові. Однак, концепція функції в Scala є більш
    загальною, ніж метод. Інші шляхи Scala для вираження функцій будуть пояснені
    в наступних розділах.<br>
    <h3>8.2 Локальні функції</h3>
    Конструкція метода processFile в попередньому розділі демонструє важливий
    принцип розробки функціонального стилю програмування: програми повинні бути
    декомпоновані на багато меньших функцій, кожна з яких робить гарно визначену
    роботу. Окремі функції часто є досить малими. Перевага цього стилю в тому,
    що він надає прогармісту багато будівельних блоків, що можуть бути гнучко
    скомпоновані в більш складні речі. Кожний будівельний блок повинен бути
    досить простим, щоб бути зрозумілим індивідуально.<br>
    <br>
    Одна з проблем цього підхода в тому, що всі імена допоміжних функцій можуть
    забруднити програмний простір імен. В інтерпретаторі це не є великою
    проблемою, але тільки функції пакуються в повторно використовувані класи та
    об'єкти, бажано приховати допоміжні функції від клієнтів класа. Вони часто
    поодинці не мають сенсу, та ви часто бажаєте залишити досить гнучкості, щоб
    видалити допоміжні функції, якщо ви пізніше перепишете клас іншим шляхом.<br>
    <br>
    В Java вашим головним інструментом для ціх цілей є приватний метод. Цей
    підхід приватних методів робить також і в Scala, як продемонстровано в
    Лістингу 8.1, але Scala пропонує додатковий підхід: ви можете визначити
    функції в інших функціях. Точно як і локальні змінні, такі локальні функції
    видимі тільки в оточуючому блоці. Ось приклад:
    <pre class="prettyprint linenums language-scala">def processFile(filename: String, width: Int) {
  def processLine(filename: String,
    width: Int, line: String) {
    if (line.length &gt; width)
      println(filename +": "+ line)
  }
  val source = Source.fromFile(filename)
  for (line &lt;- source.getLines()) {
    processLine(filename, width, line)
  }
}</pre>
    В цьому прикладі ми рефакторимо оригінальну версію LongLines, показану в
    Лістингу 8.1, трансформуючи приватний метод processLine в локальну функцію
    processFile. Для цього ми видаляємо приватний модифікатор, що може
    застосовуватись (та тільки потрібен) для методів, та розташували визначення
    processLine всередині визначення processFile. Як локальна функція,
    processLine в полі зору в processFile, але недосяжна ззовні.<br>
    <br>
    Тепер ця processLine визначена в processFile, однак, стає можливим інше
    покращення. Помітили, як ім'я файлу та ширина передаються без змін до
    допоміжної функції? Це не потірбне, оскільки локальні функції можуть мати
    доступ до параметрів їх оточуючої функції. Ви можете просто використовувати
    параметри зовнішньої функції processLine, як показано в Лістингу 8.2:
    <pre class="prettyprint linenums language-scala">import scala.io.Source
object LongLines {
  def processFile(filename: String, width: Int) {
    def processLine(line: String) {
      if (line.length &gt; width)
        println(filename +": "+ line)
    }
    val source = Source.fromFile(filename)
    for (line &lt;- source.getLines())
      processLine(line)
  }<br>}</pre>
    Лістинг 8.2 LongLines з локальною функцією.<br>
    <br>
    Простіше, чи не так? Це використання параметрів оточующої функції&nbsp; є
    загальним та корисним прикладом загального вкладання, що провадить Scala.
    Вкладання та поле зору, описані в Розділі 7.7, стосуються до всіх
    конструкцій Scala, включаючи функції. Це простий, принцип, але дуже
    потужний, особливо в мові з першокласними функціями.<br>
    <h2>8.3 Першокласні функції</h2>
    Scala має першокласні функції. Ви не тільки можете визначити функції, та
    виклиати їх, але ви можете записати функції як неіменовані літерали, та
    потім передати їх кудись як значення. Ми ввели функціональні літерали в
    Главі 2, та базовий синтаксис показаний на Малюнку 2.2.<br>
    <br>
    Функціональні літерали компілюються в клас, що потім втілюється під час
    виконання як значення функції. Таким чином, різниця між функціональним
    літералом та значеннями в тому, що функціональні літерали існують в
    первинному коді, тоді як значення функцій існує як об'єкт під час виконання.
    Різниця здебільшого така, як між класами (початковий код) та об'єкти (час
    виконання). Ось простий приклад функціонального літерала, що додає один до
    числа:
    <pre class="prettyprint linenums language-scala">(x: Int) =&gt; x + 1</pre>
    Знак =&gt; позначає, що ця функція конвертує річ зліва (любе ціле x ) на річ
    зправа ( x + 1 ). Таким чином, ця функція відображує любе ціле x на x + 1.<br>
    <br>
    Функціональні значення є об'єктами, так що ви можете зберігати їх, якщо
    побажаєте, в змінних. Вони також функції, так що ви можете викликати їх з
    використанням звичайної нотації виклику функції з дужками. Ось приклад обох
    активностей:
    <pre class="prettyprint linenums language-scala">scala&gt; var increase = (x: Int) =&gt; x + 1
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
res0: Int = 11</pre>
    Оскільки increase, в цьому випадку, є змінна var, ви можете з часом
    перепризначити їй інше функціональне значення.
    <pre class="prettyprint linenums language-scala">scala&gt; increase = (x: Int) =&gt; x + 9999
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
res1: Int = 10009</pre>
    Якщо ви бажаєте мати більш ніж одне твердження в функціональному літералі,
    оточіть його тіло фігурними дужками, та розташуйте одне твердження в рядок,
    таким чином формуючи блок. Так само як метод, коли викликається значення
    функції, всі твердження будуть виконані, та значення, повернуте від функції
    буде тим, що обчислює останній рядок.
    <pre class="prettyprint linenums language-scala">scala&gt; increase = (x: Int) =&gt; {
println("We")
println("are")
println("here!")
x + 1
}
increase: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; increase(10)
We
are
here!
res2: Int = 11</pre>
    Так що тепер ви бачили шестерні функціональних літералів та функціональних
    значень. Багато бібліотек Scala дають вам можливість використовувати їх.
    Наприклад, метод foreach доступний для всіх колекцій. Він приймає функцію як
    аргумент, та викликає цю функцію для кожного з його елементів. Ось як це
    може бути використано для друку всіх елементів списку:
    <pre class="prettyprint linenums language-scala">scala&gt; val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala&gt; someNumbers.foreach((x: Int) =&gt; println(x))
-11
-10
-5
0
5
10</pre>
    Як інший приклад, типи колекцій також мають метод filter. Цей метод обирає
    ті елементи з колекції, що проходять перевірку, що надає користувач. Ця
    перевірка надається в вигляді функції. Наприклад, функція (x: Int) =&gt; x
    &gt; 0 може бути використана для фільтрації. Ця функція відображує додатні
    цілі на true, та всі інші на false. Ось як використовувати цей фільтр:
    <pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter((x: Int) =&gt; x &gt; 0)
res4: List[Int] = List(5, 10)</pre>
    Методи як foreach та filter описані далі в цій книзі. Глава 16 розкаже щодо
    їх використання в класі List. Глава 17 обговорює їх використання з іншими
    типуми колекцій.<br>
    <h3>8.4 Скорочені форми функціональних літералів</h3>
    Scala провадить декілька шляхів відкинути непотрібну інформацію та записати
    функціональні літерали більш коротко. Держіть ваші очі відкритими щодо ціх
    можливостей, оскільки вони дозволяють вам видалити непотріб з вашого кода.<br>
    <br>
    Один спосіб зробити функціональний літерал більш коротким є відкинути типи
    параметрів. Таким чином, попередній приклад з filter може бути записаний
    таким чином:
    <pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter((x) =&gt; x &gt; 0)
res5: List[Int] = List(5, 10)</pre>
    Компілятор Scala знає, що x має бути цілим, оскільки він бачить, що ви
    безпосередньо використовуєте використовуєте функцію для фільтрації списка
    цілих (посилається на деякий someNumbers ). Це називається цільовою
    типізацією, оскільки цільове використання виразу — в цьому випадку аргумент
    до someNumbers.filter() — може впливати на тип виразу — в цьому випадку для
    визначення типу параметра x. Точні деталі цільової типізації не важливі для
    вивчення. Ви можете просто почати писати функціональні літерали без типу
    аргумента, та, якщо компілятор буде сконфужений, додати тип. З часом ви
    отримаєте відчуття, для яких ситуацій компілятор може, та для яких не може
    розв'язати загадку.<br>
    <br>
    Другий шлях для видалення некорисних символів, є відкидання дужок кругом
    параметра, чий тип виведений. В попередньому прикладі дужки кругом x не
    потрібні:
    <pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(x =&gt; x &gt; 0)
res6: List[Int] = List(5, 10)</pre>
    <h3>8.5 Синтаксис заміщувача</h3>
    Щоб зробити синтаксис функціонального літерала навіть ще стилсішим, ви
    можете використати підкреслення як заміщувачі для одного або більше
    параметрів, доки кожний параметр зустрічається тільки один раз в
    функціональному літералі. Наприклад, _ &gt; 0 є дуже короткою нотацією для
    функції, що перевіряє, чи значення більше ніж ноль:
    <pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(_ &gt; 0)
res7: List[Int] = List(5, 10)</pre>
    Ви можете думати про підкреслення я "пропуск" в виразі, що має бути
    "заповнено". Цей проміжок буде заповнений аргументом функції, кожного разу,
    коли викликається функція. Наприклад, беручи що цей someNumbers був
    ініціалізований в значення List(-11, -10, -5, 0, 5, 10), метод фільтра буде
    заміняти проміжок в _ &gt; 0 спочатку -11, як в виразі -11 &gt; 0, потім на
    -10, як в -10 &gt; 0, потім на -5, як в -5 &gt; 0, і так далі до кінця List.
    Функціональний літерал _ &gt; 0, таким чином, еквівалентний до трихи більш
    балакучого x =&gt; x &gt; 0, як продемонстровано тут:
    <pre class="prettyprint linenums language-scala">scala&gt; someNumbers.filter(x =&gt; x &gt; 0)
res8: List[Int] = List(5, 10)</pre>
    Іноді при використанні підкреслень для заміщення параметрів, компілятор не
    має достатньо інформації, щоб вивестивідсутні типи параметрів. Наприклад,
    уявімо, ви пишете _ + _:
    <pre class="prettyprint linenums language-scala">scala&gt; val f = _ + _
&lt;console&gt;:4: error: missing parameter type for expanded
function ((x$1, x$2) =&gt; x$1.$plus(x$2))
val f = _ + _
        ˆ</pre>
    В таких випадках ви можете вказати типи з використанням двокрапки:
    <pre class="prettyprint linenums language-scala">scala&gt; val f = (_: Int) + (_: Int)
f: (Int, Int) =&gt; Int = &lt;function2&gt;
scala&gt; f(5, 10)
res9: Int = 15</pre>
    Зауважте, що _ + _ розширюється в літерал для функції, що приймає два
    параметри. Ось чому ви можете використовувати цю коротку форму, тільки якщо
    параметри з'являються в функціональному літералі тільки один раз. Декілька
    підкреслень озжначають декілька параметрів, не повторне використання одного
    параметру. Перше підкреслення представляє перший параметр, друге
    підкреслення другий параметр, третє підкреслення третій параметр, і так
    далі.<br>
    <h3>8.6 Частково застосовані функції</h3>
    Хоча попередні приклади заміняють підкреслення замість індивідуальних
    параметрів, ви можете також замінити цілий список параметрів на
    підкреслення. Наприклад, скоріше ніж писати println(_), ви можете записати
    println _ . Ось приклад:
    <pre class="prettyprint linenums language-scala">someNumbers.foreach(println _)</pre>
    Scala трактує цю коротку форму точно так, якби ви написали наступне:
    <pre class="prettyprint linenums language-scala">someNumbers.foreach(x =&gt; println(x))</pre>
    Таким чином, підкреслення в цьому випадку не є заміщувачем одного параметра.
    Це заміщувач для всього списка параметрів. Пам'ятайте, що вам треба залишити
    проміжок між ім'ям функції та підкресленням, оскільки інакше компілятор буде
    думати, що ви посилаєтесь на інший символ, для цього приклада на метод з
    ім'ям println_, що, скоріше всього, не існує.<br>
    <br>
    Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково
    застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи всі
    потрібні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад,
    маючи таку функцію:
    <pre class="prettyprint linenums language-scala">scala&gt; def sum(a: Int, b: Int, c: Int) = a + b + c
sum: (a: Int,b: Int,c: Int)Int</pre>
    Ви можете застосувати функцію sum до аргументів 1, 2, та 3, таким чином:
    <pre class="prettyprint linenums language-scala">scala&gt; sum(1, 2, 3)
res10: Int = 6</pre>
    Частково застосована функція є виразом, і якому ви не надаєте всі аргументи,
    потрібні для функції. Замість цього, ви надаєте деякі, або жодних, з
    потрібних аргументів. Наприклад, щоб створити вираз частково застосованої
    функції, що використовує sum, до якої ви можете надати жодного з трьох
    потрібних аргументів, ви тільки покладаєте підкреслення після "sum".
    Отримана функція потім може бути збережена в змінній. Ось приклад:
    <pre class="prettyprint linenums language-scala">scala&gt; val a = sum _
a: (Int, Int, Int) =&gt; Int = &lt;function3&gt;</pre>
    Маючи цей код, компілятор Scala створює примірник значення функції, що
    приймає три цілі параметри, що відсутні в виразі частково застосованої&nbsp;
    функції, sum _, та присвоює посилання цього нового значення функції змінній
    a. Коли ви застосовуєте три аргументи до цього нового значення функції, вона
    замкнеться, та викличе sum, передаючи ці самі три аргументи:
    <pre class="prettyprint linenums language-scala">scala&gt; a(1, 2, 3)
res11: Int = 6</pre>
    Ось що тільки но відбулось: змінна на ім'я a посилається на об'єкт
    функціонального значення. Ця значення функції є примірником класа,
    згенерованого автоматично компілятором Scala з sum _, вираза частково
    застосованої функції.<br>
    <br>
    Згенерований компілятором клас має метод apply, що приймає три аргументи.
    Метод apply згенерованого класа приймає три аргументи, оскільки в виразі sum
    _ відсутні три аргументи. Компілятор Scala транслює вираз a(1, 2, 3) на
    виклик метода apply функціонального значення, передаючи туди три аргументи
    1, 2, та 3. Таким чином, a(1, 2, 3) є скороченням для:
    <pre class="prettyprint linenums language-scala">scala&gt; a.apply(1, 2, 3)
res12: Int = 6</pre>
    Цей метод apply, визначений в класі, згенерованому автоматично компілятором
    Scala з виразу sum _, посто передає ці три відсутні параметри до sum, та
    повертає результат. В цьому випадку apply викликає sum(1, 2, 3), та повертає
    що повертає sum, що є 6.<br>
    <br>
    Інший спосіб думати про цей тип виразів, де підкреслення використовується
    для представлення всього списку параметерів, як про спосіб трансформувати
    def на функціональне значення. Наприклад, якщо ви маєте локальну функцію,
    таку як sum(a: Int, b: Int, c: Int): Int, ви можете "огорнути" її в
    функціональне значення, чий метод apply має той же список параметрів та тип
    результата. Коли ви застосовуєте цю функціональне значення до деяких
    аргументів, вона в свою чергу застосовує sum до тих самих аргументів, та
    повертає результат. Хоча ви не можете присвоїти метод або вкладену функцію
    до змінної, або передати його як аргумент до іншої функції, ви можете
    зробити це, якщо ви огорнете метод або вкладену функцію в функціональне
    значення, розмістивши підкреслення після імені.<br>
    <br>
    Тепер, хоча sum _ насправді є частково застосованою функцією, для вас може
    бути не очевидним, чому вона так називається. Вона має це ім'я, оскільки ви
    не застосовуєте цю функцію до всіх аргументів. В випадку sum _, ви не
    застосовуєте її до жодного з аргументів. Але ви також можете виразити
    частково застосовану функцію, надаючи деякі, але не всі з потрібних
    аргументів. Ось приклад:
    <pre class="prettyprint linenums language-scala">scala&gt; val b = sum(1, _: Int, 3)
b: (Int) =&gt; Int = &lt;function1&gt;</pre>
    В цьому випадку, ви надали перший&nbsp; та останній аргументи до sum, але
    середній аргумент відсутній. Оскільки відсутній тільки один аргумент,
    компілятор Scala генерує новий функцінальний клас, чий метод apply приймає
    один аргумент. При виклику з цім аргументом, цей згенерований метод apply
    функції викликає sum, пеердаючи 1, аргумент, переданий до функції, та 3. Ось
    деякі приклади:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; b(2)
res13: Int = 6</pre>
    В цьому випадку b.apply викликав sum(1, 2, 3) .<br>
    <pre class="prettyprint linenums language-scala">scala&gt; b(5)
res14: Int = 9</pre>
    Та в цьому випадку b.apply викликав sum(1, 5, 3) .<br>
    <br>
    Якщо ви пишете вираз&nbsp; частково застосованої функції, в якій ви
    відкидаєте всі параметри, таку, як println _ або sum _, ви можете виразити
    це більш стисло, відкинувши також і підкреслення, якщо функція потрібна в
    цьому місці в коді. Наприклад, замість роздрукування кожного з чисел з
    someNumbers таким чином:
    <pre class="prettyprint linenums language-scala">someNumbers.foreach(println _)</pre>
    ви можете просто написати:<br>
    <pre class="prettyprint linenums language-scala">someNumbers.foreach(println)</pre>
    Ця остання форма дозволяється тільки в місцях, де потрібна функція, як в
    виклику foreach в цьому прикладі. Компілятор знає, що в цьому випадку
    потрібна функція, оскільки foreach потребує, що була передана функція в
    якості аргумента. В ситуаціях, де функція не потрібна, спроба
    використовувати цю форму призведе до помилки компіляції. Ось приклад:
    <pre class="prettyprint linenums language-scala">scala&gt; val c = sum
&lt;console&gt;:5: error: missing arguments for method sum...
follow this method with `_' if you want to treat it as a
partially applied function
val c = sum
        ˆ
scala&gt; val d = sum _
d: (Int, Int, Int) =&gt; Int = &lt;function3&gt;
scala&gt; d(10, 20, 30)
res15: Int = 60</pre>
    <h4>Чому завершуєче підкреслення?</h4>
    Синтаксис Scala для частково застосованих функцій наголошує на різниці в
    компромісах розробки Scala, та класичних функціональних мов, як Haskell або
    ML. В ціх мовах частково застосовані функції розглдаються як нормальний
    випадок. Більше того, ці мови мають досить строгу статичну систему типів,
    що, звичайно, буде виділяти кожну помилку з частковими застосуваннями, які
    ви можете зробити. Scala підтримує значно ближчі стосунки до імперативних
    мов, таких, як Java, де метод, що не застосовується до всіх аргументів,
    розглядається як помилка. Більше того, об'єктно-орієнтована традиція
    субтипів та універсального кореневого типу сприймає деякі програми, що
    можуть бути визнані помилковими в класичних функціональних мовах.<br>
    <br>
    Наприклад, скажімо, ви переплутали метод drop(n: Int) з List з<br>
    tail(), і, таким чином, забули передати число відкинутих елементів. Ви
    можете записати&nbsp; "println(drop)". Якби Scala адаптувала б класичну
    функціональну традицію, що частково застосовані функції годні будь-де, цей
    код пройшов би перевірку типів. Однак ви були б здивовані винайти, що вивід,
    надрукований цім твердженням println завжди буде &lt;function&gt; ! Що
    відбулось, це вираз drop був трактований як функціональний об'єкт. Оскільки
    println приймає об'єкти любого типу, це буде успішно компілюватись, але це
    може мати неочікувані результати.<br>
    <br>
    Щоб цникнути ситуацій як ця, Scala звичайно потребує, щоб ви вказували
    аргументи функції, що явно відкинуті, навіть якщо показчик такий простий, як
    ‘ _ ’. Scala дозволяє вам відкинути навіть&nbsp; _, але тільки очікується
    функція.<br>
    <h3>8.7 Замикання</h3>
    До сих пір в цій главі всі приклади функціональних літералів посилались
    тільки на передані параметри. Наприклад, в (x: Int) =&gt; x &gt; 0, єдина
    змінна, що використовується в тілі функції, є x, що визначена як параметр до
    функції. Ви можете, однак, посилатись на змінні, визначені деінде:
    <pre class="prettyprint linenums language-scala">(x: Int) =&gt; x + more
// що таке more?</pre>
    Ця функція додає "more" до свого аргументу, але що таке more? З цієї точки
    зору на цю функцію, more є вільною змінною, оскільки функціональний літерал
    сам по собі не дає цьому ради. Змінна x, на відміну від цього, є прив'язаною
    змінною, оскільки вона має смисл в контексті функції: вона визначена як
    єдиний параметр функції з типом Int. Якщо ви спробуєте використати цей
    функціональний літерал сам по собі, без жодного more, визначеного в полі
    зору, компілятор буде скаржитись:
    <pre class="prettyprint linenums language-scala">scala&gt; (x: Int) =&gt; x + more
&lt;console&gt;:5: error: not found: value more
(x: Int) =&gt; x + more
                 ˆ</pre>
    З іншого боку, той же функціональний літерал буде добре робити, доки дступне
    дещо доступне на ім'я more :
    <pre class="prettyprint linenums language-scala">scala&gt; var more = 1
more: Int = 1
scala&gt; val addMore = (x: Int) =&gt; x + more
addMore: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; addMore(10)
res17: Int = 11</pre>
    Значення функції (об'єкт), що створений під час виконання з функціонального
    літерала називається замиканням. Ім'я походить від дії "замикання"
    функціонального літерала через "захоплення" прив'язок вільних змінних.
    Функціональний літерал без вільних змінних, як (x: Int) =&gt; x + 1,
    називається замкнутим термом, де терм це шмат первинного кода. Таким чином,
    значення функції, створене під час виконання з функціонального літерала не є
    замиканням в найстогому сенсі, оскільки (x: Int) =&gt; x + 1 є вже закритим
    від написання. Але любий функціональний літерал з вільними змінними, такий
    як (x: Int) =&gt; x + more, є відкритим термом. Більше того, любе
    функціональне значення, створене під час виконання з (x: Int) =&gt; x + more
    буде по визначенню потребувати, щоб була захоплена прив'язка для його
    вільної змінної more. Результуюче значення функції, що буде містити
    посилання на захоплену змінну more, називається замиканням, оскільки
    значення функції є кінцевим продуктом акта закриття відкритого терма, (x:
    Int) =&gt; x + more.<br>
    <br>
    Цей приклад дає на запитання: що відбудеться, якщо more зміниться після
    створення замикання? В Scala відповідь така, що замикання бачить зміну.
    Наприклад:
    <pre class="prettyprint linenums language-scala">scala&gt; more = 9999
more: Int = 9999
scala&gt; addMore(10)
res18: Int = 10009</pre>
    Інтцітивно, замикання Scala захоплюють самі змінні, не значення, на які вони
    посилаються. Як демонструє попередній приклад, замикання, створене для (x:
    Int) =&gt; x + more бачить зміну more, зроблену ззовні замикання. Те ж саме
    вірне в зворотньому напрямку. Зміни, зроблені замиканням відносно захопленої
    змінної, видимі за межами замикання. Ось приклад:
    <pre class="prettyprint linenums language-scala">scala&gt; val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala&gt; var sum = 0
sum: Int = 0
scala&gt; someNumbers.foreach(sum += _)
scala&gt; sum
res20: Int = -11</pre>
    Цей приклад використовує обхідний шлях для підсумку чисел в List. Змінна sum
    з оточуючого поля зору для функціонального літерала sum += _, що додає числа
    до sum. Навіть вважаючи, що замикання модифікує sum під час виконання,
    результат, -11, все ще видиме ззовні замикання.<br>
    <br>
    Що, якщо замикання отримає доступ до деякої змінної, що має декілька копій
    під час виконання програми? Наприклад, якщо замикання використовує локальну
    змінну деякої функції, та функція викликається декілька раз? Який примірник
    цієї змінної використовується для кожного доступу?<br>
    <br>
    Тільки одна відповідь узгоджується з рештою мови: використаний примірник
    буде той, що був активний під час створення замикання. Наприклад, ось
    функція, що створює та повертає тип замикань "збільшити":
    <pre class="prettyprint linenums language-scala">def makeIncreaser(more: Int) = (x: Int) =&gt; x + more</pre>
    Кожного разу, коли викликається ця функція, вона буде створювати нове
    замикання. Кожне замкання буде отримувати змінну more, що була активною,
    коли замикання було створене.
    <pre class="prettyprint linenums language-scala">scala&gt; val inc1 = makeIncreaser(1)
inc1: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; val inc9999 = makeIncreaser(9999)
inc9999: (Int) =&gt; Int = &lt;function1&gt;</pre>
    Коли ви викликаєте makeIncreaser(1), створюється та повертається замикання,
    що захоплює значення 1 в якості прив'язки до more. Подібним чином, коли ви
    викликаєте makeIncreaser(9999), повертається замикання, що захоплює значення
    9999 для more. Коли ви застосовуєте ці замикання для аргументів (в цьому
    випадку є тільки один аргумент, x, що має бути переданий ззовні), результат,
    що повертається, залежить від того, як було визначене more при створені
    замикання:
    <pre class="prettyprint linenums language-scala">scala&gt; inc1(10)
res21: Int = 11
scala&gt; inc9999(10)
res22: Int = 10009</pre>
    Не має різниці, що more і цьому випадку є параметром до виклику метода, що
    вже скінчився. Компілятор Scala переставляє речі в випадках як цей, так що
    захоплений параметр живе на купі, замість стеку, і, таким чином, може
    пережити виклик метода, що створив його. Всі ці перестановки робляться
    автоматично, так що вам не треба хвилюватись щодо цього. Захоплюйте любу
    змінну, яку побажаєте: val, var, параметр.<br>
    <h4>8.8 Спеціальні форми виклику функцій</h4>
    Більшість функцій та функціональних викликів, що ви зустрінете, будуть
    такими, як ви вже бачили в цій главі. Функція буде мати фіксоване число
    параметрів, виклик буде мати рівне число аргументів, та аргументи будуть
    вказані в тому ж порядку і числі, що і параметри.<br>
    <br>
    Однак оскільки виклики функцій є такими центральними для програмування в
    Scala, декілька спеціальних форм функціональних визначень та викликів
    функцій були додані до мови, щоб покрити деякі особливі потреби. Scala
    підтримує повторювані параметри, іменовані аргументи, та аргументи по
    замовчанню.<br>
    <h4>Повторювані параметри</h4>
    Scala дозволяє вам вказати, що останній параметр функції може бути
    повторений. Це дозволяє клієнтам передавати до функції списки аргументів
    змінної довжини. Щоб задати повторюваний параметр, поставьте зірочку після
    типу параметра. Наприклад:
    <pre class="prettyprint linenums language-scala">scala&gt; def echo(args: String*) =
for (arg &lt;- args) println(arg)
echo: (args: String*)Unit</pre>
    Визначене таким чином, echo може бути викликане з нулем або багатьма
    аргументами String:
    <pre class="prettyprint linenums language-scala">scala&gt; echo()
scala&gt; echo("one")
one
scala&gt; echo("hello", "world!")
hello
world!</pre>
    Всередині функції тип поверненого параметра є Array декларованого типу
    параметру. Таким чином, тип аргументів в функції echo, що декларований як
    тип "String*" є насправді Array[String]. Тим не менш, якщо ви маєте масив
    відпоідного типу, та ви спробуєте передати його як повторюваний параметр, ви
    отримаєте помилку компіляції:
    <pre class="prettyprint linenums language-scala">scala&gt; val arr = Array("What's", "up", "doc?")
arr: Array[java.lang.String] = Array(What's, up, doc?)
scala&gt; echo(arr)
&lt;console&gt;:7: error: type mismatch;
found
: Array[java.lang.String]
required: String
echo(arr)
     ˆ</pre>
    Щоб досягти цього, вам треба додати до аргумента масива дві крапки та символ
    _* :
    <pre class="prettyprint linenums language-scala">scala&gt; echo(arr: _*)
What's
up
doc?</pre>
    Ця нотація каже компілятору передати кожний елемент arr як окремий аргумент
    до echo, скоріше ніж всі як один аргумент.<br>
    <h4>Іменовані аргументи</h4>
    В нормальному виклику функції аргументи виклику співадають один за одним в
    порядку параметрів викликаної функції:
    <pre class="prettyprint linenums language-scala">scala&gt; def speed(distance: Float, time: Float): Float =
distance / time
speed: (distance: Float,time: Float)Float
scala&gt; speed(100, 10)
res28: Float = 10.0</pre>
    В цьому виклику, 100 співпадає з distance, та 10 з time. 100 та 10 співпали
    в тому ж порядку, що і перелічені формальні параметри.<br>
    <br>
    Іменовані аргументи дозволяють вам передавати аргументи до функції в іншому
    порядку. Синтаксис такий, що кожний аргумент складається з імені, знака
    рівності та значення. Наприклад, наступний виклик speed еквівалентний
    speed(100,10):
    <pre class="prettyprint linenums language-scala">scala&gt; speed(distance = 100, time = 10)
res29: Float = 10.0</pre>
    Виклик з іменованими аргументами дозволяє обернути порядок без зміни
    значення:
    <pre class="prettyprint linenums language-scala">scala&gt; speed(time = 10, distance = 100)
res30: Float = 10.0</pre>
    Також можливо змішати позиціні та іменовані аргументи. В цьому випадку
    позиційні аргументи ідуть першими.<br>
    <br>
    Іменовані аргументи використовуються найбільш частов комбінації зі
    значеннями параметрів по замовчанню.<br>
    <h4>Значення параметрів по замовчанню</h4>
    Scala дозволяє вам вказати значення по замовчанню для параметрів функції.
    Аргумент для такого параметра може опціонально бути пропущений у виклику
    функції, в якому випадку відповідний аргумент буде заповнений по замовчанню.<br>
    <br>
    Приклад показаний в Лістингу 8.3. Функція printTime має один параметр, out,
    та він по замовчанню має значення Console.out.
    <pre class="prettyprint linenums language-scala">def printTime(out: java.io.PrintStream = Console.out) =
  out.println("time = "+ System.currentTimeMillis())</pre>
    Лістинг 8.3 Параметр зі значенням по замовчанню.<br>
    <br>
    Якщо ви викликаєте функцію як printTime(), тобто не вказуючи аргументів для
    out, тоді він буде встановлений в значення Console.out.<br>
    <br>
    Ви також можете викликати функцію з явним вказанням вихідного потоку.
    Наприклад, ви можете надіслати журналювання до стандарного потоку помилки,
    викликавши функцію як printTime(Console.err).<br>
    <br>
    Параметри по замовчанню особливо корисні, коли використовуються в комбінації
    з іменованими параметрами. В Лістингу 8.4 функція printTime2 має два
    опціональні параметра. Параметр out має замовчання Console.out, та параметр
    divisor має значення замовчання 1.<br>
    <br>
    Функція printTime2 може бути викликана як printTime2(), щоб мати обоє свої
    параметри заповненими значеннями по замовчанню. Однак з використанням
    іменованих параметрів один з них може бути встановлений, та інший залишитись
    по замовчанню. Щоб вказати вихідний потік, викличте так:
    <pre class="prettyprint linenums language-scala">def printTime2(out: java.io.PrintStream = Console.out,
divisor: Int = 1) =
out.println("time = "+ System.currentTimeMillis()/divisor)</pre>
    Лістинг 8.4 Функція з двома параметрами, що мають замовчання.
    <pre class="prettyprint linenums language-scala">printTime2(out = Console.err)</pre>
    Щоб вказати дільник часу, викличте так:
    <pre class="prettyprint linenums language-scala">printTime2(divisor = 1000)</pre>
    <h3>8.9 Кінцева рекурсія</h3>
    В Розділі 7.2 ми вказували, що трансформація цикла while, що оновлює var на
    більш функціональний стиль, що використовує тільки val, іноді потребуватиме
    від вас використання рекурсії. Ось приклад рекурсивної функції, що
    апроксимує значення, повторюючи покращення guess, докі він не буде досить
    гарним:
    <pre class="prettyprint linenums language-scala">def approximate(guess: Double): Double =
  if (isGoodEnough(guess)) guess
  else approximate(improve(guess))</pre>
    Функція такого типу часто використовується в проблемах пошуку, з
    відповідними реалізаціями для isGoodEnough та improve. Якщо ви бажаєте, щоб
    функція апроксимації робила швидше, ви можете мати спокусу написати її за
    допомогою цикла while, щоб спробувати пришвидшити її, таким чином:
    <pre class="prettyprint linenums language-scala">def approximateLoop(initialGuess: Double): Double = {
  var guess = initialGuess
  while (!isGoodEnough(guess))
    guess = improve(guess)
  guess
}</pre>
    <br>
    Яка з двох версій апроксімації має перевагу? В термінах кратості та
    уникнення var, перша, функціональна функція пермагає. Але чи є імперативний
    підхід більш ефективним? Фактично, якщо ми виміряємо час, він буде майже
    однаковим! Це може виглядати дивним, бо рекурсивний виклик виглядає більш
    коштовним, ніж простий стрибок від одного краю цикла на початок.<br>
    <br>
    Однак, в випадку апроксимації вище, компілятор Scala в змозі застосувати
    важливу оптимізацію. Зауважте, що рекурсивний виклик є останнім, що
    трапляється в обчисленні тіла функції апроксимації. Функції, подібні до
    approximate, що викликають себе в якості останньої дії, називаються кінечно
    рекурсивними. Компілятор Scala детектує кінцеву рекурсію, та заміщує її на
    перехід назад, на початок функції, після оновлення параметрів функції на
    нові значення.<br>
    <br>
    Мораль полягає в тому, що ви не повинні соромитись використовувати
    рекурсивні алгоритми для вирішення ваших проблем. Часто рекурсивне рішення
    більш елегантне та стисле, ніж базоване на циклі. Якщо рішення кінцево
    рекурсивне, ви навіть не&nbsp; заплатите за перенавантаження під час
    виконання.<br>
    <h4>Відслідковування кінцево-рекурсивних функцій</h4>
    Кінцево рекурсивні функції не будуть будувати новий стек для кожного
    виклику; всі виклики будуть виконуватись в одному фреймі. Це може здивувати
    програміста, що очікує, що відсліджування стек програми, що схибила.
    Наприклад, ця функція викликає себе декілька разів, та потім підіймає
    виключення:
    <pre class="prettyprint linenums language-scala">def boom(x: Int): Int =
  if (x == 0) throw new Exception("boom!")
  else boom(x - 1) + 1</pre>
    Ця функція не є кінцево рекурсивною, оскільки вона виконує операцію
    інкремента після рекурсивного виклику. Ви отримаєте те, що очікували, якщо
    ви виконаєте її:
    <pre class="prettyprint linenums language-scala">scala&gt;
boom(3)
java.lang.Exception: boom!
at .boom(&lt;console&gt;:5)
at .boom(&lt;console&gt;:6)
at .boom(&lt;console&gt;:6)
at .boom(&lt;console&gt;:6)
at .&lt;init&gt;(&lt;console&gt;:6)
...</pre>
    <br>
    Якщо ви тепер модифікуєте boom так, щоб вона стала кінцево рекурсивною:def
    bang(x: Int): Int =
    <pre class="prettyprint linenums language-scala">if (x == 0) throw new Exception("bang!")
else bang(x - 1)</pre>
    ви отримаєте:
    <pre class="prettyprint linenums language-scala">scala&gt; bang(5)
java.lang.Exception: bang!
at .bang(&lt;console&gt;:5)
at .&lt;init&gt;(&lt;console&gt;:6) ...</pre>
    <br>
    На цей раз ви бачите тільки один фрейм стеку для bang. Ви можете подумати,
    що bang звалився перед тим, як визвати себе, але це не той випадок. Якщо ви
    думаєте, що можете бути збиті з пантелику оптимізацією кінцевої рекурсії при
    погляді на трассу стеку, ви можете відключити її, надавши наступний аргумент
    до оболонки scala shell або до компілятора scalac:
    <pre class="prettyprint linenums language-scala">-g:notailcalls</pre>
    <br>
    Коли вказана ця опція, ви отримаєте довшу трасу стеку:
    <pre class="prettyprint linenums language-scala">scala&gt; bang(5)
java.lang.Exception: bang!
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .bang(&lt;console&gt;:5)
at .&lt;init&gt;(&lt;console&gt;:6) ...</pre>
    <h4>Оптимізація кінцевого виклику</h4>
    Скомпільований код для approximate загалом той самий, що і скомпільований
    код для approximateLoop. Обі функції компілюються до тих же тринадцяти
    інструкцій байткоду Java. Якщо ви дивитесь на згенеровані компілятором Scala
    байткоди для кінцево рекурсивного метода approximate, ви побачите, що хоча
    обоє, isGoodEnough та improve викликані в тілі метода, approximate ні.
    Компілятор Scala оптимізував цей рекурсивний виклик:<br>
    public double approximate(double);
    <pre class="prettyprint linenums language-scala">Code:
0: aload_0
1: astore_3
2: aload_0
3: dload_1
4: invokevirtual #24; //Method isGoodEnough:(D)Z
7: ifeq 12
10: dload_1
11: dreturn
12: aload_0
13: dload_1
14: invokevirtual #27; //Method improve:(D)D
17: dstore_1
18: goto 2

</pre>
    <h4>Межі кінцевої рекурсії</h4>
    Використання кінцевої рекурсії в Scala є досить обмеженою, оскільки набір
    інструкцій JVM робить реалізацію більш докладних форм кінцевої рекусрії
    складним. Scala оптимізує тільки прямо рекурсивні виклики назад до тієї
    самої функції, що робить виклик. Якщо рекурсія є непрямою, як в наступному
    прикладі двох взаємно рекурсивних функцій, оптимізація неможлива:
    <pre class="prettyprint linenums language-scala">def isEven(x: Int): Boolean =
  if (x == 0) true else isOdd(x - 1)
<br>def isOdd(x: Int): Boolean =
if (x == 0) false else isEven(x - 1)</pre>
    Ви також не бажаєте кінцеву оптимізацію, якщо заключний виклик іде до
    функціонального значення. Розгляньте для прикладу наступний рекурсивний код:
    <pre class="prettyprint linenums language-scala">val funValue = nestedFun _
  def nestedFun(x: Int) {
    if (x != 0) { println(x); funValue(x - 1) }
}</pre>
    Зміннна funValue посилається на значення функції, що, загалом, тільки
    огортає виклик до nestedFun. Коли ви застосовуєте значення функції до
    аргумента, вона обертається, та застосовує nestedFun до того ж аргумента, та
    повертає результат.<br>
    <br>
    Як ви могли здогадатись, компілятор Scala буде виконувати оптимізацію
    кінцевого виклику, але в цьому випадку це не так. Таким чином, оптимізація
    кінцевого виклику обмежена до ситуацій, в яких метод або вкладена функція
    викликає себе напряму, в якості останньої операції, без переходу через
    функціональне значення, або якійсь інший посередник. (Якщо ви досі не
    повністю розумієте кінцеву рекурсію, дивіться Розділ 8.9).<br>
    <h3>8.10 Висновок</h3>
    Ця глава надала вам гранд тур по функціям в Scala. На додаток до методів,
    Scala провадить локальні функції, функціональні літерали, та значення
    функцій. На додаток до нормальних викликів функцій, Scala провадить частково
    застосовані функції, та функції з повторюваними параметрами. Коли можливо,
    виклики функцій реалізоані як оптимізовані кінцеві виклики, і, таким чином,
    багато гарно виглядаючих рекурсивних функцій роблять так же швидко, як
    оптимізовані вручну версії, що використовують цикли while. Наступна глава
    буде будуватись на ціх засадах, та покаже, наскільки багата підтримка
    функцій в Scala допомагає вам абстрагуватись над керуванням.<br>
    <br>
    <h3>Глава 9</h3>
    <h2>Абстракція керування</h2>
    В Главі 7, ми вказали, що Scala не має багато вбудованих абстракцій
    керування, оскільки вона надає вам можливість створювати ваші власні. В
    попередній главі ви навчились щодо функціональних значень. В цій главі ми
    покажемо вам, як застосовувати функціональні значення для створення нових
    абстракцій керування. По ходу ви також вивчите щодо карування та параметрів
    за-ім'ям.<br>
    <h3>9.1 Зменьшення дублікації кода</h3>
    Всі функції поділені на загальні частини, що є однаковими для кожного
    виклика функції, та незагальних частей, що можуть відрізнтись від одного
    виклику функції до іншого. Загальні частини знаходяться в тілі функції, тоді
    як незагальні частити мають бути поставлені через аргументи. Коли ви
    використовуєте значення функції як аргумент, незагальна частина алгоритму
    сама по собі є іншим алгоритмом! За кожного виклику такої функції, ви можете
    передати туди різне функціональне значення в якості аргумента, та викликана
    функція буде, час від часу, за власним вибором, викликати передані
    функціональні значення. Ці функції вищого порядку — функції, що приймають
    функції як параметри — дають вам додаткові можливості до стискання та
    спрощення кода.<br>
    <br>
    Одна з вигод функцій вищого порядка в тому, що вони дозволяють вам
    створювати абстракцій керування, що дозволяє зменшити дублікацію кода.
    Наприклад, уявімо, ви пишете файловий переглядач, та ви бажаєте провадтити
    API, що дозволить користувачам шукати файли, що співпадають за деяким
    критерієм. Перше, ви додаєте можливість шукати файли, чиї імена завершуються
    на певний рядок. Це може дати вашим користувачам пошук, наприклад, всіх
    файлів з розширенням ".scala". Ви можете запровадити такий API, визначаючи
    публічний метод filesEnding в об'єкті-синглтоні, таким чином:<br>
    <pre class="prettyprint linenums language-scala">object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles
  def filesEnding(query: String) =
    for (file &lt;- filesHere; if file.getName.endsWith(query))
      yield file
}</pre>
    <p>Метод filesEnding отримує список всіх файлів в поточному каталозі з
      використанням приватного допоміжного метода filesHere, потім фільтрує їх
      на основі того, чи кожне ім'я файла звершується на заданий користувачем
      запит. Беручи до уваги, що filesHere є приватним, метод filesEnding є
      єдиним доступним методом, доступним в FileMatcher, API, що ви провадите
      користувачам.<br>
      <br>
      Докі все гарно, та код не повторюється. Однак потім ви вирішуєте дозволити
      людям шукати на основі любої частини імені файла. Це добре, коли ваші
      користувачі не пам'ятають, чи вони іменовали файл phb-important.doc,
      stupid-phb-report.doc, may2003salesdoc.phb, або щось зовсім інше, але вони
      думають, що "phb" з'являється десь в імені. Ви повертаєтесь назад, та
      додаєте цю функцію до вашого FileMatcher API:</p>
    <pre class="prettyprint linenums language-scala">def filesContaining(query: String) =
  for (file &lt;- filesHere; if file.getName.contains(query))
  yield file</pre>
    <p>Ця функція робить так само, як filesEnding. Вона шукає filesHere,
      перевіряє ім'я, та повертає файл, якщо ім'я співпадає. Єдина різниця є в
      тому, що ця функція використовуєcontains замість endsWith.</p>
    <p>Проходить декілька місяців, та програма стає більш успішною. Одного разу
      ви отримуєте запити від декількох потужних користувачів, що бажають шукати
      на основі регулярних виразів. Ці недбалі хлопці мають величезні каталоги з
      тисячами файлів, та вони бажають робити такі речі, як шукати всі "pdf"
      файли, що мають "oopsla" десь в імені. Щоб підтримати їх, ви пишете таку
      функцію:</p>
    <pre class="prettyprint linenums language-scala">def filesRegex(query: String) =
  for (file &lt;- filesHere; if file.getName.matches(query))
    yield file</pre>
    <p>Досвідчені програмісти зауважать всі ці повторення, та здогадаються, що
      все це можна виділити в загальну допоміжну функцію. Однак зробити це в
      очевидний спосіб не спрацює. Ви хочете бути в змозі робити наступне:</p>
    <pre class="prettyprint linenums language-scala">def filesMatching(query: String, method ) =
  for (file &lt;- filesHere; if file.getName. method (query))
    yield file</pre>
    <p>Цей підхід буде робити в деяких динамічних мовах, але Scala не дозволяє
      вклеювати код разом таким чином. То що нам робити? Функціональні значення
      провадять відповідь. Хоча ви не можете передати ім'я метода як значення,
      ви можете отримати той же ефект, передаючи функціональне значення, що
      викликає метод за вас. В цьому випадку ви можете додати параметр matcher
      до метода, єдине призначення якого є перевірка імені файла відносно
      запиту:</p>
    <pre class="prettyprint linenums language-scala">def filesMatching(query: String,
                  matcher: (String, String) =&gt; Boolean) = {
  for (file &lt;- filesHere; if matcher(file.getName, query))
    yield file
}</pre>
    <p>В цій версії метода вираз if тепер використовує matcher для перевірки
      імені файла відносно запиту. В точності що робить ця перевірка, залежить
      від того, що вказано в matcher. Тепер подівіться на тип самого matcher. Це
      функція, і, таким чином, має в типі =&gt;. Ця функція приймає два рядкових
      аргументів — ім'я файла та запит — та повертає логічне значення and
      returns a boolean, так що тип цієї функції (String, String) =&gt; Boolean
      .</p>
    <p>Мачи цей новий допоміжний метод filesMatching, ви можете спростити три
      метода пошуку, щоб вони викликали допоміжний метод, передаючи відповідну
      функцію:</p>
    <pre class="prettyprint linenums language-scala">def filesEnding(query: String) =
  filesMatching(query, _.endsWith(_))
def filesContaining(query: String) =
  filesMatching(query, _.contains(_))
def filesRegex(query: String) =
  filesMatching(query, _.matches(_))</pre>
    <p>Функціональні літерали, показані в цьому прикладі, використовують
      синтаксис заміщувачів, введений в попередній главі, що може відчуватись не
      дуже природним для вас. Таким чином, ось пояснення, як заміщувачі
      використовуються в цьому прикладі. Функціональний літерал _.endsWith(_),
      використаний в методі filesEnding, означає те саме, що і:</p>
    <pre class="prettyprint linenums language-scala">(fileName: String, query: String) =&gt; fileName.endsWith(query)</pre>
    <p>Оскільки filesMatching приймає функцію, що потребує два аргументи String,
      однак вам не треба вказувати типи аргументв. Таким чином, ви можетет також
      записати: </p>
    <pre class="prettyprint linenums language-scala">(fileName, query) =&gt; fileName.endsWith(query). </pre>
    <p>Оскільки параметри використовуються тільки одного разу в тілі функції, та
      оскільки перший параметр, fileName, використовується першим в тілі, та
      другий параметр, query, використовується другим, ви можете використовувати
      синтаксис з заміщувачем: _.endsWith(_). Перше підкреслення є заміщувачем
      для першого параметра, імені файла, та друге підкреслення заміщує другий
      параметр, рядок запиту query.</p>
    <p>Цей код вже спрощений, але він може стати навіть коротшим. Зауважте, що
      запит переданий до filesMatching, але filesMatching нічого не робить з
      query, за винятком передачі його назад до переданої функції порівняння. Ця
      передача вперед та назад не є необхідною, оскільки викликач вже знає, яким
      буде запит! Ви можете також просто видалити параметр запиту з
      filesMatching та matcher, таким чином спрощуючи код, як показано в
      Лістингу 9.1.</p>
    <pre class="prettyprint linenums language-scala">object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles
  <br>  private def filesMatching(matcher: String =&gt; Boolean) =
    for (file &lt;- filesHere; if matcher(file.getName))
      yield file
<br>  def filesEnding(query: String) =
    filesMatching(_.endsWith(query))
  <br>  def filesContaining(query: String) =
    filesMatching(_.contains(query))
  <br>  def filesRegex(query: String) =
    filesMatching(_.matches(query))
}</pre>
    <p>Лістинг 9.1 Використання замикань для зменшення дублікації кода.</p>
    <p>Цей приклад демонструє спосіб, яким першокласні функції можуть допомогти
      вам виключити дублікований код, де може бути дуже складним зробити це без
      них. Наприклад, в Java, ви можете створити інтерфейс, що містить метод, що
      приймає один рядок String, та повертає Boolean, потім створити та передати
      анонімний внутрішній клас, що реалізує цей інтерфейс до filesMatching.
      Хоча цей підхід буде видаляти дублікацію кода, якої ви намагаєтесь
      уникнути, в той же час додасть значно більше нового кода. Таким чином,
      вигода не варта ціни, та ви можете так же гарно жити з дублікацією.</p>
    <p>Більше того, цей приклад демонструє, як замикання може допомогти вам
      зменшити дублікацію кода. Ці функціональні літерали, використані в
      попередньому прикладі, такі, як _.endsWith(_) та _.contains(_),
      перетворені під час виконання в функціональні значення, що не є
      замиканнями, оскільки вони не захоплюють любих вільних змінних. Обі
      змінні, використані в виразі, наприклад,&nbsp; _.endsWith(_), представлені
      підкресленнями, що означає, що вони отримані з аргументів функції. Таким
      чином, _.endsWith(_) використовує дві закріплені змінні, але не вільні
      змінні. На відміну від цього, фукціональний літерал _.endsWith(query),
      використаний в самому останньому прикладі, містить одну закріплену знінну,
      аргумент, представлений підкресленням, та одну вільну змінну, представлену
      іменованим query. Тільки через підтримку Scala замикань, ми можемо бути в
      змозі видалити парамтер query з filesMatching в останньому прикладі, таки
      мчином спрощуючи код навіть ще більше.</p>
    <h3>9.2 Спрощення клієнтського кода</h3>
    <p>Попередній приклад демонструє, що функції вищого опрядку можуть допомогти
      зменшити дублікацію коду при реалізації API. Інше важливе використання
      функцій вищого порядка є покласти їх в саме API, щоб зробити код клієнта
      більш стислим. Гарним прикладом є провадження циклічних методів
      спеціального призначення типів колекцій Scala. Багато з них перелічені в
      Таблиці 3.1 в Главі 3, але зараз погленемо тільки на один приклад, щоб
      побачити, чому ці методи є такими корисними.</p>
    <p>Ці спеціальні циклічні методи визначені в трейті Traversable, що
      розширюється List, Set, та Map. Дивіться Главу 17 щодо обговорення.
      Візьмемо exists, метод, що визначає, чи передане значення міститься в
      колекції. Ви можете, звичайно, шукати елемент, маючи var, ініціалізовану в
      false, в циклі по колекції перевіряти кожний елемент, та встановити var в
      true, якщо ви знайшли що шукали.</p>
    <p>Ось метод, що використостовує цей підхід для визначення, чи переданий
      List містить від'ємне число:</p>
    <pre class="prettyprint linenums language-scala">def containsNeg(nums: List[Int]): Boolean = {
  var exists = false
  for (num &lt;- nums)
    if (num &lt; 0)
      exists = true<br>  exists<br>}</pre>
    <p>Якщо ви визначите цей метод в інтерпретаторі, ви можете викликати його
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; containsNeg(List(1, 2, 3, 4))
res0: Boolean = false
scala&gt; containsNeg(List(1, 2, -3, 4))
res1: Boolean = true</pre>
    <p>Однак більш стислий спосіб визначити метод є виклик функції вищого
      порядку exists на переданому List, ось так:</p>
    <pre class="prettyprint linenums language-scala">def containsNeg(nums: List[Int]) = nums.exists(_ &lt; 0)</pre>
    <p>Ця версія containsNeg видає той же результат, що і попередній:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; containsNeg(Nil)
res2: Boolean = false
scala&gt; containsNeg(List(0, -1, -2))
res3: Boolean = true</pre>
    <p>Метод exists представляє абстракцію керування. Це циклічна конструкція
      спеціального призначення, запровадженна бібліотекою Scala, скоріше ніж
      бути вбудованою в мову Scala, як while або for. В попередньому розділі
      гетерогенна функція filesMatching зменшила дублікацію кода в реалізації
      об'єкта FileMatcher. Метод exists провадить подібну вигоду, або оскільки
      exists є публічною зі Scala’s API колекцій, дублікація кода, що вона
      зменьшує, є клієнтський код до цього API. Якщо exists не існує, та ви
      бажаєте написати метод containsOdd, щоб перевірити, чи список містить
      нпарні числа, ви можете написати таке:</p>
    <pre class="prettyprint linenums language-scala">def containsOdd(nums: List[Int]): Boolean = {
  var exists = false
  for (num &lt;- nums)
    if (num % 2 == 1)
      exists = true
  exists
}</pre>
    <p>Якщо ви порівняєте тіло containsNeg з тілом containsOdd, ви знайдете, що
      все повторюється, за винятком умови перевірки в виразі if. Використовуючи
      exists, ви замість цього можете написати таке:</p>
    <pre class="prettyprint linenums language-scala">def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)</pre>
    <p>Тіло кода в цій версії знову ідентичне до тіла відповідоного метода
      containsNeg (версія, що використовує), за виключенням того, що
      відрізняється умова, за якою виконується пошук. Також об'єм дублікації
      кода значно менший, оскільки вся циклічна інфраструктура виділена в самий
      метод exists.</p>
    <p>Є багато інших циклічних методів в стандартній бібліотеці Scala. Як і з
      exists, вони часто можуть скоротити ваш код, якщо ви розпізнали моживості
      їх використання.</p>
    <h3>9.3 Карування</h3>
    <p>В Главі 1 ми казали, що Scala дозволяє вам створювати нові абстракції
      керування, що "відчуваються як природна пдітримка мови". Хоча приклади, що
      ви бачили досі, очевидно є абстракціями керування, ніхто не може сплутати
      їх з природною підтримкою мови. Щоб зрозуміти, як зробити абстракції
      керування, що виглядають як розширення мови, вам зпершу треба зрозуміти
      техніку функціонального програмування,&nbsp; що називається каруванням.</p>
    <p>Карована функція застосовується до декількох списків аргументів, замість
      одного. Лістинг 9.2 показує звичайну, некаровану функцію, що додає два
      параметри Int, x та y .</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def plainOldSum(x: Int, y: Int) = x + y
plainOldSum: (x: Int,y: Int)Int
scala&gt; plainOldSum(1, 2)<br>res4: Int = 3</pre>
    <p>Лістинг 9.2 Визначення та виклик "звичайної старої" функції.</p>
    <p>На відміну, Лістинг 9.3 показує подібну функцію, що карована. Замість
      одного списку з двох параметрів Int, ви застосовуєте цю функцію до двох
      списків, по одному параметру Int в кожному.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def curriedSum(x: Int)(y: Int) = x + y
curriedSum: (x: Int)(y: Int)Int
scala&gt; curriedSum(1)(2)
res5: Int = 3</pre>
    <p>Лістинг 9.3 Визначення та виклик карованої функції.</p>
    <p>Що відбувається тут, це коли ви викликаєте curriedSum, ви, насправді
      отримуєте два традиційні виклика функцій поспіль. Перший виклик функції
      приймає один параметр Int на ім'я x, та повертає функціональне значення
      для другої функції. Друга функція приймає&nbsp; Int параметр y. Ось
      функція, названа first, що діє в дусі першого традиційного виклику функції
      curriedSum:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def first(x: Int) = (y: Int) =&gt; x + y
first: (x: Int)(Int) =&gt; Int</pre>
    <p>Застосовуючи 1 до першої функції&nbsp; — іншими словами, викликаючи першу
      функцію та передаючи їй 1 — дає другу функцію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val second = first(1)
second: (Int) =&gt; Int = &lt;function1&gt;</pre>
    <p>Застосовуючи 2 до другої функції дає результат:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; second(2)
res6: Int = 3</pre>
    <p>Ці перша та друга функції є тільки ілюстрацією процеса карування. Вони не
      під'єднані напряму до функції curriedSum. Тим не менш, є спосіб отримати
      справжнє посилання на "другу" функцію curriedSum. Ви можете використати
      нотацію з заміщувачем для використання curriedSum в виразі частково
      застосованої функції, таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val onePlus = curriedSum(1)_
onePlus: (Int) =&gt; Int = &lt;function1&gt;</pre>
    <p>Підкреслення в curriedSum(1)_ є заміщувачем для другого списку
      параметрів. Результатом є посилання на функцію, що, коли викликається,
      додає один до свого єдиного аргумента Int, та повертає результат:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; onePlus(2)
res7: Int = 3</pre>
    <p>Та ось як ви отримаєте функцію, що додає два до свого єдиного аргумента
      Int:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val twoPlus = curriedSum(2)_
twoPlus: (Int) =&gt; Int = &lt;function1&gt;
scala&gt; twoPlus(2)
res8: Int = 4</pre>
    <h3>9.4 Написання нових структур керування</h3>
    <p>В мовах з першокласними функціями ви можете ефективно зробити нові
      структури керування, навіть якщо синтаксис мови зафіксовано. Все, що вам
      треба зробити, це створити методи, що приймають функції як аргументи.
      Наприклад, ось керівна структура "twice", що повторює операцію два рази,
      та повертає результат:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def twice(op: Double =&gt; Double, x: Double) = op(op(x))
twice: (op: (Double) =&gt; Double,x: Double)Double
scala&gt; twice(_ + 1, 5)
res9: Double = 7.0</pre>
    <p>В попередній главі, коли нотація заміщувача використовувалась на
      традиційних методах, як println _, ви мали залишити проміжок між ім'ям та
      підкресленням. В цьому випадку ні, бо коли println_ є легальним
      ідентифікатором Scala, curriedSum(1)_ ні. Тип op в цьому прикладі Double
      =&gt; Double, що означає, що ця функція сприймає один Double як аргумент,
      та повертає інший Double.</p>
    <p>Кожного разу, коли ви знайдете шаблон керування, повторений в багатьох
      частинах вашого кода, ви повинні подумати про реалізацію його як структури
      керування. Раніше в цій главі ви бачили filesMatching, дуще специфічний
      шаблон керування. Розгляньте тепер широко застосований шаблон керування:
      відкрити ресурс, виконати операції з ним, та потім зачинити ресурс. Ви
      можете захопити його в керівній абстракції, використовуючи метод наступним
      чином:</p>
    <pre class="prettyprint linenums language-scala">def withPrintWriter(file: File, op: PrintWriter =&gt; Unit) {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}</pre>
    <p>Маючи такий метод, ви можете використовувати його так:</p>
    <pre class="prettyprint linenums language-scala">withPrintWriter(
  new File("date.txt"),
  writer =&gt; writer.println(new java.util.Date)
)</pre>
    <p>Перевага використання цього метода в тому, що його withPrintWriter, не
      код користувача, гагнтує закриття файла в кінці. Так що неможливо забути
      закрити файл. Цей прийом називається шаблоном позичання, оскільки функція
      абстракції керування, як withPrintWriter, відкриває ресурс, та "позичає"
      його функції. Наприклад,&nbsp; withPrintWriter в попередньому прикладі
      позичає PrintWriter функції op. Коли функція завершується, вона сигналить,
      що їй більше не треба "позичений" ресурс. Потім ресурс зачиняється в блоці
      finally, щоб переконатись, що він напевне закритий, безвідносно, чи
      функція завершилась нормально, або викликавши виключення.</p>
    <p>Одним способом, як ви можете змусити клієнтський код виглядати більше як
      вбудовані структури керування, є використання фігурних дужок замість
      звичайних, щоб оточити список аргументів. В кожному виклику метода Scala,
      в якому ви передаєте рівно один аргумент, ви маєте можливість використати
      фігурні дужки для оточення аргумента, замість звичайних. Наприклад,
      замість:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; println("Hello, world!")
Hello, world!</pre>
    <p>ви можете записати:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; println { "Hello, world!" }
Hello, world!</pre>
    <p>В другому прикладі ви використовуєте фігурні дужки замість дужок, щоб
      оточити аргумент println. Однак цей прийом з фігурними дужками буде
      робити, тільки якщо ви передаєте один аргумент. Ось приклад порушити це
      правило: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; val g = "Hello, world!"
g: java.lang.String = Hello, world!
scala&gt; g.substring { 7, 9 }
&lt;console&gt;:1: error: ';' expected but ',' found.
g.substring { 7, 9 }
               ˆ</pre>
    <p>Оскільки ви намагаєтесь передати два аргументи до substring, ви отримуєте
      помилку, коли ви намагаєтесь оточити ці аргументи фігурними дужками.
      Замість цього, вам треба використовувати дужки:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; g.substring(7, 9)
res12: java.lang.String = wo</pre>
    <p>Призначення цієї можливості замінити дужки на фігурні для передачі одного
      параметра є дозволити клієнтським програмістам писати функціональні
      літерали між фігурними дужками. Це може зробити виклик метода виглядати
      більше як керівна абстракція. Візьміть метод withPrintWriter, попередньо
      визначений як приклад. В своїй найбільш ранішній формі withPrintWriter
      приймає два аргументи, так що ви не можете використати фігурні дужки. Тим
      не менш, оскільки функція, передана до withPrintWriter є останнім
      аргументом в списку, ви можете використати карування, щоб підтягнути
      перший аргумент, File, в окремий списк аргументів. Це залишить функцію як
      єдиний параметр другого списку аргументів.</p>
    <p>Лістинг 9.4 показує, як вам треба перевизначити
      withPrintWriter.&nbsp;&nbsp;</p>
    <pre class="prettyprint linenums language-scala">def withPrintWriter(file: File)(op: PrintWriter =&gt; Unit) {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}</pre>
    <p>Лістинг 9.4 Використання шаблона позичання для написання файла.</p>
    <p>Нова версія відрізняється від старої тільки в тому, що тепер є два списки
      параметрів, з одним параметром в кожному, замість одного списка з двома
      параметрами. Подівіться між двома параметрами. В попередній версії
      withPrintWriter ви бачите . . . File, op . . . . Але в цій версії ви
      бачите&nbsp; . . . File)(op . . . . Маючи визаченя вище, ви можете
      викликати метод з більш приємним синтаксисом:</p>
    <pre class="prettyprint linenums language-scala">val file = new File("date.txt")
withPrintWriter(file) {
  writer =&gt; writer.println(new java.util.Date)
}</pre>
    <p>В цьому прикладі перший список аргументів, що містить один аргумент File,
      записаний в оточенні дужок. Другий список аргументів, що містить один
      функціональний аргумент, осочений фігурними дужками.</p>
    <h3>9.5 Параметри за-ім'ям</h3>
    <p>Метод withPrintWriter, показаний в попередньому розділі відрізняється від
      вбудованої структури керування мови, такої, як if та while, в тому, що код
      між фігурними дужками приймає аргумент. Метод withPrintWriter потребує
      один аргумент типу PrintWriter. Це йаргумент показаний як "writer =&gt;"
      в:</p>
    <pre class="prettyprint linenums language-scala">withPrintWriter(file) {
  writer =&gt; writer.println(new java.util.Date)
}</pre>
    <p>Однак що, якщо ви бажаєте реалізовати щось більше схоже на if або while,
      де немає значення, що передається в код між фігурними дужками? Щоб
      допомогти з такими ситуаціями, Scala провадить параметри за-ім'ям.</p>
    <p>Як конкретний приклад, уявімо, що ви бажаєте реалізовати конструкцію
      припущення з назвою myAssert. Функція myAssert буде приймати функціональне
      значення на вході, та консультується з флагом, щоб вирішити, що робити.
      Якщо флаг встановлений, myAssert буде викликати передану функцію, та
      перевіряти, чи вона повертає&nbsp; true. Якщо флаг вимкнений, myAssert
      буде мовчки зовсім нічого не робити.</p>
    <p>Без використання параметрів зі-ім'ям, ви можете написати myAssert таким
      чином: </p>
    <pre class="prettyprint linenums language-scala">var assertionsEnabled = true
def myAssert(predicate: () =&gt; Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate())
    throw new AssertionError</pre>
    <p>Визначення гарне, але викорастання його трохи незграбне:</p>
    <pre class="prettyprint linenums language-scala">myAssert(() =&gt; 5 &gt; 3)</pre>
    <p>Ви можете спробувати відкинути пустий список параметрів та символ =&gt; в
      функціональному літералі, та записати код таким чином: </p>
    <pre class="prettyprint linenums language-scala">myAssert(5 &gt; 3) // Не буде робити через відсутнє () =&gt;</pre>
    <p>Параметри за-ім'ям існують точно для того, щоб ви могли зробити це. Щоб
      зробити параметр за-ім'ям, ви надаєте параметру тип, що починається з
      =&gt; замість () =&gt; . Наприклад, ви можете змінити параметр предиката
      myAssert на параметр за-ім'ям, змінивши його тип, "() =&gt; Boolean ", на
      " =&gt; Boolean ". Лістинг 9.5 показує, як це буде виглядати:<br>
    </p>
    <pre class="prettyprint linenums language-scala">def byNameAssert(predicate: =&gt; Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate)
    throw new AssertionError</pre>
    Лістинг 9.5 Використання параметра за-ім'ям.<br>
    <br>
    Тепер ви можете відкинути пустий параметр у властивості, що ви бажаєте
    оцінити. Результат в тому, що використання byNameAssert виглядає точно як
    використання вбудованої структури: ви викликаєте цей myAssert, не assert,
    оскільки Scala провадить свій власний assert, що буде описане в Розділі
    14.1.
    <pre class="prettyprint linenums language-scala">byNameAssert(5 &gt; 3)</pre>
    <p>Тип за-ім'ям, в якому пустий список параметрів, (), відкидається,
      дозволяється тільки для параметрів. Немає такоє речі, як змінна за-ім'ям,
      або поле за-іменем. Тепер ви можете здивуватись, чому ми просто не пишемо
      myAssert, з використанням простого старого Boolean для типу параметра, як
      тут: </p>
    <pre class="prettyprint linenums language-scala">def boolAssert(predicate: Boolean) =
  if (assertionsEnabled &amp;&amp; !predicate)
    throw new AssertionError</pre>
    <p>Це формулювання, звичайно, також легальне, та код з використанням цієї
      версії boolAssert буде також виглядати точно як раніше:</p>
    <pre class="prettyprint linenums language-scala">boolAssert(5 &gt; 3)</pre>
    <p>Тим не менш, одна різниця існує між ціма двома підходами, що важливо
      занотувати. Оскільки тип параметра boolAssert є Boolean, вираз в дужках в
      boolAssert(5 &gt; 3) обчислюється перед викликом boolAssert. Вираз 5 &gt;
      3 дає true, що передається до boolAssert. На відміну, оскільки тип
      параметра предиката byNameAssert є =&gt; Boolean, вираз в дужках
      byNameAssert(5 &gt; 3) не обчислюється до виклику byNameAssert. Замість
      функціонального значення буде створена той метод apply, що обчислюватиме 5
      &gt; 3, та це функціональне значення буде передане до byNameAssert.
      Різниця між двома підходами, таким чином, в тому, що якщо допущення
      відключене, ви побачите любі побічні ефекті, що може мати вираз в дужках
      для boolAssert, але не в byNameAssert. Наприклад, ящо допущення
      відключене, спроба визначитись для "x / 0 == 0" буде давати виключення в
      випадку boolAssert:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; var assertionsEnabled = false
assertionsEnabled: Boolean = false
scala&gt; boolAssert(x / 0 == 0)
java.lang.ArithmeticException: / by zero
at .&lt;init&gt;(&lt;console&gt;:9)
at .&lt;clinit&gt;(&lt;console&gt;)
at RequestResult$.&lt;init&gt;(&lt;console&gt;:9)
at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)</pre>
    <p>Але спроба допущення на тому ж коді в випадку byNameAssert не буде давати
      виключення:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; byNameAssert(x / 0 == 0)</pre>
    <h3>9.6 Висновок</h3>
    <p>Ця глава показала вам, як ви можете будувати на багатій підтримці функцій
      в Scala абстракції керування. Виможете використовувати функції в вашому
      коді для виділення загальних шаблонів керування, та ви можете отримати
      переваги фукнцій вищого порядку в бібліотеці Scala для повторного
      використання шаблонів керування, що є загальними в коді програміста. Ця
      глава також показала, як використовувати каринг та параметри за-ім'ям,
      так, що ваші власні функції можуть бути використані в стислому синтаксисі.</p>
    <p>В попередній та цій главі ви побачили досить багато інформації щодо
      функцій. Наступні декілька глав повернуться назад до обговорення більш
      об'єктно-орієнтованих можливостей мови. </p>
    <h3>Глава 10</h3>
    <h2>Композиція та наслідування</h2>
    <p>Глава 6 ввела деякі базові об'єктно-орієнтовані аспекти Scala. Ця глава
      продовжить там, де скінчила Глава 6, та зануриться в значно глибші деталі
      підтримки Scala об'єктно-орієнтованого програмування. Ми порівняємо два
      функціональні відношення між класами: композиція та наслідування.
      Композиція означає, що один клас містить посилання на інший, використоуючи
      цей клас для допомоги у виконання своє міссії. Наслідування є відношення
      суперкласса/субкласа. На додаток до ціх тем ми обсудимо абстрактні класи,
      методи без параметрів, розширення класів, перевизначення методів та полів,
      параметричні поля, виклик конструкторів суперкласів, поліморфізм та
      динамічне зв'язування, фінальні члени та класи, та об'єкти-фабрики та
      методи.</p>
    <h3>10.1 Бібліотека двовимірного розташування</h3>
    <p>Як робочий приклад цієї глави, ми створимо бібліотеку для побудови та
      відображення двовимірних елементів розташування. Кожний елемент буде
      представляти прямокутник, заповнений текстом. Для зручності бібліотека
      буде провадити методи-фабрики, названі “elem”, що конструюють нові
      елементи з переданих даних. Наприклад, ви будете в змозі створити елемент
      розташування, що містить рядок, використовуючи метод-фабрику з наступною
      сигнатурою:</p>
    <pre class="prettyprint linenums language-scala">elem(s: String): Element</pre>
    <p>Як ви можете бачити, елементи будуть змодельовані типом з назвою Element.
      Ви будете в змозі викликати above або beside з елемнетом, передаючи другий
      елемент, щоб отримати новий елемент, що комбінує обоє. Наприклад,
      наступний вираз буде конструювати більший елемент, що складається з двох
      стовпчиків, кожний висотою два рядки:</p>
    <pre class="prettyprint linenums language-scala">val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2</pre>
    <p>Друк результату цього виразу:</p>
    <pre class="prettyprint linenums language-scala">hello ***
*** world</pre>
    <p>Елементи розташування є гарним прикладом системи, в якій об'єкти можуть
      бути сконструйовані з простих частин за допомогою операторів композиції. В
      цій главі ми визначимо класи, що дозволяють об'єктам елементів бути
      сконструйованими з масивів, ліній та прямокутниуів — простих частин. Ми
      також визначимо оператори композиції above та beside. Такі операції
      композиції також часто називіють комбінаторами, оскільки вони комбінують
      елементи в деякій галузі в нові елементи.</p>
    <p>Думати в термінах комбінаторів є загалом гарним шляхом для підходу до
      розробки бібліотеки: це змішує думати про фундаментальні шляхи
      конструювання об'єктів в галузі застосування. Що таке прості об'єкти? В
      який спосіб з простих об'єктів можна створити більш цікаві об'єкти? Як
      комбінатори поєднуються разом? Які комбінації є найбільш загальними? Чи
      вони задовільняють деяким цікавим законам? Якщо ви маєте гарні відповіді
      на ці запитання, дизайн вашої бібліотеки на вірному шляху.</p>
    <h3>10.2 Абстрактні класи</h3>
    <p>Наше перше завдання є визначити тип Element, що представляє елементи
      розташування. Оскільки елементи є двовимірними прямокутниками символів,
      має сенс включити член contents, що посилається на вміст елементу
      розташування. Член contents може бути предствлений як масив рядків, де
      кожний рядок представляє одну лінію. Таким чином, тип результата, що
      повертає contents, буде Array[String]. Лістинг 10.1 показує, на що це буде
      схоже. В цьому класі contents декларований як метод, що не має реалізації.
      Іншими словами, метод є абстрактним членом класа Element. Клас з
      абстрактними членами має сам бути декларований як абстрактний, що робиться
      за допомогою модифікатора abstract перед ключовим словом class:</p>
    <pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
}</pre>
    <p>Лістинг 10.1 Визначення абстрактного метода та класа.</p>
    <pre class="prettyprint linenums language-scala">abstract class Element ...</pre>
    <p>Модифікатор abstract вказує, що клас може мати абстрактні члени, що не
      мають реалізації. Як результат, ви не можете створити примірник
      абстрактного класа. Якщо ви спробуєте зробити це, ви отримаєте помилку
      компілятора:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Element
&lt;console&gt;:5: error: class Element is abstract; 
cannot be instantiated
new Element
ˆ</pre>
    <p>Пізніше в цій главі ми побачимо, як створити субкласи класа Element, що
      будуть в змозі створювати примірники, оскільки вони заповнять відсутні
      визначення для contents .</p>
    <p>Зауважте, що метод contents в класі Element не має модифікатора abstract.
      Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або
      тіла). На відміну від Java, модифікатор abstract не потрібен (або, навіть,
      дозволений) на декларації метода. Методи, що мають реалізацію, називаються
      конкретними.</p>
    <p>Інша термінологія робить розділ між деклараціями та визначеннями. Клас
      Element декларує абстрактний метод contents, але наразі не визначає
      конкретних методів. В наступньому розділі, однак, ми
      розширимо&nbsp;Element, визначивши деякі конкретні методи.</p>
    <h3>10.3 Визначення методів без параметрів</h3>
    <p>Як наступний крок, ми додамо методи до Element, що представлятимуть його
      ширину та довжину, як показано в Лістингу 10.2. Метод height повертає
      число ліній вмісту. Метод width повертає довжину першого рядка, або, якщо
      немає жодного рядка, нуль (це означає, що ви не можете визначити елемент з
      висотою нуль, та ненульовою шириною).</p>
    <pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}</pre>
    <p>Лістинг 10.2 Визначення методів width та height без параметрів.</p>
    <p>Зауважте, що жодний з трьох методів не має списка параметрів, навіть
      пустого. Наприклад, замість:</p>
    <pre class="prettyprint linenums language-scala">def width(): Int</pre>
    <p>іде метод, визначений без дужок:</p>
    <pre class="prettyprint linenums language-scala">def width: Int</pre>
    <p>Такі методи без дужок є досить загальними в Scala. Замість цього, методи,
      визначені з пустими дужками, такі як def height(): Int, називаються
      методами з порожніми дужками. Рекомдованою домовленостю є використання
      дужок, коли немає параметрів, та метод отримує доступ до змінного стану
      тільки для читання полів об'єкта (зокрема, він не змінює змінний стан). Ця
      домовленість підтримує одноманітний принцип доступу, що каже, що на код
      клієнта не повинно впливати рішення реалізоати атрибут як поле або як
      метод. Наприклад, ви можете обрати реалізовати width та height як поля,
      замість методів, просто змінивши def в кожному визначенні на val :</p>
    <pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  val height = contents.length
  val width =
    if (height == 0) 0 else contents(0).length
}</pre>
    <p>Дві пари визначень повністю еквівалентні з точки зору клієнта. Єдина
      відмінність в тому, що доступ до поля може бути трохи швидшим, ніж виклики
      метода, оскільки значення полів попередньо обчислені при ініціалізації
      класа, замість обчислюватись при кожному виклику метода. З іншого боку,
      поле потребує додатковий простір пам'яті в кожному об'єкті Element. Так що
      все залежить від профіля використання класа, буде атрибут краще
      представлений як поле, або як метод, та цей профіль використання може
      змінитись з часом. Суть полягає в тому, що клієнти класа Element не
      повинні зазнвати впливу, коли змінюється внутрішня реалізація. Зокрема,
      клієнт класа Element не повинен бути переписаний, якщо поле цього класа
      змінюється на функцію доступу, доки функція доступу залишається чистою,
      тобто він не має побічних ефектів та не залежить від змінного стану.
      Клієнт не повинен турбуватись в жодному разі. </p>
    <p>Доки все добре. Але все ще є деяке ускладнення, що пов'язане з тим, як
      Java обробляє речі. Проблема в тому, що&nbsp; Java не реалізує
      одноманітний принцип доступу. Так що в Java існує string.length(), не
      string.length (хоча є array.length, та не array.length()) .</p>
    <p>Не треба казати, що це дуже зпантеличує. Щоб закрити цю дірку, Scala є
      дуже ліберальною, коли доходить до змішування методів без параметрів та
      методів з порожніми дужками. Зокрема, ви можете перевизначити метод без
      параметрів методом з порожніми дужками, та навпаки. Ви також можете
      відкинути пусті дужки у виклику любої функції, що не має аргументів.
      Наприклад, наступні два рядки обоє легальні в Scala:</p>
    <pre class="prettyprint linenums language-scala">Array(1, 2, 3).toString
"abc".length</pre>
    <p>В принципі, можливо відкинути порожні дужки в викликах функцій Scala.
      Однак, рекомендовано все ще писати порожні дужки, коли викликаний метод
      представляє більше ніж чим властивість об'єкта-отримувача. Наприклад,
      порожні дужки є доречними, якщо метод виконує I/O, записує в
      переприсвоювані змінні (var), або читає інші var, крім полей отримувача,
      прямо чи опосередковано, використовуючи змінні об'єкти. Таким чином,
      список параметрів діє як віруальна підказка, що дещо цікаве обчислення
      вмикається в результаті цього виклику. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">"hello".length // немає (), оскільки немає побічних ефектів
println() // краще не відкидати ()</pre>
    <p>Щоб підсумувати, заохочуваним стилем в Scala є визначати методи, що не
      приймають параметрів та не мають побічних ефектів, як методи без
      параметрів, тобто, відкидаючи порожні дужки. З іншого боку, ви ніколи не
      повинні визначати метод, що має побічні ефекти, без дужок, оскільки тоді
      виклики цього метода будуть виглядать як вибірка поля. Так що ваші клієнти
      будуть здивовані побачити побічні ефекти. Також, коли ви викликаєте
      функції, що мають побічні ефекти, переконайтесь, що включили пусті дужки
      під час написання виклику. Інший спосіб думати про це: якщо функція, що ви
      викликаєте, виконує операцію, використовуйте дужки, але якщо вона лише
      провадить доступ до властивості, відкидайте дужки геть.</p>
    <h3>10.4 Розширення класів</h3>
    <p>Нам все ще треба змога створювати нові об'єкти елементів. Ви вже бачили,
      що “new Element” не може бути використаний для цього, оскільки клас
      Element є абстрактним. Щоб створити примірник елемента, таким чином, нам
      треба створити субклас, що розширює Element та реалізує абстрактний метод
      contents. Лістинг 10.3 показує один можливий спосіб зробити це:</p>
    <pre class="prettyprint linenums language-scala">class ArrayElement(conts: Array[String]) extends Element {
  def contents: Array[String] = conts
}</pre>
    <p>Лістинг 10.3 Визначення ArrayElement як субкласа Element .</p>
    <p>Class ArrayElement визначений для розширення класа Element. Так само як в
      Java, ви використовуєте extends після імені класа для вираження цього:</p>
    <pre class="prettyprint linenums language-scala">... extends Element ...</pre>
    <p>Таке твердження extends має два ефекти: воно робить те, ArrayElement
      наслідує всі не-приватні члени від класа Element, та він робить тип
      ArrayElement субтипом типу Element. Якщо ArrayElement розширює Element,
      клас ArrayElement називається субкласом класа Element. Відповідно, Element
      є суперкласом ArrayElement. Якщо ви приберете твердження extends,
      компілятор Scala неявно вважає, що ваш клас розширює scala.AnyRef, що на
      платформі Java є тим самим, що клас java.lang.Object. Таким чином, клас
      Element неявно розширює клас AnyRef. Ви можете бачити це відношення
      розширення на Малюнку 10.1.</p>
    <pre class="prettyprint linenums language-scala">      scala
      AnyRef
 «java.lang.Object»<br>       ^ <br>    &nbsp;Element
   «abstract»<br>       ^<br> &nbsp;ArrayElement &lt;- Array[String]
</pre>
    <p>Малюнок 10.1 Діаграма класів дл ArrayElement.<br>
    </p>
    <p>Наслідовання означає, що всі члени суперкласа є також членами субкласа, з
      двома виключеннями. Перше, приватні члени суперкласа не наслідуються
      субкласами. Друге, член суперкласа не наслідується, якщо член з тим же
      ім'ям та параметрами вже реалізований в субкласі. В цьому випадку ми
      кажемо, що член субкласа перевизначає член суперкласа. Якщо член субкласа
      є конкретним, та член суперкласа є абстрактним, ми також кажемо, що
      конкретний клас реалізує абстрактний.</p>
    <p>Наприклад, метод contents в ArrayElement перевизначає (або,
      альтернативно: реалізує) абстрактний метод contents в класі Element. На
      відміну, клас ArrayElement наслідує методи width та height від класа
      Element. Наприклад, маючи ArrayElement ae, ви можетет запитати
      його&nbsp;width, використовуючи ae.width, якби width було визначено в
      класі ArrayElement:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val ae = new ArrayElement(Array("hello", "world"))
ae: ArrayElement = ArrayElement@d94e60
scala&gt; ae.width
res1: Int = 5</pre>
    <p>Один недолік цього дизайну в тому, що оскільки повернутий масив є
      змінним, клієнти можуть змінити його. Для цієї книги ми будемо утримувати
      речі простими, але якщо ArrayElement був би частиною реального проекта, ви
      можете, замість цього, вирішити повертати захищену копію масива. Інша
      проблема полягає в тому, що ми наразі не гарантуємо, що кожний елемент
      String масива contents має ту ж довжину. Це може бути вирішено перевіркою
      цієї умови в первинному конструкторі, та викликати виключення, якщо воно
      порушене.</p>
    <p>Субтипи означають, що значення суперкласа може бути використане, там, де
      потрібне значення суперкласа. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">val e: Element = new ArrayElement(Array("hello"))</pre>
    <p>Змінна e визначена типу Element, так що її ініціалізоване значення
      повинно також бути Element. Фактично, тип ініціалізуючого значення є
      ArrayElement. Це є гаразд, оскільки клас ArrayElement розширює клас
      Element, та як результат, тип ArrayElement сумісний з типом Element.
      Малюнок 10.1 також показує відноешння композиції, що існує між
      ArrayElement та Array[String]. Це відношення називається композицією, бо
      клас ArrayElement&nbsp; “скомпонований” з класу Array[String], в тому
      сенсі, що компілятор Scala буде розміщувати в бінарний код, якій він
      генерує для ArrayElement, поле, що містить посилання на переданий масив
      conts. Ми обговоримо деякі міркування&nbsp; дизайну щодо композиції та
      наслідування пізніше в цій главі, в Розділі 10.11.</p>
    <h3>10.5 Перевизначення методів та полів</h3>
    <p>Принцип одноманітного доступу є тільки одним аспектом, коли Scala трактує
      поля та методи більш одноманітно, ніж Java. Інша різниця в тому, що в
      Scala поля та методи належать до одного простору імен. Це робить можливим
      для полів перевизначати методи без дужок. Наприклад, ви можете змінити
      реалізацію contents в класі ArrayElement, з метода на поле, без
      необхідності модифікувати визначення абстрактного метода contents в класі
      Element, як показано в Лістингу 10.4:</p>
    <pre class="prettyprint linenums language-scala">class ArrayElement(conts: Array[String]) extends Element {
  val contents: Array[String] = conts
}</pre>
    <p>Лістинг 10.4 Перевизначення метода без дужок на поле.</p>
    <p>Поле contents (визначене за допомогою val) в цій версії ArrayElement є
      чудово гарною реалізацією метода без дужок contents (декларованого за
      допомогою&nbsp; def ) в класі Element.&nbsp; Для більшої перспективи щодо
      різниці між субкласом та субтипом, дивіться глосарій щодо субтипів.</p>
    <p>З іншого боку, в Scala заборонено визначати поле та метод з одним ім'ям в
      одному і тому ж класі, хоча це дозволено в Java. Наприклад, цей клас Java
      буде компілюватись повністю нормально:</p>
    <pre class="prettyprint linenums language-java">// Це Java
class CompilesFine {
    private int f = 0;
    public int f() {
        return 1;
    }
}</pre>
    <p>Але відповідний клас Scala не буде компілюватись:</p>
    <pre class="prettyprint linenums language-scala">class WontCompile {
  private var f = 0 // Не буде компілюватись, оскільки поле
  def f = 1 // та метод мають однакові імена
}</pre>
    <p>Загалом, Scala має лише два простори імен для визначень, замість чотирьох
      в Java. Чотири простори імен Java: поля, методи, типи та пакунки. На
      відміну, в Scala їх лише два:</p>
    <p>• значення (поля, методи, пакунки, об'єкти-синглтони)<br>
      • типи (імена класів та трейтів)</p>
    <p>Причина, з якої Scala покладає поля та методи в те ж поле імен, в
      точності таке, щоб ви могли перевизначити методи без параметрів за
      допомогою val, що ви не можете зробити в Java.</p>
    <h3>10.6 Визначення параметричних полів</h3>
    <p>Знову розглянемо визначення класу ArrayElement, показаного в попередньому
      розділі. Він має параметр conts, єдиним призначенням якого є бути
      скопійованим в поле contents. Ім'я conts параметра було обране таким
      чином, щоб він виглядав подібно до імені поля contents, без того, щоб
      насправді перетинатись з ним. Цей “запах коду” є ознакою, що є деяка
      непотрібна надмірність та повторення в вашому коді. Ви можете уникати
      запаху коду,&nbsp; комбінуючи параметр та поле в одне параметричне
      визначення поля, як показане в Лістингу 10.5:</p>
    <pre class="prettyprint linenums language-scala">class ArrayElement(
  val contents: Array[String]
) extends Element</pre>
    <p>Лістинг 10.5 Визначення contents як параметричного поля.</p>
    <p>Зауважте, що тепер параметр contents починається з val. Це скорочення, що
      визначає одночаc<code></code>но параметр та поле з тим же ім'ям. Більш
      специфічно, клас ArrayElement тепер має (непереприсвоюване) поле contents,
      що може бути доступне за межами класу. Поле ініціалізоване значенням
      параметра. Це так, якби клас був написаний таким чином, де x123 є
      довільним новим ім'ям параметра:</p>
    <pre class="prettyprint linenums language-scala">class ArrayElement(x123: Array[String]) extends Element {
  val contents: Array[String] = x123
}</pre>
    <p>Ви також можете почати параметр класа за допомогою var, в якому випадку
      відповідне поле може бути перепризначене. Нарешті, можливо додати
      модифікатори, такі як private, protected, або override до ціх
      параметричних полів, таким же чином, як ви можете зробити для любого
      іншого члена класа. Розгляньте, наприклад, наступне визначення класа:</p>
    <pre class="prettyprint linenums language-scala">class Cat {
  val dangerous = false
}
class Tiger(
  override val dangerous: Boolean,
  private var age: Int
) extends Cat</pre>
    <p>Модифікатор protected, що гарантує доступ до субкласів, буде детально
      пояснений в Главі 13. Визначення Tiger є скороченням для наступної
      альтернативи визначення класу, з перевизначенним методом dangerous, та
      приватним методом age :</p>
    <pre class="prettyprint linenums language-scala">class Tiger(param1: Boolean, param2: Int) extends Cat {
  override val dangerous = param1
  private var age = param2
}</pre>
    <p>Обоє члени ініціалізовані з відповідних параметрів. Ми довільно обрали
      імена ціх параметрів, param1 та param2. Важлива річ, що вони не
      перетинаються з іншими іменами в полі зору.</p>
    <h3>10.7 Виклик конструкторів суперкласа</h3>
    <p>Тепер ви маєте повну систему, що складається з двох класів: абстрактного
      класа Element, що розширений конкретним класом ArrayElement. Ви можете
      також побачити інші шляхи для вираження елемента. Наприклад, клієнт може
      побажати створити елемент розташування, що складається з одного рядка, що
      утворює лінію. Об'єктно-орієнтовне програмування спрощує розширення
      системи за допомогою нових варіантів даних. Ви можете просто додати
      субкалс. Наприклад, Лістинг 10.6 показує клас LineElement, що розширює
      ArrayElement:</p>
    <pre class="prettyprint linenums language-scala">class LineElement(s: String) extends ArrayElement(Array(s)) {
  override def width = s.length
  override def height = 1
}</pre>
    <p>Лістинг 10.6 Включаючи конструктор суперкласу.</p>
    <p>Оскільки LineElement розширює ArrayElement, та конструктор ArrayElement
      приймає параметр (Array[String]), LineElement потребує передання аргумента
      первинному конструктору суперкласа. Щоб викликати конструктор суперкласа,
      ви просто можете покласти бажаний аргмунт або аргументи в дужки, що йдуть
      за іменем суперкласа. Наприклад, клас LineElement передає декілька Array
      до первинного конструктора ArrayElement, кладучи його в дужки після імені
      суперкласа ArrayElement:</p>
    <pre class="prettyprint linenums language-scala">... extends ArrayElement(Array(s)) ...</pre>
    <pre class="prettyprint linenums language-scala">     Element
    «abstract»
        ^<br>   ArrayElement  &lt;- Array[String]
        ^<br>    LineElement</pre>
    <p>Малюнок 10.2 Діаграма класа для LineElement.</p>
    <p>З новим субкласом ієрархія наслідування для елементів розташування тепер
      виглядає як на Малюнку 10.2.</p>
    <h3>10.8 Використання модифікатора override</h3>
    <p>Зауважте, що визначення width та height в LineElement містять модифікатор
      override. В Розділі 6.3 ви бачили цей модифікатор в визначенні метода
      toString. Scala вимагає цей модифікатор для всіх членів, що перевизначають
      конкретний член в батьківському класі. Модифікатор є опціональним, якщо
      член реалізує абстрактний член з тим же ім'ям. Модифікатор заборонений,
      якщо член не перевизначає або реалізує деякий інший член базового класу.
      Оскільки height та width в класі&nbsp; LineElement перекривають конкретні
      визначення в класі Element, присутніть override вимушена. </p>
    <p>Це правило провадить корисну інформацію для компілятора, що допомагає
      уникнути деякі складні для відлову помилки, та робить розвиток системи
      простішою. Наприклад, якщо ви випадково помилились в назві метода, або
      випадково надали йому інший список параметрів, компілятор відповість
      повідомленням про помилку:</p>
    <pre class="prettyprint linenums language-scala">$ scalac LineElement.scala
.../LineElement.scala:50:
error: method hight overrides nothing
  override def hight = 1
           ˆ</pre>
    Домовленість перевизначення навіть більш важлива, коли йдеться про розвиток
    системи. Скажімо, ви визначили бібліотеку методів 2D малювання. Ви зробили
    її публічно доступною, та вона масово застосовується. В наступній версії
    бібліотеки ви бажаєте додати до вашого базового класа Shape новий метод з
    такою сигнатурою:
    <pre class="prettyprint linenums language-scala">def hidden(): Boolean</pre>
    <p>Ваш новий метод буде використаний в багатьох методах малювання, щоб
      визначити, чи фігура має бути намальована. Це може призвести до значного
      прискорення, але ви не можете зробити це без ризику поламати клієнтський
      код. Кінець кінцем, клієнт може визначити субклас Shape з іншою
      реалізацією hidden. Можилво, метод об'єкта насправді приховує об'єкт,
      замість перевіряти, чи він є прихованим. Оскільки дві версії hidden
      перевизначають одна одну, ваш метод малювання може закінчити тим, що
      приховуватиме об'єкт, що, напевне, не те, чого ви прагнете! Ці&nbsp;
      “випадкові перевизначення” є найбільш загальною маніфестацією того, що
      називається проблемою “крихкого базового класа”. Проблема в тому, що якщо
      ви додаєте новий член до базового класу (що ми звичайно називаємо
      суперкласом) в ієрархії класів, ви ризикуєте поламати клієнтський код.</p>
    <p>Scala не може повністю вирішити проблему крихкого базового класу, але
      порівняно з Java вона поліпшує ситуацію.&nbsp; Якщо бібліотека малювання,
      та її клієнти написані в Scala, тоді оригінальна реалізація клієнта hidden
      може не мати модифікатора override, оскільки на той час немає іншого
      метода з цім ім'ям. Коли ви додасте метод hidden до другої весії свойого
      класа фігури, рекомпіляція клієнта буде давати помилку, як наступна:</p>
    <pre class="prettyprint linenums language-scala">.../Shapes.scala:6: error: error overriding method
    hidden in class Shape of type ()Boolean;
method hidden needs `override' modifier
def hidden(): Boolean =
ˆ</pre>
    Тобто, замість хибної поведінки, ваш клієнт буде отримувати помилку
    компіляції, що, зазвичай, більш прийнятне. В Java 1.5 була введена анотація
    @Override, що робить подібно до модифікатора Scala override, але, на відміну
    від Scala override, вона не обов'язкова.
    <h3>10.9 Поліморфізм та динамічне зв'язування</h3>
    <p>Ви бачили в Розлілі 10.4, що змінна типу Element може посилатись на
      об'єкт типу ArrayElement. Ім'я цього феномена є поліморіфзм, що означає
      “багатогранний” або “що має декілька форм”. В цьому випадку об'єкти
      Element можуть приймати декілька форм. До тепер ми бачили дві форми:
      ArrayElement та LineElement. Ви можете створити більше форм Element,
      визначаючи нові субкласи Element. Наприклад, ось як ви можете визначити
      нову форму Element, що має надану ширину та висоту, та повністю заповнена
      наданим символом:</p>
    <pre class="prettyprint linenums language-scala">class UniformElement(
  ch: Char,
  override val width: Int,
  override val height: Int
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}</pre>
    <p>Ієрархія наслідування для класа Element тепер виглядає як показано на
      Малюнку 10.3. </p>
    <pre class="prettyprint linenums language-scala">               AbstractElement<br>                 «abstract»
UniformElement                   ArrayElement<br>          <br>                                &nbsp;LineElement</pre>
    <p>Малюнок 10.3 Ієрархія класів елементів розташування.</p>
    <p>Як результат, Scala буде сприймати всі з наступних присвоєнь, оскільки
      тип просвоєтого виразу відповідає типи визначеної змінної:</p>
    <pre class="prettyprint linenums language-scala">val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)</pre>
    Якщо ви подивитесь на ієрархію наслідування, ви винайдете, що для кожного з
    ціх чотирьох визначень val, тип виразу зправа від знака рівності є нижчим
    від типу val, що ініціалізується зліва від знаку рівності. Інша частина
    історії, однак, полягає в тому, що виклик методів на змінних та виразах
    зв'язуються динамічно. Це означає, що дійсна реалізація метода, що буде
    викликаний, визначається під час виконання, на основі класу об'єкта, не на
    типі змінної або вираза. Щоб продемструвати цю поведінку, ми тимчасово
    видалимо всі існуючі члени з нашого Element, та додамо метод, названий demo
    до Element. Ми перевизначимо demo в ArrayElement та LineElement, але не в
    UniformElement :
    <pre class="prettyprint linenums language-scala">abstract class Element {
  def demo() {
    println("Викликана реалізація Element")
  }
}<br><br>class ArrayElement extends Element {
  override def demo() {
    println("Викликана реалізація ArrayElement")
  }
}
<br>class LineElement extends ArrayElement {
  override def demo() {
    println("Викликана реалізація LineElement")
  }
}
<br>// UniformElement наслідує Element demo
class UniformElement extends Element</pre>
    <p>Якщо ви введете цей код в інтерпретатор, ви потім можете визначити цей
      метод, що приймає Element, та викликає на ньому demo:</p>
    <pre class="prettyprint linenums language-scala">def invokeDemo(e: Element) {
  e.demo()
}</pre>
    <p>Якщо ви передасте ArrayElement до invokeDemo, ви побачите повідомлення,
      що вказує, що викликана реалізація ArrayElement demo, навіть якщо тип
      змінної, e, на якій був викликаний demo, був Element:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new ArrayElement)
ArrayElement's implementation invoked </pre>
    <p>Подібно, якщо ви передасте LineElement до invokeDemo, ви побачите
      повідомлення, що вказує, що був викликаний LineElement demo:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new LineElement)
LineElement's implementation invoked</pre>
    <p>Поведінка при передачі UniformElement може на перший погляд виглядати
      підозрілою, але вона коректна:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; invokeDemo(new UniformElement)</pre>
    <p>Реалізація Element визвана, тому що UniformElement не перевизначає demo,
      він наслідує реалізацію demo від суперкласа, Element. Таким чином,
      реалізація Element є коректною реалізацією demo, що треба викликати, коли
      клас об'єкта є UniformElement.</p>
    <h3>10.10 Декларація фінальних членів</h3>
    <p>Іноді, при розробці ієрерхії наслідування, ви бажаєте переконатись, що
      член не може бути перевизначеним в субкласі. В Scala, як і в Java, ви
      можете зробити це, додавши модифікатор final до члена. Наприклад, ви
      можете поставити модифікатор final на метод ArrayElement demo, як показано
      в Лістингу 10.7.</p>
    <p>Маючи цю версію ArrayElement, спроба перевизначити demo в субкласі
      LineElement, не буде компілюватись:</p>
    <pre class="prettyprint linenums language-scala">class ArrayElement extends Element {
  final override def demo() {
    println("ArrayElement's implementation invoked")
  }
}</pre>
    <p>Лістинг 10.7 Декларування фінального метода.</p>
    <pre class="prettyprint linenums language-scala">elem.scala:18: error: error overriding method demo
    in class ArrayElement of type ()Unit;
method demo cannot override final member
override def demo() {
             ˆ</pre>
    <p>Ви також часом забажаєте переконатись, що весь клас не буде
      наслідуватись. Щоб зробити це, ви просто декларуєте цілий клас як&nbsp;
      final, додаючи модифікатор final до декларації класа. Наприклад, Лістинг
      10.8 показує, як ви декларуєте ArrayElement як final:</p>
    <pre class="prettyprint linenums language-scala">final class ArrayElement extends Element {
  override def demo() {
    println("ArrayElement's implementation invoked")
  }
}</pre>
    <p>Лістинг 10.8 Декларування фінального класа.</p>
    <p>З цією версією ArrayElement люба спроба визначити субклас не буде
      компілюватись:</p>
    <pre class="prettyprint linenums language-scala">elem.scala: 18: error: illegal inheritance from final class
    ArrayElement
class LineElement extends ArrayElement {
                          ˆ</pre>
    <p>Тепер ми видаляємо модифікатор final та метод demo, та повертаємось до
      ранішньої реалізації сімейства Element. Ми сфокусуємо нашу увагу у залишку
      цієї глави на довершені робочої вермсії цієї бібліотеки розташування.</p>
    <h3>10.11 Використання композиції та наслідування</h3>
    <p>Композиція та наслідування є двома смособами визначити новий клас в
      термінах іншого існуючого класа. Якщо ви найбільш бажаєте досягти
      повторного використання кода, ви, загалом, повинні схилятись до
      композиції, а не наслідування. Наслідування єдине потерпає від проблеми
      крихкого базового класа, коли ви можете випадково поламати субкласи, через
      зміну суперкласу.</p>
    <p>Одне запитання, що ви можете задати собі щодо відношення наслідування,
      це: коли воно моделює відношення є-одним-з. Наприклад, має сенс сказати,
      що ArrayElement є-одним-з Element. Інше питання, що ви можете задати: чи
      клієнти бажатимуть використовувати тип субкласа як тип суперкласа. В
      випадку ArrayElement, ми, очевидно, очікіємо, що клієнти будуть бажати
      використовувати ArrayElement як Element.</p>
    <p>Якщо ви питаєте ці запитання щодо відношень наслідування, показаних на
      Малюнку 10.3, чи не виглядають деякі з відношень підозрілими? Зокрема, чи
      не виглядає для вас очевидним, що LineElement є-одним-з ArrayElement? Чи
      ви вважаєте, клієнти будуть колись потребувати використання LineElement як
      ArrayElement? Фактично, ми визначили LineElement як субклас ArrayElement,
      тільки щоб повторно задіяти визначення ArrayElement contents. Можливо,
      буде краще, визначити LineElement як прямий субклас Element, ось так:</p>
    <pre class="prettyprint linenums language-scala">class LineElement(s: String) extends Element {
  val contents = Array(s)
  override def width = s.length
  override def height = 1
}</pre>
    <p>В попередній версії LineElement мав відношення наслідування з
      ArrayElement, від якого він наслідував contents. Тепер він має відношення
      композиції з Array: він містить посилання на масив рядків зі свого
      власного поля contents. Маючи цю реалізацію LineElement, ієрархія
      наслідування для Element тепер виглядає як показане на Малюнку 10.4.</p>
    <p>Клас ArrayElement також має відношення композиції з Array, оскільки його
      параметричне поле contents місмтить посилання на масив рядків. Код для
      ArrayElement показаний в Лістингу 10.5. Його відношення композиції
      представлене в діаграмах класів кристалом, як показане, наприклад, на
      Малюнку 10.1.</p>
    <pre class="prettyprint linenums language-scala">                     Element
                    «abstract»<br><br>ArrayElement        LineElement       UniformElement
</pre>
    <p>Малюнок 10.4 Ієрархія класів з перевизначеним LineElement.</p>
    <h3>10.12 Реалізація above, beside та toString</h3>
    <p>В якості наступного крока ми реалізуємо метод above в класі Element.
      Поставити один елемент над іншим означає конкатенувати два значення
      contents елементів. Так що перший чорновик метода above може виглядати
      наступним чином:</p>
    <pre class="prettyprint linenums language-scala">def above(that: Element): Element =
  new ArrayElement(this.contents ++ that.contents)</pre>
    <p>Операція ++ конкатенує два масива. Масиви в Scala представлені як масиви
      Java, але підтримують значно більше методів. Більше того, масиви в Scala
      можуть бути конвертовані в примірники класа scala.Seq, що представляє
      послідовніть-подібні структури, та містить декілька методів для доступу та
      трансформації послідовностей. Деякі інші методи масивів будуть пояснені в
      цій главі, та повномаштабна дискусія буде надана в Главі 17.</p>
    <p>Фактично, попередньо показаний код не є дуже ефективним, оскільки він не
      дозволяє вам покласти елементи з різною шириною один на одний. Однак щоб
      утримувати речі простими в цьому розділі, ми залишимо це як є, та будемо
      передавати до above елементи однакової довжили. В Розділі 10.14 ми зробимо
      покращення above, так що клієнти зможуть використовувати його для
      комбінування елементів різної ширини.</p>
    <p>Наступний метод, що ми реалізуємо, буде beside. Щоб розташувати два
      елементи один поряд з іншим, ми створимо новий елемент, в кожному рядку
      якого будуть конкатеновані відповідні рядки двох елементів. Як і раніше,
      щоб утримувати речі простими, ми почнемо з припущення, що два елементи
      мають однакову висоту. Це призведе до наступного дизайну метода beside:</p>
    <pre class="prettyprint linenums language-scala">def beside(that: Element): Element = {
  val contents = new Array[String](this.contents.length)
  for (i &lt;- 0 until this.contents.length)
    contents(i) = this.contents(i) + that.contents(i)
  new ArrayElement(contents)
}</pre>
    <p>Метод спочатку розміщує новий масив, contents, та заповнює його
      конкатенаціями відповідних елементів масивів this.contents та
      that.contents. Нарешті він продукує новий ArrayElement, що містить новий
      contents.</p>
    <p>Хоча ця реалізація beside робить, вона виконана в імперативному стилі,
      промовистою ознакою якого є цикл, в якому ми індексуємо масиви.
      Альтернативно метод може бути скорочений до одного виразу:</p>
    <pre class="prettyprint linenums language-scala">new ArrayElement(
  for (
    (line1, line2) &lt;- this.contents zip that.contents
  ) yield line1 + line2
)</pre>
    <p>Тут два масиви, this.contents та that.contents, трансформуються в масив
      пар (що представлені як Tuple2), з використанням оператора zip. Метод zip
      підхоплює відповідні елементи з двох аргументів, та формує масив пар.
      Наприклад, цей вираз:</p>
    <pre class="prettyprint linenums language-scala">Array(1, 2, 3) zip Array("a", "b")</pre>
    <p>буде обчислюватись як:</p>
    <pre class="prettyprint linenums language-scala">Array((1, "a"), (2, "b"))</pre>
    <p>Якщо один з двох масивів-операндів довший ніж інший, zip буде скидати
      залишкові елементи. В виразі вище третій елемент лівого операнда, 3, не
      формує пару з результатом, оскільки він не має відповідного елемента в
      правому операнді.</p>
    <p>Зипований масив потім ітерується через вираз for. Тут синтаксист “for
      ((line1, line2) &lt;- . . . )” дозволяє вам назвати обоє елементи пари в
      одному шаблоні, тобто line1 тепер означає перший елемент пари, та line2
      означає другий. Система порівняння з шаблоном Scala буде описана в Главі
      15. На цей час ви можете думати про це, як про дві val, line1 та line2, на
      кожному кроці ітерації. Вираз for має частину yield, і, таким чином, надає
      результат. Результат є того ж типу, що і вираз по якому ітерується, тобто,
      це масив. Кожний елемент масива є результатом конкатенації відповідних
      рядків, line1 та line2. Так що кінцевий результат цього кода буде той
      самий, що і першої версії beside, але оскільки він уникає прямої
      індексації масивів, результат буде отриманий в менш помилко-схильний
      спосіб.</p>
    <p>Вам все ще треба спосіб для відображення елементів. Як звичано, це
      робиться через визначення метода toString, що повертає елемент,
      форматований як рядок. Ось його визначення:</p>
    <pre class="prettyprint linenums language-scala">override def toString = contents mkString "\n"</pre>
    <p>Реалізація toString використовує mkString, що визначений для всіх
      послідовностей, включаючи масиви. Як ви бачили в Розділі 7.8, вираз
      вигляда “arr mkString sep” повертає рядок, що складається з усіх елементів
      масива arr. Кожний елемент відображується на рядок, з викликом його метода
      toString. Рядок роздільника sep вставляється між сусідніми
      елементами-рядками. Так що вираз “contents mkString "\n"” форматує масив
      contents як рядок, де кожний елемент масива опиняється в окремому рядку. </p>
    <p>Зауважте, що toString не має пустого списку параметрів. Це слідує
      рекомендаціям для одноманітного принципу доступу, оскільки toString є
      чистим методом, що не приймає жодних параметрів. З додаванням ціх трьох
      методів клас Element тепер виглядає як показано в Лістингу 10.9.</p>
    <h3>10.13 Визначення об'єкта-фабрики</h3>
    <p>Ви маєте ієрархію класів для елементів розташування. Ця ієрархія може
      бути представлена вашим клієнтам “як є”. Але ви також можете обрати
      приховати ієрархію за об'єктом-фабрикою. Об'єкт-фабрика містить методи, що
      конструюють інші об'єкти. Потім клієнти можуть використовувати ці
      методи-фабрики для створення об'єктів, скоріше, ніж конструювати об'єкти
      напряму, за допомогою new. Перевага цього підходу в тому, що створення
      об'єкта може бути централізоване, та деталі, як об'єкти представлені
      класами, можуть бути приховані. Це приховання буде одночасно робити вашу
      бібліотеку простішою для розуміння клієнтами, оскільки менше деталей буде
      висвітлено, та дає вам більше можливостей пізніше змінити реалізацію вашої
      бібліотеки, без ламання клієнтського кода. </p>
    <pre class="prettyprint linenums language-scala">abstract class Element {
  def contents: Array[String]
  def width: Int =
    if (height == 0) 0 else contents(0).length
  def height: Int = contents.length
  def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)
  def beside(that: Element): Element =
    new ArrayElement(
      for (
        (line1, line2) &lt;- this.contents zip that.contents
        ) yield line1 + line2
    )
  override def toString = contents mkString "\n"
}</pre>
    <p>Лістинг 10.9 Клієнт Element з above, beside та toString.</p>
    Перше завдання в конструюванні фабрики елементів є обрати розташування, де
    будуть розташовані методи-фабрики. Чи повінні вони бути членами
    об'єкта-синглтона, або класа? Що повинно викликатись в об'єті або класі? Є
    багато можливостей. Прямолінійне рішення є створити об'єкт-компанйон до
    класу Element, та зробити його об'єктом-фабрикою для елементів розташування.
    Таким чином, вам треба показати клієнтам тільки комбінацію класа/об'єкта, та
    ви можете приховати три класа реалізації ArrayElement, LineElement, та
    UniformElement.
    <p>Лістинг 10.10 є дизайном об'єкта Element, що слідує цій схемі.
      Об'єкт-компанйон Element містить три перевантажені варіанта метода elem.
      Кожний варіант конструює різний тип об'єкта розташування. З пришестям ціх
      методів-фабрик, має сенс змінити реалізацію класа Element, так щоб вона
      проходила через метод-фабрику elem, скоріше ніж напряму створення нових
      примірників ArrayElement. Щоб визвати методи-фабрики без кваліфікації їх
      за допомогою імені об'єкта-синглтона Element, ми будемо імпортувати
      Element.elem на поверхні в файлі з кодом. Іншими словами, замість виклика
      метода-фабрики за допомогою Element.elem в класі Element, ми імпортуємо
      Element.elem, так що ми зможемо тільки викликати методи-фабрики за їх
      простим ім'ям, elem. Лістинг 10.11 показує, як клас Element буде виглядати
      після ціх змін. </p>
    <pre class="prettyprint linenums language-scala">object Element {
  def elem(contents: Array[String]): Element =
    new ArrayElement(contents)
  def elem(chr: Char, width: Int, height: Int): Element =
    new UniformElement(chr, width, height)
  def elem(line: String): Element =
    new LineElement(line)
}</pre>
    <p>Лістинг 10.10 Об'єкт-фабрика з методами-фабриками.</p>
    На додаток, маючи методи-фабрики, субкласи ArrayElement, LineElement та
    UniformElement тепер можуть бути приватні, оскільки вони більше не повинні
    бути доступні напряму з клієнтів. В Scala ви можете визначити класи та
    об'єкти-синглтони в інших класах та об'єктах-синглтонах. Таким чином, один
    шлях зробити субкласи Element приватними є розташувати їх в
    об'єкті-синглтоні Element, та декларувати їх тут як приватні. Класи все ще
    можуть бути доступні для трьох методів-фабрик elem, де вони будуть потрібні.
    Лістинг 10.12 показує, як це буде виглядати.
    <h3>10.14 Підвищуємо та розширюємо</h3>
    <p>Нам треба одне останнє покращення. Версія Element, показана в Лістингу
      10.11, не є повністю достатньою, оскільки вона не дозволяє клієнтам
      покладати елементи з різною шириною один зверху іншого, або ставити
      елементи різної висоти поруч одне одного. Наприклад, обчислення наступного
      виразу не буде робити коректно, оскільки другий рядок в комбінованому
      елементі довший ніж перший:</p>
    <pre class="prettyprint linenums language-scala">new ArrayElement(Array("hello")) above
new ArrayElement(Array("world!"))

import Element.elem
abstract class Element {
  def contents: Array[String]
  def width: Int =
    if (height == 0) 0 else contents(0).length
  def height: Int = contents.length
  def above(that: Element): Element =
    elem(this.contents ++ that.contents)
  def beside(that: Element): Element =
    elem(
      for (
        (line1, line2) &lt;- this.contents zip that.contents
      ) yield line1 + line2
    )
  override def toString = contents mkString "\n"
}</pre>
    <p>Лістинг 10.11 Рефакторений клас Element для використання методів-фабрик.</p>
    <p>Подібно до цього, обчислення наступного виразу не буде робити як треба,
      оскільки перший ArrayElement має висоту два, та другий висоту тільки один:</p>
    <pre class="prettyprint linenums language-scala">new ArrayElement(Array("one", "two")) beside
new ArrayElement(Array("one"))</pre>
    <p>Лістинг 10.13 показує допоміжний приватний метод, widen, що приймає
      ширину, та повертає Element такої ширини. Результат містить contents цього
      Element, відцентрований, доповнений зліва та зправа проміжками, потрібними
      для отримання потрібної ширини. Лістинг 10.13 також показує подібний
      метод, heighten, що виконує ту ж функцію в вертикальному напрямку. Метод
      widen викликається з above, щоб переконатись, що Element, розміщені один
      під одним, мають однакову ширину. Подібним чином, метод heighten
      викликається з beside, щоб переконатись, що елементи, поставлені поряд
      один одного, мають ту саму висоту. З ціма змінами бібліотека розташування
      готова для використання.</p>
    <pre class="prettyprint linenums language-scala">object Element {
  private class ArrayElement(
    val contents: Array[String]
  ) extends Element
  private class LineElement(s: String) extends Element {
    val contents = Array(s)
    override def width = s.length
    override def height = 1
  }
  private class UniformElement(
    ch: Char,
    override val width: Int,
    override val height: Int
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
  }
  def elem(contents: Array[String]): Element =
    new ArrayElement(contents)
  def elem(chr: Char, width: Int, height: Int): Element =
    new UniformElement(chr, width, height)
  def elem(line: String): Element =
    new LineElement(line)
}</pre>
    <p>Лістинг 10.12 Приховування реалізації за допомогою приватних класів.</p>
    <pre class="prettyprint linenums language-scala">import Element.elem
abstract class Element {
  def contents: Array[String]
  def width: Int = contents(0).length
  def height: Int = contents.length
<br>  def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    elem(this1.contents ++ that1.contents)
  }
<br>  def beside(that: Element): Element = {
    val this1 = this heighten that.height
    val that1 = that heighten this.height
    elem(
      for ((line1, line2) &lt;- this1.contents zip that1.contents)
        yield line1 + line2)
  }
<br>  def widen(w: Int): Element =
    if (w &lt;= width) this
      else {
        val left = elem(' ', (w - width) / 2, height)
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
      }
<br>  def heighten(h: Int): Element =
    if (h &lt;= height) this
    else {
      val top = elem(' ', width, (h - height) / 2)
      var bot = elem(' ', width, h - height - top.height)
      top above this above bot
    }
<br>  override def toString = contents mkString "\n"
}</pre>
    <p>Лістинг 10.13 Element з методами widen та heighten.</p>
    <h3>10.15 Скадаємо все разом</h3>
    <p>Цікавим завданням, серед усіх елементів бібліотеки розташуванн, є
      написання програми, що малює спіраль з заданим числом ребер. Наша програма
      Spiral, показана в Лістингу 10.14, робить саме це:</p>
    <pre class="prettyprint linenums language-scala">import Element.elem
object Spiral {
  val space = elem(" ")
  val corner = elem("+")
  def spiral(nEdges: Int, direction: Int): Element = {
    if (nEdges == 1)
      elem("+")
    else {
      val sp = spiral(nEdges - 1, (direction + 3) % 4)
      def verticalBar = elem('|', 1, sp.height)
      def horizontalBar = elem('-', sp.width, 1)
      if (direction == 0)
        (corner beside horizontalBar) above (sp beside space)
      else if (direction == 1)
        (sp above space) beside (corner above verticalBar)
      else if (direction == 2)
        (space beside sp) above (horizontalBar beside corner)
      else
        (verticalBar above corner) beside (space above sp)
    }
  }<br><br> &nbsp;def main(args: Array[String]) {
    val nSides = args(0).toInt
    println(spiral(nSides, 0))
  }
}</pre>
    <p>Лістинг 10.14 Застосування Spiral.</p>
    <p>Оскільки Spiral є окремим об'єктом з методом main відповідної сигнатуру,
      це є застосування Scala. Spiral приймає один аргумент командного рядка,
      ціле, та малює спіраль з вказаним числом ребер. Наприклад, ви можете
      намалювати шести-реберну спіраль, як показано нижче зліва, та більші, як
      показано зправа:</p>
    <pre class="prettyprint linenums language-scala">$ scala Spiral 6       $ scala Spiral 11        $ scala Spiral 17
+-----                 +----------              +----------------
|                      |                        |               
| +-+                  | +------+               | +------------+ 
| + |                  | |      |               | |            | 
|   |                  | | +--+ |               | | +--------+ |  
+---+                  | | |  | |               | | |        | |<br>                       | | ++ | |               | | | +----+ | |<br>                       | |    | |               | | | |    | | |<br>                       | +----+ |               | | | | ++ | | |<br>                       |        |               | | | |  | | | |<br>                       +--------+ &nbsp;             | | | +--+ | | |<br>                                                | | |      | | |<br>                                                | | +------+ | |<br>                                                | |          | |<br>                                                | +----------+ | <br>                                                |              |<br>                                                +--------------+ &nbsp; </pre>
    <h3>10.16 Висновок</h3>
    <p>В ціьому розділі ви бачили більше концепцій, пов'язаних з
      о'бєктно-орієнтовним програмуванням в Scala. Серед іншого, ви ознайомились
      з абстрактними класами, наслідуванням та субтипами, ієрархіями класів,
      параметричними полями та перевизначенням методів. Ви мали виробити
      відчуття для побудови нетривіальних ієрархій класів в Scala. Ми знову
      робитимемо з бібліотекою розташувань в Главі 14.</p>
    <h3>Глава 11</h3>
    <h2>Ієрархія Scala</h2>
    <p>Тепер, коли ви побчачили деталі наслідування класів в попередній главі,
      настав гарний час щоб зробити крок назад, та подивитись в цілому на
      ієрархію класів Scala. В Scala кожний клас наслідує від загального
      суперкласу на ім'я Any.</p>
    <p>Оскільки кожний клас є субкласом Any, методи, визначані в Any, є
      “цніверсальними методами”: вони можуть бути виклакині на кожному об'єкті.
      Scala також визначає деякі цікаві класи знизу ієрархії, Null та Nothing,
      що, загалом, діють як загальні субкласи. Наприклад, так, як Any є
      суперкласом для кожного іншого класа, Nothing є субкласом для кожного
      іншого класа. В цій главі ми зробимо тур по їєрархії класів Scala.</p>
    <h3>11.1 Ієрархія класів Scala</h3>
    <p>Малюнок 11.1 показує контур ієрархії класів Scala. Зверху ієрархії стоїть
      клас Any, що визначає методи, що включають наступне:</p>
    <pre class="prettyprint linenums language-scala">final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String</pre>
    <p>Оскільки кожний клас наслідує від Any, кожний об'єкт в програмі Scala
      може бути порівняний з використанням ==, !=, або equals; хешовані за
      допомогою ## або hashCode; та форматовані за допомогою toString . Методи
      еквівалентності та нерівності, == та !=, декларовані як final в класі Any,
      так що вони не можуть бути перевизначені в субкласах.</p>
    <p>Метод == загалом те саме, що equals, та != є завжди обертанням equals.
      Так що окремі класи можуть підкроїти, що означає == або !=, перевизначивши
      метод equals. Ми покажемо приклад пізніше в цій главі. Кореневий клас Any
      має два субкласи: AnyVal та AnyRef. AnyVal є батьківським класом для
      кожного вбудованого значення класа в Scala. Є дев'ять таких значень
      класів: Byte, Short, Char, Int, Long, Float, Double, Boolean, та Unit.
      Перші вісім з них відповідають примітивним типум Java, та їх значення
      представлені під час виконання як примітивні значення Java. Примірники ціх
      класів всі записані як літерали в Scala. Наприклад, 42 є примірником Int,
      'x' є примірником Char, та false є примірником Boolean. Ви не можете
      створити примірники ціх класів з використанням new . Це примушене через
      “трюк”, що класи значень всі визначені одночасно abstract та final. Так що
      якщо ви напишете таке, ви отримаєте помилку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Int
&lt;console&gt;:5: error: class Int is abstract; cannot be
     instantiated
new Int
ˆ</pre>
    <p>Інший клас значення, Unit, грубо відповідає класу Java void; він
      використовується як тип результата метода, що інакше не повертає цікавого
      результата. Unit має єдине значення примірника, що записується (), що
      обговорювалось в Розділі 7.2.</p>
    <p>Як пояснено в Главі 5, класи значень підтримують звичайні арифметичні та
      логічні операції як методи. Наприклад, Int має методи на ім'я&nbsp; + та
      *, та Boolean має методи з іменами || та &amp;&amp; . Класи значень також
      наслідують всі методи від класа Any. Ви можете перевірити це в
      інтерпретаторі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 42.toString
res1: java.lang.String = 42
<br>scala&gt; 42.hashCode
res2: Int = 42
<br>scala&gt; 42 equals 42
res3: Boolean = true</pre>
    <p>Зауважте, що простір класів значень плаский; всі класи значення є
      субтипами до&nbsp; scala.AnyVal, але вони не наслідують один одного.
      Замість цього є неявні перетворення між різними типуми класів значення.
      Наприклад, за потреби, примірник класа scala.Int автоматично розширюється
      (через неявне перетворення) до примірника класа scala.Long.</p>
    <p>Як зазначалось в Розділі 5.9, неявні перетворення також використовуються
      для довавання більшої функціональності до типів значень. Наприклад, тип
      Int підтримує всі операції нижче:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; 42 max 43
res4: Int = 43
<br>scala&gt; 42 min 43
res5: Int = 42
<br>scala&gt; 1 until 5
res6: Range = Range(1, 2, 3, 4)
<br>scala&gt; 1 to 5
res7: Range.Inclusive = Range(1, 2, 3, 4, 5)
<br>scala&gt; 3.abs
res8: Int = 3
<br>scala&gt; (-3).abs
res9: Int = 3</pre>
    <p>Ось як це робить: методи min, max, until, to, та abs всі визначені в
      класі&nbsp; scala.runtime.RichInt, та є неявне перетворення від класу Int
      до RichInt. Перетворення застосоується кожного разу, коли метод
      викликається на Int, що не визначений в Int, але визначений в RichInt.</p>
    <p>Подібно існують “класи-прискорювачі” та неявні перетворювачі для інших
      класів значень. Неявні перетворення будуть обговорені в Главі&nbsp; 21.
      Інший субклас до кореневого класа Any є клас AnyRef . Це базовий клас до
      всіх класів посилань в Scala. Як вже обговорювалось, на Java платформі
      AnyRef є, фактично, тільки псевдонимом для класа java.lang.Object. Так що
      класи, написані в Java, так само, що написані в Scala, всі насліудють від
      AnyRef. Таким чином, одним способом думати про java.lang.Object, є як про
      спосіб, яким AnyRef реалізований на платформі Java. Таким чином, хоча ви
      можете використовувати Object та AnyRef взаємозамінно в Scala програмах на
      платформі Java, рекомендований стиль завжди використовувати AnyRef. Класи
      Scala відрізняються від класів Java в тому, що вони також наслідують від
      спеціального маркерного трейта на ім'я&nbsp; ScalaObject .</p>
    <h3>11.2 Як реалізовані примітиви</h3>
    <p>Як все це реалізовано? Фактично, Scala зберігає цілі в той же спосіб, що
      і Java: як 32-біт слова. Це важливо для ефективності на JVM, а також для
      взаємодії з бібліотеками Java. Стандартні операції, як додавання або
      множення, реалізовані як примітивні операції. Однак, Scala використовує
      “класи підтримки”,&nbsp; java.lang.Integer, коли ціле потребує видимості
      як об'єкт (Java). Це, наприклад, трапляється, коли викликається метод
      toString на цілому числі, або коли призначається ціле до змінної типу Any.
      Цілі типу Int прозоро конвертуються до “запакованих цілих” типу
      java.lang.Integer, кожного разу, коли це потрібно. </p>
    <p>Все це виглядає як авто-боксинг в Java 5, та це, в жодному разі, подібне.
      Однак, існує одна важлива відмінність, в тому, що боксинг в Scala є значно
      менш помітний, ніж в Java. Спробуйте наступне в Java: </p>
    <pre class="prettyprint linenums language-scala">// Це Java
boolean isEqual(int x, int y) {
    return x == y;
}
System.out.println(isEqual(421, 421));</pre>
    <p>Ви напевне отримаєте true. Тепер змініть типи аргументів isEqual на
      java.lang.Integer (або Object, результат буде той самий). Причина того, що
      існує псевдонм AnyRef, замість простого використання імені
      java.lang.Object, оскільки Scala була розроблена для роботи на обох
      платформах, Java та .NET. На .NET AnyRef є псевдонимом до System.Object.</p>
    <pre class="prettyprint linenums language-scala">// Це Java
boolean isEqual(Integer x, Integer y) {
    return x == y;
}
System.out.println(isEqual(421, 421));</pre>
    <p>Ви винайдете, що ви отримаєте false! Що відбувається, це те, що число 421
      боксується двічи, так що аргумент для x та y є два різні об'єкти. Оскільки
      == означає рівність типів посилань, результат є false. Це один аспект, що
      показує, що Java не є чистим о'бєктно-орієнтованою мовою. Є різниця між
      примітивними типуми, та типуми посилань, що може бути просто досліджена.</p>
    <p>Тепер спробуємо той же експеримент в Scala:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def isEqual(x: Int, y: Int) = x == y
isEqual: (Int,Int)Boolean
<br>scala&gt; isEqual(421, 421)
res10: Boolean = true
<br>scala&gt; def isEqual(x: Any, y: Any) = x == y
isEqual: (Any,Any)Boolean
<br>scala&gt; isEqual(421, 421)
res11: Boolean = true</pre>
    <p>Фактично, операція == в Scala розроблена бути прозорою з точки зору до
      презентації типу. Для типів значення це природна (числова або логічна)
      рівність. Для типів посилань, інших, ніж боксовані числові типи Java, ==
      розглядається як псевдоним до метода equals, унаслідованого від Object.
      Цей метод оригінально розроблений як рівність посилань, але перевизначений
      багатьма субкласами, щоб реалізовати їх власну ідею щодо еквівалентності.
      Це також означає, що в Scala ви ніколи не піймаєтесь в гарно-відому пастку
      Java відповідно порівняння рядків. В Scala порівняння рядків робить так,
      як має:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val x = "abcd".substring(2)
x: java.lang.String = cd
<br>scala&gt; val y = "abcd".substring(2)
y: java.lang.String = cd
<br>scala&gt; x == y
res12: Boolean = true</pre>
    <p>В Java результат порівняння x з y буде false. Програміст повинен
      використовувати в цьому випадку equals, але це просто забути. Однак є
      ситуації, коли вам треба еквівалентність посилань, замість визначеної
      користувачем. Наприклад, в деяких ситуаціях, коли ефективність вирішує, ви
      бажаєте хешувати з деякими класами, та порівнювати іх примірники за
      допомгою еквівалентності посилань. Для ціх класів клас&nbsp; AnyRef
      визначає додатковий метод eq, що не може бути перевизначаний, та
      реалізований як еквівалентність посилань&nbsp; (тобто, він поводиться як
      == в Java для типів посилань).</p>
    <p>Є також протилежність eq, що називається ne. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val x = new String("abc")
x: java.lang.String = abc
<br>scala&gt; val y = new String("abc")
y: java.lang.String = abc
<br>scala&gt; x == y
res13: Boolean = true
<br>scala&gt; x eq y
res14: Boolean = false
<br>scala&gt; x ne y
res15: Boolean = true</pre>
    <p>Еквівалентність в Scala далі обговорюється в Главі 30.</p>
    <h3>11.3 Нижні типи</h3>
    <p>Знизу ієрархії на Малюнку 11.1 ви бачите два класи, scala.Null та
      scala.Nothing. Це впеціальні типи, що обслуговують деякі “прикордонні
      випадки” об'єктно-орієнтовної системи типів Scala, в одноманітний спосіб.
      Клас Null є типом посилання null; це субклас кожного класа посилання
      (тобто, кожного класа, що сам походить від AnyRef). Null несумісний з
      типуми значень. Ви не можете, наприклад, присвоїти значення null до цілої
      змінної:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val i: Int = null
&lt;console&gt;:4: error: type mismatch;
found
: Null(null)
required: Int</pre>
    <p>Тип Nothing є на самому дні ієрархії класів Scala; він є субтипом кожного
      іншого типу. Однак не існує жодного значення цього типу. Чому має сенс
      мати тип без значення? Як дискутувалось в Розділі 7.4, дехто може
      використовувати тип Nothing як сигнал нештатного завершення. Наприклад,
      існує метод error в об'єкті Predef стандартної бібліотеки Scala, що
      визначений таким типом:</p>
    <pre class="prettyprint linenums language-scala">def error(message: String): Nothing =
  throw new RuntimeException(message)</pre>
    <p>Тип результата помилки є Nothing, що каже користувачам, що метод не буде
      завершуватись в нормальний спосіб (замість цього він викликає виключення).
      Оскільки Nothing є субтипом любого іншого типу, ви можете використовувати
      такі методи, як error, в дуже гнучкий спосіб. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">def divide(x: Int, y: Int): Int =
  if (y != 0) x / y
  else error("can't divide by zero")</pre>
    <p>Гілка “then” умовного виразу, x / y, має тип Int, тоді як гілка else,
      виклик помилки, має тип Nothing. Оскільки Nothing є субтипом Int, тип
      цілого виразу є Int, як і треба.</p>
    <h3>11.4 Висновок</h3>
    <p>В цій главі ми показали вам класи нагорі на знизу ієрархії класів Scala.
      Тепер, коли ви отримали гарну основу з наслідування класів в Scala, ви
      готові зрозуміти композицію підмішування. В наслупній главі ви навчитесь
      щодо трейтів.</p>
    <h3>Глава 12</h3>
    <h2>Трейти</h2>
    <p>Трейти є фундаментальною одиницею повторного використання кода в Scala.
      Трейт інкапсулює визначення метода та поля, що потім може повторно
      використовуватись через підмішування їх до класів. На відміну від
      наслідування класів, коли кожний калс має наслідувати від одного
      суперкласа, клас може міксуватись з довільним числом трейтів. Ця глава
      покаже вам, як роблять трейти, та покаже два найбільш поширень способи, де
      вони корисні: розширення тонких інтерфейсів до більш багатих, та
      визначення накладених модифікацій. Тут також показано, як використовувати
      трейт Ordered, та порівняємо трейти з множинним наслідуванням в інших
      мовах.</p>
    <h3>12.1 Як роблять трейти</h3>
    <p>Визначення трейта виглядає&nbsp; як визначення класа, з тою різницею, що
      використовується ключове слово trait. Приклад показаний в Лістингу 12.1:</p>
    <pre class="prettyprint linenums language-scala">trait Philosophical {
  def philosophize() {
    println("I consume memory, therefore I am!")
  }
}</pre>
    <p>Лістинг 12.1 Визначення трейта Philosophical.</p>
    <p>Цей трейт названий Philosophical. Він не декларує суперклас, так що як
      клас, він має суперклас по замовчанню, AnyRef. Він визначає один метод,
      philosophize, що є конкретним. Це простий трейт, достатній тільки щоб
      показати роботу трейтів.</p>
    <p>Коли трейт визначений, він може бути зміксований (підмішаний) до класа,
      використовуючи ключові слова extends, або with. Програмісти Scala
      “міксують” трейти, скорішен, ніж наслідують від них, оскікільки
      підмішування трейта має суттєві відмінності від множинного наслідування,
      що можна знайти в багатьох інших мовах. Ця проблема розглядається в
      Розділі 12.6. Наприклад, Лістинг 12.2 показує клас, що міксує трейт
      Philosophical за допомогою extends :</p>
    <pre class="prettyprint linenums language-scala">class Frog extends Philosophical {
  override def toString = "green"
}</pre>
    <p>Лістинг 12.2 Підмішування трейта за допомогою extends .</p>
    <p>Ви можете використовувати ключове слово, щоб підмішати трейт; і цьому
      випадку ви неявно наслідуєте суперклас трейта. Наприклад, в&nbsp; Лістингу
      12.2, клас Frog є субкласом AnyRef (суперклас Philosophical ), та підмішує
      Philosophical. Методи, унаслідовані від трейта, можуть бути використані
      таким же чином, що і методи, унаслідовані від суперкласа. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val frog = new Frog
frog: Frog = green
<br>scala&gt; frog.philosophize()
I consume memory, therefore I am!</pre>
    <p>Трейт також визначає клас. Ось приклад, в якому Philosophical
      використовується як тип:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val phil: Philosophical = frog
phil: Philosophical = green
<br>scala&gt; phil.philosophize()
I consume memory, therefore I am!</pre>
    <p>Тип phil є Philosophical, трейт. Таким чином, змінна phil може
      ініціалюватись любим об'єктом, чий клас міксує Philosophical. Якщо ви
      бажаєте підмішати трейт до класа, що явно розширює суперклас, ви
      використовуєте extends, що вказує суперклас, та with, що підмішати трейт.
      Лістинг 12.3 показує приклад. Якщо ви бажаєте зміксувати декілька трейтів,
      ви додаєте більше&nbsp; тверджень with. Наприклад, маючи трейт HasLegs, ви
      можете зміксувати обоє, Philosophical та HasLegs у Frog, як показує
      Лістинг 12.4.</p>
    <pre class="prettyprint linenums language-scala">class Animal
  class Frog extends Animal with Philosophical {
    override def toString = "green"
  }</pre>
    <p>Лістинг 12.3 Міксування трейта за допомогою with .</p>
    <pre class="prettyprint linenums language-scala">class Animal
trait HasLegs
  class Frog extends Animal with Philosophical with HasLegs {
    override def toString = "green"<br>  }</pre>
    <p>Лістинг 12.4 Міксування декількох трейтів.</p>
    <p>В прикладах, що ви бачили дотепер, клас Frog наслідував реалізацію
      philosophize від трейта Philosophical. Альтернативно, Frog може
      перевизначити philosophize. Синтаксис виглядає такий самий, як
      перевизначення метода, задекларованого в суперкласі. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">class Animal 
  class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() {
      println("It ain't easy being "+ toString +"!")
    }
  }</pre>
    <p>Оскільки це нове визначення Frog все ще підмішує трейт Philosophical, ви
      можете використовувати його як змінну такого типу. Але оськільки Frog
      перевизначає реалізацію Philosophical метода philosophize, ви отримаєте
      нову поведінку, коли ви викличете його:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val phrog: Philosophical = new Frog
phrog: Philosophical = green
<br>scala&gt; phrog.philosophize()
It ain't easy being green!</pre>
    <p>В цьому місці ви можете філосовськи розмірковувати, що трейти - це як
      інтерфейси Java з конкретними методами, але вони, насправді, можуть значно
      більше. Трейти можуть, наприклад, декларувати поля та обслуговувати стан.
      Фактично, ви можете робити будь-що в визначенні трейта, з того, що ви
      можете робити в визначенні класа, та синтаксис виглядає точно тим самим,
      тільки з двома виключеннями. Перше, трейт не може мати жодних параметрів
      “класа”, тобто, параметрів, переданих до первинного конструктора класа.
      Іншими словами, хоча ви можете визначити клас таким чином: </p>
    <pre class="prettyprint linenums language-scala">class Point(x: Int, y: Int)</pre>
    <p>наступна спроба визначити трейт не буде компілюватись:</p>
    <pre class="prettyprint linenums language-scala">trait NoPoint(x: Int, y: Int) // Does not compile</pre>
    <p>Ви винайдете в Розділі 20.5, як обходити це обмеження. </p>
    <p>Інша відмінність між класами та трейтами в тому, що в класах виклики
      super пов'язані статично, тоді як в трейтах вони пов'язані динамічно. Якщо
      ви пишете “super.toString” в класі, ви точно знаєте, який метод реалізації
      буде викликаний. Однак, коли ви пишете теж саме в трейті, реалізація
      метода, що буде викликаний для виклику super не визначений на момент
      визначення трейта. Скоріше, реалізація, що буде викликана, буде визначена
      кожного раза, коли трейт міксується до конкретного класа. Ця цікава
      поведінка super є ключем, що дозволяє трейтам робити як накладані
      модифікації, що буде обговорено в Розділі 12.5. Правила для розрішення
      викликів super будуть надані в Розділі 12.6.</p>
    <h3>12.2 Протистояння тонких та багатих інтерфейсів</h3>
    <p>Одне головне використання трейтів є автоматичне додавання методів до
      класа, в термінах методів класа, що він вже має. Тобто, трейти можуть
      збагатити тонкий інтерфейс, перетворивши його на багатий інтерфейс.</p>
    <p>Протистояння тонких та багатих інтерфейсів представляє загальний
      коспроміс в об'єктно-орієнтованій розробці. Компроміс між тими, хто
      реалізує інтерфейс, та клієнтами. Багатий інтерфейс має багато методів, що
      робить його більш зручним до викликача. Клієнти можуть обрати метод, що
      точно співпадає з потрібною функціональністю. З іншого боку, тонкий
      інтерфейс має меньше методів, і, таким чином, простіший для реалізаторів.
      Натомість, клієнти, що викликають тонкий інтерфейс, мають писати більше
      кода. Маючи меньший вибір методів для виклика, вони можуть обрати меньш
      ніж ідеально підходяще для своїх потреб, та писати більше кода для його
      використання.</p>
    <p>Інтерфейси Java більш часто тонкі, ніж багаті. Наприклад, CharSequence,
      що був введений в Java 1.4, є тонким інтерфейсом, загальним для всіх
      рядко-подібних класів, що містять послідовність символів. </p>
    <p>Ось його визначення, якщо дивитись на нього як на трейт Scala:</p>
    <pre class="prettyprint linenums language-scala">trait CharSequence {
  def charAt(index: Int): Char
  def length: Int
  def subSequence(start: Int, end: Int): CharSequence
  def toString(): String<br>}</pre>
    <p>Хоча більшість з дюжин методів в класі String можуть застосовуватись до
      кожного CharSequence, інтерфейс Java CharSequence декларує тільки чотири
      методи. Якби замість цього CharSequence включав повний інтерфейс String,
      це б наклало великий безлад на реалізаторів CharSequence. Кожний
      програміст, що реалізував CharSequence в Java, мав би реалізувати дюжини
      методів. Оскільки трейти Scala можуть містити конкретні методи, вони
      роблять багаті інтерфейси значно більш зручними. Додавання конкретного
      метода до трейта схиляє компроміс тонкий-багатий значною мірою на бік
      багатих інтерфейсів. На відміну від Java, додавання конкретного метода до
      трейта Scala є одноразовим зусиллям. Вам треба реалізувати тільки метод
      один раз, в самому трейті, замість того, щоб реалізувати його для кожного
      класа, що міксує цей трейт. Таким чином, багаті інтерфейси вимагають
      меньшої роботи в Scala, ніж в мовах без трейтів.</p>
    <p>Щоб збагатити інтерфейс з використанням трейтів, просто визначте трейт з
      малим числом абстрактних методів — тонка частина інтерфейса трейта — та
      потенційно великим числом конкретних методів, що всі реалізовані в
      термінах абстрактних методів. Тоді ви можете міксувати збагачений трейт до
      класа, реалізовати тонку частину інтерфейса, та отримати клас, що має
      доступним весь багатий інтерфейс.</p>
    <h3>12.3 Приклад: прямокутні об'єкти</h3>
    <p>Графічні бібліотеки часто мають багато різних класів, що представляють
      дещо прямокутне. Деякими прикладами є вікна, бітові зображення та регіони,
      обрані за допомогои миши. Щоб зробити ці прямокутні об'єкти зручними в
      використанні, було б гарно, якщо бібліотека провадила геометричні запити,
      такі як width, height, left, right, topLeft, і так далі. Однак, існує
      багато таких методів, які б хотілось мати, що може бути великим безладом
      до створювачів бібліотеки, щоб провадити всі ці методи для всіх
      прямокутних об'єктівв бібліотеці Java. Напроти, якщо така бібліотека буде
      написана в Scala, створювач бібліотеки може використовувати трейти, щоб
      просто надати всі ці зручні методи до всіх класів, до яких побажає.</p>
    <p>Для того, щоб побачити, як це робить, для початку уявіть, на що буде
      схожий код без трейтів. Там будуть деякі геометричні класи, як Point та
      Rectangle :</p>
    <pre class="prettyprint linenums language-scala">class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point) {
def left = topLeft.x
def right = bottomRight.x
def width = right - left
// та ще багато геометричних методів...
}</pre>
    <p>Цей клас Rectangle приймає дві точки в своєму первинному конструкторі:
      координати вернього-лівого, та правого-нижнього кутів. Потім він реалізує
      багато зручних методів, таких, як left, right та width, виконуючи прості
      обчислення над ціма двома точками.</p>
    <p>Інший клас графічної бібліотеки може мати двовимірний 2-D графічний
      віджет:</p>
    <pre class="prettyprint linenums language-scala">abstract class Component {
  def topLeft: Point
  def bottomRight: Point
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
// та ще багато геометричних методів...
}</pre>
    <p>Зауважте, що визначення left, right та width такі з самі в обох класах.
      Вони також будуть однаковими, можливо з малими змінами, в кожному іншому
      класі для прямокутних об'єктів.</p>
    <p>Цього повторення можна уникнути за допомогою збагачуючого трейта. Трейт
      буде мати два абстрактні методи: один, що повертатиме верхню-ліву
      координату об'єкта, та другий, що повертає нижню-праву координату. Потім
      він може надати конкретні реалізації для всіх інших геометричних запитів.
      Лістинг 12.5 показує, на що це може виглядати:</p>
    <pre class="prettyprint linenums language-scala">trait Rectangular {
  def topLeft: Point
  def bottomRight: Point
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
// та ще багато геометричних...
}</pre>
    <p>Лістинг 12.5 · Визначення збагачуючого трейта.</p>
    <p>Клас Component може приміксувати цей трейс, щоб отримати всі геометричні
      методи, що провадить Rectangular:</p>
    <pre class="prettyprint linenums language-scala">abstract class Component extends Rectangular {
// інші методи...
}</pre>
    <p>Подібно, Rectangle сам може примішати трейт:</p>
    <pre class="prettyprint linenums language-scala">class Rectangle(val topLeft: Point, val bottomRight: Point)
  extends Rectangular {
// інші методи...
}</pre>
    <p>Маючи ці визначення, ви можете створити Rectangle, та викликати на ньому
      геометричні методи, такі як width та left:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val rect = new Rectangle(new Point(1, 1),
new Point(10, 10))
rect: Rectangle = Rectangle@3536fd
<br>scala&gt; rect.left
res2: Int = 1
<br>scala&gt; rect.right
res3: Int = 10
scala&gt; rect.width
res4: Int = 9</pre>
    <h3>12.4 Трейт Ordered</h3>
    <p>Порівняння є іншою галуззю, де зручні багаті інтерфейси. Кожного разу,
      коли ви порівнюєта два об'єкта, що впорядковані. є зручним, коли ви
      використовуєте єдиний виклик метода, для запита щодо точного бажаного
      порівняння. Якщо вам треба “меньше ніж”, ви викличите &lt;, та якщо
      “меньше або дорівнює”, ви викличите &lt;= . З тонким інтерфейсом
      порівняння, ви можете мати тільки метод &lt; method, та іноді вам
      доведеться писати дещо подібне до “(x &lt; y) || (x == y)”. Багатий
      інтерфес надасть вам всі звичайні оператори порівнянь, таким чином ви
      зразу зможете писати речі як “x &lt;= y”.</p>
    <p>Перед тим, як подивитись на Ordered, уявіть, що ви можете без нього.
      Уявіть, ви берете клас Rational з Глави 6, та додаєте до нього оператор
      порівняння. Ви можете дійти до чогось, подібного наступному:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
// ...
  def &lt; (that: Rational) =
    this.numer * that.denom &gt; that.numer * this.denom
  def &gt; (that: Rational) = that &lt; this
  def &lt;= (that: Rational) = (this &lt; that) || (this == that)
  def &gt;= (that: Rational) = (this &gt; that) || (this == that)
}</pre>
    <p>Цей клас визначає чотири оператора порівняння ( &lt;, &gt;, &lt;=, and
      &gt;= ), та це є класичною демонстрацією ціни визначення багатого
      інтерфейса. Зпершу, зауважте, що три з операторів порівняння визначені в
      термінах першого. Наприклад, &gt; визначений як протилежність &lt;, та
      &lt;= визначения як буквально “меньше або дорівнює”. Додатково, зауважте,
      що всі три методи будуть однакові для любого іншого класа, що піддається
      порівнянню. Немає нічого особливого щодо раціональних чисел щодо &lt;= . В
      контексті порівняння &lt;= завжди використовується в сенсі “меньше або
      дорівнює”. Загалом, в цьому класі існує досить багато шаблонного кода, що
      буде однаковим в кожному іншому класі, що реалізує операції порівняння.</p>
    <p>Ця проблема така загальна, що Scala провадить трей, що допомагає з цім.
      Трейт називається Ordered. Щоб використовувати його, ви заміняєте всі
      індифідуальні методи порівняння на один метод&nbsp;compare. Трейт Ordered
      потім визначає для вас &lt;, &gt;, &lt;=, та &gt;= в термінах цього
      метода. Таким чином, трейт Ordered дозволяє вам збагатити клас методами
      порівняння, реалізуючи методи порівняння через реалізацію одного метода,
      compare.</p>
    <p>Ось як поно виглядає, коли ви визначаєте операції порівняння для
      Rational, через використання трейта Ordered:</p>
    <pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) extends Ordered[Rational] {
// ...
  def compare(that: Rational) =
    (this.numer * that.denom) - (that.numer * this.denom)
}</pre>
    <p>Є тільки дві речі, що треба зробити. Перше, це версія Rational підмішує
      трейт <br>
      Ordered. На відміну від трейтів, що ми бачили до тепер, Ordered потребує,
      щоб ви вказали параметр типу, коли ви підмішуєте його. Параметри типів не
      будуть детально обговорюватись до Глави 19, але все, що вам треба знати,
      це те, що коли ви додаєте Ordered, ви, насправді, повинні домінувати
      Ordered[C], де C є класом, чиї елементи ви порівнюєте. В цьому випадку
      Rational міксується з Ordered[Rational] .</p>
    <p>Друга річ, що вам треба зробити, це визначити метод compare для
      порівняння двох об'єктів. Цей метод потрібен порівнювати отримувача, this,
      з об'єктом, переданим як аргумент до цього метода. Він повинен повертати
      ціле, що дорівнює нулю, якщо об'єкти однакові, від'ємне, якщо отримувач
      меньший за аргумент, та додатне, якщо отримувач більший за аргмумент. В
      цьому випадку метод comparison від Rational використовує формулу, що
      приводить раціональні до загального займенника, та потім віднімає отримані
      чисельними. Маючи це змішування, та визначення compare, тепер клас
      Rational має всі чотири метода порівняння:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val half = new Rational(1, 2)
half: Rational = 1/2
scala&gt; val third = new Rational(1, 3)
third: Rational = 1/3
scala&gt; half &lt; third
res5: Boolean = false
scala&gt; half &gt; third
res6: Boolean = true</pre>
    <p>Кожного разу, коли ви реалізуєте клас, що впорядкований за деяким
      порядком, вам слідує підмішувати трейт Ordered. Якщо ви зробите це, ви
      надасте користувачам класа багатний набір методів порівняння. Майте на
      увазі, що трейт Ordered не визначає метод equals за вас, оскільки він не в
      змозі це зробити. Проблема в тому, що реалізація equals в термінах compare
      потребує перевірки типу переданого об'єкта, та завдяки затиранню типів,
      Ordered сам по собі не може виконати цю перевірку. Таким чином, вам треба
      визначити equals самому, навіть якщо ви наслідуєте Ordered. Ви побачити,
      як пройти це, в Главі 30.</p>
    <h3>12.5 Трейти та перекриття модифікацій</h3>
    <p>Тепер ви бачили одне головне використання трейтів: перетворення тонкого
      інтерфейса на багатий. Тепер ми перейдемо до другого важливого
      використання: надання класам стекових (накладених) модифікацій. Трейти
      дозволяють вам модифікувати методи класів, та вони роблять це таким чином,
      що дозволяє вам накладати ці модифікації одне на одного.</p>
    <p>Як приклад, розглянемо стековану модифікацію черги цілих. Черга буде мати
      дві операції: put, що ставить ціле в чергу, та get, що вибирає цілі з
      черги. Черга дотримується принципу перший-ввійшов-перший-вийшов, так що
      get має повертати цілі в тому ж порядку, що вони булі поставлені в чергу.</p>
    <p>Маючи клас, що реалізує таку чергу, ви можете визначити трейти, що
      виконують наступні модифікації:<br>
      • Подвоєння: подвоює всі цілі, що знаходяться в черзі<br>
      • Збільшення: збільшує на одиницю всі цілі, що знаходяться в черзі<br>
      • Фільтрація: відфільтровує всі від'ємні цілі з черги</p>
    <p>Ці три трейта представляють модифікації, оскільки вони модифікують
      поведінку підлеглої класа черги, скоріше, ніж визначати повний новий клас
      черги. Вони також є скековані. Ви можете обрати любі з трьох, за власним
      бажанням, домішати їх до класа, та отримати новий клас, що мають всі
      модифікації, що ви обрали.</p>
    <p>Абстрактний клас IntQueue показаний в Лістингу 12.6. IntQueue має метод
      put, що додає нові цілі до черги, та метод get, що видаляє та повертає їх.
      Бвзова реалізація IntQueue, що використовує ArrayBuffer, показана в
      Лістингу 12.7.</p>
    <pre class="prettyprint linenums language-scala">abstract class IntQueue {
  def get(): Int
  def put(x: Int)
}</pre>
    <p>Лістинг 12.6 Абстрактний клас IntQueue .</p>
    <pre class="prettyprint linenums language-scala">import scala.collection.mutable.ArrayBuffer
class BasicIntQueue extends IntQueue {
  private val buf = new ArrayBuffer[Int]
  def get() = buf.remove(0)
  def put(x: Int) { buf += x }
}</pre>
    <p>Лістинг 12.7 BasicIntQueue, реалізований за допомогою ArrayBuffer .</p>
    <p>Клас BasicIntQueue має приватне поле, що містить масив буфера. Метод get
      видаляє елемент з одного кінця буфера, доки метод put додає елементи з
      іншого боку. Ось як ця реалізація виглядає, коли ви використовуєте її:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val queue = new BasicIntQueue
queue: BasicIntQueue = BasicIntQueue@24655f
<br>scala&gt; queue.put(10)
scala&gt; queue.put(20)
scala&gt; queue.get()
res9: Int = 10
scala&gt; queue.get()
res10: Int = 20</pre>
    <p>Доки все гарно. Тепер поглянемо на використання трейтів для модифікації
      поведінки. Лістинг 12.8 показує трейт, що подвоює цілі, як вони додаються
      до черги. Трейт Doubling має дві цікаві особливості. Перше полягає в тому,
      що він декларує суперклас, IntQueue. Ця декларація означає, що цей трейт
      може бути зміксований в клас, що також розширює IntQueue. Таким чином, ви
      можете зміксувати Doubling до BasicIntQueue, але не до Rational.</p>
    <pre class="prettyprint linenums language-scala">trait Doubling extends IntQueue {
  abstract override def put(x: Int) { super.put(2 * x) }
}</pre>
    <p>Лістинг 12.8 Стекований трейт модифікації Doubling.</p>
    <p>Друга цікава річ в тому, що трейт має виклик super на методі, що
      декларований як abstract. Такі виклики є нелегальними для нормальних
      класів, оскільки вони напевне схиблять під час виконання. Однак для
      трейтів такий виклик насправді може бути успішним. Оскільки виклики super
      в трейті зв'язані динамічно, виклик super в трейті Doubling будуть робити
      доти, доки трейт зміксований після іншого трейта або класа, що надає
      конкретне визначення метода.</p>
    <p>Такий механізм часто потрібний для трейтів, що реалізують накладені
      модифікації. Щоб сказати компілятору, що ви робите це навмисно, ви повинні
      маркувати ці методи як abstract override. Ця комбінація модифікаторів
      дозволена тільки для членів трейтів, не класів, та це означає, що трейт
      мусить бути зміксований з деяким класом, що має конкретне визначення
      розглядаємого метода.</p>
    <p>Навіть такий простий трейт викликає багато наслідків! Ось як виглядає
      використання трейта:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; class MyQueue extends BasicIntQueue with Doubling
defined class MyQueue
<br>scala&gt; val queue = new MyQueue
queue: MyQueue = MyQueue@91f017
<br>scala&gt; queue.put(10)
scala&gt; queue.get()
res12: Int = 20</pre>
    <p>В першому рядку цієї сесії інтерпретатора ми визначаємо клас MyQueue, що
      розширює BasicIntQueue, та міксується з Doubling. Потім ми кладемо 10 в
      чергу, але завдяки тому, що зміксований Doubling, 10 подвоюється. Коли ми
      отримуємо значення з черги, це буде 20.</p>
    <p>Зауважте, що MyQueue не визначає нового кода. Він просто ідентифікує
      клас, та підмішує трейт. В цій ситуації ви можете надати “BasicIntQueue
      with<br>
      Doubling” напряму до new, замість визначення поіменованого класа. Це буде
      виглядати, як показано в Лістингу 12.9:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val queue = new BasicIntQueue with Doubling
queue: BasicIntQueue with Doubling = $anon$1@5fa12d
<br>scala&gt; queue.put(10)
scala&gt; queue.get()
res14: Int = 20</pre>
    <p>Listing 12.9 · Mixing in a trait when instantiating with new .</p>
    <p>Щоб побачити, як накладати модифікації, нам треба визначити інші два
      трейти модифікації, Incrementing та Filtering. Реалізації ціх трейтів
      показані в Лістингу 12.10:</p>
    <pre class="prettyprint linenums language-scala">trait Incrementing extends IntQueue {
  abstract override def put(x: Int) { super.put(x + 1) }
}
trait Filtering extends IntQueue {
  abstract override def put(x: Int) {
    if (x &gt;= 0) super.put(x)
  }
}</pre>
    <p>Лістинг 12.10: Стековані модифікації в трейтах Incrementing та Filtering
      .</p>
    <p>Маючи ці модифікації, тепер ви можете обирати, яки ви застосуєте до
      окремої черги. Наприклад, ось черга, що одночасно фільтрує від'ємні числа,
      та додає один до всіх чисел, що зберігає:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val queue = (new BasicIntQueue
with Incrementing with Filtering)
queue: BasicIntQueue with Incrementing with Filtering...
scala&gt; queue.put(-1); queue.put(0); queue.put(1)
scala&gt; queue.get()
res15: Int = 1
scala&gt; queue.get()
res16: Int = 2</pre>
    <p>Порядок міксів важливий. Точні правила надаються в наступному розділі,
      аге. грубо кажучи, трейти, що ближчі зправа, перші набувають чинності.
      Коли ви викликаєте метод класа з міксами, метод трейта, що правіший,
      викликається першим. Якщо метод викликає calls, він викликає метод в
      наступному трейті зліва, і так далі. В попередньому прикладі першим
      викликаєть Filtering put, так що він для початку видаляє від'ємні.
      Incrementing put викликається другим, так що він додає один до тих цілих,
      що остались.</p>
    <p>Якщо ви зміните порядок, зпершу цілі будуть збільшені, та потім цілі, що
      все ще від'ємні, будуть відкинуті:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val queue = (new BasicIntQueue
with Filtering with Incrementing)
queue: BasicIntQueue with Filtering with Incrementing...
scala&gt; queue.put(-1); queue.put(0); queue.put(1)
scala&gt; queue.get()
res17: Int = 0
scala&gt; queue.get()
res18: Int = 1
scala&gt; queue.get()
res19: Int = 2</pre>
    <p>Загалом, код, написаний в цьому стилі, дає вам величезні можливості
      гнучкості. Ви можете визначити різні класи, міксуючи їх з ціма трьома
      трейтами в різному порядку та комбінації. Це величезна гнучкість для
      такого малого кода, так що ви повинні придивлятись до можливостей
      створення кода як стекованих модифікацій, що можна накладати один на
      одного.</p>
    <h3>12.6 Чому не множинне наслідування?</h3>
    <p>Трейти є шляхом наслідування від класо-подібних конструкцій, але
      відрізняються в важливий спосіб від множинного наслідування, присутньго в
      багатьох мовах. Одна відмінність особливо важлива: інтерпретація super. З
      множинним наслідуванням, метод, викликаний за виклика call, може бути
      визначений прямо тоді, коли відбувається виклик. З трейтами, метод, що
      буде викликаний, визначається через лінеарізацію класів та трейтів, що
      домішані до класа. Ця різниця, що дозволяє накладання модифікацій, описана
      в попередньому розділі.</p>
    <p>Перед тим, як поглянути на лінеарізацію, затратьте момент, та розгляньте.
      як накладати модифікації в традиційній мові з множинним наслідуванням.
      Уявіть наступний код, але на цей раз інтерпретований як множинне
      наслідування, замість міксування трейта:</p>
    <pre class="prettyprint linenums language-scala">// Множинне наслідування як експерімент
val q = new BasicIntQueue with Incrementing with Doubling
q.put(42)
// який put має бути викликаний?</pre>
    <p>Перше питання, який метод put повинен бути викликаний під час цього?
      Можливо, правило полягатиме в тому, що виграє останній суперклас, в якому
      випадку буде викликаний Doubling. Doubling буде подвоювати свій аргумент,
      та викликати super.put, та ось і все. Інкрементація не відбудеть! Таким же
      чином, якщо правило буде таке, що перемагає перший суперклас, отримана
      черга буде інкрементувати цілі, але не подвоювати їх. Таким чином, жодний
      порядок не буде працювати.</p>
    <p>Ви можете також розважитись можливістю дозволити програмістам точно
      ідентифікувати, які суперкласи методів вони бажають, коли вони кажуть
      super. Наприклад, уявіть, наступний Scala-подібний код, в якому super
      з'являється, щоб бути викликаним з обох, Incrementing та Doubling :</p>
    <pre class="prettyprint linenums language-scala">// Множинне наслідування в якості експеримента
trait MyQueue extends BasicIntQueue
  with Incrementing with Doubling {
    def put(x: Int) {
      Incrementing.super.put(x) // (Несправжня Scala)
      Doubling.super.put(x)
    }
}</pre>
    <p>Цей підхід дає нам нові проблеми. Балакливість цього підходу є найменьшою
      з його проблем. Що має відбутись, це те що метод get базового класа
      викликається двічі — одного раза з інкрементованим значенням, та один раз
      з подвоєним значенням, але жодного разу зі збільшеним та подвоєним
      значенням.</p>
    <p>Просто не існує гарного рішення цієї проблеми з використанням множинного
      наслідування. Вам треба мати відкотитись в своїй розробці, та поділити код
      інакше. На відміну, рішення Scala тейтами прямолінійне. Ви міксуєте
      Incrementing та Doubling, та особлива трактовка Scala super в трейтах
      робить все, щоб це робило. Дещо прозоро відрізняє це від традиційного
      множинного наслідування, але що?</p>
    <p>Як натякалось раніше, віповіддю є лінеарізація. Коли ви створюєте
      примірник класа за допомогою new, Scala бере клас, та всі його наслідувані
      класи та трейти, та кладе їх в одному, лінійному порядку. Потім, кожного
      разу, коли ви викликаєте super в одному з ціх класів, викликаний метод є
      наступним в цьому ланцюжці. Якщо всі методи, крім останнього, викликають
      super, нетто-результатом буде стекована поведінка.</p>
    <p>Точний порядок лінеаризації описаний в специфікації мови. Він трохи
      ускладнений, але основна річ, що ви маєте знати, це те, що в любій
      лінеарізації, клас завжди лінеаризується, перед тим, як це відбудеться з
      усіма його суперкласами, та заміксованими трейтами. Таким чином, коли ви
      пишете метод, що викликає super, цей метод однозначно модифікує поведінку
      суперкласів та примішаних трейтів, для цього немає обхідного шляху.</p>
    <h4>Зауваження</h4>
    <p>Залишок цього розділу описує деталі лінеаризації. Ви можете вільно
      пропустити залишок розділу, якщо прямо зараз вас не цікавлять подробиці та
      деталі.</p>
    <p>Головні властивості лінеаризації Scala ілюструються наступним прикладом:
      скажімо, ви маєте клас Cat, що наслідує від суперкласа Animal, та двох
      трейтів , Furry та FourLegged. FourLegged, в свою чергу, розширює трейт
      HasLegs:</p>
    <pre class="prettyprint linenums language-scala">class Animal
trait Furry extends Animal
trait HasLegs extends Animal
trait FourLegged extends HasLegs
class Cat extends Animal with Furry with FourLegged</pre>
    <p>Ієрархія наслідування класа Cat та лінеаризація показані на Малюнку 12.1.
      Наслідування вказані з використанням тридиційної нотації UML: стілки з
      білими, трикутними кінцями, вказують на наслідування, де стрілка вказує на
      супертип. Стрілки з темними, не-трикутними кінцями, зображують
      лінеаризацію. Темна стрілка вказує в напрямку, в якому розрішується виклик
      super.</p>
    <img style="width: 497px; height: 213px;" alt="" src="12.1.png"><br>
    <br>
    Малюнок 12.1 Ієрархія наслідування та лінеаризація класа Cat .<br>
    <p>Лінеаризація Cat обчислюється з кінця на перед наступним чином. Остання
      частина лінеаризації Cat є лінеаризація його суперкласа, Animal. Ця
      лінеаризація копіюється без жодних змін. (Лінеаризація кожного з ціх типів
      показана в Таблиці 12.1). Оскільки Animal явно не розширює суперклас, або
      міксує жодного супертрейта, він по замовчанню розширює AnyRef, що розширює
      Any. Лінеарізація Animal, таким чином, виглядає так:</p>
    <pre class="prettyprint linenums language-scala">Animal =&gt; AnyRef =&gt; Any</pre>
    <p>Дрігий ззаду в лінеаризації є перший мікс, трейт Furry, але всі класи, що
      вже в ліеаризації Animal доки полишені, так що кожний клас з'являється
      тільки один раз в лінеаризації Cat. Результат такий:</p>
    <pre class="prettyprint linenums language-scala">Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
    <p>Це передує лінеаризації FourLegged, де знову, відкидаються всі класи, що
      вже скопійовані в лінеаризцію суперкласа, або все від першого мікса:</p>
    <pre class="prettyprint linenums language-scala">FourLegged =&gt; HasLegs =&gt; Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
    <p>Нарешті, перший клас в лінеаризації Cat є сам Cat:</p>
    <p>Таблиця 12.1 Лінеаризація класів в ієрархії Cat</p>
    <table border="0">
      <tbody>
        <tr>
          <td>Animal</td>
          <td>Animal, AnyRef, Any</td>
        </tr>
        <tr>
          <td>Furry</td>
          <td>Furry, Animal, AnyRef, Any</td>
        </tr>
        <tr>
          <td>FourLegged</td>
          <td>FourLegged, HasLegs, Animal, AnyRef, Any</td>
        </tr>
        <tr>
          <td>HasLegs</td>
          <td>HasLegs, Animal, AnyRef, Any</td>
        </tr>
        <tr>
          <td>Cat</td>
          <td>Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</td>
        </tr>
      </tbody>
    </table>
    <pre class="prettyprint linenums language-scala">Cat =&gt; FourLegged =&gt; HasLegs =&gt; Furry =&gt; Animal =&gt; AnyRef =&gt; Any</pre>
    <p>Коли кожний з ціх класів та трейтів викликає метод через super,
      реалізація, до буде викликана, буде першою реалізацією зправа в
      лінеаризації.</p>
    <h3>12.7 То трейт, або не трейт?</h3>
    <p>Кожного раза, коли ви реалізуєте повторо використовувану колекцію
      поведінок, вам прийдеться вирішувати, чи ви бажаєте використовувати трейт
      або абстрактний клас. Не існує жорсткого правила, але цей розділ містить
      декілька порад, що треба розглянути. Якщо поведінка не буде повторо
      використана, тоді робіть її в вигляді конкретного класа. Кінець кніцем ця
      поведінка не для повторного використання.</p>
    <p>Якщо дещо може використовуватись в багатьох непов'язаних класах, робіть
      це як трейт. Тільки трейти можуть бути зміксовані до різних частин
      ієрархії класів. Якщо ви бажаєте наслідувати код в Java, використовуйте
      абстрактний клас. Оскільки трейти з кодом не мають близького аналога в
      Java, буває складно наслідувати від трейта в класі Java. Тим часом,
      наслідування від класа Scala точно як наслідування від класа Java. Як одне
      виключення, трейт Scala тільки з одними абстрактними членами транслюється
      прямо в інтерфейс Java, так що ви можете вільно визначати такі трейти,
      навіть коли очікуєте, що Java код буде наслідувати їх. Дивіться Главу 31
      щодо додаткової інформації по роботі з Java та Scala одночасно.</p>
    <p>Якщо ви плануєте розповсюджувати код в компільованій формі, та ви
      очікуєте, що зовнішні групи будуть писати класи, що наслідують він нього,
      ви маєте схилятись до використання абстрактних класів. Проблема в тому, що
      коли трейт отримує або втрачає члена, любі класи, що наслідують від нього,
      мають бути перекомпільовані, навіть якщо вони не змінились. Якщо зовнішні
      клієнти тільки викликають поведінку, замість наслідувати її, тоді
      використання трейтів є гарним.</p>
    <p>Якщо ефективність дуже важлива, схиляйтесь до використання класа.
      Більшість середовищ виконання Java робить виклики віртуальних методів
      членів класа швидшою операцією, ніж виклик метода інтерфейса. Трейти
      компілюються як інтерфейси, та, таким чином, можуть накладати деякі
      додаткові витрати. Однак, ви маєте робити цей вибір, тільки якщо ви
      знаєте, що розгляданий трейт містить прогалину в продуктивності, та маєте
      докази, що використання класа заміть трейта наспраавді вирішує проблему.</p>
    <p>Якщо ви все ще не знаєте, після прийняття до уваги всього сказаного, тоді
      починайте з того, що робіть з усього трейт. Ви завжди зможете змінити це в
      пізніше, та, загалом, використання трейта відкриває більше опцій.</p>
    <h3>12.8 Висновок</h3>
    <p>Ця глава показала вам, як роблять трейти, та як їх використовувати в
      декількох загальних ідіомах. Ви побачили, що трейти подібні до множинного
      наслідування, але оскільки вони інтерпретують super з використанням
      лінеарізації, вони одночасно уникають деяких складностей традиційного
      множинного наслідування, та дозволяють вам накладати поведінку одну на
      одну. Ви також побачили трейт Ordered, та навчились писати ваші власні
      збагачуючи трейти.</p>
    <p>Тепер, коли ви побачили всі ці аспекти, має сенс повернутись трохи назад,
      та поглянути на трейти як на ціле. Трейти не просто підтримують описані в
      цій главі ідіоми. Вони є фундаментальними одиницями кода, що повторно
      використовується через наслідування. Завдяки цій природі багато з
      досвідчених Scala програмістів починають з трейтів, коли знаходяться ще на
      ранішніх стадіях розробки. Кожний трейт може містити меньше, ніж цілу
      концепцію, тільки фрагмент концепції. По мірі кристалізації розробки
      фрагменти можуть комбінуватись в більш повні концепції, через змішування
      трейтів.&nbsp;</p>
    <h3>Глава 13</h3>
    <h2>Пакунки та імпорт</h2>
    <p>Коли ви працюєте над програмою, особливо над великою, важливо зменшити
      взаємодію — межі, в яких різні частини програми покладаються на інші
      частини. Слабка зв'язаність зменшує ризик того, що мала, на перший погляд
      безневинна зміна в одній частині програми буде мати руйнівні наслідки в
      іншій частині. Один спосіб мінізувати поєднання є писати в модульному
      стилі. Ви поділяєте програму на декілька меньших модулів, кожний з яких
      має внутрішній та зовнішній світ. Коли ви робите всередині модуля — в його
      реалізації — вам треба тільки координуватись тільки з іншими
      програмістами, що роблять над тим самим модулем. Тільки коли вам треба
      змінити дещо ззовні модуля — його інтерфейс — тоді треба координуватись з
      розробниками, що роблять над іншими модулями.</p>
    <p>Ця глава показує деякі конструкції, що допомагають вам програмувати в
      модульному стилі. Вона показує, як покласти речі в пакунки, зробити імена
      видимі через імпорт, та контролювати видимість визначень через
      модифікатори доступу.</p>
    <p>Конструкції подібні по духу до конструкцій в Java, але деякі відмінності
      — іноді в більш узгоджений спосіб — так що має сенс прочитати цю главу,
      навіть якщо ви вже знаєте Java.</p>
    <h3>13.1 Покладання речей в пакунки</h3>
    <p>Код Scala міститься в глобальній ієрархії пакунків Java платформи.
      Приклад кода, що ви вже бачили в цій книзі, знаходився в непоіменованому
      пакунку. Ви можете покласти код в поіменований пакунок в Scala в два
      способи. Перше, ви можете покласти вміст цілого файла в пакунок,
      розмістивши твердження package на початку файла, як показане в Лістингу
      13.1.</p>
    <pre class="prettyprint linenums language-scala">package bobsrockets.navigation
class Navigator</pre>
    <p>Лістинг 13.1 Покладання цілого файла в пакунок.</p>
    <p>Твердження package в Лістингу 13.1 покладає клас Navigator до пакунка на
      ім'я bobsrockets.navigation. Можливо, це програма навігації, розроблена
      компанією Боба, Rockets, Inc.</p>
    <h4>Зауваження</h4>
    <p>Оскільки код Scala є частиною екосистеми Java, рекомендовано слідувати
      домовленості Java щодо реверного доменного іменування для пакунків Scala,
      що ви викладаєте на загал. Таким чином, краще ім'я для пакунка Navigator
      може бути com.bobsrockets.navigation. Однак в цій главі ми будемо
      відкидати “com.”, щоб зробити приклади простішими для розуміння.</p>
    <p>Інший спосіб, як ви можете покласти код в пакунок в Scala, більш
      скидається на простори імен C#. Ви ставите за твердженням package розділ в
      фігурних дужках, що містить визначення, що ідуть до пакунка. Цей синтаксис
      називається пакуванням. Пакування, показане в Лістингу 13.2, має той же
      ефект, що в код в Лістингу 13.1:</p>
    <pre class="prettyprint linenums language-scala">package bobsrockets.navigation {
  class Navigator
}</pre>
    <p>Лістинг 13.2 Довга форма простої декларації пакунка.</p>
    <p>Для таких простих прикладів ви можете також використовувати синтаксичний
      цукор, показаний в Лістингу 13.1. Однак, одним з використань більш
      загальної нотації є мати різні частини файла в різних пакунках. Наприклад,
      аи можете включити тести класа в той же файл, що і оригінальний код, але
      покласти тести в інший пакунок, як показано в Лістингу 13.3.</p>
    <pre class="prettyprint linenums language-scala">package bobsrockets {
  package navigation {
// В пакунку bobsrockets.navigation
    class Navigator
      package tests {
// В пакунку bobsrockets.navigation.tests
        class NavigatorSuite
    }
  }
}</pre>
    <p>Лістинг 13.3 Багато пакунків в одному файлі.</p>
    <h3>13.2 Стислий доступ до пов'язаного кода</h3>
    <p>Коли код поділений в ієрархію пакунків, це не тільки спрощує людям
      переглядати цей код. Це також каже компілятору, що код в одному пакунку
      пов'язаний деяким чином, один з одним. Scala використовує перевагу від
      цього пов'язання, дозволяючі скорочені, некваліфіковані імена, коли ви
      отримуєте доступ до кода в тому ж пакунку. </p>
    Лістинг 13.4 надає три прості приклади. Перше, як ви можете очікувати, клас
    може бути доступний з його власного пакунка, без необхідності вказувати
    префікс. Ось чому компілюється new StarMap. Клас StarMap в тому ж пакунку,
    bobsrockets.navigation, що і вираз new, що отримує доступ до нього, так що
    немає потреби вказувати ім'я пакунка.<br>
    <p>Друге, сам пакунок може бути доступний з пакунка, що містить його, без
      потреби вказувати його повний шлях. В Лістингу 13.4 подивіться, як
      створюється примірник класа Navigator. Вираз new з'являється в пакунку
      bobsrockets, що є пакунком, який містить bobsrockets.navigation. Таким
      чином, він може отримати доступ до пакунка bobsrockets.navigation, просто
      як navigation.<br>
      <br>
      Третє, при використанні синтаксиса пакування з фігурними дужками, всі
      імена, доступні в полі зору за межами пакування, також доступні і в ньому.
      Як приклад, в Лістингу 13.4 є спосіб для addShip() створити новий Ship.
      Метод визначений в двох пакунках: зовнішній bobsrockets, та внутрішній,
      bobsrockets.fleets.&nbsp; Оскільки Ship доступний в зовнішньому пакунку,
      він також може бути використаний в addShip().</p>
    <pre class="prettyprint linenums language-scala">package bobsrockets {
  package navigation {
    class Navigator {
// Не треба казати bobsrockets.navigation.StarMap
      val map = new StarMap
    }
    class StarMap
  }
  class Ship {
// Не треба казати bobsrockets.navigation.Navigator
    val nav = new navigation.Navigator
  }
  package fleets {
    class Fleet {
// Не треба казати bobsrockets.Ship
      def addShip() { new Ship }
    }
  }
}</pre>
    <p>Лістинг 13.4 Стислий доступ до класів та пакунків.</p>
    Зауважте, що цей клас доступу можливий, тільки якщо ви явно вкладуєте
    пакування. Якщо ви схильні до одного пакунка на файл, тоді, як в like in
    Java — будуть доступні імена, що визначені в поточному пакунку. <br>
    <pre class="prettyprint linenums language-scala">package bobsrockets {
  class Ship
}
package bobsrockets.fleets {
  class Fleet {
// Не компілюється! Ship не в полі зору.
    def addShip() { new Ship }
  }
}</pre>
    <p>Лістинг 13.5 Символи в оточуючих пакунках автоматично не доступні.</p>
    В Лістингу 13.5 пакування bobsrockets.fleets було переміщене на рівень вище.
    Оскільки воно більше не оточене пакуванням bobsrockets, імена з bobsrockets
    не є безпосередньо в полі зору. Як результат, new Ship дає помилку
    компіляції. Якщо вкладені пакунки з дужками некомфортабельно зсувають ваш
    код вправо, ви можете також використовувати декілька тверджень package без
    дужок. Наприклад, код нижче також визначає клас Fleet в двох вкладених
    пакунках, bobrockets та fleets, точно так само, як ви бачили в Лістингу
    13.4:<br>
    <pre class="prettyprint linenums language-scala">package bobsrockets
package fleets
class Fleet {
// Не компілюється! Ship не в полі зору.
  def addShip() { new Ship }
}</pre>
    <p>Один заключний прийом, що важливо знати. Іноді вам доводиться кодувати в
      жорстоко захаращеному полі зору, де вмена пакунків приховують одне одного.
    </p>
    <pre class="prettyprint linenums language-scala">// В файлі launch.scala
package launch {
  class Booster3
}
// В файлі bobsrockets.scala
package bobsrockets {
  package navigation {
    package launch {
      class Booster1
    }
    class MissionControl {
      val booster1 = new launch.Booster1
      val booster2 = new bobsrockets.launch.Booster2
      val booster3 = new _root_.launch.Booster3
    }
  }
  package launch {
    class Booster2
  }<br>}</pre>
    <p>Лістинг 13.6 Доступ до прихованих імен пакунків.</p>
    <p>В лістингу 13.6 поле зору класа MissionControl включає три окремі
      пакунки, з назвами launch! Є launch в bobsrockets.navigation, ще один в
      bobsrockets, та ще один на верхньому рівні. Як ви повинні посилатись на
      кожний з Booster1, Booster2, та Booster3?</p>
    <p>Доступ до першого найпростішій. Посилання на launch саме по собі буде
      давати вам bobsrockets.navigation.launch, оскільки це пакунок launch,
      визначений в найближчому оточующому полі зору. Таким чином, ви можете
      посилатись на перший клас booster class, просто як на launch.Booster1.
      Посилання на другий також не складне. Ви можете записати
      bobrockets.launch.Booster2, та буде ясним, на що ви посилаєтесь. Однак,
      остається питанням третій клас booster. Як ви можете отримати доступ до
      Booster3, приймаючи до уваги, що вкладений пакунок launch затіняє з
      одноіменний з верхнього рівня?</p>
    <p>Щоб допомогти в цій ситуації, Scala провадить пакунок на ім'я _root_, що
      є зовнішнім до любого пакунку, що може написати користувач. Кажучи інакше,
      кожний пакунок вищого рівня, що ви можете написати, розглядається як член
      пакунка _root_ . Наприклад, обоє, launch та bobsrockets з Лістинга 13.6 є
      членами пакунка _root_. Як результат, _root_.launch дає нам високорівневий
      пакунок launch, та _root_.launch.Booster3 означає самий зовнішній клас
      booster.</p>
    <h3>13.3 Імпорти</h3>
    <p>В Scala пакунки та їх члени можуть бути імпортовані з використанням
      тверджень import. Імпортовані елементи потім можуть бути досяжні через
      просте ім'я, як File, на відміну від потреби задавати кваліфіковане ім'я,
      як java.io.File. Наприклад, розглянемо код, показаний в Лістингу 13.7.</p>
    <p>Твердження import робить члени пакунка або об'єкта доступним через їх
      імена, без потреби ставити префікс з імені пакунка або об'єкта. Ось деякі
      прості приклади:</p>
    <pre class="prettyprint linenums language-scala">// простий доступ до Fruit
import bobsdelights.Fruit
<br>// простий доступ до всіх членів bobsdelights
import bobsdelights._
<br>// простий доступ до всіх членів Fruits
import bobsdelights.Fruits._

package bobsdelights
<br>abstract class Fruit(
  val name: String,
  val color: String
)<br><br>object Fruits {
  object Apple extends Fruit("apple", "red")
  object Orange extends Fruit("orange", "orange")
  object Pear extends Fruit("pear", "yellowish")
  val menu = List(Apple, Orange, Pear)
}</pre>
    <p> Лістинг 13.7&nbsp; Улюблені фрукти Боба, готові до імпорта.</p>
    <p>Перше з них відповідає імпорту одного типу в Java, друге - імпорту на
      вимогу в Java. Єдина різниця в тому, що імпорт на вимогу в Scala записаний
      з завершуючим підкресленням ( _ ), замість зірочки ( *) (кінець кінцем, *
      є придатним ідентифікатором в Scala!). Третій імпорт вище відповідає до
      імпорта полів статичного класа в Java.</p>
    <p>Ці три імпорти дають вам присмак того, що можуть імпорти, але насправді
      імпорти в Scala значно більш загальні. Для початку, імпорти в Scala можуть
      з'являтись будь-де, не тільки на початку одиниці компіляції. Також вони
      можуть посилатись на довільні значення. Наприклад, можливий імпорт,
      показаний в Лістингу 13.8:</p>
    <pre class="prettyprint linenums language-scala">def showFruit(fruit: Fruit) {
  import fruit._
  println(name +"s are "+ color)
}</pre>
    <p>Лістинг 13.8 Імпортування членів звичайного об'єкта (не синглтона).</p>
    <p>Метод showFruit імпортує всі члени свого параметра fruit, що має тип
      Fruit. Наступне твердження println може безпосередньо посилатись на name
      та color. Ці два посилання еквівалентні до fruit.name та fruit.color. Цей
      синтаксис, зокрема, корисний, коли ви використовуєте об'єкти як модулі, що
      буде описане в Главі 29.</p>
    <h4>Гнучкі імпорти Scala</h4>
    <p>Твердження Scala import є трохи більш складними, ніж в Java. Є три
      принципові відмінності. Імпорти в Scala: <br>
      • можуть з'являтись будь-де<br>
      • можуть посилатись на об'єкти (синглтони або звичайні), на додаток до
      пакунків<br>
      • дозволяють вам переіменувати або приховати деякі імпортовані члени</p>
    <p>Інший спосіб, в який імпорти Scala є гнучкими - це те, що вони можуть
      імпортувати самі пакунки, не тільки їх члени-не-пакунки. Це природно
      тільки в випадку, коли ви думаєте про вкладені пакунки, що містяться в
      оточуючих пакунках. Наприклад, в Лістингу 13.9, пакунок java.util.regex є
      імпортованим. Це робить regex корисним як просте ім'я. Щоб отримати доступ
      до об'єкта-синглтона Pattern з пакунку java.util.regex, ви можете просто
      сказати regex.Pattern, як показано в Лістингу 13.9:</p>
    <pre class="prettyprint linenums language-scala">import java.util.regex
class AStarB {
// Отримує досутп до java.util.regex.Pattern
  val pat = regex.Pattern.compile("a*b")
}</pre>
    <p>Лістинг 13.9 Імпорт імені пакунку.</p>
    <p>Імпорти в Scala можуть також переіменовувати або приховувати члени. Це
      робиться за допомогою селектора import, заточеного в фігурні дужки, що
      слідують за об'єктом, з якого імпортуються члени. Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">import Fruits.{Apple, Orange}</pre>
    <p>Це імпотрує члени Apple та Orange з об'єкта Fruits .</p>
    <pre class="prettyprint linenums language-scala">import Fruits.{Apple =&gt; McIntosh, Orange}</pre>
    <p>Це імпортує два члени, Apple та Orange з об'єкта Fruits. Однак, об'єкт
      Apple переіменований на McIntosh. Так що доступ до об'єкта виглядає або
      Fruits.Apple, або McIntosh. Твердження переіменування завжди має форму
      “&lt;оригінальне-ім'я&gt; =&gt; &lt;нове-ім'я&gt;”.</p>
    <pre class="prettyprint linenums language-scala">import java.sql.{Date =&gt; SDate}</pre>
    <p>Це імпортує клас SQL date як SDate, так що ви можете одночасно
      імпортувати звичайний клас Java date як прост Date.</p>
    <pre class="prettyprint linenums language-scala">import java.{sql =&gt; S}</pre>
    <p>Це імпортує пакунок java.sql як S, так що ви можете писати такі речі, як
      S.Date .</p>
    <pre class="prettyprint linenums language-scala">import Fruits.{_}</pre>
    <p>Це імпортує всі члени об'єякта Fruits. Це означає те ж саме, що import
      Fruits._.</p>
    <pre class="prettyprint linenums language-scala">import Fruits.{Apple =&gt; McIntosh, _}</pre>
    <p>Це імпортує всі члени об'єкта Fruits, але переіменовує Apple на <br>
      McIntosh .</p>
    <pre class="prettyprint linenums language-scala">import Fruits.{Pear =&gt; _, _}</pre>
    <p>Це імпотрує всі члени Fruits, окрім Pear. Твердження в формі <br>
      “&lt;оригінальне-ім'я&gt; =&gt; _” виключає &lt;оригінальне-ім'я&gt; з
      імен, що імпортуються. В цьому сенсі, переіменування будь-чого на ‘_’
      означає зовсім приховати його. Це корисне для уникнення невизнеченостей.
      Скажімо, ви маєте два пакунки, Fruits та Notebooks, що обоє визначають
      клас Apple. Якщо ви бажаєте отримати тільки ноутбук Apple, але не фрукт,
      ви можете використовувати обоє імпорти на вимогу, наступним чином:</p>
    <pre class="prettyprint linenums language-scala">import Notebooks._
import Fruits.{Apple =&gt; _, _}</pre>
    <p>Це буде імпортувати всі Notebooks, та всі фрукти, окрім Apple. Ці
      виключення демонструють велику гнучкість, що пропонує Scala, коли доходить
      до вибіркового імпорту членів, та, можливо, під різними іменами.</p>
    <p>Загалом, селектор імпорту може складатись з наступного:<br>
      • Простого імені x. Це включає x в набір вмпортованих імен.<br>
      • Твердження переіменування x =&gt; y. Це робить член на ім'я x відомим
      під ім'ям y .<br>
      • Твердження приховування x =&gt; _ . Це виключає x з набору імпортованих
      імен.<br>
      • Узагальнене ‘ _ ’. Це імпортує всі члени, крім тих, що згадані в
      попередньому пункті. Якщо задається цей вираз, він іде останнім в
      селекторі імпорта.</p>
    <p>Простіші форми тверджень імпорта, показані на початку цього розділу,
      можуть розглядатись як окремі скорочення виразів імпорта з селекторами.
      Наприклад, “import p._” еквівалентне до “import p.{_}”, та “import p.n”<br>
      еквівалентне до “import p.{n}”.</p>
    <h3>13.4 Неявний імпорт</h3>
    <p>Scala додає деякі імпорти неявно до кожної програми. Загалом це те саме,
      якби нагорі кожного файла з розширенням .scala були наступні три
      твердження import:</p>
    <pre class="prettyprint linenums language-scala">import java.lang._ // все в пакунку java.lang
import scala._ // все в пакунку scala
import Predef._ // все в об'єкті Predef</pre>
    <p>Пакунок java.lang містить стандиртні класи Java. Вони завжди неявно
      імпортуються на JVM реалізації Scala. Реалізація .NET замість цього має
      імпортувати пакунок system, що в .NET є аналогом java.lang. Оскільки
      java.lang імпортований неявно, ви, наприклад, можете писати Thread,
      замість java.lang.Thread.</p>
    <p>Як ви, без сумніву, вже здогадались, пакунок scala містить стандартну
      бібліотеку Scala, з багатьма загальними класами та об'єктами. Оскільки
      scala імпортується неявно, ви, наприклад, можете писати List заміть
      scala.List.</p>
    <p>Об'єкт Predef містить багато визначень типів, методів, та неявних
      перетворень, що загально використовуються в програмах Scala. Наприклад,
      оскільки Predef імпортований неявно, ви можете писати assert замість<br>
      Predef.assert.</p>
    <p>Ці три імпорти вище розглядаються трохи особливо, в тому, що подальші
      імпорти затіняють попередні. Наприклад, клас StringBuilder визначений
      одночасно в пакунку scala, та, починаючи з версії Java 1.5, також в
      пакунку java.lang. Оскільки імпорт scala затінює імпорт java.lang, просте
      ім'я StringBuilder буде посилатись на scala.StringBuilder, але не на
      java.lang.StringBuilder.</p>
    <h3>13.5 Модифікатори доступу</h3>
    <p>Члени пакунків, класів або об'єктів можуть бути помічені модифікаторами
      доступу private та protected. Ці модифікатори обмежують доступ до членів
      для окремих регіонів кода. Погляд Scala на модифікатори доступу приблизно
      слідують таким в Java, але є деякі важливі відмінності, що пояснюються в
      цьому розділі.</p>
    <h4>Приватні члени</h4>
    <p>Приватні члени розглядаються подібно до Java. Член, помічений як private,
      видимий тільки зсередини класа або об'єкта, що містить визначення члена. В
      Scala це правило стосується також внутрішніх класів. Ця трактовка більш
      узгодженна, але відрізняється від Java. Розгляньте приклад, показаний у
      Лістингу 13.10:</p>
    <pre class="prettyprint linenums language-scala">class Outer {
  class Inner {
    private def f() { println("f") }
    class InnerMost {
      f() // OK
    }
  }
  (new Inner).f() // помилка: f недоступне
}</pre>
    <p>Лістинг 13.10 Як доступ private відрізняється в Scala та Java.</p>
    <p>В Scala доступ (new Inner).f() нелегальний, бо f задекларовано як private
      Inner, та доступ на зсередини класа Inner. Навпаки, перший доступ до f в
      класі InnerMost є задовільним, оскільки цей доступ міститься в тілі класа
      Inner. Java дозволятиме обоє доступи, оскільки вона дозволяє зовнішньому
      класу мати доступ до приватних членів внутрішніх класів. </p>
    <h4>Захищені члени</h4>
    <p>Доступ до захищених членів також трохи більш обмежений, ніж в Java. В <br>
      Scala захищений член доступний тільки з субкласів класу, в якому
      визначений цей член. В Java такий доступ також можливий з інших класів в
      тому ж пакунку. В Scala намає іншого шляху досягти того ж ефекту, як
      показано нижче, так що protected можна залишити такім, як він є. Приклад,
      показаний в Лістингу 13.11, ілюструє захищений доступ:</p>
    <pre class="prettyprint linenums language-scala">package p {
  class Super {
    protected def f() { println("f") }
  }
  class Sub extends Super {
    f()
  }
  class Other {
    (new Super).f()
    // помилка: f недоступне
  }
}</pre>
    <p>Лістинг 13.11 Як доступ protected відрізняється в Scala та Java.</p>
    <p>В Лістингу 13.11 доступ до f в класі Sub є можливим, бо f декларовне як <br>
      protected в Super, та Sub є субкласом Super. На відміну від цього, доступ
      до f в Other не дозволений, оскільки Other не наслідує від Super. В Java,
      в останньому випадку доступ буде дозволений, оскільки Other в тому ж
      пакунку, що і Sub.</p>
    <h4>Публічні члени</h4>
    <p>Кожний член, не помічений як private або protected, є публічним. Немає
      явного можифікатора для публічних членів. Такі члени можуть бути досяжні з
      відусюди.&nbsp; </p>
    <pre class="prettyprint linenums language-scala">package bobsrockets
<br>package navigation {
  private[bobsrockets] class Navigator {
    protected[navigation] def useStarChart() {}
    class LegOfJourney {
      private[Navigator] val distance = 100
    }
    private[this] var speed = 200
  }
}<br><br>package launch {
  import navigation._
  object Vehicle {
    private[launch] val guide = new Navigator
  }
}</pre>
    <p>Лістинг 13.12 Гнучке поле зору protection з кваліфікаторами доступу.</p>
    <h4>Поле зору protection</h4>
    <p>Модифікатори доступу в Scala можуть бути прикрашені кваліфікаторами.
      Модифікатор має форму private[X] або protected[X], що означає, що доступ
      є&nbsp; private або protected “аж до” X, де X позначає деякий оточуючий
      пакунок, клас або об'єкт синглтона.</p>
    <p>Модифікатори з кваліфікованим доступом дають вам гарний контроль над
      видимістю. Зокрема, вони дозволяють вам виразити нотації доступу Java,
      такі як пакунок-приватний, пакунок-захищений, або приватний до самого
      зовнішнього класа, що прямо не має вираження простими модифікаторами в
      Scala. Але вони також дозволяють вам виразити привила доступності, яких
      немає в Java. Лістинг 13.12 представляє приклад з використанням декількох
      кваліфікаторів. В цьому лістингу клас Navigator помічений як
      private[bobsrockets]. Це означає, що цей клас видимий в усіх класах та
      об'єктах, що містяться в пакунку bobsrockets. Зокрема, доступ до Navigator
      в об'єкті Vehicle дозволений, оскільки Vehicle міститься в пакунку launch,
      що міститься в bobsrockets. З іншого боку, весь код за межами пакунку
      bobsrockets не має доступу до Navigator .</p>
    <p>Цей прийом є достатньо корисним в великих проектах, що обіймають декілька
      пакунків. Це дозволяє вам визначати речі, що видимі в декількох
      субпакунках вашого проекта, але що залишаються приховані від клієнтів,
      зовнішніх до вашого проекта. Той же прийом неможливий в Java. Там, коли
      визначення виходить за межі свого безпосереднього пакунка, воно видиме для
      широкого загалу.</p>
    <p>Звичайно, кваліфікатор private може бути також безпосередньо оточуючим
      пакунком. Прикладом є модифікатор доступу до guide об'єкта Vehicle в
      Лістингу 13.12. Такий модифікатор доступу еквівалентний до
      пакунок-приватного доступу в Java.</p>
    <p>Таблиця 13.1 Ефект кваліфікаторів private на LegOfJourney.distance</p>
    <table style="width: 100%" border="1">
      <tbody>
        <tr>
          <td>no access modifier</td>
          <td>public access</td>
        </tr>
        <tr>
          <td>private[bobsrockets]</td>
          <td>access within outer package</td>
        </tr>
        <tr>
          <td>private[navigation]</td>
          <td>same as package visibility in Java</td>
        </tr>
        <tr>
          <td>private[Navigator]</td>
          <td>same as private in Java</td>
        </tr>
        <tr>
          <td>private[LegOfJourney]</td>
          <td>same as private in Scala</td>
        </tr>
        <tr>
          <td>private[this]</td>
          <td>access only from same object</td>
        </tr>
      </tbody>
    </table>
    <p>Всі кваліфікатори можуть також бути застосовані до protected, з тим же
      значенням, що і для private. Таким чином, модифікатор protected[X] в класі
      C дозволяє доступ до поміченого визначення в усіх субкласах C, а також в
      охоблюючому пакунку, класі, або об'єкті X. Наприклад, метод useStarChart в
      Лістингу 13.12 доступний в усіх субкласах Navigator, а також у всьому
      коді, що міститься в охоплюючому пакунку navigation. Таким чином, це прямо
      відповідає до значення protected в Java.</p>
    <p>Кваліфікатори private також можуть посилатись на охоплюючий клас або
      об'єкт. Наприклад, змінна distance класа LegOfJourney в Лістингу 13.12
      помічена як private[Navigator], так що її можна бачити будь-де в класі<br>
      Navigator. Це дає ті ж можливості доступу, як для приватних членів
      внутрішнього класа в Java. Модифікатор private[C], де C є замим зовнішнім
      класом, є тим самим, що просто private в Java.</p>
    <p>Нарешті, Scala також має модифікатор доступу, що навіть більш обмежений,
      ніж private. Визначення, помічене як private[this], відкриває доступ
      тільки для того ж об'єкта, що містить це визначення. Таке визначення
      називається приватним-до-об'єкта. Наприклад, визначення speed в класі
      Navigator з Лістинга 13.12 є приватним до об'єкта. Це означає, що любий
      доступ має бути не тільки з класа Navigator, але має бути від того самого
      примірника Navigator. Таким чином, доступ до “speed” та “this.speed” буде
      легальним зсередини Navigator. Однак, наступний доступ, не буде можливим,
      навіть якщо він відбувається в класі Navigator :</p>
    <pre class="prettyprint linenums language-scala">val other = new Navigator
other.speed // це не скомпілюється</pre>
    <p>Маркування члена як private[this] є гарантією, що він не буде видимий з
      інших об'єктів того ж самого класа. Це може бути корисним для
      документації. Це також іноді дозволяє вам писати більш загальні варіанти
      анотацій (дивіться Розділ 19.7 щодо деталей).</p>
    <p>Щоб підсумувати, Таблиця 13.1 перелічує ефекти кваліфікатора private.
      Кожний рядок показує кваліфікований модифікатор private, та що це буде
      значить, якщо такий модифікатор буде приєднаний до змінної distance,
      задекларованої в класі LegOfJourney в Лістингу 13.12.</p>
    <h4>Поле зору та об'єкти-компанйони</h4>
    <p>В Java статичні члени та члени примірника належать до одного і того ж
      класа, так що модифікатори доступу однаково стосуються обох з них. Ви вже
      бачили, що в Scala немає статичних членів; замість цього ви можете мати
      об'єкт-компанйон, що містить члени, що існують тільки один раз. Наприклад,
      в Лістингу 13.13 об'єкт Rocket є об'єктом-компанйоном класа Rocket .</p>
    <p>Правила доступу Scala надають привілеї об'єктам-компанйонам та класам,
      коли доходить до модифікаторів private або protected. Клас поділяє всі
      свої права доступу з об'єктом-компанйоном, та навпаки. Зокрема, об'єкт
      може мати доступ до всіх приватних членів класа-компанйона, так само,
      як&nbsp; клас може мати доступ до всіх приватних членів свого
      об'єкта-компанйона.</p>
    <p>Наприклад, клас Rocket вище може отримати доступ до метода fuel, що
      задекларований як private в об'єкті Rocket. Аналогічно, об'єкт Rocket може
      отримати доступ до приватного метода canGoHomeAgain класа Rocket.</p>
    <p>Одне виключення, де є закінчується подібність між Scala та Java
      стосується захищених статичних методів. Захищені статичні члени класа Java
      C може отримати доступ у всіх субкласах C. На відміну від цього, захищені
      класи&nbsp; в об'єкті-компанйомі не мають сенсу, бо об'єкт-синглтон не має
      субкласів.</p>
    <pre class="prettyprint linenums language-scala">class Rocket {
  import Rocket.fuel
  private def canGoHomeAgain = fuel &gt; 20
}
<br>object Rocket {
  private def fuel = 10
  def chooseStrategy(rocket: Rocket) {
    if (rocket.canGoHomeAgain)
      goHome()
    else
      pickAStar()
  }
  def goHome() {}
  def pickAStar() {}
}</pre>
    <p>Лістинг 13.13: Доступ до приватних членів класа-компанйона та об'єктів.</p>
    <h4>13.6 Об'єкти пакунка</h4>
    <p>До цього часу, єдиний код, що ви додавали до пакунку, були класи, трейти,
      та окремі об'єкти. Це найбільш загальні визначення, що покладаються на
      верхній рівень пакунка, але Scala не обмежує вас цім.</p>
    <p>Любий тип визначення, що ви можете покласти в клас, ви також можете
      покласти на верхній рівень пакунка. Якщо ви маєте деякій допоміжний метод,
      що ви бажаєте покласти в полі зору всього пакунка, зробіть так, та
      покладіть його на верхній рівень пакунка. Щоб зробити це, покладіть
      визначення в об'єкт пакунка. Кожний пакунок дозволяє мати об'єкт пакунка.
      Любі визначення, покладені в об'єкт пакунка, будуть розглядатись як члени
      самого пакунка.</p>
    <p>Приклад, показаний в Лістингу 13.14. Файл package.scala містить об'єкт
      пакунка для пакунка bobsdelights . Синтаксично, об'єкт пакунка виглядає
      більше як один з фігурно-дужкових пакунків, показаних раніше в цій главі.
      Одна різниця полягає в тому, що він включає ключове слово object. Це обєкт
      пакунка, не сам пакунок. Вміст фігурних дужок може включати любе
      визначення, яке ви побажаєте. В цьому випадку, об'єкт пакунка включає
      допоміжний метод showFruit з Лістинга 13.8.</p>
    <p>Маючи це визначення, любий інший код в любому пакунку може імпортувати
      метод, так само, як він може імпортувати клас. Наприклад, Лістинг 13.14
      також показує окремий об'єкт PrintMenu, що розміщений в іншому пакунку.
      PrintMenu може імпортувати допоміжний метод showFruit, таким же чином, як
      він може імпортувати клас Fruit .</p>
    <pre class="prettyprint linenums language-scala">// В файлі bobsdelights/package.scala
package object bobsdelights {
  def showFruit(fruit: Fruit) {
    import fruit._
    println(name +"s are "+ color)
  }
}
<br>// В файлі PrintMenu.scala
package printmenu
<br>import bobsdelights.Fruits
import bobsdelights.showFruit
<br>object PrintMenu {
  def main(args: Array[String]) {
    for (fruit &lt;- Fruits.menu) {
      showFruit(fruit)
    }
  }
}</pre>
    <p>Лістинг 13.14 Об'єкт пакунка.</p>
    <p>Заглядаючи наперед, є інші використання об'єктів пакунків для типів
      визначень, що ви вже бачили. Об'єкти пакунків часто використовуються для
      зберігання псевдонимів типів для всього пакунка (Глава 20) та неявних
      перетворювань (Глава 21). Високорівневий пакунок scala має об'єкт пакунка,
      та його визначення доступні для всього кода Scala.</p>
    <p>Об'єкти пакунків компілюються в файли класів на ім'я package.class, що
      розташовані в каталозі пакунку, що вони представляють. Це корисно,
      притримуватись тієї ж домовленості для первинних файлів. Так що ви маєте
      зазвичай покладати файли об'єкта пакунка bobsdelights з Лістинга 13.14 до
      файла з назвою package.scala, що знаходиться в каталозі bobsdelights.</p>
    <h3>13.7 Висновок</h3>
    <p>В цій главі ви побачили базові конструкції для поділу програми на
      пакунки. Це дає вам просту та корисну можливість модулярності, так що ви
      можете працювати з дуже великими обсягами кода, без того, щоб різні
      частини кода налазили один на одний. Ця система в тому ж дусі, що і
      пакунки Java, але є деякі відмінності, де Scala обирає бути більш
      узгодженою або більш загальною.</p>
    <p>Заглядаючи наперед, Глава 29 описує більш гнучку систему модулів, ніж
      поділ на пакунки. На додаток до можливості поділити код на декілька
      просторів імен, цей підхід дозволяє модулям бути параметризованими, та
      наслідувати один від одного. В наступній главі ми звернемо нашу увагу на
      припущення та юніт-тестування.</p>
    <h3>Глава 14</h3>
    <h2>Припущення та юніт тести</h2>
    <p>Два важливі способи перевірити, що поведінка вашого програмного
      забезпечення така, як ви очікуєте, є припущення та юніт тести. В цьому
      розділі ми покажемо деякі доступні вам опції, що ви можете записати та
      протестувати в Scala.</p>
    <h3>14.1 Припущення</h3>
    <p>Припущення в Scala записуються як виклики попередньо визначеного
      метода&nbsp; assert. Вираз assert(умова) викликає AssertionError, якщо
      умова не справдиться. Також є версія assert з двома аргументами. Вираз
      assert(умова, пояснення) перевіряє умову, та якщо вона не справжується,
      підіймає&nbsp; AssertionError, що містить надане пояснення. Тип пояснення
      Any, так що ви можете передати любий об'єкт в якості пояснення. Метод
      assert буде викликати на ньому toString, щоб отримати рядок пояснення, яке
      буде розміщене в AssertionError.</p>
    <p>Наприклад, в методі на ім'я “above” класа Element, показаному в Лістингу
      10.13, ви можете розмістити assert після виклику widen, щоб переконатись,
      що розширені елементи мають однакову ширину. Це показано в Лістингу 14.1.</p>
    <p>Інший шлях, що ви можете обрати, щоб зробити це, це перевірити ширину
      наприкінці метода widen, прямо перед поверненням значення. Ви можете
      досягти цього, зберігаючи результат в val, виконавши припущення на
      результаті, та потім вказавши val останнім, так що результат буде
      повернений, якщо припущення справдиться.</p>
    <pre class="prettyprint linenums language-scala">def above(that: Element): Element = {
  val this1 = this widen that.width
  val that1 = that widen this.width
  assert(this1.width == that1.width)
  elem(this1.contents ++ that1.contents)
}</pre>
    <p>Лістинг 14.1 Використання припущень.</p>
    <p>Однак, ви можете зробити це більш стисло, за допомогою зручного метода в
      Predef, ща називається ensuring, як показано в Лістингу 14.2. Метод
      ensuring може бути використаний з любим типом результата, завдяки неявній
      конверсії типів. Хоча це виглядає в коді, якби ми б викликали ensuring на
      результаті widen, що є типом Element, ми насправді викликаємо ensuring на
      типі, до якого неявно приводиться Element. Метод ensuring приймає один
      аргумент, функцію-предикат, що приймає тип результата, та повертає
      Boolean. Сам ensuring передасть результат в предикат. Якщо предикат
      поверне true, ensuring поерне результат. Інакше, ensuring підійме
      AssertionError.</p>
    <p>В цьому прикладі предикат “w &lt;= _.width”. Підкреслення є підміною
      одного аргумента, що передається до предиката, результат Element метода
      widen. Якщо передана до widen ширина, w, меньше або дорівнює до width
      отриманого Element, предикат будет true, та ensuring поверне Element, на
      якому він був викликаний. Оскільки це останній вираз в методі widen, сам
      widen завершиться з результатом Element.</p>
    <pre class="prettyprint linenums language-scala">private def widen(w: Int): Element =
  if (w &lt;= width)
    this
  else {
    val left = elem(' ', (w - width) / 2, height)
    var right = elem(' ', w - width - left.width, height)
    left beside this beside right
  } ensuring (w &lt;= _.width)</pre>
    <p>Лістинг 14.2 Використання ensuring для перевірки результата функції.</p>
    <p>Припущення (та перевірки ensuring) можуть бути включені або відключені з
      використанням флагів командного рядка JVM -ea та -da. Коли включені, кожне
      припущення виступає як невеликий тест, що використовує справжні дані, що
      трапляються під час виконання програми. В залишку цієї глави ми
      сфокусуємось на написанні зовнішніх юніт тестів, що провадять власні
      тестові дані, та виконуються незалежно від застосування.</p>
    <h3>14.2 Юніт тести в Scala</h3>
    <p>Ви маєте багато опцій для юніт тестів в Scala, від визнаних інструментів
      Java, таких, як JUnit та TestNG, до нових інструментів, написаних на
      Scala, як ScalaTest, specs, та ScalaCheck. В залишку цієї глави ми надамо
      вам огляд ціх інструментів. Ми почнемо зі ScalaTest.</p>
    <p>ScalaTest провадить декілька шляхів для написання тестів, простіший з
      яких є створення класів, що розширюють org.scalatest.Suite, та визначають
      тестові методи в ціх класах. Suite представляє сюїту тестів. Тестові
      методи починаються з "test". Лістинг 14.3 показує приклад:</p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.Suite
import Element.elem
<br>class ElementSuite extends Suite {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width == 2)
  }
}</pre>
    <p>Лістинг 14.3 Написання тестового метода за допомогою Suite.</p>
    <p>Хоча ScalaTest включає застосування Runner, ви можете виконати Suite
      напряму з інтерпретатора Scala, викликавши для нього execute. Метод
      execute використовує рефлексію для пошуку тестових методів, та викликає
      їх. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; (new ElementSuite).execute()
Test Starting - ElementSuite.testUniformElement
Test Succeeded - ElementSuite.testUniformElement</pre>
    <p>ScalaTest спрощує різні стилі тестування, оскільки execute може бути
      перевизначений в підтипах Suite. Наприклад, ScalaTest пропонує трейт з
      назвою FunSuite, що перевизначає execute, так що ви можете визначити тести
      як функціональні значення, скоріше, ніж методи. Лістинг 14.4 показує
      приклад:</p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.FunSuite 
import Element.elem
<br>class ElementSuite extends FunSuite {
  test("elem result should have passed width") {
    val ele = elem('x', 2, 3)
    assert(ele.width == 2)
  }
}</pre>
    <p>Лістинг 14.4 Написання тестової функції за допомогою FunSuite.</p>
    <p>“Fun” в FunSuite означає функцію. Метод “test ” визначений в FunSuite, що
      буде викликаний первинним конструктором ElementSuite. Ви задаєте ім'я
      теста як рядок між дужками, та сам код теста між фінурними дужками. Код
      теста є функцією, що передається як параметр за-ім'ям до тесту, що
      реєструє її для подальшого виконання. Одна з переваг FunSuite в тому, що
      вам не потрібне називати всі ваші тести з початком на “test”. На додаток,
      ви можете просто отримати довгі імена для ваших тестів, оскільки ми не
      змушені кодувати їх в верблюжому реєстрі, як це робиться для імен методів.</p>
    <h3>14.3 Інформативні доповіді про тестування</h3>
    <p>Тести в попередніх двох прикладах намагаютсья створити елемент з шириною,
      та припускають, що ширина отриманого елемента є 2. Коли це припущення
      схибить, ви побачите повідомлення, що вказує, що припущення схибило.</p>
    <p>Ви отримаєте номер рядка, але не будете знати, що два значення не були
      рівні. Ви можете винайти це, якщо розмістите рядок в припущення, що вказує
      на два значення, але більш стислий підхід є використання оператора з
      трьома знаками рівняння, що ScalaTest провадить саме для ціх цілей:</p>
    <pre class="prettyprint linenums language-scala">assert(ele.width === 2)</pre>
    <p>Коли припущення схибить, ви побачите повідомлення, таке як “3 did not
      equal 2” в доповіді про помилку. Це скаже вам, що ele.width невірно
      повернуло&nbsp; 3. Оператор з трьма знаками рівняння не розрізняє між
      дійсним і очікуваним результатом. Він просто вказує, що лівий оператор не
      був рівним до правого оператора. Якщо ви бажаєте наголосити на цій
      різниці, ви можете альтернативно використанти метод ScalaTest expect, як
      це:</p>
    <pre class="prettyprint linenums language-scala">expect(2) {
  ele.width
}</pre>
    <p>Цім віразом ви вказуєте, що ви очікуєте, що код в фігурних дужках дасть
      2. Коли код в дужках дасть 3, ви побачите повідомлення “Expected 2, but
      got 3” в доповіді про помилку. Якщо ви бажаєте перевірити, чи метод
      викликає виключення, ви можете використати метод ScalaTest intercept,
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">intercept[IllegalArgumentException] {
  elem('x', -2, 3)
}</pre>
    <p>Якщо код в фігурних дужках завершається передчасно з примірником вказано
      класа виключення, intercept поверне викликане виключення, щоб ви могли
      його подалі достілдити. Більш часто вас буде тільки турбувати, щоб вказане
      виключення просто було викликане, та ігнорувати результат перехоплення, як
      це робиться в нашому прикладі. З іншого боку, якщо код не викликає
      виключення, або викликає інше виключення, метод intercept буде підіймати
      TestFailedException, та ви отримаєте корисне повідомлення про помилку в
      доповіді про відмову, ось так:</p>
    <pre class="prettyprint linenums language-scala">Expected IllegalArgumentException to be thrown,
  but NegativeArraySizeException was thrown.</pre>
    <p>Ціллю оператора ScalaTest === та його методів expect та intercept -
      допомогти вам писати методи тестування на основі припущень, що зрозумілі
      та стислі. В наступному розділі ми покажемо, як використовувати цей
      синтаксис в тестах JUnit та TestNG, написаних на Scala.</p>
    <h3>14.4 Використання JUnit та TestNG</h3>
    <p>Найбільш популярним фремворком для юніт тестів на платформі Java є JUnit,
      інструмент з відкритим кодом, написаний Кентоом Беком та Еріхон Гамма. Ви
      можете писати тести JUnit в Scala досить просто. Ось приклад з
      використанням JUnit 3.8.1:</p>
    <pre class="prettyprint linenums language-scala">import junit.framework.TestCase
import junit.framework.Assert.assertEquals
import junit.framework.Assert.fail
import Element.elem
<br>class ElementTestCase extends TestCase {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assertEquals(2, ele.width)
    assertEquals(3, ele.height)
    try {
      elem('x', -2, 3)
      fail()
    }
    catch {
      case e: IllegalArgumentException =&gt; // expected
    }
  }
}</pre>
    <p>Коли ви скомпілюєте цей клас, JUnit буде виконувати його як любий інший
      TestCase. JUnit не обходить, що він був написаний на Scala. Однак, якщо ви
      бажаєте використовувати синтаксис припущень ScalaTest в вашому тесті JUnit
      3, ви можете наслідувати JUnit3Suite, як показано в Лістингу 14.5.</p>
    <p>Трейт JUnit3Suite розширює TestCase, так що одного разу, коли ви
      скомпілюєте цей клас, JUnit буде робити дуже гарно, не зважаючи на те, що
      він використовує більш стислий синтаксис припущень ScalaTest. Більше того,
      оскільки JUnit3Suite змішує трейт ScalaTest Suite, ви можете альтернативно
      виконати цей тест з виконувачем ScalaTest. Ціллю є провадити м'яку
      міграцію, щоб дозволити користувачам&nbsp; JUnit почати писати тести JUnit
      на Scala, що мають переваги стислості, надані Scala. ScalaTest також має
      JUnitWrapperSuite, що дозволяє вам виконувати існуючі тести JUnit,
      написані на Java, з виконувачем ScalaTest.</p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.junit.JUnit3Suite
import Element.elem
<br>class ElementSuite extends JUnit3Suite {
  def testUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width === 2)
    expect(3) { ele.height }
    intercept[IllegalArgumentException] {
      elem('x', -2, 3)
    }
  }
}</pre>
    <p>Лістинг 14.5 Написання теста JUnit за допомогою JUnit3Suite .</p>
    <p>ScalaTest пропонує подібні класи інтеграції для JUnit 4 та TestNG, обоє з
      яких щедро використовують анотації. Ми покажемо приклад використання
      TestNG, фреймворка з відкритим кодом, написаного Седріком Бюстом та
      Александру Попеску. Як і з JUnit, ви можете просто написати тести TestNG
      на Scala, скомпілювати їх, та виконати за допомогою виконувача TestNG. Ось
      приклад:</p>
    <pre class="prettyprint linenums language-scala">import org.testng.annotations.Test
import org.testng.Assert.assertEquals
import Element.elem
<br>class ElementTests {
<br>  @Test def verifyUniformElement() {
    val ele = elem('x', 2, 3)
    assertEquals(ele.width, 2)
    assertEquals(ele.height, 3)
  }
<br>  @Test(
    expectedExceptions =
    Array(classOf[IllegalArgumentException])
  )
  <br>  def elemShouldThrowIAE() { elem('x', -2, 3) }
}</pre>
    <p>Однак, якщо ви схиляєтесь до використання синтаксису припущень ScalaTest
      в ваших тестах TestNG, ви можете розширити трейт TestNGSuite, як показано
      в Лістингу 14.6:</p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.testng.TestNGSuite
import org.testng.annotations.Test
import Element.elem
<br>class ElementSuite extends TestNGSuite {
<br>  @Test def verifyUniformElement() {
    val ele = elem('x', 2, 3)
    assert(ele.width === 2)
    expect(3) { ele.height }
    intercept[IllegalArgumentException] {
      elem('x', -2, 3)
    }
  }
}</pre>
    <p>Лістинг 14.6 Написання теста TestNG за допомогою TestNGSuite.</p>
    <p>Як і з JUnit3Suite, ви можете виконати TestNGSuite або з TestNG<br>
      або ScalaTest, та ScalaTest також провадить TestNGWrapperSuite, що
      дозволяє&nbsp; виконувати існуючі тести TestNG, написані на Java, за
      допомогою ScalaTest. Щоб побачите приклад теста JUnit 4, написаного на
      Scala, дивіться Розділ 31.2.</p>
    <h3>14.5 Тести як специфікації</h3>
    <p>В розробці в стилі тестування на основі поведінки (behavior-driven
      development, BDD), ставиться наголос на написанні читабельних людиною
      специфікацій очікуваної поведінки кода, та супровідних тестів, що
      перевіряють, що код має вказану поведінку. ScalaTest включає декілька
      трейтів — Spec, WordSpec, FlatSpec, та FeatureSpec — що спрощують цей
      стиль тестування. Приклад FlatSpec показаний в Лістингу 14.7.</p>
    <p>В FlatSpec ви пишете тести як твердження специфікацій. Ви починаєте з
      написання імені для предмета тестування, в вигляді рядка ("A
      UniformElement" в Лістингу 14.7), потім should (або must, або can), потім
      рядок, що задає частину поведінки, що очікується від предмета, потім in. В
      фігурних дужках за in ви пишете код, що тестує вказану поведінку. В
      наступних твердженнях для посилання на останній згадуваний предмет
      тестування ви можете писати it. </p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.FlatSpec
import org.scalatest.matchers.ShouldMatchers
import Element.elem
<br>class ElementSpec extends FlatSpec with ShouldMatchers {
  "A UniformElement" should
<br>  "have a width equal to the passed value" in {
     val ele = elem('x', 2, 3)
     ele.width should be (2)
  }
<br>  it should "have a height equal to the passed value" in {
    val ele = elem('x', 2, 3)
    ele.height should be (3)
  }
<br>  it should "throw an IAE if passed a negative width" in {
    evaluating {
      elem('x', -2, 3)
    } should produce [IllegalArgumentException]
  }
}</pre>
    <p>Лістинг 14.7 Задання та тестування поведінки за допомогою ScalaTest
      FlatSpec.</p>
    <p>При виконанні FlatSpec він буде виконувати кожний заданий специфікатор як
      тест ScalaTest. FlatSpec (та інші трейти специфікації ScalaTest) генерують
      вивід, що читається здебільшого як специфікація, що ви виконуєте.
      Наприклад, ось на що буде скидатись результат, якщо виконати ElementSpec з
      Лістинга 14.7 в інтерпретаторі: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; (new ElementSpec).execute()
A UniformElement
- should have a width equal to the passed value
- should have a height equal to the passed value
- should throw an IAE if passed a negative width</pre>
    <p>Лістинг 14.7 також ілюструє DSL порівнювачів ScalaTest. Міксуючи трейти
      ShouldMatchers, ви можете записати припущення, що виглядають більш схожими
      на природу мову, та генерують більш описові повідомлення відмов. ScalaTest
      провадить багато порівнювачів в своєму DSL, а також дозволяє вам
      створювати ваші власні порівнювачі. Порівнювачі, показані в Лістингу 14.7
      включають “should be” та синтаксис “evaluating { . . . } should produce”.
      Ви можете альтернативно доміксувати MustMatchers, якщо ви надаєте перевагу
      must замість should . Наприклад, міксуючи MustMatchers дозволить вам
      записати такі вирази:</p>
    <pre class="prettyprint linenums language-scala">result must be &gt;= 0
array must have length 3
map must contain key 'c'</pre>
    <p>Якщо припущення схибить, ви побачите повідомлення помилки, подібну до
      такої:</p>
    <pre class="prettyprint linenums language-scala">Map('a' -&gt; 1, 'b' -&gt; 2) did not contain key 'c'</pre>
    <p>Фреймворк тестування specs, інструмент з відкритим кодом, що написаний на
      Scala Еріком Торреборре, також підтримує стиль тестування BDD, але має
      інший синтаксис.</p>
    <p>Наприклад, ви можете використовувати specs для написання тесту,
      показаного в Лістингу 14.8:</p>
    <pre class="prettyprint linenums language-scala">import org.specs._
import Element.elem
<br>object ElementSpecification extends Specification {
  "A UniformElement" should {
<br>    "have a width equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.width must be_==(2)
    }
    <br>    "have a height equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.height must be_==(3)
    }
<br>    "throw an IAE if passed a negative width" in {
      elem('x', -2, 3) must
      throwA[IllegalArgumentException]
    }
  }
}</pre>
    <p>Лістинг 14.8 Задання та тестування поведінки за допомогою фреймворка
      specs.</p>
    <p class="prettyprint linenums language-scala">Як і ScalaTest, specs
      провадить DSL порівнювачів. Ви можете бачити деякі приклади порівнювачів
      specs в дії в Лістингу 14.8, в рядках, що містять “must be_==” та “must
      throwA”. Ви можете використовувати specs окремо, але він також
      інтегрований зі ScalaTest та JUnit, так що ви можете виконувати тести
      specs також і з ціма інструментами. <span class="refer">Ви можете
        завантажити specs з http://code.google.com/p/specs/.</span> </p>
    <h3>14.6 Тестування на основі властивостей</h3>
    <p>Іншим корисним інструментом для Scala є ScalaCheck, фреймворк з відкритим
      кодом, написаний Рікардом Нілсоном. ScalaCheck дозволяє вам вказати
      властивості, яким має підкорятись код, що тестується. Для кожної
      властивості ScalaCheck буде генерувати тестові дані, та виконувати тести,
      що перевіряють, чи дотримується ця властивість. Лістинг 14.9 показує
      приклад використання ScalaCheck зі ScalaTest WordSpec, що примішує трейт
      Checkers :</p>
    <pre class="prettyprint linenums language-scala">import org.scalatest.WordSpec
import org.scalatest.prop.Checkers
import org.scalacheck.Prop._
import Element.elem
class ElementSpec extends WordSpec with Checkers {
  "elem result" must {
    "have passed width" in {
      check((w: Int) =&gt; w &gt; 0 ==&gt; (elem('x', w, 3).width == w))
    }
    "have passed height" in {
      check((h: Int) =&gt; h &gt; 0 ==&gt; (elem('x', 2, h).height == h))
    }
  }
}</pre>
    <p>Лістинг 14.9 Написання тестів на основі властивостей за допомогою
      ScalaCheck.</p>
    <p>WordSpec є трейтом ScalaTest, що провадить синтаксис, подібний до specs<br>
      Specification. Трейт Checkers провадить декілька методів перевірки, що
      дозволяють вам поєднувати базовані на властивостях тести ScalaCheck з
      традиційними тестами, базованими на припущеннях або порівняннях. В цьому
      прикладі ми перевіряємо дві властивості, яким має підкорятись фабрика
      elem. Властивості ScalaCheck виражені як функціональні значення, що
      приймають в якості параметрів необхідні для тестування дані, що будуть
      згенеровані ScalaCheck. В першій властивості, показаній в Лістингу 14.9,
      тестові дані є цілим на ім'я w, що представляє ширину. В тілі функції ми
      бачимо такий код:</p>
    <pre class="prettyprint linenums language-scala">w &gt; 0 ==&gt; (elem('x', w, 3).width == w)</pre>
    <p>Символ ==&gt; є оператором застосування в ScalaCheck. Мається на увазі,
      що кожного разу, коли вираз в лівій частині є true, вираз в правій також
      має бути true. Таким чином, в цьому випадку, вираз зправа від ==&gt; мєа
      бути true, коли w більше ніж 0. Вираз зправа в цьому випадку буде давати
      true, якщо ширина, передана до фабрики elem буде така сама, як ширина
      Element, що повертає фабрика.</p>
    <p>За допомогою цієї малої кількості кода ScalaCheck згенерує можливо сотні
      значень для w, та протестує кожний, шукаючи значення, для якого властивіст
      не справжується. Якщо властивість залишається true для кожного значення,
      що спроує ScalaCheck, тест буде пройдено. Інакше тест буде терміново
      закінчено з AssertionError, що містить інформацію, включаючи значення, що
      призвело до відмови.&nbsp;</p>
    <h3>14.7 Організація та виконання тестів</h3>
    <p>Кожний фреймворк, розглянутий в цій главі, провадить деякий механізм для
      організації та виконання тестів. В цьому розділі ми отримаємо швидкий
      огляд підходу ScalaTest. Однак, щоб отримати повну історію щодо ціх
      фреймворків, вам знадобиться звертатись до їх документації.</p>
    <p>В ScalaTest ви організуєте великі тестові сюїти, вкладаючи Suite в Suite.
      Коли виконується сюїта, вона буде виконувати вкладені сюїти, так само, як
      тести. Вкладені сюїти, в свою чергу, будуть виконувати свої вкладені
      сюїти, і так далі. Таким чином, велика тестова сюїта представлена як
      дерево з об'єктів Suite. коли ви виконуєте кореневу сюїту дерева, будуть
      виконані всі сюїти в дереві.</p>
    <p>Ви можете вкласти сюїти вручну або автоматично. Щоб вкласти вручну, ви
      або пееркриваєте метод nestedSuites на ваших Suite, або передаєте сюїти,
      що ви бажаєте вкласти, до конструктора класа SuperSuite, що ScalaTest
      провадить саме для ції цілей. Щоб вкласти автоматично, ви провадите імена
      пакунків до ScalaTest Runner, що буде знаходити сюїти автоматично,
      вкладати їх під кореневу сюїту, та виконувати кореневу Suite .</p>
    <img alt="" src="14.1.png">
    <p>Малюнок 14.1 Графічний доповідач ScalaTest.</p>
    <p>Ви можете визвати застосування ScalaTest Runner з командного рядка або з
      завдання ant. Ви маєте вказати, які сюїти ви бажаєте виконати, або
      назвавши сюїти явно, або вказавши префікси імен, для яких ви бажаєте, щоб
      Runner виконав автоматичний пошук. Опціонально ви можете вказати runpath,
      список каталогів та файлів JAR, з яких будуть завантажені файли класів для
      тестів, та код, що вони тренують.<span class="refer"> Тести можуть бути
        будь-де на runpath або classpath, але зазвичай ви будете тримати ваші
        тести окремо від вашого виробничого кода, в окремій ієрархії каталогів,
        що відзеркалює ієрархію каталогів ваших класів. </span>Також ви можете
      вказати один або більше доповідачів, що будуть визначати, як будуть
      представлені результати тестів.</p>
    <p>Наприклад, дистрибутив ScalaTest включає сюїти, що тестують сам
      ScalaTest. Ви можете виконати одну з ціх сюїт, SuiteSuite, за допомогою
      наступної команди:</p>
    <pre class="prettyprint linenums language-scala">$ scala -cp scalatest-1.2.jar org.scalatest.tools.Runner
  -p "scalatest-1.2-tests.jar" -s org.scalatest.SuiteSuite</pre>
    <p>За допомогою -cp ви покладаєте файл ScalaTest JAR до classpath. Наступний
      токен, org.scalatest.tools.Runner, є повністю кваліфікованим ім'ям
      застосування Runner. Scala буде виконувати це застосування, та передасть
      йому інші токени як аргументи командного рядка. Ключ -p вказує на runpath,
      що в цьому випадку є JAR файлом, що містить класи сюїти:
      scalatest-1.2-tests.jar. Ключ -s вказує на SuiteSuite, як на сюїту, що
      треба виконати. Оскільки ви явно не вказуєте доповідача, ви по замовчанню
      отримаєте графічного доповідача. Результат показаний на Малюнку 14.1.</p>
    <h3>14.8 Висновок</h3>
    <p>В цій главі ми бачили приклади міксування припущень безпосередньо в
      виробничий код, а також написання їх зовні, в вигляді юніт тестів. Ви
      бачили це як Scala програміст, що можна отримати вигоди від популярних
      тестових інструментів спільноти Java, таких, як JUnit та TestNG, а також
      від новіших інструментів, розроблених спеціально для Scala, таких, як
      ScalaTest, ScalaCheck, та specs. Обоє, припущення в коді, та юніт тести
      можуть допомогти вам досягти ваших цілей щодо якості програми.</p>
    <p>Ми відчуваємо, що ці прийоми досить важливі, щоб виправдати невеликий
      відступ від розгляду Scala, що і представлено в цій главі. Однак, в
      наступній главі ми повернемось до розгляду мови, та розкриємо дуже
      корисний аспект Scala: порівняння шаблонів.</p>
    <h3>Глава 15</h3>
    <h2>Кейс класи та порівняння шаблонів</h2>
    <p>Ця глава вводить кейс класи та порівняння (співпадіння) шаблонів,
      пов'язані конструкції, що підтримують вас, коли ви пишете регулярні, не
      інкапсульовані структури даних. Ці дві конструкції, зокрема, корисні для
      деревоподібних рекурсивних даних. Якщо ви до цього програмували в
      функціональних мовах, тоді ви, можливо, розпізнаєте порівняння шаблонів.
      Однак кейс класи будуть новими для вас. Кейс класи є способом Scala
      дозволити співпадіння шаблонів на об'єктах, без потреби великої кількості
      рутинного кода. В загальному випадку, все, що вам треба, це додати одне
      ключове слово case до кожного класа, що ви бажаєте використовувати в
      співпадіннях з шаблонами.</p>
    <p>Ця глава починається з простого прикладу кейс класа та порівняння. Потім
      він проходить по всіх типух шаблонів, що підтримуються, промовляє про роль
      прив'язанних sealed класів, обговорює тип Option, та показує деякі
      нерчевидні місця в мові, де використовується порівнняння з шаблонами.</p>
    <p>Нарешті, показаний більший, та більш реалістичний приклад порівняння.</p>
    <h3>15.1 Простий приклад</h3>
    <p>Перед тим, як зануритись в усі правила та нюанси порівняння шаблонів, є
      сенс подивитись на простий приклад, щоб спіймати головну ідею. Скажімо,
      вам треба написати бібліотеку, що маніпулює арифметичними виразами,
      можливо, як частину галузевої мови, що ви розробляєте.</p>
    <p>Перший крок зрушити цю проблему є визначення вхідних даних. Щоб
      утримувати речі простими, ми сконцентруємось на арифметичних виразах, що
      складаються зі змінних, чисел, та унарних та бінарних операцій. Це
      виражене ієрархією Scala класі, показаню в Лістингу 15.1.</p>
    <pre class="prettyprint linenums language-scala">abstract class Expr
<br>case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr</pre>
    <p>ЛІстинг 15.1 Визначення кейс класів.</p>
    <p class="prettyprint linenums language-scala">Ієрархія включає абстрактний
      базовий клас Expr з чотирма субкласами, по одному на кожний вираз, що ми
      розглядаємо. <span class="refer">Замість абстрактного класа ми з тим же
        успіхом можемо змоделювати корінь цієї ієрархії класів як трейт.
        Моделювання через абстрактний клас може бути трохи більш ефективним. </span>Тіла
      всіх п'яти класів пусті. Як попередньо зазначалось, в Scala ви можете
      залишити фігурні дужки коло пустого класа, якщо побажаєте, так що клас C
      те саме, що і клас C {}.</p>
    <h4>Кейс класи</h4>
    <p>Інша варта уваги річ щодо декларацій в Лістингу 15.1, це те, що кожний
      субклас має можифікатор case. Класи з таким модифікатором називаються кейс
      класами. Використання цього модифікатора примушує компілятор&nbsp; Scala
      додати деякі синтаксичні зручності до вашого класа.</p>
    <p>Перше, це додає метод-фабрику з ім'ям класа. Це означає, що ви можете
      написати, скажімо, Var("x"), щоб побудувати об'єкт Var, замість трохи
      довшого new Var("x") :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val v = Var("x")
v: Var = Var(x)</pre>
    <p>Методи-фабрики зокрема добрі, коли ви вкладаєте їх. Оскільки немає
      надокучливих ключових слів new, розсипаних в коді, ви можете охопити
      структуру виразу з першого погляду:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val op = BinOp("+", Number(1), v)
op: BinOp = BinOp(+,Number(1.0),Var(x))</pre>
    Друга синтаксична зручність в тому, що всі аргументи зі списка параметрів
    кейс класа неявно мають префікс val, так що вони обробляються як поля:
    <pre class="prettyprint linenums language-scala">scala&gt; v.name
res0: String = x
scala&gt; op.left
res1: Expr = Number(1.0)</pre>
    <p>Третьє, компілятор додає до вашого класа “природні” реалізації методів
      toString, hashCode, та equals. Вони будуть друкувати, хешувати та
      порівнювати ціле дерево, що складається з класа та (рекурсивно) всіх його
      аргументів. Оскільки == в Scala завжди делегує до equals, це означає, що
      елементи кейс класів завжди порівнюються структурно:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; println(op)
BinOp(+,Number(1.0),Var(x))
scala&gt; op.right == Var("x")
res3: Boolean = true</pre>
    <p>Нарешті, компілятор додає до вашого класа метод copy, щоб робити
      модифіковані копії. Цей метод корисний для створень нових примірників
      класа, що такий самий, як інший, за виключенням одного або двох атрибутів.
      Метод робить з використанням поіменованих параметрів та параметрів по
      замовчанню (Розділ 8.8). Ви задаєте бажані зміни, використовуючи
      поіменовані параметри. Для любих параметрів, що ви не вказуєте, буде
      використане значення зі старого об'єкта. Як приклад, ось як ви можете таку
      ж операцію, як і op, за тим виятком, що вона має змінений оператор:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; op.copy(operator = "-")
res4: BinOp = BinOp(-,Number(1.0),Var(x))</pre>
    <p>Всі ці домовленості додають багато зручності за малу ціну. Ціна полягає в
      тому, що що вам треба вказати модифікатор case, та що ваші класи стають
      трохи більшими. Вони більші, бо генеруються додаткові методи, та додаються
      неявні поля для кожного параметра конструктора. Однак, найбільша вигода
      від кейс класів в тому, що вони підтримують порівняння (співпадіння)
      шаблонів.</p>
    <h4>Порівняння (співпадіння) шаблонів</h4>
    <p>Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених
      типів. Є багато можливих правил спрощення. Наступні три служать&nbsp;
      тільки ілюстрацією:</p>
    <pre class="prettyprint linenums language-scala">UnOp("-", UnOp("-", e )) =&gt; e // Подвійна зміна знака
BinOp("+", e, Number(0)) =&gt; e // Додавання нуля
BinOp("*", e, Number(1)) =&gt; e // Множення на одиницю</pre>
    <p>Використовуючи порівняння шаблонів, ці правила можуть бути сприйняті
      майже так, як вони є, щоб сформувати ядро функції спрощення в Scala, як
      показано в Лістингу 15.2. Функція, simplifyTop, може бути використана
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; simplifyTop(UnOp("-", UnOp("-", Var("x"))))
res4: Expr = Var(x)<br><br>def simplifyTop(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e)) =&gt; e // Подвійна зміна знака
  case BinOp("+", e, Number(0)) =&gt; e // Додавання нуля
  case BinOp("*", e, Number(1)) =&gt; e // Множення на одиницю
  case _ =&gt; expr 
}</pre>
    <p>Лістинг 15.2 Функція simplifyTop, що виконує порівняння шаблонів.</p>
    <p>Права частина simplifyTop складається з виразу match. match відповідає до
      switch в Java, але записується після виразу селектора, тобто:</p>
    <pre class="prettyprint linenums language-scala">селектор match { альтернативи }</pre>
    <p>замість:</p>
    <pre class="prettyprint linenums language-scala">switch ( селектор ) { альтернативи }</pre>
    <p>Порівняння шаблонів включає послідовність альтернатив, кожна з яких
      починається ключовим словом case. Кожна альтернатива включає шаблон, та
      один або більше виразів, що будуть обчислені, якщо шаблон співпаде. Символ
      стрілки =&gt; відділяє шаблон від виразів.</p>
    <p>Вираз match обчислюється через спробу кожного з шаблонів, в тому порядку,
      як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що
      слідує за стрілкою, буде виконана.</p>
    <p>Шаблон-константа, як "+" або 1, співпаде зі значеннями, рінвними
      константі за допомгою відповідного ==. Змінний шаблон як e співпадає з
      любим значенням. Змінна потім посилається на те значення, що знаходиться
      зправа до твердження case.</p>
    <p>Зауважте, що перші три приклади обчислюються до e, змінної, що прив'язана
      до асоційованого шаблона. Узагальнений шаблон ( _ ) також співпадає з
      кожним значенням, але він не вводить ім'я змінної, що посилається на це
      значення. Зуважте з Лістингу 15.2, як match завершується випадком по
      замовчанню, що нічого не робить в виразі. Замість цього, він повертає
      тільки expr, вираз, до якого виконане порівняння.</p>
    <p>Шаблон конструктора виглядає як UnOp("-", e) . Цей шаблон співпадає з
      типом UnOp, чий перший аргумент співпадає з "-", та чий другий аргумент
      співпадає з e. Зауважте, що аргументи конструктора також є шаблонами. Це
      дозволяє записати глибші шаблони, використовуючи стислу нотацію. Ось
      приклад:</p>
    <pre class="prettyprint linenums language-scala">UnOp("-", UnOp("-", e))</pre>
    <p>Уявіть намагання реалізувати ту ж функціональність за допомогою шаблона
      візітора! Щонайменьше це буде незграбним, якщо уявити реалізацію як довну
      послідовність тверджень if, перевірки типів, та приведення типів.</p>
    <p>Оператор match, в порівнянні зі switch виразами, можуть розглядатись як
      узагальнення switch в Java. Існуючий в Java switch може бути природно
      виражений як вираз match, де кожний шаблон є сталою, та останній шаблон
      може бути узагальненням (що представлене як default case в виразі switch
      ). Однак, є три різниці, що треба мати на увазі. Перше, match є виразом в
      Scala, тобто, це завжди завершується значенням. Друге, альтернативи-вирази
      Scala ніколи не "провалюються" на наступний case. Третє, якщо жодний з
      шаблонів не співпаде, буде підійняте MatchError. Це означає, що ви маєте
      переконатись, що всі варіанти покриті, навіть якщо це означає додання
      випадку по замовчанню, що нічого не робить. Лістинг 15.3 показує приклад.</p>
    <p>Другий випадок є необхідним в Лістингу 15.3, бо інакше вираз match буде
      викликати MatchError для кожного аргумента expr, що не є BinOp. І цьому
      прикладі для цього другого випадка не визначено ніякого кода, так що в
      цьому випадку нічого не відбувається. Результатом цього випадку є одничне
      значення ‘()’, що, таким чином, є і результатом всього виразу порівняння з
      шаблоном.</p>
    <pre class="prettyprint linenums language-scala">expr match {
  case BinOp(op, left, right) =&gt; println(expr +" is a binary operation")
  case _ =&gt;
}</pre>
    <p>Лістинг 15.3 Порівняння шаблона з пустим випадком “по замовчанню”.</p>
    <h3>15.2 Різні типи шаблонів</h3>
    <p>Попередній приклад показує декілька типів шаблонів в швидкому переліку.
      Тепер витратимо хвилину, щоб поглянути на кожний випадок.</p>
    <p>Синтаксис шаблону простий, так що дуже не хвилюйтесь. Всі шаблони
      виглядають як відповідний вираз. Наприклад, якщо ми маємо ієрархію з
      Лістингу 15.1, шаблон Var(x) співпадає з любою змінною, ща закріплює x до
      імені змінної. Якщо використати як вираз, Var(x) — точно такий синтаксис —
      відновить еквівалентний об'єкт, вважаючи, що x вже прикріплений до назви
      змінної. Оскільки синтаксис шаблонів є таким прозорим, головна річ, на що
      треба звернути увагу, це те, які взагалі шаблони є можливими.</p>
    <h4>Шаблони з узагальнюючими символами</h4>
    <p>Узагальнюючий символ підстановки ( _ ) співпадає з будь-яким об'єктом. Ви
      вже бачили, як це використовується по замовчанню, для перехоплення
      альтернативи "все інше", таким чином:</p>
    <pre class="prettyprint linenums language-scala">expr match { 
case BinOp(op, left, right) =&gt;
  println(expr +" is a binary operation")
case _ =&gt;
}</pre>
    <p>Узагальнення також можуть використовуватись в для ігнорування частини
      об'єкта, що вас не турбує. Наприклад, попередній приклад насправді не
      турбується щодо елементів бінарної операції. Він тільки перевіряє, що це
      взагалі бінарна операція. Таким чином може так само гарно використовувати
      узагальнюючий шаблон для елементів BinOp, як показано на Лістингу 15.4:</p>
    <pre class="prettyprint linenums language-scala">expr match {
case BinOp(_, _, _) =&gt; println(expr +" is a binary operation")
case _ =&gt; println("It's something else")
}</pre>
    <p>Лістинг 15.4 Порівняння шаблонів з узагальненнями.</p>
    <h4>Шаблони-константи</h4>
    <p>Константи в шаблонах співпадають тільки самі з собою. Кожний літерал може
      бути використаний як константа. Наприклад: 5, true, або "hello" всі є
      шаблонами-константами. Також кожне val або об'єкт-синглтон може
      використовуватись як константа. Наприклад, Nil, об'єкт-синглтон, є
      шаблоном, що співпадає тільки з пустим списком. Лістинг 15.5 показує деякі
      приклади шаблонів-констант:</p>
    <pre class="prettyprint linenums language-scala">def describe(x: Any) = x match {
case 5 =&gt; "five"
case true =&gt; "truth"
case "hello" =&gt; "hi!"
case Nil =&gt; "the empty list"
case _ =&gt; "something else"
}</pre>
    <p>Лістинг 15.5 Порівняння з шаблонами-константами.</p>
    <p>Ось як шаблон з Лістингу 15.5 виглядає в дії:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; describe(5)
res6: java.lang.String = five
<br>scala&gt; describe(true)
res7: java.lang.String = truth
<br>scala&gt; describe("hello")
res8: java.lang.String = hi!
<br>scala&gt; describe(Nil)
res9: java.lang.String = the empty list
<br>scala&gt; describe(List(1,2,3))
res10: java.lang.String = something else</pre>
    <h4>Шаблони-змінні</h4>
    <p>Шаблон-змінна співпадає з кожним об'єктом, так само як символ
      узагальнюючий підстановки. Відміна в тому, що Scala прикріплює змінну до
      того об'єкту, що знайде. Потім ви можете використовувати цю змінну, щоб
      вподальшому задіяти цей об'єкт. Наприклад, Лістинг 15.6 показує порівняння
      шаблонів, що має окремий випадок для нуля, та випадок по замовчанню для
      всіх інших значень. Випадок по замовчанню використовує шаблон-змінну, так
      що надає ім'я значенню, не має значення, якому.</p>
    <pre class="prettyprint linenums language-scala">expr match {
case 0 =&gt; "zero"
case somethingElse =&gt; "not zero: "+ somethingElse
}</pre>
    <p>Лістинг 15.6 Порівняння з шаблонами-змінними.</p>
    <h4>Змінна чи константа?</h4>
    <p>Шаблони-константи можуть мати символічні імена. Ви можете задати це, коли
      використовуєте Nil в якості шаблона. Ось пов'язаний з цім приклад, де
      шаблон включає константи E (2.71828. . . ) та Pi (3.14159. . . ):</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import math.{E, Pi}
import math.{E, Pi}
<br>scala&gt; E match {
case Pi =&gt; "дивне співпадіння? Pi = "+ Pi
case _ =&gt; "OK"
}
res11: java.lang.String = OK</pre>
    <p>Як і очікувалось, E не співпадає з Pi, так що випадок “дивне співпадіння”
      не використовується. Як компілятор Scala знає, що Pi є константою,
      імпортованою з scala.math, але не змінною, що не стоїть за самим значенням
      селектора? Scala використовує просте лексичне правило щодо непорозумінь:
      просте ім'я, що починається з літери нижнього реєстра, має бути
      шаблоном-змінною; всі інші посилання розглядаються як константи. Щоб
      побачити різницю, створіть псевдоним в нижньому реєстрі для pi, та
      спробуйте використати це:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val pi = math.Pi
pi: Double = 3.141592653589793
<br>scala&gt; E match {
case pi =&gt; "strange math? Pi = "+ pi
}
res12: java.lang.String = strange math? Pi =
2.718281828459045</pre>
    <p>Ось де компілятор навіть не дасть вам додати випадок по замовчанню.
      Оскільки pi є шаблоном-змінною, вона буде співпадати з будь-чим, так що
      жодний подальший випадок не буде досяжним:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; E match {
case pi =&gt; "strange math? Pi = "+ pi
case _ =&gt; "OK"
}
&lt;console&gt;:9: error: unreachable code
case _ =&gt; "OK"
ˆ</pre>
    <p>Якщо вам конце треба, ви можете застосувати константу в малому реєстрі, з
      використанням двох трюків. Перше, якщо константа є полем деякого об'єкта,
      ви можете задати його в вигляді кваліфікатора. Наприклад, pi є
      шаблоном-змінно, але this.pi або obj.pi є константами, навіть якщо вони
      вочевидь починаються з малих літер. Якщо це не спрацьовує (оскільки pi є,
      скажімо, локальною змінною), ви можете альтернативно оточити ім'я змінної
      в зворотні лапки. Наприклад, `pi` знову буде інтерпретовано як константу,
      але не змінну:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; E match {
case `pi` =&gt; "strange math? Pi = "+ pi
case _ =&gt; "OK"
}
res14: java.lang.String = OK</pre>
    <p>Як ви можете бачити, синтаксис зі зворотніми лапками для ідентифікаторів
      використовується в&nbsp; Scala для двох різних цілей: щоб допомогти вашому
      коду знайти вихід в різних скрутних становищах. Тут ви можете бачити, як
      це використовується для трактування ідентифікатора в нижньому реєстрі в
      якості константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили,
      як це також використовувалось для трактування ключового слова як
      ідентифікатора, тобто, написання Thread.`yield`()&nbsp; трактує yield як
      ідентифікатор, скорішен, ніж ключове слово.</p>
    <h4>Шаблони конструктора</h4>
    <p>Конструктори при порівнянні шаблонів стають дійсно потужними. Шаблон
      конструктора виглядає як “BinOp("+", e, Number(0)) ”. Він складається з
      імені&nbsp; (BinOp), та потім з числа шаблонів в дужках: "+", e, та
      Number(0). Якщо вважати, що ім'я показує кейс клас, в тій якості, що
      шаблон буде перевіряти як об'єкт, що є примірником кейс класа, та потім
      перевірить, що параметри конструктора об'єкта співпадуть з додатковими
      наданими шаблонами.</p>
    <p>Ці додаткові шаблони означають, що ці шаблони Scala підтримують глибокі
      порівняння. Такі шаблони не тільки порівнюють надані об'єкти вищого рівня,
      але також перевіряють об'єкти щодо подальших об'єктів. Оскільки додаткові
      шаблони можуть, в свою чергу, також бути шаблонами конструкторів, ви
      можете використовувати їх для перевірки об'єктів будь-якої глибини.
      Наприклад, шаблон, показаний В Лістингу 15.7, перевіряє, що високорівневий
      об'єкт є BinOp, що його третій параметр конструктора є Number, та що поле
      значення цього числа є 0. Цей шаблон довжиною в один рядок, але при цьому
      перевіряє на три рівні вглиб.</p>
    <pre class="prettyprint linenums language-scala">expr match {
case BinOp("+", e, Number(0)) =&gt; println("a deep match")
case _ =&gt;<br>}</pre>
    <p>Лістинг 15.7 Порівняння шаблонів з шаблоном конструктора.</p>
    <h4>Шаблони послідовностей</h4>
    <p>Ви можете порівнювати з типуми послідовностей, як List або Array, точно
      як робите це з кейс класами. Використовуйте той же синтаксис, але ви
      можете вказати довільне число елементів в шаблоні. Наприклад, Лістинг 15.8
      показує шаблон, що перевіряє список з трьох елементів, якій починається з
      нуля:</p>
    <pre class="prettyprint linenums language-scala">expr match {
case List(0, _, _) =&gt; println("found it")
case _ =&gt;
}</pre>
    <p>Лістинг 15.8 Шаблон послідовності з фіксованою довжиною.</p>
    <p>Якщо ви бажаєте порівняти з послідовністю без надання довжини, ви можете
      вказати _* в якості останнього елемента шаблона. Цей дивно виглядачий
      шаблон співпадає з будь-яким числом елементів в послідовносі, включаючи
      нуль елементів. Лістинг 15.9 показує приклад шаблона, що співпадає з любим
      списком, що починається на нуль, безвідносно до його довжини.</p>
    <pre class="prettyprint linenums language-scala">expr match {
case List(0, _*) =&gt; println("found it")
case _ =&gt;
}</pre>
    <p>Лістинг 15.9 Шаблон послідовності з довільною довжиною.</p>
    <h4>Шаблони кортежів</h4>
    <p>Ви можете також виконати порівняння з кортежем. Кортеж, як (a, b, c),
      співпадає з довільним тримісним кортежем. Приклад показаний в Лістингу
      5.10:</p>
    <pre class="prettyprint linenums language-scala">def tupleDemo(expr: Any) =
  expr match {
  case (a, b, c) =&gt; println("matched "+ a + b + c)
  case _ =&gt;
}</pre>
    <p>Лістинг 15.10 Порівняння з шаблоном кортежу.</p>
    <p>Якщо ви завантажете метод tupleDemo, показаний в Лістингу 15.10 до
      інтерпретатора, та надасте кортеж з трьома елементами, ви побачите:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; tupleDemo(("a ", 3, "-tuple"))
matched a 3-tuple</pre>
    <h4>Типізовані шаблони</h4>
    <p>Ви можете використати шаблони за типом, як зручну заміну перевірці та
      приведенню типів. Лістинг 15.11 показує приклад:</p>
    <pre class="prettyprint linenums language-scala">def generalSize(x: Any) = x match {
  case s: String =&gt; s.length
  case m: Map[_, _] =&gt; m.size
  case _ =&gt; -1
}</pre>
    <p>Лістинг 15.11 Порівняння з типізованими шаблонами.</p>
    <p>Ось деякі приклади використання метода generalSize в інтерпретаторі
      Scala:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; generalSize("abc")
res16: Int = 3
<br>scala&gt; generalSize(Map(1 -&gt; 'a', 2 -&gt; 'b'))
res17: Int = 2
<br>scala&gt; generalSize(math.Pi)
res18: Int = -1</pre>
    <p>Метод generalSize повертає розмір або довжину об'єктів різного типу. Його
      аргумент типу Any, так що може отримувати будь-яке значення. Якщо аргумент
      є String, метод повертатиме довжину рядка. Шаблон “s: String” є
      типізованим; він відповідає кожному (не-нульовому) примірнику String.
      Змінна шаблона&nbsp; s потім посилається на цей рядок.</p>
    <p>Зауважте, що навіть припускаючи, що s та x посилаються на одне значення,
      тип x є Any, але тип s є String. Таким чином ви можете записати s.length в
      альтернативному виразі, що відповідає шаблону, але ви не можете записати
      x.length, оскільки тип Any не має члена length. </p>
    <p>Еквівалентний, але більш розгорнутий спосіб досягти того ж ефекту, що і
      порівняння з типізованим шаблоном, задіє перевірку типу, за яким слідує
      приведення типу. Scala використовує інший синтаксис, ніж Java, для ціх
      цілей. Скажімо, для перевірки, чи є вираз expr типу String, ви пишете:</p>
    <pre class="prettyprint linenums language-scala">expr.isInstanceOf[String]</pre>
    <p>Щоб привести деякий вираз до типу String, ви використовуєте:</p>
    <p>expr.asInstanceOf[String]</p>
    <p>Використовуючи перевірку та приведення типу ви можете переписати перший
      case попереднього виразу match як показане в Лістингу 15.12. Оператори
      isInstanceOf та asInstanceOf розглядаються як попередньо визначені методи
      класа Any, що приймають параметр типу в прямокутних дужках.</p>
    <pre class="prettyprint linenums language-scala">if (x.isInstanceOf[String]) {
  val s = x.asInstanceOf[String]
  s.length
else ...</pre>
    <p>Лістинг 15.12 Використання isInstanceOf та asInstanceOf (дешевий стиль).</p>
    <p>Фактично, x.asInstanceOf[String] є особливим випадком виклика метода з
      явним параметром типу String.</p>
    <p>Як ви вже зазначили, написання перевірки типу та приведення (кастинг)
      типу є балакучим в Scala. Це зроблене навмисно, оскільки це не те, до чого
      вас закликають. Для вас зазвичай краще використовувати типізовані
      порівняння шаблонів. Це особливо доречно, якщо вам треба виконати
      одночасно перевірку та приведення типу, оскільки обі операції згортаються
      до одного порівняння шаблонів. Другий випадок попереднього виразу
      порівняння&nbsp; містить шаблон типу “m: Map[_, _]”. Цей шаблон співпадає
      з кожним значенням, що є Map з деяким довільним типом ключа та виразу, та
      дозволяє m посилатись на це значення. Таким чином, m.size гарно
      типізоване, та повертає розмір мапи. Підкреслення в типізованому шаблоні -
      як підкреслення в інших шаблонах. Ви також могли замість цього
      використовувати типові змінні (в нижньому реєстрі).</p>
    <h4>Очищення типів</h4>
    <p>Чи можете ви перевірити мапу з певними типуми елементів? Це було б
      зручним, скажімо, для перевірки, чи певне значення є мапою, що відзеркалює
      тип Int на тип Int. Давайте спробуємо:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def isIntIntMap(x: Any) = x match {
case m: Map[Int, Int] =&gt; true
case _ =&gt; false
}
warning: there were unchecked warnings; re-run with
-unchecked for details
isIntIntMap: (x: Any)Boolean</pre>
    <p>Інтерпретатор видає неперевірене попередження. Ви можете визначити
      подробиці, запустивши інтерпретатор знову з опцією командного рядка&nbsp;
      -unchecked:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; :quit
$ scala -unchecked
Welcome to Scala version 2.8.1
(Java HotSpot(TM) Client VM, Java 1.5.0_13).
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;
def isIntIntMap(x: Any) = x match {
case m: Map[Int, Int] =&gt; true
case _ =&gt; false
}
&lt;console&gt;:5: warning: non variable type-argument Int in
type pattern is unchecked since it is eliminated by erasure
case m: Map[Int, Int] =&gt; true
ˆ</pre>
    <p>Scala використовує модель очищення дженериків, так само як це робить
      Java. Це означає, що під час виконання ніякої інформації щодо типів
      аргументів не підтримуються. Відповідно, немає можливості визначити під
      час виконання, чи окремий об'єкт Map був створений з двома аргументами
      Int, або з двома аргументами інших типів. Все, що може визначити система,
      це що значення є Map довільними типуми параметрів. Ви можете перевірити ц.
      поведінку, застосувавши isIntIntMap до аргументів інших примірників класа
      Map:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; isIntIntMap(Map(1 -&gt; 1))
res19: Boolean = true
<br>scala&gt; isIntIntMap(Map("abc" -&gt; "abc"))
res20: Boolean = true</pre>
    <p>Перше застосування повертає true, що виглядає коректним, але друге
      застосування також повертає true, що може здивувати. Щоб попередити вас
      щодо, можливо, неінтуітивної поведінки під час виконання, компілятор видає
      попередження unchecked, як ви бачили вище.</p>
    <p>Одним виключення до правила очищення є масиви, оскільки вони обробляються
      особливим чином в Java, і так само в Scala. Тип елемента масива
      зберігається як частина об'єкта масива, так що ви можете виконувати
      порівняння шаблонів до нього. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def isStringArray(x: Any) = x match {
case a: Array[String] =&gt; "yes"
case _ =&gt; "no"
}
isStringArray: (x: Any)java.lang.String
<br>scala&gt; val as = Array("abc")
as: Array[java.lang.String] = Array(abc)
<br>scala&gt; isStringArray(as)
res21: java.lang.String = yes
<br>scala&gt; val ai = Array(1, 2, 3)
ai: Array[Int] = Array(1, 2, 3)
<br>scala&gt; isStringArray(ai)
res22: java.lang.String = no</pre>
    <h4>Закріплення змінних</h4>
    <p>На додаток до окремих шаблонів зі змінними, ви також можете додати змінні
      до кожного іншого шаблона. Ви просто пишете ім'я змінної, знак @, та потім
      шаблон. Це дає вам шаблон з закріпленням до змінної. Значення такого
      шаблона є виконати перевірку шаблона, та якщо співпадіння буде вдачним,
      встановити змінну до співпавшого об'єкта, так само, як за простого
      співпадіння змінної.</p>
    <p>Як пирклад, Лістинг 15.13 показує співпадіння шаблона, що виглядає
      як&nbsp; абсолютна операція зі значенням, що задіяна двічі поспіль. Такий
      вираз може бути спрощений щоб мати тільки одне абсолютне значення кожного
      разу.</p>
    <pre class="prettyprint linenums language-scala">expr match {
&nbsp; case UnOp("abs", e @ UnOp("abs", _)) =&gt; e
&nbsp; case _ =&gt;
}</pre>
    <p>Лістинг 15.13 Шаблон з прив'язкою до змінної (через @).</p>
    <p>В Лістингу 15.13 є шаблон з прив'язкою змінної e, та шаблон UnOp("abs",
      _). Якщо співпадіння цілого шаблона буде успішним, тоді частина, що
      співпаде з частиною UnOp("abs", _) буде доступною через змінну e. Як
      записаний цей код, e буде повернена як є .</p>
    <h4>15.3 Вартівник шаблону</h4>
    <p>Іноді синтаксичне порівняння шаблонів не є досить точним. Наприклад,
      скажімо, ви отримали завдання сформулювати правило спрощення, що замінює
      вирази суми на два ідентичні операнди, як&nbsp; e + e, на множення на
      двійку, як e * 2 . В мові дерев Expr вираз як:</p>
    <pre class="prettyprint linenums language-scala">BinOp("+", Var("x"), Var("x"))</pre>
    <p>завдяки цьому правилу перетвориться на:</p>
    <pre class="prettyprint linenums language-scala">BinOp("*", Var("x"), Number(2))</pre>
    <p>Ви можете спробувати визначити це правило таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, x) =&gt; BinOp("*", x, Number(2))
  case _ =&gt; e
}
&lt;console&gt;:11: error: x is already defined as value x
case BinOp("+", x, x) =&gt; BinOp("*", x, Number(2))
ˆ</pre>
    <p>Це не дає результату, оскільки Scala обмежує шаблони до лінійних: змінна
      шаблона може потрапити в шаблон тільки один раз. Однак ви можете
      переформулювати match за допомогою вартівника шаблона, як показано на
      Лістингу 15.14:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, y) if x == y =&gt;
    BinOp("*", x, Number(2))
  case _ =&gt; e
}simplifyAdd: (e: Expr)Expr</pre>
    <p>Лістинг 15.14 Вираз match з вартівником шаблона.</p>
    <p>Вартівник шаблона іде після шаблона, та починається з if. Вартівник може
      бути довільним логічним виразом, що типово посилається на змінні в
      шаблоні. Якщо вартівник присутній, порівняння буде вдалим, тільки якщо
      вартівник обчислюється до true. Таким чином, перший випадок вище буде
      співпадати з бінарними операціями з двома однаковими операндами.</p>
    <p>Деякі інші приклади шаблонів з вартівником:</p>
    <pre class="prettyprint linenums language-scala">// співпадає тільки з додатними цілими
case n: Int if 0 &lt; n =&gt; ...
<br>// співпадає тільки з рядками, що починаються на літеру ‘a’
case s: String if s(0) == 'a' =&gt; ...</pre>
    <h3>15.4 Перекриття шаблонів</h3>
    <p>Шаблони випробовуються в тому порядку, в якому записані. Версія
      спрощення, показана в Лістингу 15.15, презентує приклад, коли порядок
      випадків має значення:</p>
    <pre class="prettyprint linenums language-scala">def simplifyAll(expr: Expr): Expr = expr match {
<br>  case UnOp("-", UnOp("-", e)) =&gt; simplifyAll(e)
// ‘-’ інвертує значення
<br>  case BinOp("+", e, Number(0)) =&gt; simplifyAll(e)
// ‘0’ є нейтральним елементом для ‘+’
<br>  case BinOp("*", e, Number(1)) =&gt; simplifyAll(e)
// ‘1’ є нейтральним елементом для ‘*’
<br>  case UnOp(op, e) =&gt; UnOp(op, simplifyAll(e))
<br>  case BinOp(op, l, r) =&gt; BinOp(op, simplifyAll(l), simplifyAll(r))
  <br>  case _ =&gt; expr
}</pre>
    <p>Лістинг 15.15 Вираз порівняння, де порядок має значення.</p>
    <p>Версія спрощення, показана в Лістингу 15.15 буде стосуватись правил
      спрощення будь-де в виразі, не тільки нагорі, як робив simplifyTop. Він
      може походити від simplifyTop додаванням двох випадків для загальних
      унарних та бінарних виразів (чипадки чотири та п'ять в Лістингу 15.15).
      Четвертий випадок має шаблон UnOp(op, e); тобто, він співпадає з любою
      унарною операцією. Оператор та операнд унарної операції можуть бути
      довільними. Вони прив'язані до змінних шаблона op та e, відповідно.
      Альтернатива в цьому випадку стосується simplifyAll рекурсивно до операнда
      e, та потім перебудовує ту ж унарну операцію з (можливо) спрощеним
      операндом.</p>
    <p>П'ятий випадок для BinOp є аналогічним: це випадок “всі-інші” для
      довільних бінарних операцій, що рекурсивно застосовує метод спрощення до
      двох операндів.</p>
    <p>В цьому прикладі важливо, що випадки всі-інші ідуть після більш
      специфічних правил спрощення. Якщо ви напишете іх в іншому порядку, тоді
      випадки всі-інші будуть мати перевагу над більш специфічними випадками. В
      багатьох випадках компілятор буде скаржитись за такої спроби.</p>
    <p>Наприклад, ось вираз порівняння, що не буде компілюватись, оскікльи
      перший випадок буде співпадати з усім, що могло б співпасти з другим
      випадком:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def simplifyBad(expr: Expr): Expr = expr match {
  case UnOp(op, e) =&gt; UnOp(op, simplifyBad(e))
  case UnOp("-", UnOp("-", e)) =&gt; e
}
&lt;console&gt;:18: error: unreachable code
case UnOp("-", UnOp("-", e)) =&gt; e
ˆ</pre>
    <h3>15.5 Запечатані класи</h3>
    <p>Коли ви пишете порівняння шаблонів, вам треба переконатись, що ви накрили
      всі можливі випадки. Іноді ви можете зробити це, додавши випадок по
      замовчанню в кінці&nbsp;match, але це стосується тільки якщо є змістовна
      поведінка по замовчанню. Що, коли немає нічого по замовчанню? Як ви можете
      почуватись в безпеці щодо того, що накрили всі випадки?</p>
    <p>Фактично, ви можете залучитись допомогою компілятора Scala в визначенні
      пропущених комбінацій шаблонів в виразі match. Щоб мати змогу зробити це,
      компілятор потребує бути в змозі сказати, які випадки є можливими.
      Загалом, це неможливо в Scala, оскільки нові кейс класи можуть бути
      визначені будь-коли, в довільних одиницях компіляції. Наприклад, нічого не
      заважає вам додати п'ятий кейс клас до ієрархії класа Expr в іншій одиниці
      компіляції, ніж визначені інші чотири випадки.&nbsp;</p>
    <p>Альтернативою є зробити суперклас ваших кейс класів запечатаним.
      Запечатаний клас не може додати жодних субкласів, за винятком тих, що
      знаходятся в тому ж файлі. Це дуже корисно для порівняння шаблонів,
      оскільки це означає, що вам треба турбуватись щодо субкласів, про які ви
      вже знаєте. Що ще більше, ви також отримуєте кращу підтримку компілятора.
      Якщо ви порівнюєте з кейс класами, що наслідують від запечатаного класа,
      компілятор буде відмічати втрачені комбінації шаблонів повідомленнями
      попереджень.</p>
    <p>Таким чином, якщо ви пишете ієрархію класів, призначену бути шаблонами
      для порівняння, вам слід розглянути можливість зробити їх запечатаними.
      Просто додайте ключове слово sealed перед class нагорі ієрархії.
      Програмісти, що будуть використовувати вашу ієрархію класів, будуть
      відчувати зручність при порівнянні за їх участю. Ключове слово sealed,
      таким чином, часто є ліцензією на порівняння з шаблонами. Лістинг 15.16
      показує приклад, в якому Expr перетврений на запечатаний клас.</p>
    <pre class="prettyprint linenums language-scala">sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
  left: Expr, right: Expr) extends Expr</pre>
    <p>Лістинг 15.16 Запечатана ієрархія кейс класів.</p>
    <p>Тепер визначимо порівняння шаблонів, де пропущені деякі з кейс класів:</p>
    <pre class="prettyprint linenums language-scala">def describe(e: Expr): String = e match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
}</pre>
    <p>Ви можете отримати попередження компілятора, подібне до наступного:</p>
    <pre class="prettyprint linenums language-scala">warning: match is not exhaustive!
missing combination UnOp
missing combination BinOp</pre>
    <p>Таке повідомленя каже вам, що існує ризик, що ваш код може спродукувати
      виключення MatchError, оскількі деякі можливі шаблони ( UnOp, BinOp) не
      оброблени. Попередження вказує на потенційне джерело збоїв часу виконання,
      так ща, зазвичай, так що ви запрошені допомогти вашій програмі. Однак,
      часом ви можете натрапити на ситуацію, коли компілятор дуже прискіпливий,
      щодо надання попередження. Наприклад, ви можете знати з контекста, що ви
      напевне застосували метод describe вище для виразів, що не Number, ні Var.
      Так що ви знаєте, що, фактично, не буде спродуковано MatchError. Щоб
      попередження пішло, ви можете додати третій випадок все-інше до метода,
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">def describe(e: Expr): String = e match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
  case _ =&gt; throw new RuntimeException // не повинно відбутись
}</pre>
    <p>Це робить, але не є ідеальним. Можливо, ви будете не дуже щастливим від
      того, що змушені додавати код, що ніколи не буде виконаний (або ви так
      вважаєте), тільки для того, щоб примовчати компілятор.</p>
    <p>Більш легковісна альтернатива є додати&nbsp; анотацію @unchecked до
      вираза селектора для match. Це робиться таким чином:</p>
    <pre class="prettyprint linenums language-scala">def describe(e: Expr): String = (e: @unchecked) match {
  case Number(_) =&gt; "число"
  case Var(_) =&gt; "змінна"
}</pre>
    <p>Анотації описані в Главі 27. Загалом, ви можете додати анотацію до виразу
      в той же спосіб, що ви додаєте тип: після виразу вкажіть дві крапки,
      заверште вираз іменем анотації (зі знаком @ спереду). Наприклад, в цьому
      випадку ви додаєте анотацію @unchecked&nbsp; до змінної e, за допомогою
      “e: @unchecked”. Анотація @unchecked має особливе значення для порівняння
      шаблонів. Якщо вираз селектора має цю анотацію, перевірка на вичерпність
      шаблонів, що слідують за анотацією, буде пригнічено.</p>
    <h3>15.6 Тип Option</h3>
    <p>Scala має стандартний тип з назвою Option для опціональних значень. Таке
      значення може мати дві форми.&nbsp; Це може бути в формі Some(x), де x є
      справжнім значенням. Або це може бути об'єкт None, що представляє відсутнє
      значення.</p>
    <p>Опціональні значення продукуються деякими стандартними операціями на <br>
      Scala колекціях. Наприклад, метод get в Scala Map продукує Some(value),
      якщо значення, відповідне до наданого ключа, було знайдене, або None, якщо
      даний ключ не визначений в Map. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val capitals =
  Map("France" -&gt; "Paris", "Japan" -&gt; "Tokyo")
  capitals: scala.collection.immutable.Map[java.lang.String,
  java.lang.String] = Map(France -&gt; Paris, Japan -&gt; Tokyo)
<br>scala&gt; capitals get "France"
res23: Option[java.lang.String] = Some(Paris)
<br>scala&gt; capitals get "North Pole"
res24: Option[java.lang.String] = None</pre>
    <p>Найбільш загальний спосіб сприймати опціональні значення нарізно є
      порівняння шаблонів. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def show(x: Option[String]) = x match {
  case Some(s) =&gt; s
  case None =&gt; "?"
}
show: (x: Option[String])String
<br>scala&gt; show(capitals get "Japan")
res25: String = Tokyo
<br>scala&gt; show(capitals get "France")
res26: String = Paris
<br>scala&gt; show(capitals get "North Pole")
res27: String = ?</pre>
    <p>Тип Option часто використовується в Scala програмах. Порівняйте це з
      домінуючою ідіомою в Java використовувати null, щоб вказати відсутність
      значення. Наприклад, метод get з java.util.HashMap повертає або значення,
      що зберігаєтсья в HashMap, або null, якщо значення не знайдене. Цей підхід
      робить для Java, але схильний до помилок, оскільки на практиці складно
      відсліджувати, якім змінним в програмі дозволено бути null. Якщо змінній
      дозволено бути null, тоді ви маєте пам'ятати перевіряти її на null кожного
      разу, коли використовуєте її. Коли ви забудете перевірити, ви відкриваєте
      можливість того, що під час виконання все може завершиться
      NullPointerException. Оскільки такі виключення можуть не траплятись часто,
      може бути складно винайти помилку на протязі тестування. Для Scala цей
      підхід зовсім не буде робити, оскільки можливо зберігати типи значення в
      хеш мапах, але null не є легальним елементом для типу значення. Наприклад,
      HashMap[Int, Int] не може повертати щоб позначити відсутність елемента.</p>
    <p>На відміну, Scala заохочує використання Option, щоб вказати опціональне
      значення. Цей підхід опціональних значень має декілька переваг над Java.</p>
    <p>Перше, є значно більш очевидним для читачів кода, що змінна, чий тип є
      Option[String] є опціональним рядком String, ніж змінна типу String, що
      іноді може бути null. Але більш важливо, що помилка програмування, описана
      вище з використанням змінної, що може бути null, якщо перед цім не
      перевірити її на null, стає в Scala помилкою типу. Якщо змінна є типу
      Option[String], та ви намагаєтесь використовувати її як String, ваша Scala
      програма не буде компілюватись.</p>
    <h3>15.7 Шаблони скрізь</h3>
    <p>Шаблони дозволяються в багатьох частинах Scala, не тільки як окремі&nbsp;
      вирази match. Подивіться на деякі інші місця, де ви можете використовувати
      шаблони.</p>
    <h4>Шаблони в визначенні змінних</h4>
    <p>Кожного разу, коли ви визначаєте val або var, ви можете використовувати
      шаблон замість простого ідентифікатора. Наприклад, ви можете зробити це,
      щоб розбити на частини кортеж, та присвоїти кожну частину окремій змінній,
      як показано в Лістингу 15.17:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val myTuple = (123, "abc")
myTuple: (Int, java.lang.String) = (123,abc)
<br>scala&gt; val (number, string) = myTuple
number: Int = 123
string: java.lang.String = abc</pre>
    <p>Лістинг 15.17 Визначення декількох змінних за допомогою одного
      присвоєння.</p>
    <p>Ця конструкція досити корисна при роботі з кейс класами. Якщо ви знаєте
      точний кейс клас, з яким ви працюєте, тоді ви можете деконструювати його
      за допомогою шаблона. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val exp = new BinOp("*", Number(5), Number(1))
exp: BinOp = BinOp(*,Number(5.0),Number(1.0))
<br>scala&gt; val BinOp(op, left, right) = exp
op: String = *
left: Expr = Number(5.0)
right: Expr = Number(1.0)</pre>
    <h4>Case послідовності як часткові функції</h4>
    <p>Послідовність випадків (альтернатив) в фігурних дужках можуть бути
      використані будь-де, де може бути використаний функціональний літерал.
      Загалом кажучи, послідовність case є функціональним літералом, але більш
      загальним. Замість мати одну точку входу, та перелік параметрів,
      послідовність case має декілька точок входу, кожний з власним переліком
      параметрів. Кожний case є точкою входу до функції, та параметри вказуються
      за допопмогою шаблона. Тіло кожної точки входа є правою частиною case.</p>
    <p>Ось простий приклад:</p>
    <pre class="prettyprint linenums language-scala">val withDefault: Option[Int] =&gt; Int = {
  case Some(x) =&gt; x
  case None =&gt; 0
}</pre>
    <p>Тіло цієї функції має два випадки. Перший випадок співпадає з Some, та
      повертає число в Some. Другий випадок співпадає з None, та повертає число
      по замовчанню, нуль. Ось як використовувати цю функцію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; withDefault(Some(10))
res28: Int = 10
<br>scala&gt; withDefault(None)
res29: Int = 0</pre>
    <p>Ця можливість досить корисна для акторської бібліотеки, описаної с Главі
      32. Ось деякий типовий код актора. Він передає порівняння шаблона напряму
      до метода react:</p>
    <pre class="prettyprint linenums language-scala">react {
  case (name: String, actor: Actor) =&gt; {
    actor ! getip(name)
    act()
  } 
  case msg =&gt; {
    println("Unhandled message: "+ msg)
    act()
  }
}</pre>
    <p>Одне інше узагальнення: послідовність case дає вам часткову фукцію. Якщо
      ви застосуєте таку функцію на значенні, яке вона не підтримує, вона
      згенерує виключення часу виконання. Наприклад, ось часткова функція, що
      повертає другий елемент зі списку цілих:</p>
    <pre class="prettyprint linenums language-scala">val second: List[Int] =&gt; Int = {
  case x :: y :: _ =&gt; y
}</pre>
    <p>Коли ви це скомпілюєте, компілятор буде коректно скаржитись, що
      порівняння не є вичерпним:</p>
    <pre class="prettyprint linenums language-scala">&lt;console&gt;:17: warning: match is not exhaustive!
missing combination
Nil</pre>
    <p>Ця функція буде успішною, якщо ви передасте їй список з трьох елементів,
      але ні, якщо це буде пустий список:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; second(List(5, 6, 7))
res24: Int = 6
<br>scala&gt; second(List())
scala.MatchError: List()
at $anonfun$1.apply(&lt;console&gt;:17)
at $anonfun$1.apply(&lt;console&gt;:17)</pre>
    <p>Якщо ви бажаєте перевірити, чи часткова функція є визначеною, ви маєте
      спочатку сказати компілятору, що ви знаєте, що робите з частковими
      функціями. Тип List[Int] =&gt; Int включає всі функції, що відзеркалюють
      список цілих на ціле, безвідносно, чи є ці функції частковими. Тип, що
      включає тільки часткові функції зі списків на цілі записуються
      PartialFunction[List[Int],Int]. Ось знову друга функція, на цей раз
      записана за допомогою типу з частковою функцією:</p>
    <pre class="prettyprint linenums language-scala">val second: PartialFunction[List[Int],Int] = {
  case x :: y :: _ =&gt; y
}</pre>
    <p>Часткові функції мають метод isDefinedAt, що може бути використаний для
      перевірки, чи функція визначена в окремому значенні. В цьому випадку,
      функція визначена для любих списків, що має щонайменьше два елементи:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; second.isDefinedAt(List(5,6,7))
res30: Boolean = true
<br>scala&gt; second.isDefinedAt(List())
res31: Boolean = false</pre>
    <p>Типовий приклад часткової функції є функціональний літерал співпадіння
      шаблонів, такий, як в попередньому прикладі. Фактично, такий вираз
      транслюється компілятором Scala до часткової функції, транслюючи шаблони
      двічі — один раз для реалізації дійсної функції, та ще раз для перевірки,
      чи функція визначена, чи ні. Наприклад, функціональний літерал { case x ::
      y :: _ =&gt; y } вище транслюється до наступного значення часткової
      функції:</p>
    <pre class="prettyprint linenums language-scala">new PartialFunction[List[Int], Int] {
  def apply(xs: List[Int]) = xs match {
    case x :: y :: _ =&gt; y
  }
  def isDefinedAt(xs: List[Int]) = xs match {
    case x :: y :: _ =&gt; true
    case _ =&gt; false
  }
}</pre>
    <p>Ця трансляція має ефект, коли декларований тип функціонального літерала є
      PartialFunction. Якщо декларований тип є тільки Function1, або відсутній,
      функціональний літерал замість цього транслюється до повної функції.</p>
    <p>Загалом, вам слідує спробувати робити з повними функціями буде-де, де це
      можливо, оскільки використання часткових функцій відкриває можливість
      помилок часу виконання, з якими компілятор не може вам допомогти. Однак
      іноді часткові функції дійсно корисні. Ви можете переконатись, що
      необроблене значення ніколи не буде надане. Альтернативно, ви можете
      використовувати фреймворк, що очікує часткові функції, так що буде завжди
      перевіряти isDefinedAt перед викликом функції. Приклад останнього є
      наданий вище приклад react, де аргумент є частково визначеною функцією,
      визначеною точно для тих повідомлень, що бажає обробити викликач. </p>
    <h4>Шаблони в виразах for</h4>
    <p>Ви також можете використовувати шаблон в виразах for, як показане в
      Лістингу 15.18. Цей вираз повертає всі пари ключ/значення з мапи capitals.
      Кожна пара співпадає з заблоном (country, city), що визначає дві
      змінні,&nbsp; country та city.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; for ((country, city) &lt;- capitals)
println("The capital of "+ country +" is "+ city)
<br>The capital of France is Paris
The capital of Japan is Tokyo</pre>
    <p>Лістинг 15.18 Вираз for з шаблоном-кортежем.</p>
    <p>Парний шаблон, показаний на Лістингу 15.18 був особливим, бо паравірко з
      ним ніколи не схибить. Замість цього, capitals отримує послідовність пар,
      так що ви можете бути певні, що кожна згенерована пара може бути порівняна
      з парним шаблоном. Але так сама можливо, що шаблон може не співпасти зі
      згенерованим значенням.</p>
    <p>Лістинг 15.19 показує приклад, де саме це має місце:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val results = List(Some("apple"), None,
  Some("orange"))
results: List[Option[java.lang.String]] = List(Some(apple),
  None, Some(orange))
<br>scala&gt; for (Some(fruit) &lt;- results) println(fruit)
apple
orange</pre>
    <p>Лістинг 15.19 Вибірка елементів зі списка, що співпадають з шаблоном.</p>
    <p>Як ви можете бачити з цього приклада, згенеровані значення, що не
      співпадають з шаблоном, відкидаються. Наприклад, другий елемент None в
      списку results не співпадає з шаблоном Some(fruit); таким чином, він не
      показаний в результаті.</p>
    <h4>Більший приклад</h4>
    <p>Після того, як ви навчились різних формам шаблонів, ви можете бути
      зацікавлені в їх застосуванні в більшому прикладі. Запропоноване завдання
      є написати клас-форматувальник виразів, що відображуєарифметичний вираз в
      двовимірному розташуванні. Діленя, як “x/(x + 1)” повинне бути
      роздруковане вертикально, розміщуючи чисельник над знайменником, десь так:</p>
    <pre class="prettyprint linenums language-scala">               x<br>             -----<br>             x + 1</pre>
    <p>Як інший приклад, ось вираз ((a / (b * c) + 1 / n) / 3) в двовимірному
      форматі:</p>
    <pre class="prettyprint linenums language-scala">            a     1  
          ----- + -
          b * c   n
          ---------
              3</pre>
    <p>З ціх прикладів виглядає, що клас (нехай назвемо його ExprFormatter) буде
      в значній мірі жонглювати розташуванням, так що має сенс задіяти
      бібліотеку розміщення, розроблену в Главі 10. Ми також використаємо родину
      кейс класів Expr, що ви попередньо бачили в цій главі, та покладемо обоє,
      бібліотеку розташування з Глави 10, та форматувальник виразів з цієї, до
      одного іменованого пакунка.&nbsp;</p>
    <p>Повний код для цього приклада буде показаний в Лістингу 15.20 та 15.21.
      Корисний перший крок є концентрація на горизонтальному розташуванні.
      Структурований вираз, як:</p>
    <pre class="prettyprint linenums language-scala">BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
    Var("z")),
  Number(1))</pre>
    <p>має друкуватись як (x + y) * z + 1. Зауважте, що дужки є обов'язковими
      довкола x + y, але можуть бути опціональні довкола (x + y) * z . Щоб
      утримувати розташування виразними, вашою ціллю буде уникати дужок там, де
      вони надлишкові, при цьому переконавшись, що всі необхідні дужки присутні.</p>
    <p>Щоб знати, де ставити дужки, код має знати щодо відносних преоритетів
      кожного рператора, так що є гарною ідеєю приладнати спочатку це. Ви можете
      виразити відносні преоритети напряму як мапу-літерал в наступній формі:</p>
    <pre class="prettyprint linenums language-scala">Map(
  "|" -&gt; 0, "||" -&gt; 0,
  "&amp;" -&gt; 1, "&amp;&amp;" -&gt; 1, ...
)</pre>
    <p>Однак, це може включати деяке перед-обчислення ціх преоритетів з вашого
      боку. Більш зручний підхід є просто визначити групи операторів по
      наростанню преоритетів, та потім обчислити преоритет оператора на цій
      основі. Лістинг 15.20 показує код.</p>
    <p>Змінна precedence є мапою з операторів до їх преоритетів, що є цілими від
      0. Він обчислюється з використанням виразу for. Перший генератор продукує
      кожний індекс i масива opGroups. Другий генератор продукує кожний оператор
      op в opGroups(i). Для кожного такого оператора вираз for дає асоціацію
      оператора op на його індекс i. Таким чином, відносна позиція оператора в
      масиві сприймається як його преоритет. Асоціації записані в вигляді
      інфіксної стрілки, тобто, op -&gt; i. До тепер ви бачили асоціації тільки
      як частину конструкцій мап, але вони можуть використовуватись і самі по
      собі. Фактично, асоціація op -&gt; i є нічим іншим, ніж пара (op, i).</p>
    <p>Тепер, коли ми зафіксували преоритети всіх двомісних операторів, крім /,<br>
      має сенс узагальнити цю концепцію, і також захопити одномісні оператори.
      Преоритет унарних операторів вищий, ніж преоритет кожного з двомісних
      операторів. Таким чином ми можемо встановити unaryPrecedence (показаний в
      Лістингу 15.20) в довжину масива opGroups, що на один більше, ніж
      преоритет операторів * та %.</p>
    <p>Преоритет дробу трактується інакше, ніж інших операторів, бо дріб
      використовує вертикальне розташування. Однак буде зручним присвоїти
      оператору ділення спеціальне значення преоритета, -1, так що ми
      ініціалізуємо fractionPrecedence до -1 (показано в Лістингу 15.20). Після
      ціх операцій ви готові записати головний метод форматування. Цей метод
      приймає два аргументи: вираз e, типу Expr, та преоритет оператора
      enclPrec,&nbsp; що напряму оточує вираз e (якщо немає оточующого
      оператора, enclPrec повинне бути нулем). Метод дає елемент розташування,
      що представляє двовимірний масив символів.</p>
    <pre class="prettyprint linenums language-scala">package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem
<br>sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
<br>class ExprFormatter {
<br>// Містить оператори в групах з наростаючим рейтингом
  private val opGroups =
   Array(
     Set("|", "||"),
     Set("&amp;", "&amp;&amp;"),
     Set("ˆ"),
     Set("==", "!="),
     Set("&lt;", "&lt;=", "&gt;", "&gt;="),
     Set("+", "-"),
     Set("*", " % ")
  )
<br>// Відображення операторів на їх преоритети
  private val precedence = {
    val assocs =
    for {
      i &lt;- 0 until opGroups.length
      op &lt;- opGroups(i)
    } yield op -&gt; i
    assocs.toMap
  }
<br>  private val unaryPrecedence = opGroups.length
  private val fractionPrecedence = -1
<br>  private def format(e: Expr, enclPrec: Int): Element =
    e match {
      case Var(name) =&gt;
        elem(name)
      case Number(num) =&gt;
        def stripDot(s: String) =
          if (s endsWith ".0") s.substring(0, s.length - 2)
          else s
          elem(stripDot(num.toString))
      case UnOp(op, arg) =&gt;
        elem(op) beside format(arg, unaryPrecedence)
      case BinOp("/", left, right) =&gt;
        val top = format(left, fractionPrecedence)
        val bot = format(right, fractionPrecedence)
        val line = elem('-', top.width max bot.width, 1)
        val frac = top above line above bot
        if (enclPrec != fractionPrecedence) frac
        else elem(" ") beside frac beside elem(" ")
      case BinOp(op, left, right) =&gt;
        val opPrec = precedence(op)
        val l = format(left, opPrec)
        val r = format(right, opPrec + 1)
        val oper = l beside elem(" "+ op +" ") beside r
        if (enclPrec &lt;= opPrec) oper
        else elem("(") beside oper beside elem(")")
    }
  def format(e: Expr): Element = format(e, 0)
}</pre>
    <p>Лістинг 15.21 Нижня частина форматувальника виразів.</p>
    <p>Лістинг 15.21 наприкінці показує частину класа ExprFormatter, що включає
      три методи. Перший метод, stripDot, є допомоіжним. Наступний метод,
      приватний метод format, робить більшість роботи по форматуванню виразів. В
      останньому методі, також з назвою format, є єдиний публічний метод в
      бібліотеці, що приймає вираз для форматування. </p>
    <p>Приватний метод format робить свою роботу, виконуючи перевірку шаблона на
      типі виразу. Вираз match має три випадки. Ми обсудимо їх індивідуально. </p>
    <p>Перший випадок такий:</p>
    <pre class="prettyprint linenums language-scala">case Var(name) =&gt;
  elem(name)</pre>
    <p>Якщо вираз є змінною, результатом буде елемент, сформований з імені
      змінної. </p>
    <p>Другий випадок такий:</p>
    <pre class="prettyprint linenums language-scala">case Number(num) =&gt;
  def stripDot(s: String) =
    if (s endsWith ".0") s.substring(0, s.length - 2)
    else s
  elem(stripDot(num.toString))</pre>
    <p>Якщо вираз є число, то результат є елемент, сформований зі значення
      числа. Функція stripDot прояснює відображення числа з плаваючою крапкою,
      відкидаючи любі суфікси ".0" з рядка. </p>
    <p>Третій випадок такий:</p>
    <pre class="prettyprint linenums language-scala">case UnOp(op, arg) =&gt;
  elem(op) beside format(arg, unaryPrecedence)</pre>
    <p>Якщо вираз є унарною операцією UnOp(op, arg), результат формується з
      операції op, та результата форматування аргумента arg, з найвищим-можливим
      преоритетом оточення. Це означає, що якщо arg є двомісним оператором (але
      не діленням), він завжди буде показаний в лапках.</p>
    <p>Четвертий випадок:</p>
    <pre class="prettyprint linenums language-scala">case BinOp("/", left, right) =&gt;
  val top = format(left, fractionPrecedence)
  val bot = format(right, fractionPrecedence)
  val line = elem('-', top.width max bot.width, 1)
  val frac = top above line above bot
  if (enclPrec != fractionPrecedence) frac
  else elem(" ") beside frac beside elem(" ")</pre>
    <p>Якщо вираз є діленням, формуєтья проміжний результат frac, шляхом
      покладання операндів зліва та зправа один над одним, розділених елементом
      горизонтальної лінії. Ширина горизонтальної лінії є максимумом з довжин
      форматованих операндів. Цей проміжний результат також є фінальним, тільки
      якщо саме ділення не з'являється як аргумент іншого ділення. В останньому
      випадку додається проміжок з кожного боку від frac.</p>
    <p>Щоб побачити, чому так, розглянемо вираз “(a / b) / c”. Без корекцій
      розширення форматування цього виразу дасть таке:</p>
    <pre class="prettyprint linenums language-scala">          a
          -
          b
          -
          c</pre>
    <p>Проблема з цім розташуванням очевидна — не зрозуміло, де риска ділення
      вищого рівня. Враз вище може значити або “(a / b) / c”, або “a / (b / c)”.
      Щоб вирішити неоднозначність, повинно додати проміжок з кожного боку
      розташування вкладеного ділення “a / b”. Тоді розташування стає
      однозначним:</p>
    <pre class="prettyprint linenums language-scala">          a
          -
          b
         ---
          c</pre>
    <p>П'ятий, та останній, випадок:</p>
    <pre class="prettyprint linenums language-scala">case BinOp(op, left, right) =&gt;
  val opPrec = precedence(op)
  val l = format(left, opPrec)
  val r = format(right, opPrec + 1)
  val oper = l beside elem(" "+ op +" ") beside r
  if (enclPrec &lt;= opPrec) oper
  else elem("(") beside oper beside elem(")")</pre>
    <p>Цей випадок стосується всіх двомісних операцій. Оскільки це іде за case,
      що починається з:</p>
    <pre class="prettyprint linenums language-scala">case BinOp("/", left, right) =&gt; ...</pre>
    <p>ви знаєте, що оператор op в шаблоні BinOp(op, left, right) не може бути
      діленням. Щоб форматувати таку операцію, спершу треба відформатувати її
      операнди зліва та зправа. Параметр переваги для форматування лівого
      операнда є opPrec оператора op, тоді як для правого це дещо більше. Ця
      схема запевняє, що дужки також відзеркалюють коректну асоциативність.
      Наприклад, операція:</p>
    <pre class="prettyprint linenums language-scala">BinOp("-", Var("a"), BinOp("-", Var("b"), Var("c")))</pre>
    <p>буде коректно заточена в дужки як “a - (b - c)”. Потім формується
      проміжний результат oper, шляхом розміщення поряд форматованих правого та
      лівого операнда, розділених оператором. Якщо преоритет поточного оператора
      менший, ніж преоритет оточующого оператора, r покладається в дужки, інакше
      він повертається як є.</p>
    <pre class="prettyprint linenums language-scala">import org.stairwaybook.expr._
<br>object Express extends Application {
  val f = new ExprFormatter
  val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),
  <br>  BinOp("+", Var("x"), Number(1)))
  val e2 = BinOp("+", BinOp("/", Var("x"), Number(2)),
  <br>  BinOp("/", Number(1.5), Var("x")))
  val e3 = BinOp("/", e1, e2)
  <br>  def show(e: Expr) = println(f.format(e)+ "\n\n")
  <br>  for (e &lt;- Array(e1, e2, e3)) show(e)
}</pre>
    <p>Лістинг 15.22 Застосування, що друкує форматовані вирази.</p>
    <p>Це завершує розробку приватної функції форматування. Єдиний метод, що
      залишився, є публічний метод format, що дозволяє програміста клієнтів
      форматувати вирази вищого рівня без надання аргумента precedence. Лістинг
      15.22 показує демо програму, що тренує ExprFormatter.</p>
    <p>Зауважте, що, хоча ця програма не визначає метод main, це все ж таки є
      застосуванням, оскільки він наслідує від трейта Application. Як
      зазначалось в Розділі 4.5, трейт Application просто визначає пустий метод
      main, що був унаслідуваний об'єктом Express. Справжня робота в об'єкті
      Express робиться як частина ініціалізації об'єкта, перед тим, як
      виконається метод main. Ось чому ви можете застосувати цей трюк тільки
      якщо ваша програма не сприяє жодних аргументів командного рядка. Як тільки
      з'явились аргументи, вам треба писати метод main явно. Ви можете запустити
      програму Express такою командою:</p>
    <pre class="prettyprint linenums language-scala">scala Express</pre>
    <p>Це дасть такий результат:</p>
    <pre class="prettyprint linenums language-scala">            1
            - * (x + 1)
            2<br><br>            x   1.5
            - + ---
            2    x

            1
            - * (x + 1)
            2
            -----------
              x   1.5
              - + ---
              2    x

</pre>
    <h3>15.9 Висновок</h3>
    <p>В цій главі ви в деталях вивчили кейс класи Scala, та порівняння
      шаблонів. З їх використанням ви можете отримати переваги від декількох
      стислих ідіом, що звичайно недоступні в об'єктно-орієнтовних мовах. Однак
      співпадіння шаблонів Scala іде далі, ніж описує ця глава. Якщо ви бажаєте
      використовувати співпадіння шаблонів для ваших класів, але не бажаєте
      відкривати доступ до ваших класів таким чином, як це роблять кейс класи,
      тоді ви можете використовувати екстрактори, описані в Главі 26. Однак в
      наступній главі ми повернемо нашу увагу до списків.</p>
    <h3> Глава 16</h3>
    <h2>Робота зі списками</h2>
    Списки, мабуть, найбільш загально уживані структури даних в програмах на
    Scala. Ця глава пояснює списки в деталях. Вона представляє багато загальних
    операцій, що можуть бути виконані зі списками. Вона також навчить деяким
    важливим принципам розробки для програм, що роблять зі списками.<br>
    <h3>16.1 Спискові літерали</h3>
    Ви вже бачили списки в попередніх главах, так що ви знаєте, що список, який
    складається з елементів 'a', 'b', та 'c' записується List('a', 'b', 'c').
    Ось деякі інші приклади:<br>
    <pre class="prettyprint linenums language-scala">val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
  List(
    List(1, <br>0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
val empty = List()
</pre>
    <p>Списки досить подібні до масивів, але є дві важливі різниці. Перше,
      списки є незмінними. Тобто елементи списку ніколи не можуть бути змінені
      через присвоєння. Друге, списки мають рекурсивну структуру (тобто, списки
      зв'язані), тоді як масиви пласкі.</p>
    <h3>16.2 Тип списків</h3>
    <p>Як і масиви, списки є гомогенними: елементи списку завжди того ж самого
      типу. Тип списку, що має елементи типу T, записується як List[T].
      Наприклад, ось ті ж чотири списки з явно заданими типуми: </p>
    <pre class="prettyprint linenums language-scala">val fruit: List[String] = List("apples", "oranges", "pears")
<br>val nums: List[Int] = List(1, 2, 3, 4)
<br>val diag3: List[List[Int]] =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
<br>val empty: List[Nothing] = List()</pre>
    <p>Список в Scala є коваріантним. Це означає, що для кожної пари типів S та
      T, якщо S є субтипом до T, тоді List[S] є субтипом для List[T]. Наприклад,
      List[String] є субтипом до List[Object]. Це є природним, бо кожний список
      рядків може також розглядатись як список об'єктів.</p>
    <p>Зауважте, що пустий список має тип List[Nothing]. Ви бачили в Розділі
      11.3, що Nothing є низом ієрархії класів Scala. Це є субтипом для кожного
      іншого типу Scala. Оскільки список є коваріантним, з цього слідує, що
      List[Nothing] є субтипом до List[T] для кожного тупа T. Так що об'єкт
      пустого списка, що має тип List[Nothing], може також розглядатись як
      об'єкт кожного іншого типу в формі List[T]. Ось чому припустимо записати
      наступний код:</p>
    <pre class="prettyprint linenums language-scala">// List() також є типом List[String]!
val xs: List[String] = List()</pre>
    <h3> 16.3 Конструювання списків</h3>
    Всі списки побудовані на двох фундаментальних блоках, Nil та ::
    (вимовляється “cons”). Nil представляє пустий список. Інфіксний оператор ::
    виражає додавання до початку списка. Тобто x :: xs представляє список, чий
    перший елемент є x, за яким слідують елементи списку xs. Таким чином
    попередні значення списків також можуть бути визначені так:<br>
    <pre class="prettyprint linenums language-scala">val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
  (0 :: (1 :: (0 :: Nil))) ::
    (0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
</pre>
    <p>Фактично, попередні визначення fruit, nums, diag3, та empty в термінах
      List(...) є тільки огорткою, що розширюється до ціх визначень. Наприклад,
      List(1, 2, 3) створює список 1 :: (2 :: (3 :: Nil)). Оскільки це
      завершується на дві крапки, оператор :: асоціюється зправа: A :: B :: C
      інтерпретується як A :: (B :: C). Таким чином ви можете відкинути дужки в
      попередньому визначенні. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">val nums = 1 :: 2 :: 3 :: 4 :: Nil</pre>
    <p>є еквівалентним до попереднього визначення nums. Всі операції зі списками
      можуть бути виражені в термінах наступних трьох:</p>
    <p>head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; повертає перший елемент
      зі списка</p>
    <p>tail&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      повертає список, що складається з усіх елементів, за винятком першого</p>
    <p>isEmpty&nbsp;&nbsp;&nbsp; повертає true, якщо список пустий</p>
    <p>Ці операції визначені як методи класа List. Деякі приклади показані в
      Таблиці 16.1.</p>
    <p>Таблиця 16.1 Базові операції зі списками</p>
    <pre class="prettyprint linenums language-scala">      &nbsp;&nbsp; <strong>Операція</strong>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  <strong>Що повертає</strong>
        empty.isEmpty       true
        fruit.isEmpty       false 
        fruit.head         "apples"
        fruit.tail.head    "oranges"
        diag3.head       List(1, 0, 0)</pre>
    <p>Методи head та methods are defined only for non-empty lists. When<br>
      selected from an empty list, they throw an exception. For instance:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; Nil.head 
java.util.NoSuchElementException: head of empty list</pre>
    <p>Як приклад того, як можуть бути оброблені списки, розглянемо сортування
      елементів списка в зростаючому порядку. Один простий шлях зробити це є
      сортування вставкою, що робить таким чином: щоб відсортувати непустий
      список x :: xs, сортувати залишок xs, та вставити перший елемент x в
      потрібну позицію результата. Сортування пустого списка дає пустий список.
      Виражене в коді Scala, алгоритм сортування вставкою виглядає так:</p>
    <pre class="prettyprint linenums language-scala">def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
<br>def insert(x: Int, xs: List[Int]): List[Int] =
  if (xs.isEmpty || x &lt;= xs.head) x :: xs
  else xs.head :: insert(x, xs.tail)
</pre>
    <h3> 16.5&nbsp; Шаблони списків</h3>
    Списки також можуть бути розділені на частини через порівняння шаблонів.
    Шаблони списків відповідають виразам списка один-за-одним. Ви можете або
    порівнювати на всіх елементах списка, з використанням шаблона в формі
    List(...), або ви розділяєте список на частки один-за-одним, використовуючи
    шаблони, що складаються з оператора :: та константи Nil. Ось приклад першого
    типу шаблона:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears
</pre>
    <h4>Щодо шаблонів порівняння зі списками</h4>
    <p>Якщо ви переглядаєте можливі форми шаблонів, що описані в Главі 15, ви
      можете винайти, що ні List(...), ані :: не пасують до різновидів шаблонів,
      що визначені тут. Фактично, List(...) є примірником визначеного в
      бібліотеці шаблону екстрактора. Такі шаблони будуть трактуватись в Главі
      26. Шаблон “cons” x :: xs є спеціальним випадком шаблона інфіксної
      операції. Ви вже знаєте, що коли розглядається як вираз, інфіксна операція
      еквівалентна до виклику метода. Для шаблонів правило інше: коли
      розглядається як шаблон, інфіксна операція, такая як p op q, еквівалентна
      до op(p, q). Таким чином, інфіксний оператор op трактується як шаблон
      конструктора. Зокрема, шаблон cons, такий як x :: xs, трактується як ::(x,
      xs). Це підказка, що десь має бути клас на ім'я ::, що відповідає шаблону
      конструктора. Очевидно десь має бути такий клас. Він називається scala.::,
      та є саме тим класом, що будує непусті списки. Так що :: існує в Scala
      двічі, один раз як ім'я класу в пакунку scala, та ще раз як метод в класі
      List. Ефект метода :: полягає в тому, щоб створювати&nbsp; примірник класа
      scala.::. Ви знайдете більше щодо того, як реалізований клас List, в Главі
      22.</p>
    <p>Шаблон List(a, b, c) співпадає зі списками довжини 3, та прив'язує три
      елементи до змінних шаблона, a, b, та c. Якщо ви не знаєте число елементі
      заздалегідь, краще замість цього порівнювати за допомогою ::. Наприклад,
      шаблон a :: b :: rest співпадає зі списками довжини 2 або більше:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)</pre>
    <p>Брати списки частками за допомогою шаблонів є альтернативою до їх
      розподілу за допомогою базових методів, head, tail, та isEmpty. Наприклад,
      ось знову сортування вставкою, на цей раз написаний за допомогою
      порівняння шаблонів:</p>
    <pre class="prettyprint linenums language-scala">def isort(xs: List[Int]): List[Int] = xs match {
  case List() =&gt; List()
  case x :: xs1 =&gt; insert(x, isort(xs1))
}
<br>def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() =&gt; List(x)
  case y :: ys =&gt; if (x &lt;= y) x :: xs
  else y :: insert(x, ys)
}
</pre> Часто порівняння шаблонів зі списками є чистішим, ніж декомпозиція їх за
    допомогою методів, так що порівняння шаблонів повинне бути часткою вашого
    інструментарію роботи зі списками.<br>
    <br>
    Це все, що вам треба знати щодо списків в Scala, щоб бути в змозі
    використовувати їх коректно. Однак ще є велике число методів, що охоплюють
    загальні шаблони операцій над списками. Ці методи роблять програми обробки
    списків більш стислими та чистими. Наступні два розділи презентують найбільш
    важливі методи, визначені для класа List.<br>
    <br>
    <h3>16.6&nbsp; Методи першого порядку на класі List</h3>
    Цей розділ пояснює більшість методів першого порядку, визначених в класі
    List. Метод є першого порядку, якщо він не приймає жодних функцій як
    аргументів. Розділ також вводить шляхом двох прикладів деякі рекомендовані
    прийоми для структурування програм, що оперують списками. <br>
    <h4>Конкатенація двох списків</h4>
    Операція, подібна до ::, є конкатенація, що записується як ‘:::’. На відміну
    від&nbsp; ::, ::: приймає два списки в якості операндів. Результат xs ::: ys
    є новий список, що містить всі елементи xs, за якими ідуть всі елементи ys.
    Ось декілька прикладів:<br>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)
<br>scala&gt; List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)
<br>scala&gt; List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)</pre>
    <p>Як і cons, конкатенація списків асоціюється зправа. Вираз як цей:</p>
    <pre class="prettyprint linenums language-scala">xs ::: ys ::: zs</pre>
    <p>інтерпретується таким чином:</p>
    <pre class="prettyprint linenums language-scala">xs ::: (ys ::: zs)</pre>
    <h4>Принцип Розділюй та Захоплюй</h4>
    <p>Конкатенація (:::) реалізована як метод в класі List. Також можливо
      реалізувати конкатенацію "власноруч", з використанням порівнянь шаблонів
      зі списками. Є корисним спробувати реалізовати це самому, бо це показує
      загальний шлях для реалізації алгоритмів, що використовують списки. Перше,
      поглянемо на сигнатуру метода конкатенації, що ми називаємо append. Щоб не
      дуже змішувати все докупи, уявімо, що append визначена за межами класа
      List.</p>
    <p>Так що ми маємо два списка, що ми маємо конкатенувати, як параметри. Ці
      два списки мають домовитись щодо типів ебементів, але цей тип елементів
      може бути довільним. Це може бути виражене, надавши append тип parameter3,
      що представляє тип елементів двох вхідних списків:</p>
    <pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T]</pre>
    <p>Щоб розробити реалізацію append, треба згадати принцип розробки “діли та
      захоплюй” для програм з рекурсивними структурами даних, як списки. Багато
      алгоритмів зі списками спочатку розділяють ввод на простіші випадки за
      допомогою порівнять шаблонів. Це частина Розділяй нашого принципа. Потім
      вони конструюють результат для кожного випадка. Якщо результат є непустим
      списком, деякі з його частин можуть бути сконструйовані через рекурсивні
      виклики того ж самого алгоритма. це частина Захоплюй нашого
      принципа.&nbsp;</p>
    <p>Щоб застосувати цей принцип до реалізації метода append, перше питання,
      що треба задати, це з чим порівнювати списки. Це менш тривіально в випадку
      append, ніж для багатьох інших методів, оскільки є два вибори. Однак
      наступна фаза “захоплюй” каже вам, що вам треба конструювати список, що
      складаєтсья з усіх елементів обох вхідних списків. Оскільки списки
      складаються з кінця до початку, ys може залишатись без змін, тоді як xs
      буде потребувати розбиття на частини, та передування до ys. Таким чином,
      має сенс сконцентруватись на xs як на джерелі для співпадіння шаблонів.
      Найбільш загальний шаблон зі списками є просте розділення списків на
      порожні та непорожні. Так що це дає наступний контур метода append:</p>
    <pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T] =
xs match {
  case List() =&gt; // ??
  case x :: xs1 =&gt; // ??
}</pre>
    <p>Все що залишилось, це заповнити два місця, позначені як “??”. Перше таке
      місце є альтернатива, де вхідний список xs порожній. В цьому випадку
      конкатенацію дає другий список:</p>
    <pre class="prettyprint linenums language-scala">case List() =&gt; ys</pre>
    <p>Друге місце, що залишилось відкритим, є альтернатива, де вхідний список
      xs складається з деякої голови x, за якою іде хвіст xs1. В цьому випадку
      результат також є непустий список. Щоб сконструювати непорожній список,
      вам треба знати, що за голова та хвіст в цього списка має бути. Ви знаєте,
      що перший елемент результуючого списка є x. Щодо залишку елементів, це
      може бути обчислено додаванням залишку першого списку, xs1, до другого
      списку ys. Це завершує розробку, і дає наступне:</p>
    <pre class="prettyprint linenums language-scala">def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List() =&gt; ys
    case x :: xs1 =&gt; x :: append(xs1, ys)
  }</pre>
    <p>Обчислення другої альтернативи ілюструює частину "захоплюй" загального
      принципу: спочатку думайте, який образ бажаного результату повинен бути,
      потім обчисліть окремі частини цього образу, в потрібних місцях
      використовуючи рекурсивні виклики. Нарешті, сконструюйте результат з ціх
      частин.</p>
    <h4>Отримання довжини списку: length</h4>
    <p>Метод length обчислює довжину списка.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3).length
res3: Int = 3</pre>
    <p>Для списків, на відміну від масивів, довжина є досить коштовною
      операцією. Вона вимагає пройти цілий список, щоб знайти його кінець, та,
      таким чином, приймає час, пропорційний числу елементів у списку. Ось чому
      це не гарна ідея замінити перевірку, таку як&nbsp; xs.isEmpty, на
      xs.length == 0. Цей результат двох перевірок однаковий, але другий
      повільніший, особливо якщо список xs довгий.</p>
    <h4>Доступ до кінця списка: init та last</h4>
    <p>Ви вже знаєте базові операції head та tail, що, відповідно, бере перший
      елемент зі списку та залишок списку, окрім першого елементу. Кожна має
      подвійну дію: остання повертає останній елемент з (не-порожнього) списку,
      тоді як init повертає список, що складається з усіх елементів, за винятком
      першого:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val abcde = List('a', 'b', 'c', 'd', 'e')
abcde: List[Char] = List(a, b, c, d, e)
<br>scala&gt; abcde.last
res4: Char = e
<br>scala&gt; abcde.init
res5: List[Char] = List(a, b, c, d)</pre>
    <p>Як head та tail, ці методи підіймають виключення, коли застосовуються до
      порожнього списку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List().init
java.lang.UnsupportedOperationException: Nil.init
at scala.List.init(List.scala:544)
at ...
<br>scala&gt; List().last
java.util.NoSuchElementException: Nil.last
at scala.List.last(List.scala:563)
at ...
</pre>
    <p>На відміну від head та tail, що обоє роблять сталий час, init та last
      перейти весь список, щоб обчислити свій результат. Вони, таким чином,
      приймали час пропорційний до довжини списка. Це гарна ідея організувати
      ваші дані, так щоб більшість доступа була до голови списка, скоріше ніж до
      останнього елемента.&nbsp;</p>
    <h4>Реверс списка: reverse</h4>
    <p>Якщо в деякій точці обчислень алгоритм вимагає частого доступу до кінця
      списку, іноді краще спочатку реверсувати (обернути) список, та робити з
      результатом замість цього. Ось як робити реверс-обертання:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde.reverse
res6: List[Char] = List(e, d, c, b, a)</pre>
    <p>Зауважте, що як і всі інші операції зі списками, реверс створює новий
      список, скоріше ніж модифікувати той, з яким працює. Оскільки список
      незмінний, така зміна неможлива в любому випадку. Щоб перевірити це,
      перевірте, що&nbsp; оригінальне значення abcde не змінене після операції
      реверсу:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde
res7: List[Char] = List(a, b, c, d, e)</pre>
    <p>Операції reverse, init, та last відповідають деяким правилам, що можуть
      бути використані для міркувань щодо обчислень та спрощення програм.</p>
    <p>1. reverse є власною протилежністю:<br>
      &nbsp;&nbsp;&nbsp; xs.reverse.reverse&nbsp; equals&nbsp; xs</p>
    <p>2. reverse перетворює init на tail, та last на head, та всі елементи
      також обернені:</p>
    <p>xs.reverse.init&nbsp;&nbsp;&nbsp; equals&nbsp; xs.tail.reverse<br>
      xs.reverse.tail&nbsp;&nbsp;&nbsp; equals&nbsp; xs.init.reverse<br>
      xs.reverse.head&nbsp; equals&nbsp; xs.last<br>
      xs.reverse.last&nbsp;&nbsp;&nbsp; equals&nbsp; xs.head</p>
    <p>Реверс може бути реалізований з використанням конкатенації (:::), як
      наступний метод, rev:</p>
    <pre class="prettyprint linenums language-scala">def rev[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; xs
  case x :: xs1 =&gt; rev(xs1) ::: List(x)
}</pre>
    <p>Однак цей метод менш ефективний, ніж деяко міг би спобіватись. Щоб
      вивчити складність rev, уявіть, що список xs має довжину n. Зауважте, що
      існують n рекурсивних викликів до rev. Кожний виклик очікує, окрім
      останнього, включає конкатенацію списків. Конкатенація списків xs ::: ys
      забирає час, пропорційний до довжини свого першого аргумента xs. Таким
      чином, загальна складність rev є:</p>
    <pre class="prettyprint linenums language-scala">n + (n − 1) + ... + 1 = (1 + n) ∗ n/2</pre>
    <p>Іншими словами, складність rev є квадратом до довжини своїх вхідних
      аргументів. Це несподівано, в порівнянні з стандартним реверсом змінного
      зв'язаного списка, що має лінійну складність. Однак поточна реалізація rev
      не є кращою можливою реалізацією. Ви побачите в Розділі 4 як можна її
      прискорити.</p>
    <h4>Префікси та суфікси: drop, take та splitAt</h4>
    <p>Операції drop та take узагальнюють tail та init в тому, що вони
      повертають довільні префікси та суфікси списка. Вираз “xs take n” повертає
      перші n елементів зі списка xs. Якщо n більше ніж xs.length, повертається
      цілий список xs. Операція “xs drop n” повертає всі елементи списку xs, за
      винятком перших n. Якщо n більше, ніж xs.length, повертається пустий
      список. Операція splitAt розділяє список по заданому індексові, повертаючи
      пару з двох списків. Це показує така рівність:</p>
    <p>xs splitAt n&nbsp; equals (xs take n, xs drop n)</p>
    <p>Однак splitAt уникає мандрувати списком xs двічі. Ось деякі приклади ціх
      трьох методів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde take 2
res8: List[Char] = List(a, b)
<br>scala&gt; abcde drop 2
res9: List[Char] = List(c, d, e)
<br>scala&gt; abcde splitAt 2
res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))</pre>
    <h4>Вибір елементів: apply та indices</h4>
    <p>Вибір випадкового елементу підтримується через метод apply; однак це менш
      загальна операція для списків, ніж для масивів.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde apply 2 // рідке в Scala
res11: Char = c</pre>
    <p>Для всіх інших типів apply вставляється неявно, коли об'єкт з'являється в
      позиції функції в виклику метода, так що вище може бути скорочене до
      такого:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde(2)
&nbsp;// рідке в Scala
res12: Char = c</pre>
    <p>Одна з причин, чому вибір довільного елемента менш популярний, ніж для
      масивів, в тому, що xs(n) забирає часу пропорційно до індексу n. Фактично,
      apply просто визначена як комбінація з drop та head:</p>
    <pre class="prettyprint linenums language-scala">xs apply n&nbsp; ~ (xs drop n).head</pre>
    <p>Це визначення також ясно дає зрозуміти, що списки індексуються з нуля до
      довжини списку мінус один, так само, як і масиви. Метод indices повертає
      список, що містить всі допустимі індекси поточного списку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde.indices
res13: scala.collection.immutable.Range =
Range(0, 1, 2, 3, 4)</pre>
    <h4>Спрямлення списка списків: flatten</h4>
    <p>Метод flatten приймає список зі списків, та спрямляє його в один список:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(List(1, 2), List(3), List(), List(4, 5)).flatten
res14: List[Int] = List(1, 2, 3, 4, 5)
scala&gt; fruit.map(_.toCharArray).flatten
res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,
                          s, p, e, a, r, s)</pre>
    <p>ВІн може бути застосований тільки до списків, чиї всі елементи також
      списки. Спроба спрями любий інший список викличе помилку компілятора:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3).flatten
&lt;console&gt;:5: error: could not find implicit value for
parameter asTraversable: (Int) =&gt; Traversable[B]
List(1, 2, 3).flatten
ˆ
</pre>
    <h4>Складання списків: zip та unzip</h4>
    <p>Операція zip приймає два списки, та формує список з пар:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde.indices zip abcde
res17: scala.collection.immutable.IndexedSeq[(Int, Char)] =
  IndexedSeq((0,a), (1,b), (2,c), (3,d), (4,e))</pre>
    <p>Якщо два списки різної довжини, любі неспівпадаючі елемент відкидаються:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val zipped = abcde zip List(1, 2, 3)
zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))</pre>
    <p>Корисний спеціальний випадок zip є список з його індексами. Це робиться
      більш ефективно за допомогою метода zipWithIndex, що парує кожний елемент
      списка з позицією, на якій він знаходиться в списку.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde.zipWithIndex
res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3), (e,4))</pre>
    <p>Любий список пар може бути змінений назад, до пари&nbsp; списків,
      використовуючи метод unzip:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; zipped.unzip
res19: (List[Char], List[Int]) = (List(a, b, c),List(1, 2, 3))</pre>
    <p>Методи zip та unzip провадять один шлях для операцій над декількома
      списками разом. Дивіться Розділ 16.9 пізніше в цій главі щодо способу, що
      іноді може бути коротшим.&nbsp;</p>
    <h4>Відображення списків: toString та mkString</h4>
    <p>Операція toString повертає канонічний рядок, що представляє список:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde.toString
res20: String = List(a, b, c, d, e)</pre>
    <p>Якщо ви бажаєте інше представлення, ви можете використати метод mkString.
      Операція xs mkString (pre, sep, post) включає чотири операнда: список для
      відображення xs, рядок префікса pre, що буде відображатись перед всіма
      елементами, рядок роздільника sep, що буде відображатись між сусідніми
      елементами, на рядок-постфікс, що буде відображатись в кінці. Результат
      операції буде рядок у такому вигляді:</p>
    <pre class="prettyprint linenums language-scala">pre + xs(0) + sep + . . . + sep + xs(xs.length - 1) + post</pre>
    <p>Метод mkString має два перевантажені варіанти, що дозволяють вам
      відкинути деякі, або всі його аргументи. Перший варіант приймає тільки
      рядок роздільника:</p>
    <pre class="prettyprint linenums language-scala">xs mkString sep ~ xs mkString ("", sep, "")</pre>
    <p>Другий варіант дозволяє нам відкинути всі аргументи:</p>
    <pre class="prettyprint linenums language-scala">xs.mkString ~ xs mkString ""</pre>
    <p>Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde mkString ("[", ",", "]")
res21: String = [a,b,c,d,e]
<br>scala&gt; abcde mkString ""
res22: String = abcde
<br>scala&gt; abcde.mkString
res23: String = abcde
<br>scala&gt; abcde mkString ("List(", ", ", ")")
res24: String = List(a, b, c, d, e)</pre>
    <p>Є також варіанти методів mkString, названі addString, що додають
      сконструйований рядок до об'єкта StringBuilder, скоріше, ніж повертати
      його як результат:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val buf = new StringBuilder
buf: StringBuilder =
scala&gt; abcde addString (buf, "(", ";", ")")
res25: StringBuilder = (a;b;c;d;e)</pre>
    <p>Методи mkString та addString наслідуються від супертрейта List,
      Traversable, так що вони стосуються всіх інших колкцій, також.</p>
    <h4>Перетворення списків: iterator, toArray, copyToArray</h4>
    <p>Щоб конвертувати дані між пласким світом масивів, та рекурсивним світом
      списків, ви можете використовувати метод toArray в класі List, та toList в
      класі Array:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val arr = abcde.toArray
arr: Array[Char] = Array(a, b, c, d, e)
<br>scala&gt; arr.toList
res26: List[Char] = List(a, b, c, d, e)</pre>
    <p>Є також метод copyToArray, що копіює елементи до послідовних позицій в
      деякому цільовому масиві. Операція:</p>
    <p>xs copyToArray (arr, start) </p>
    <p>копіює елементи списка xs в масив arr, починаючи з позиції start. Ви
      повинні переконатись, що цільовий масив arr досить великий для утримання
      цілого списка. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val arr2 = new Array[Int](10)
arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
scala&gt; List(1, 2, 3) copyToArray (arr2, 3)
scala&gt; arr2
res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)</pre>
    <p>Нарешті, якщо вам треба отримати доступ до елементів списка через
      ітератор, ви можете використовувати метод iterator:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val it = abcde.iterator
it: Iterator[Char] = non-empty iterator</pre>
    <pre class="prettyprint linenums language-scala">scala&gt; it.next
res29: Char = a
scala&gt; it.next
res30: Char = b</pre>
    <h4>Приклад: сортування злиттям</h4>
    <p>Сортування вставкою, що представлене раніше, стисле в написанні, але не
      дуже ефективне. Його середня складність пропорційна квадрату довжини
      вхідного списку. Більш ефективний алгоритм є сортування злиттям.</p>
    <h4>Швидке орієнтування</h4>
    <p>Цей приклад провадить іншу ілюстрацію принципу розділяй та захоплюй та
      карування, а також надає корисну дискусію щодо складності алгоритмів.
      Однак якщо ви бажаєте рухатись трохи швидше при першому прочитанні цієї
      книги, ви можете безпечно перейти до Розділу 16.7.</p>
    <p>Сортування злиттям робить наступним чином: зпершу, якщо список має нуль
      або один елемент, він вже впорядкований, так що список можна повертати бе
      ззмін. Довші списки поділяються на два підсписка, кожний містить близько
      половини елементів оригінального списка. Кожний підсписок сортується
      рекурсивним викликом до функції sort, та отримані два відсортованих списки
      потім комбінуються операцією злиття. </p>
    <p>Для загальної реалізації сортування злиттям ви залишаєте відкритим тип
      елементів списка, що буде сортуватись, та також залишаєте відкритою
      функцію, що буде використана для порівняння елементів. Ви отримаєте
      максимально загальну функцію, передаючи ці два елементи як параметри. Це
      призводить до реалізації, показаної в Лістингу16.1.</p>
    <p>Складність msort має порядок (n log(n)), де n є довжина вхідного списка.
      Щоб побачит чому це так, зауважте, що поділення списка на два, та злиття
      двох списків займає час, пропорційний до довжини списка-аргумента. Кожний
      рекрсивний виклик msort поділяє навпіл число елементів у вхідному списку,
      так що буде близько log(n) послідовних рекурсивних викликів, доки не буде
      досягнуто базового випадку зі списків довжиною 1. Однак для довших списків
      кожний виклик утворює два інших виклики. Додаючи все докупи, ми отримуємо,
      що на кожному з log(n) рівней виклику, кожний елемент оригінальних списків
      бере участь в одній операції розділення, та в одній операції злиття. Таким
      чином, кожний рівень має загальну складність, пропорційну n. Оскільки
      загалом log(n) рівней виклику, ми отримуємо загальну вартість, пропорційну
      до n log(n). Ця вартість не залежить від початкового розподілення
      елементів </p>
    <pre class="prettyprint linenums language-scala">def msort[T](less: (T, T) =&gt; Boolean)
(xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) =&gt; ys
      case (_, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (less(x, y)) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
<br>  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(msort(less)(ys), msort(less)(zs))
  }
}</pre>
    <p>Лістинг 16.1 Функція сортування злиттям для List.</p>
    <p>в цьому списку, так що найгірший випадок ціни є такий же, що і ціна
      середнього випадка. Ця властивість робить сортування злиттям ефективним
      алгоритмом для сортування списків. Ось приклад, як використовується msort:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 1, 3))
res31: List[Int] = List(1, 3, 5, 7)</pre>
    <p>Функція msort є класичним прикладом концепції карування, що обговорюється
      в Розділі 9.3. Карування робить простішим уточнити функцію до окремих
      функцій порівняння. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val intSort = msort((x: Int, y: Int) =&gt; x &lt; y) _
intSort: (List[Int]) =&gt; List[Int] = &lt;function1&gt;</pre>
    <p>Змінна intSort посилається на функцію, що приймає список цілих, та
      сортирує їх за значенням. Як описано в Розділі 8.6, підкреслення означає
      відсутній список аргументів. В цьому випадку відсутній артумент є список,
      що має бути відсортований. Як інший приклад, ось як ви можете визначити
      функцію, що сортує список цілих в зворотньому порядку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val reverseIntSort = msort((x: Int, y: Int) =&gt; x &gt; y) _
reverseIntSort: (List[Int]) =&gt; List[Int] = &lt;function&gt;</pre>
    <p>Оскільки завдяки каруванню ви вже надали функцію порівняння, тепер вам
      треба тільки надати список для сортування, коли ви викликаєте функції
      intSort або reverseIntSort. Ось деякі приклади: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
mixedInts: List[Int] = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
<br>scala&gt; intSort(mixedInts)
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
<br>scala&gt; reverseIntSort(mixedInts)
res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</pre>
    <h3>16.7&nbsp; Методи вищого порядка на класі List</h3>
    <p>Багато операторів зі списками мають подібну структуру. Деякі шаблони
      з'являються раз за разом. Ось деякі приклади: трансформація кожного
      елемента зі списка в деякий спосіб, перевірка, чи справджується деяка
      властивість для всіх елементів зі списку, виділення зі списку елементів,
      що задовільняють деякому критерію, або комбіювання елементів списка за
      допомогою деякого оператора. В Java такі шаблони звичайно виражені в
      ідиоматичних комбінаціях циклів for або while. В Scala вони можуть бути
      виражені більш стисло, на напряму використовуючи оператори вищіх порядків,
      що реалізовані як методи класа List. Ці оператори вищого порядка
      обговорюються в цьому розділі.</p>
    <h4>Відображення списків: map, flatMap та foreach</h4>
    <p>Операція xs map f приймає в якості операндів список xs типу List[T], та
      функцію f типу T =&gt; U. Вона повертає список, що утворений через
      застосування функції f до кожного елементу списка xs. Наприклад: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) map (_ + 1)
res32: List[Int] = List(2, 3, 4)
<br>scala&gt; val words = List("the", "quick", "brown", "fox")
words: List[java.lang.String] = List(the, quick, brown, fox)
<br>scala&gt; words map (_.length)
res33: List[Int] = List(3, 5, 5, 3)
<br>scala&gt; words map (_.toList.reverse.mkString)
res34: List[String] = List(eht, kciuq, nworb, xof)</pre>
    <p>Оператор flatMap подібний до map, але він приймає функцію, що повертає
      список елементів в якості правого операнда. Він застосовує функцію до
      кожного елемента списка, та повертає конкатенацію всіх результатів
      функції. Різниця між map та flatMap проілюстрована в наступному прикладі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; words map (_.toList)
res35: List[List[Char]] = List(List(t, h, e), List(q, u, i,
c, k), List(b, r, o, w, n), List(f, o, x))
<br>scala&gt; words flatMap (_.toList)
res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w,
n, f, o, x)</pre>
    <p>Ви бачите, що коли map повертає список списків, flatMap повертає один
      список, в якому всі списки-елементи конкатеновані. Різниця та
      взаємовідносини між map та flatMap також продемонстровані в наступному
      виразі, що конструює список з усіх пар, що (i, j), де 1 ≤ j &lt; i &lt; 5:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.range(1, 5) flatMap (
i =&gt; List.range(1, i) map (j =&gt; (i, j)))
res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),
(4,2), (4,3))</pre>
    <p>List.range є допоміжним методом, що створює список з усіх цілих в деякому
      диапазоні. Він використовується двічі в цьому прикладі: один раз для
      генерації списка цілих від 1 (включно) до 5 (виключно), та другий раз для
      генерації списка цілих від 1 до i, для кожного значення i, взтого з
      першого списка. Метод map в цьому виразі генерує список кортежів (i, j),
      де j &lt; i. Зовнішній flatMap в цьому прикладі генерує цей список для
      кожного i між 1 та 5, та потім конкатенує всі результати. </p>
    <p>Зауважте, що той же список альтернативно може бути зконкатенований за
      допомогою вираза for:</p>
    <pre class="prettyprint linenums language-scala">for (i &lt;- List.range(1, 5); j &lt;- List.range(1, i)) yield (i, j)</pre>
    <p>Ви пізнаєте більше щодо взаємодії виразів for та оперцій зі списками в
      Главі 23. Третя подібна до map операція є foreach. Однак на відміну від
      map та flatMap, foreach приймає процедуру (функцію з результатом Unit) в
      якості правого операнда. Вона просто застосовує процедуру до кожного
      елемента. Результатом самої операції є знову Unit; новий список не
      збирається з результатів. Як приклад, ось стислий шлях підсумку всіх чисел
      в списку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; var sum = 0
sum: Int = 0
scala&gt; List(1, 2, 3, 4, 5) foreach (sum += _)
scala&gt; sum
res39: Int = 15</pre>
    <h4>Фільтрація списків: filter, partition, find, takeWhile, dropWhile, та
      span</h4>
    <p>Операція xs filter p приймає як операнди список xs типу List[T], та
      функцію-предикат p типу T =&gt; Boolean. Вона дає список з усіх елементів
      x з xs, для яких which p(x) є true. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) filter (_ % 2 == 0)
res40: List[Int] = List(2, 4)
scala&gt; words filter (_.length == 3)
res41: List[java.lang.String] = List(the, fox)</pre>
    <p>Метод partition подібний до filter, але він повертає пару списків. Один
      список містить всі for, для яких предикат є true, тодя як інший список
      містить всі елементи, для яких предикат є false. Це визначається такою
      еквівалентністю:</p>
    <p>xs partition p ~ (xs filter p, xs filter (!p(_)))</p>
    <p>Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) partition (_ % 2 == 0)
res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))</pre>
    <p>Метод find також подібний до filter, але він повертає перший елемент, що
      задовільняє предикату, скоріше, ніж всі такі елементи. Операція xs find p
      приймає список xs та предикат p в якості операндів. Він повертає
      опціональне значення. Якщо є елемент x в xs, для якого p(x) є true,
      повертається Some(x). Інакше p є false для всіх елементів, та повертається
      None. Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, 4, 5) find (_ % 2 == 0)
res43: Option[Int] = Some(2)
scala&gt; List(1, 2, 3, 4, 5) find (_ &lt;= 0)
res44: Option[Int] = None</pre>
    <p>Оператори takeWhile та dropWhile також приймають предикат як свій правий
      операнд. Операція xs takeWhile p вибирає найдовший префікс зі списка xs,
      так що кожний елемент з цього префікса задовільняє p. Аналогічно, операція
      xs dropWhile p видаляє найбільший префікс зі списка xs, де кожний елемент
      з цього префікса задовільняє p. Ось деякі приклади:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, -4, 5) takeWhile (_ &gt; 0)
res45: List[Int] = List(1, 2, 3)
<br>scala&gt; words dropWhile (_ startsWith "t")
res46: List[java.lang.String] = List(quick, brown, fox)</pre>
    <p>Метод span комбінує takeWhile та dropWhile в одній операції, так само, як
      splitAt комбінує take та drop. Він повертає пару з двох списків, що
      визначені еквівалентністю:</p>
    <p>xs span p ~ (xs takeWhile p, xs dropWhile p)</p>
    <p>Як і splitAt, span уникає перебігу списка xs двічі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3, -4, 5) span (_ &gt; 0)
res47: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))</pre>
    <h4>Предикати над списками: forall та exists</h4>
    <p>Операція xs forall p приймає в якості аргументів список xs та предикат p.
      Її результат є true, якщо всі елементи в списку задовільняють p.
      Відповідно, операція xs exists p повертає true, якщо існує елемент в xs,
      що задовільняє предикату p. Наприклад, щоб знайти, чи матриця,
      представлена як список списків, має рядок з тільки нульовими елементами:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def hasZeroRow(m: List[List[Int]]) =
m exists (row =&gt; row forall (_ == 0))
hasZeroRow: (m: List[List[Int]])Boolean
scala&gt; hasZeroRow(diag3)
res48: Boolean = false</pre>
    <h4>Згортання списків: /: та :\</h4>
    <p class="prettyprint linenums language-scala">Інша загальна категорія
      операцій комбінує всі елементи зі списку за допомогою деякого оператора.
      Наприклад:</p>
    <pre class="prettyprint linenums language-scala">sum(List(a, b, c)) ~ 0 + a + b + c</pre>
    <p class="prettyprint linenums language-scala">Це спеціальний примірник
      операції fold:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def sum(xs: List[Int]): Int = (0 /: xs) (_ + _)
        sum: (xs: List[Int])Int</pre>
    <p class="prettyprint linenums language-scala">Подібно до цього:</p>
    <p class="prettyprint linenums language-scala">product(List(a, b, c)) ~ 1 *
      a * b * c</p>
    <p class="prettyprint linenums language-scala">є спеціальним примірником
      цієї операції:</p>
    <p class="prettyprint linenums language-scala">scala&gt; def product(xs:
      List[Int]): Int = (1 /: xs) (_ * _)<br>
      product: (xs: List[Int])Int</p>
    <p class="prettyprint linenums language-scala">Згортання вліво, операція (z
      /: xs) (op), включає три об'єкти: початкове значення z, список xs, та
      двомісну операцію op. Результат fold є op, застосований між сусідніми
      елементами списка, де з початку стоїть z. Наприклад:</p>
    <pre class="prettyprint linenums language-scala">(z /: List(a, b, c)) (op) ~ op(op(op(z, a), b), c)</pre>
    <p>Ось інший приклад, що ілюструє, як використовується /:. Щоб канкотенувати
      всі слова в списку рядків через проміжок між ними та попереду, ви можете
      записати це:</p>
    <pre class="prettyprint linenums language-scala">scala&gt;
&nbsp;("" /: words) (_ +" "+ _)
res49: java.lang.String =
&nbsp;the quick brown fox</pre>
    <p class="prettyprint linenums language-scala">Це дає додатковий проміжок на
      початку. Щоб видалити цей проміжок, ви можете використати невелику
      варіацію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; (words.head /: words.tail)
&nbsp;(_ +" "+ _)
res50: java.lang.String = the quick brown fox</pre>
    <p class="prettyprint linenums language-scala">Оператор /: продукує
      ліво-орієнтовані дерева операцій (його синтаксис з косою, що здимається
      вперед, має бути відображенням цього). Оператор має аналог :\, що продукує
      право-орієнтовані дерева операцій. Наприклад: </p>
    <pre class="prettyprint linenums language-scala">(List(a, b, c) :\ z) (op)&nbsp; ~&nbsp; op(a, op(b, op(c, z)))</pre>
    <p>Операція :\ промовляється як права згортка. Це включає ті ж три операнди,
      що і ліва згортка, але перші два виступають в зворотньому порядку: першим
      іде список, що буде згортатись, другим початкове значення. </p>
    <p class="prettyprint linenums language-scala">Для асоціативних операцій
      права та ліва згортки є еквівалентними, але може бути різниця в
      продуктивності. Розглянемо, наприклад, операцію, що відповідає методу
      спрямлення, що конкатенує всі елементи в списку списків. Це може бути
      реалізовано або зі згортанням вліво, або вправо:</p>
    <pre class="prettyprint linenums language-scala">def flattenLeft[T](xss: List[List[T]]) =
&nbsp; (List[T]() /: xss) (_ ::: _)
def flattenRight[T](xss: List[List[T]]) =
(xss :\ List[T]()) (_ ::: _)</pre>
    <p>Оскільки конкатенація списків xs ::: ys забирає час, пропорційний до його
      першого аргумента xs, реалізація в термінах правої згортки в flattenRight
      більш ефктивна, ніж реалізація через згортку вліво в flattenLeft. Проблема
      в тому, що flattenLeft(xss) копіює перший елемент списку xss.head n−1
      разів, де n є довжиною списка xss.</p>
    <p>Зауважете, що обидві версії require потребують анотацій типу на
      порожньому списку, що є початковим значенням згортання. Це відбувається
      через обмеженість в виводі типів Scala, що не може вивести коректний тип
      списка автоматично. Якщо ви спробуєте відкинути ці анотації, ви отримаєте
      наступне:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def flattenRight[T](xss: List[List[T]]) =
(xss :\ List()) (_ ::: _)
&lt;console&gt;:5: error: type mismatch;
found<br>&nbsp;: scala.List[T]
required: List[Nothing]
(xss :\ List()) (_ ::: _)
ˆ</pre>
    <p class="prettyprint linenums language-scala">Щоб з'ясувати, що трапилось з
      виводом типів, вам треба знати щодо типів методів згортки, та як вони
      реалізовані. Більше про це в Главі 22.</p>
    <p>Нарешті, хоча оператори /: та :\ мають перевагу через те, що напрямок
      косої надає графічний образ їх відповідних правого та лівого дерева, та
      асоціативність двох крапок покладає початкове значення в ту ж позицію в
      виразі що і в дереві, дехто може винайти отриманий код не дуже
      інтуітивним. Якщо ви бажаєте, в якості альтернативи використовувати методи
      foldLeft та foldRight, що також визначені в класі List.</p>
    <p>Приклад: реверс List за допомогою fold. Раніше в главі ви бачили
      реалізацію метода reverse, що називався rev, чий час виконання був
      квадратичним до довжини списку, що обертався. Ось інша реалізація reverse,
      що має лінійну ціну. Ідея в використанні операції лівого згортання, на
      основі наступної схеми:</p>
    <pre class="prettyprint linenums language-scala">def reverseLeft[T](xs: List[T]) = (startvalue /: xs)(operation)</pre>
    <p>Тільки залишається заповнити стартове значення та операцію. Фактично ви
      можете спробувати вивести ці частини з деяких простих прикладів. Щоб
      вивести коректні значення для startvalue, ви можете почати з найменьшого
      можливого списка, List(), та обчислити наступне:</p>
    <p>List() ~ (за властивістю reverseLeft) </p>
    <p>reverseLeft(List()) ~ (за шаблоном для reverseLeft)</p>
    <p>(startvalue /: List())(operation) ~ (за визначенням /:)&nbsp; startvalue</p>
    <p>Таким чином, startvalue має бути List(). Щоб вивести другий операнд, ви
      можете взяти другий найменьший список як випадок для приклада. Ви вже
      знаєте, що startvalue є List(), так що ви можете обчислити наступне:</p>
    <p>List(x) ~ (за властивістю reverseLeft)<br>
      reverseLeft(List(x)) ~ (за шаблоном для reverseLeft, коли startvalue =
      List())<br>
      (List() /: List(x)) (operation) ~ (за визначенням /:) operation(List(), x)</p>
    <p>Таким чином, operation(List(), x) ~ List(x), що може також бути записане
      як x :: List(). Це підказує брати в якості операції оператор :: з
      переставленими операндами (ця операція іноді називається snoc, по
      відношенню до ::, що називається cons). Тоді ми приходимо до такої
      реалізації reverseLeft:</p>
    <pre class="prettyprint linenums language-scala">def reverseLeft[T](xs: List[T]) = (List[T]() /: xs) {(ys, y) =&gt; y :: ys}</pre>
    <p>(Знову, анотація в List[T]() потрібна, щоб зробити виведення типів
      дієздатним). Якщо ви проаналізуєте складність reverseLeft, ви винайдете,
      що вона застосовує операцію зі сталим часом, snoc, n разів, де n є
      довжиною списка аргументів. Таким чином, складність reverseLeft є
      лінійною, як ми і сподівались.&nbsp;</p>
    <h4>Сортування списків: sortWith</h4>
    <p>Операція xs sortWith before, де “xs” є списком, та “before” є функцією,
      що може використовуватись для порівняння двох елементів, сортує елементи
      списку xs. Вираз x before y має повертати true, якщо x має бути попереду y
      в потрібному порядку сортування. Наприклад: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, -3, 4, 2, 6) sortWith (_ &lt; _)
res51: List[Int] = List(-3, 1, 2, 4, 6)
scala&gt; words sortWith (_.length &gt; _.length)
res52: List[java.lang.String] = List(quick, brown, the, fox)</pre>
    <p>Зауважте, що sortWith виконує сортування злиттям, подібне до алгоритма
      msort, показаного в останньому розділі, але sortWith є методом класа List,
      тоді як msort був визначений за межами списків. </p>
    <h3>16.8 Методи об'єкта List</h3>
    <p>До тепер всі операції, що ми бачили в цій главі, були реалізовані як
      методи класа List, так що ми викликали їх на окремих об'єктах списків.
      Також є декілька методів в глобально доступному об'єкті scala.List, що є
      об'єктом-компанйоном до List. Деякі з ціх операцій є методи-фабрики, що
      створюють списки. Інші є операціями, що роблять зі списками певним чином.
      Обоє типи методів будуть представлені в цьому розділі. Створити список з
      його елементів: List.apply, що ви вже бачили при деякій нагоді як літерали
      списків, List(1, 2, 3). В їх синтаксисі немає нічого особливого. Літерал
      як List(1, 2, 3) є простим застосуванням об'єкта List до елементів 1, 2,
      3. Тобто, це еквівалентно до List.apply(1, 2, 3):</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.apply(1, 2, 3)<br>res53: List[Int] = List(1, 2, 3)</pre>
    <h4>Створення списку цілих: List.range</h4>
    <p>Метод range, що ви бачили похапцем в цій главі, коли дискутували map та
      flatmap, створює список, що складається з диапазону чисел. Його
      найпростіша форма List.range(from, until), що створює списк з усіх чисел,
      починаючи з from, та ідучи далі до until мінус один. Так що останнє
      значення, until, не є частиною диапазона. Також є версія range, що приймає
      довжину кроку як третій параметр. Ця операція буде давати список
      елементів, що стоять на крок один від одного, починаючи з from. Крок може
      бути додатний або від'ємний:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.range(1, 5)
res54: List[Int] = List(1, 2, 3, 4)
scala&gt; List.range(1, 9, 2)
res55: List[Int] = List(1, 3, 5, 7)
scala&gt; List.range(9, 1, -3)
res56: List[Int] = List(9, 6, 3)</pre>
    <h4>Створення одноманітних списків: List.fill</h4>
    <p>Метод fill створює лист, що складається з нуля або більше копій того ж
      самого елемнета. Він прикмає два параметри: довжину списку, що треба
      створити, та елемент, що треба повторювати. Кожний параметр надається в
      окремому списку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.fill(5)('a')
res57: List[Char] = List(a, a, a, a, a)
scala&gt; List.fill(3)("hello")
res58: List[java.lang.String] = List(hello, hello, hello)</pre>
    <p>Якщо fill отримує більше ніж два аргументи, тоді він створює
      багатовимірні списки. Тобто він створює список списків, і так далі.
      Додаткові аргументи ідуть до першого списку аргументів.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.fill(2, 3)('b')
res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))</pre>
    <h4>Функція табуляції: List.tabulate</h4>
    <p>Метод tabulate створює список, чиї елементи обчислюються відповідно до
      наданої функції. Вона має такі ж аргументи, що і List.fill: перший
      аргумент надає розміри створюваного списку, та другий описує елементи
      списку. Єдиною відмінністю є те, що замість сталих елементів вони
      обчислюються через функцію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val squares = List.tabulate(5)(n =&gt; n * n)
squares: List[Int] = List(0, 1, 4, 9, 16)
scala&gt; val multiplication = List.tabulate(5,5)(_ * _)
multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))</pre>
    <h4>Конкатенація декількох списків: List.concat</h4>
    <p>Метод concat конкатенує декілька елементів списків. Списки, що мають
      конкатенуватись, надаються як прямі аргументи до concat:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List.concat(List('a', 'b'), List('c'))
res60: List[Char] = List(a, b, c)
scala&gt; List.concat(List(), List('b'), List('c'))
res61: List[Char] = List(b, c)
scala&gt; List.concat()
res62: List[Nothing] = List()</pre>
    <h3>16.9&nbsp; Одночасна обробка декількох списків</h3>
    <p>Метод zipped над кортежами поєднує декілька загальних операцій для роботи
      з декількоми списками, замість одного. Одна така операція є map.
      Метод&nbsp; map для двох поєднаних списків відображує пари елементів,
      замість окремих елементів. Одна пара є для першого елемента кожного
      списка, інша пара для другого елемента кожного списка, і так далі&nbsp; —
      стільки пар, яка довжина списків. Ось приклад її використання:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; (List(10, 20), List(3, 4, 5)).zipped.map(_ * _)
res63: List[Int] = List(30, 80)</pre>
    <p>Зауважте, що третій елемент в другому списку відкинутий. Метод zipped
      поєднує тільки стільки елементів, скільки існує в обох списках. Всі зайві
      елементи в кінці будуть відкинуті. Є також поєднуючі алалоги для exists та
      forall. Вони такі самі, як і версії ціх методів для одного списка, за тим
      винятком, що вони роблять з декількома спискми, замість одного:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; (List("abc", "de"), List(3, 2)).zipped.
|<br>&nbsp;forall(_.length == _)
res64: Boolean = true
scala&gt; (List("abc", "de"), List(3, 2)).zipped.|
&nbsp;exists(_.length != _)
res65: Boolean = false</pre>
    <h4>Швидка орієнтація</h4>
    <p>В наступному (та заключному) розділі цієї глави ми надамо погляд на
      алгоритм інтерфейсу типів Scala. Ви можете безпечно пропустити цілий
      розділ, якщо вас наразі не цікавлять такі деталі, та прямо перейти до
      висновків.</p>
    <h3>16.10&nbsp; Розуміння алгоритму інтерфейсу типів Scala</h3>
    <p>Одна різниця між попередніми використаннями sortWith, та msort,
      стосується&nbsp; прийнятних синтаксичних форм функції порівняння.
      Порівняйте: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; msort((x: Char, y: Char) =&gt; x &gt; y)(abcde)
res66: List[Char] = List(e, d, c, b, a)</pre>
    <p>з:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; abcde sortWith (_ &gt; _)
res67: List[Char] = List(e, d, c, b, a)</pre>
    <p>Два вирази еквівалентні, але перший використовує довшу форму функції
      порівняння з іменованими параметрами та явними типами, тоді як друга
      використовує стислу форму, (_ &gt; _), де іменовані параметри замінені на
      підкреслення. Звичайно, ви також можете використовувати першу, довшу форму
      разом з sortWith. Однак коротша форма не може використовуватись з msort:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; msort(_ &gt; _)(abcde)
&lt;console&gt;:12: error: missing parameter type for expanded
function ((x$1, x$2) =&gt; x$1.$greater(x$2))
msort(_ &gt; _)(abcde)
ˆ</pre>
    <p>Щоб зрозуміти чому, вам треба знати деякі деталі алгоритмі виведення
      типів Scala. Виведеня типів в Scala базується на потоці. В застосуванні
      метода&nbsp; m(args), алгоритм виводу спочатку перевіряє, чи метод m має
      знаний тип. Якщо це так, цей тип використовується для виведення
      очікуваного типу аргументів. Наприклад, в abcde.sortWith(_ &gt; _), тип
      abcde є List[Char], і, таким чином, sortWith заздалегідь буде методом, що
      приймає аргумент типу (Char, Char) =&gt; Boolean, та продукує результат
      типу List[Char]. Оскільки, таким чином, відомі параметри типів аргументів
      функції, їх можна не писати явно. З тим, що відомо про sortWith, алгоритм
      може дійти висновку, що (_ &gt; _) повинно розширюватись до ((x: Char, y:
      Char) =&gt; x &gt; y), де x та y є деякі довільні нові імена.</p>
    <p>Тепер розглянемо другий випадок, msort(_ &gt; _)(abcde). Тип msort є
      карований, поліморфний тип методу, що приймає аргумент типу (T, T) =&gt;
      Boolean до функції від List[T] до List[T], де T є деякий, ще невідомий
      тип. Метод msort потребує бути втілений з параметром типа, перед тим, як
      зможе застосовуватись до своїх аргументів. Оскільки точний тип примірника
      msort в застосуванні все ще невідомий, він не може бути використаний для
      виведення типу його першого аргументу. Вивід типів змінює свою стратегія в
      цьому випадку; він спочатку перевіряє типи аргументів метода, щоб
      визначити відповідний примірник типів метода. Однак, маючи завдання
      перевірити типи скороченого функціонального літерала, (_ &gt; _), він
      схибить, оскільки він не має інформації щодо типів неявний параметрів
      функції, що вказані як підкреслення. Одним способом розрішити проблему є
      передати явні типи параметрів до msort:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; msort[Char](_ &gt; _)(abcde)
res68: List[Char] = List(e, d, c, b, a)</pre>
    <p class="prettyprint linenums language-scala">Оскільки коректний тип msort
      тепер відомий, він може бути використаний для виведення типів аргументів.
      Інше можливе рішення є переписати метод msort, так щоб його параметри
      обмінялись місцями:</p>
    <pre class="prettyprint linenums language-scala">def msortSwapped[T](xs: List[T])(less:
        (T, T) =&gt; Boolean): List[T] = {
        // та ж реалізація msort,
        // але з перестановкою аргументів
        }</pre>
    <p class="prettyprint linenums language-scala">Тепер виведення типів
      спрацює:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; msortSwapped(abcde)(_ &gt; _)
res69: List[Char] = List(e, d, c, b, a)</pre>
    <p class="prettyprint linenums language-scala">Що трапилось, це те, тепер
      вивід знає тип першого параметра, abcde, щоб визначити параметр типу
      msortSwapped. Коли стає відомий точний тип msortSwapped, він може
      використовуватись в свою чергу для виведення типу другого параметру, (_
      &gt; _).</p>
    <p>Загалом, коли стоїть завдання вивести тип параметрів поліморфного метода,
      алгоритм виведення консультується з типами усіх значень аргументів в
      першому списку параметрів, але не в аргументфх за його межами. Оскільки
      msortSwapped є карованим методом з двома списками параметрів, другий
      аргуент, (тобто, значення функції) не буде братись до уваги для визначення
      параметра типу метода.</p>
    <p>Ця схема виведення підказує наступний принцип розробки бібліотек: при
      розробці поліморфних методів, що приймають деякі нефункціональні
      аргументи, розміщуйте функціональні аргументи останніми в карованому
      списку параметрів, окремо. Таким чином коректний примірник метода може
      бути виведений з нефункціональних аргументів, та цей тип, в свою
      чергу,&nbsp; може бути використаний для перевірки функціонального
      аргумента. Нетто ефект полягає в тому, що користувачі метода будуть в
      змозі надати меньше інформації про тип, та записати функціональні літерали
      в більш компактний спосіб.</p>
    <p>Далі перейдемо до більш складного випадку операції fold. Чому тут є
      потреба в явному параметрі типу, в виразі, як тіло метода flattenRight?</p>
    <pre class="prettyprint linenums language-scala">(xss :\ List[T]()) (_ ::: _)</pre>
    <p>Тип операції правої згортки поліморфний в двох змінних типу. Маючи вираз:</p>
    <pre class="prettyprint linenums language-scala">(xs :\ z) (op)</pre>
    <p>тип xs має бути списком дефкого довільного типу A, скажімо, xs: List[A].
      Початкове значення z може бути деякого іншого типу B. Операція op потім
      має приймати два аргументи типу A та B, та мусить повертати результат типу
      B, тобто, op: (A, B) =&gt; B. Оскільки тип z не пов'язаний з типом списку
      xs, вивід типу не має контекстної інформації щодо z. Тепер розглянемо
      вираз в помилковій версії flattenRight:</p>
    <pre class="prettyprint linenums language-scala">(xss :\ List()) (_ ::: _)
&nbsp;// це не компілюється</pre>
    <p>Початкове значення z в цій згортці є пустий список, List(), так що без
      додаткової інформації типу його тип виводиться з як List[Nothing]. Таким
      чином, вивід буде виводити цей тип B згортки як List[Nothing]. Таким
      чином, операція (_ ::: _) згортки очікується наступного типу: </p>
    <pre class="prettyprint linenums language-scala">(List[T], List[Nothing]) =&gt; List[Nothing]</pre>
    <p>Хоча це можливий тип для операції, такої як fold, але він не дуже
      корисний! Він каже, що операція завжди приймає пустий список в якості
      другого аргумента, та завжди продукує пустий список, як результат. Іншими
      словами, вивід типів дуже рано пристав щодо типу List(), він би мав
      зачекати, доки не побачив би тип операції op. Таким чином (інакше дуже
      корисне правило) розглядати тільки перший розділ аргументів застосування
      карованого метода для визначення типу метода тут полягає як корінь
      проблеми. З іншого боку, навіть якщо це правило послабити, вивід не зможе
      виступити з типом щодо op, тому що типи її параметрів все ще не надані.
      Тобто це замкнене коло, що можна розрішити тільки через явну анотацію типу
      від програміста.</p>
    <p class="prettyprint linenums language-scala">Цей приклад підкреслює деякі
      обмеження локальної, базованої на потоці, схеми виведення Scala. Їх немає
      в більш глобальному стилі виводу Хіндлі-Мілнера, що використовується в
      мовах як ML або Haskell. Однак локальний вивід типів Scala робить значно
      добріше з об'єктно-орієнтовними підтипами, ніж це робить стиль
      Хіндлі-Мілнера. На щастя, показані обмеження виявляють себе тільки в в
      деяких граничних випадках, та зазавичай просто ладнаються додаванням явних
      анотацій типу.</p>
    <p>Додавання анотацій типу також є корисним прийомом налагодження, коли ви
      спантеличені помилками невірних типів, пов'язаних з поліморфними методами.
      Якщо ви не певні щодо того, що спричиняє певну помилку типу, просто
      додайте деякі аргументи типів, або інші анотації типів, що ви вважаєте за
      коректні. Потім ви будете в змозі швидко побачити, де є реальна проблема.</p>
    <h3>16.11 Висновок</h3>
    <p>Тепер ви побачили багато способів роботи зі списками. Ви бачили базові
      операції, як head та tail, операції першого порядка, як reverse, операції
      вищого порядка, як map, та допоміжні методи в об'єкті List.</p>
    <p>Поміж тим ви трохи вивчили щодо того, як роблять типізовані інтерфейси
      Scala. Списки є дійсно робочою конячкою в Scala, так що ви виграєте від
      знання, як їх використовувати. З цієї причини ця глава глибоко занурилась
      в використання списків. Однак списки є тільки одним різновидом колекцій,
      що підтримує&nbsp;Scala. Наступна глава є ширшою, скоріше, ніж глибокою,
      та показує вам, як використовувати різновидь типів колекцій в Scala. </p>
    <h3>Глава 17</h3>
    <h2>Колекції</h2>
    <p>Scala має багату бібліотеку колекцій. Ця глава надає тур по найбільш
      загально уживаних типах та операцій колекцій, показаних як частини, що ви
      будете уживати найбільш часто. Глава 24 надасть більш повний тур того, що
      доступне, та Глава Chapter 25 покаже, як використовуються конструкції
      композиції Scala, щоб провадити таке багате API.</p>
    <h3>17.1&nbsp; Послідовності</h3>
    <p>Типи послідовностей дозволяють вам робити з групами даних, що вистроєні в
      порядок. Оскільки ві елементи впорядковані, ви можете запитати перший
      елемент, другий елемент, 103й елемент, і таке інше. В цьому розділі ви
      отримаєте швидкий тур по найбільш важливим послідовностям. </p>
    <h4>Списки</h4>
    <p>Можливо, найбільш важливий тип послідовності, про який слід знати, є клас
      List, незмінний пов'язаний список, детально описаний в попередній главі.
      Списки підтримують швидке додавання та видалення елементів зпереду списка,
      але вони не провадять швидкого доступа до довільних індексів, бо
      реалізація має лінійно ітерувати по всьому списку.</p>
    <p>Ця комбінація можливостей може видатись безглуздою, але вони підпадають в
      солодке поєднання, що гарно робить для більшості алгоритмів. Швидке
      додавання та видалення перших елементів означає, що гарно робить також і
      порівняння шаблонів, як описано в Главі 15. Незмінність списків допомагає
      вам розробляти коректні, ефективні алгоритми, оскільки вам ніколи не
      потрібно робити копії списків. Ось простий приклад, що показує, як
      ініціалізувати список, та отримати доступ до голови та хвоста:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val colors = List("red", "blue", "green")
colors: List[java.lang.String] = List(red, blue, green)
scala&gt; colors.head
res0: java.lang.String = red
scala&gt; colors.tail
res1: List[java.lang.String] = List(blue, green)</pre>
    <p>Для вступу до списків дивіться Крок 8 в Главі 3, та щодо деталей по
      використанню списків, дивіться Главу 16. Списки також будуть
      обговорюватись в Главі 22, що провадить погляд на те, як списки
      реалізовані в Scala.</p>
    <h4>Масиви</h4>
    <p>Масиви дозволяють вам утримувати послідовність елементів, та ефективно
      мати доступ до елемента в довільній позиції, отримуючи доступ або
      оновлюючи елемент, з індексом починаючи з одиниці. Ось як ви можете
      створити масив, чий розмір ви знаєте, але для якого ви ще не знаєте
      значень елементів: </p>
    <pre class="prettyprint linenums language-scala">scala&gt; val fiveInts = new Array[Int](5)
fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)</pre>
    <p>Ось як ви ініціалізуєте масив, коли ви знаєте значення елементів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val fiveToOne = Array(5, 4, 3, 2, 1)
fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)</pre>
    <p>Як вже зазначалось, доступ до масивів в Scala виконується заданням
      індекса в дужках, не в квадрантих дужкак, я в Java. Ось приклад обох,
      доступу та оновлення елементів масива:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; fiveInts(0) = fiveToOne(4)
scala&gt; fiveInts
res3: Array[Int] = Array(1, 0, 0, 0, 0)</pre>
    <p>Масиви Scala представлені так само, як і масиви Java. Так що ви можете
      безпомилково використовувати методи Java, що повертають масиви. Різниця в
      варіації масивів Scala та Java — тобто, коли Array[String] є підтипом
      Array[AnyRef] — буде обговорено в Розділі 19.3.</p>
    <p>Ви вже бачили масиви в дії багато разів в попередніх главах. Основи надаі
      в Кроці 7 Глави 3. Декілька прикладів ітерування по елементах списку за
      допомогою вираза for показані в Розділі 7.3. Масиви також яскраво
      фігурують в бібліотеці двовимірного розташування в Главі 10.</p>
    <h4>Буфери списків</h4>
    <p>Клас List провадить швидкий доступ до голови списка, але не до кінця.
      Таким чином, коли вам треба побудувати список через додавання в кінець, ви
      маєте розглянути побудову списку навпаки, додаючи елементи в початок, докі
      не скінчите, викликаючи reverse, для отримання елементів в потрібному для
      вас порядку. Інша альтернатива, що уникає операції реверсу, є використання
      ListBuffer. ListBuffer є змінним об'єктом (що міститься в пакунку&nbsp;
      scala.collection.mutable), що може допомогти вам побудувати списки більш
      ефективно, коли вам треба додавати. ListBuffer провадить сталий час для
      операцій append та prepend. Ви додаєте елементи за допомогою оператора +=,
      та передставляєте за допомогою оператора +=:. Коли ви завершуєте побудову,
      ви можете отримати List через виклик toList на ListBuffer. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer
<br>scala&gt; val buf = new ListBuffer[Int]
buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()
<br>scala&gt; buf += 1
res4: buf.type = ListBuffer(1)
<br>scala&gt; buf += 2
res5: buf.type = ListBuffer(1, 2)
<br>scala&gt; buf
res6: scala.collection.mutable.ListBuffer[Int]
= ListBuffer(1, 2)
<br>scala&gt; 3 +=: buf
res7: buf.type = ListBuffer(3, 1, 2)
<br>scala&gt; buf.toList
res8: List[Int] = List(3, 1, 2)</pre>
    <p>Інша причина для використання ListBuffer замість List є запобігти
      потенціальному ризику переповнення стека. Якщо ви будуєте список в
      бажаному порядку через передстанову, але рекурсивний алгоритм, що вам
      потрібен, не є кінцево-рекурсивним, ви можете замість цього
      використовувати вираз for або цикл while, та ListBuffer. Ви побачите
      ListBuffer, що використовується в такий спосіб, в Розділі 22.2.</p>
    <h4>Буфери масивів</h4>
    <p>ArrayBuffer подібні до масивів, за тим винятком, що ви додатково можете
      додавати та видаляти елементи з початку та кінці послідовності. Доступні
      всі операції Array, хоча вони трохи повільніші, через шар огортки в
      реалізації. Нові операції додавання та видалення в середньому мають сталий
      час, але часом потребують лінійний час, через те, що реалізація має
      розміщувати новий масив, що утримує вміст буфера. Щоб використовувати
      ArrayBuffer вам треба спершу імпортувати пакунок змінних колекцій:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.ArrayBuffer</pre>
    <p>Коли ви створюєте ArrayBuffer, ви маєте задати параметр типу, але не
      повинні задавати довжину. ArrayBuffer буде підлаштовувати розміщений
      простір автоматично, по мірі потреби:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val buf = new ArrayBuffer[Int]()
buf: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer()</pre>
    <p>Ви можете додавати до ArrayBuffer за допомогою метода +=:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; buf += 12
res9: buf.type = ArrayBuffer(12)
<br>scala&gt; buf += 15
res10: buf.type = ArrayBuffer(12, 15)
<br>scala&gt; buf
res11: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer(12, 15)</pre>
    <p>Доступні всі методи звичайних масивів. Наприклад, ви можете запитати
      довжину ArrayBuffer, але ви можете отримати елемент за його індексом:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; buf.length
res12: Int = 2
scala&gt; buf(0)
res13: Int = 12</pre>
    <h4>Рядки (через StringOps)</h4>
    <p>Одна інша послідовність, про яку треба знати, є StringOps, що реалізує
      багато методів послідовностей. Оскільки Predef має неявне перетворення з
      String на StringOps, ви можете трактовати любий рядок як послідовність.
      Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpper)
hasUpperCase: (s: String)Boolean
<br>scala&gt; hasUpperCase("Robert Frost")
res14: Boolean = true
<br>scala&gt; hasUpperCase("e e cummings")
res15: Boolean = false</pre>
    <p>В цьому прикладі метод exists викликається для рядка на ім'я s в тілі
      метода hasUpperCase. Оскільки немає метода з назвою “exists”,
      задекларованого для самого класа String, компілятор Scala буде неявно
      конвертувати s на StringOps, що має такий метод. Метод exists розглядає
      рядок як послідовність символів, та буде повертати true, якжо любий з
      символів в верхньому реєстрі.</p>
    <h3>17.2 Множини та мапи</h3>
    <p>Ви вже бачили основи множин та мап в попередніх главах, починаючи з Кроку
      10 в Главі 3. В цьому розділі ми отримаємо більше розуміння щодо їх
      використання, та покажемо трохи більше прикладів. Як вже зазначалось,
      бібліотека колекцій Scala пропонує обоє, змінні та незмінні версії множин
      та мап. Ієрархія для множин показана на Малюнку 3.2, та ієрархія для мап
      показана на Малюнку 3.3. Як показують ці діаграми, прості імена Set та Map
      використовуються в трьох трейтах кожне, що знаходяться в різних пакунках.</p>
    <p>По замовчанню, коли ви пишете “Set” або “Map”, ви отримуєте незмінний
      об'єкт. Якщо ви бажаєте змінний варіант, вам треба виконати явний імпорт.
      Scala дає вам простіший доступ до незмінних варіантів, в якості м'якого
      заохочення до їх використання, ніж змінних варіантів. Простий дступ
      провадяться через об'єкт Predef, що неявно імпортований в кожний
      файл&nbsp; програми Scala. Лістинг 17.1 показує відповідні визначення:</p>
    <pre class="prettyprint linenums language-scala">object Predef {
  type Map[A, +B] = collection.immutable.Map[A, B]
  type Set[A] = collection.immutable.Set[A]
  val Map = collection.immutable.Map
  val Set = collection.immutable.Set
// ...
}</pre>
    <p>Лістинг 17.1 Мапи та множини по замовчанню, визначення в Predef.</p>
    <p>Ключове слово “type”, що використовується в Predef для визначення
      псевдонимів Set та Map для довших, більш повно кваліфікованих імен трейтів
      незмінних множин та мап. Змінні val на ім'я Set та Map ініціалізовані для
      посилання на об'єкти-синглтони для незмінних Set та Map. так що Map є те ж
      саме, що Predef.Map, що визначене бути тим самим, що і
      scala.collection.immutable.Map. Це дійсне для типа Map, та об'єкта Map.</p>
    <p>Якщо ви бажаєте використати обоє, змінні та незмінні множини та мапи в
      одному файлі, один підхід є імпортувати ім'я пакунку, що містить змінні
      варіанти:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable</pre>
    <p>Ви можете продовжувати посилатись на незмінні множини як Set, як і
      раніше, але можете тепер посилатись на змінні множини, як mutable.Set. Ось
      приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val mutaSet = mutable.Set(1, 2, 3)
mutaSet: scala.collection.mutable.Set[Int] = Set(3, 1, 2)</pre>
    <h3>Розділ 17.2 Використання множин</h3>
    <p>Ключова характеристика множин полягає в тому, що вони дають впевненість,
      що кожний окремий об'єкт, як визначається ==, буде міститись в множині в
      кожний проміжок часу. Як приклад, ми будемо використовувати множину для
      підрахунка різних слів в рядку.&nbsp;</p>
    <p>Метод split в String може розділити рядок на слова, якщо ви зададете
      проміжки та знаки пунктуації як роздільники. Регулярний вираз “[ !,.]+”
      буде достатній: він вказує, що рядок має бути розбитий в кожному місці, де
      стоїть проміжок або символи пунктуації:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val text = "See Spot run. Run, Spot. Run!"
text: java.lang.String = See Spot run. Run, Spot. Run!
scala&gt; val wordsArray = text.split("[ !,.]+")
wordsArray: Array[java.lang.String]
= Array(See, Spot, run, Run, Spot, Run)</pre>
    <p>Щоб порахувати різні слова, ви можете перевести їх в один реєстр, та
      потім доодати до множини. Оскільки множина виключає дублювання, кожне
      окреме слово буде з'являтись в множині рівно один раз. Спершу ви можете
      створити порожню множину, з використанням порожнього метода, що провадить
      об'єкт-компан'он Set:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val words = mutable.Set.empty[String]
words: scala.collection.mutable.Set[String] = Set()</pre>
    <p>Потім просто ітеруємо по словах за допомогою вираза for, конвертуючи
      кожне слово в змінний набір за допомогою оператора +=:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; for (word &lt;- wordsArray)
words += word.toLowerCase
scala&gt; words
res17: scala.collection.mutable.Set[String]
= Set(spot, run, see)</pre>
    <p>Таким чином, текст містить рівно три різні слова: spot, run, та see.
      Найбільш загально уживані методи на обох, змінних та незмінних множинах
      показані в Таблиці 17.1.</p>
    <h4>Використання мап</h4>
    <p>Мапи дозволяють вам асоціювати значення з кожним елементом колекції.
      Використання мап подібне до використання масива, за тім винятком, що
      замість індексації цілими починаючи з нуля, ви можете використовувати
      любий тип ключа. Якщо ви імпортуєте пакунок scala.collection.mutable, ви
      можете створити пусту змінну мапу:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val map = mutable.Map.empty[String, Int]
map: scala.collection.mutable.Map[String,Int] = Map()</pre>
    <p>Таблиця 17.1 Загальні операції для множин</p>
    <table style="width: 674px; height: 327px;" border="1">
      <tbody>
        <tr>
          <td>val nums = Set(1, 2, 3)</td>
          <td>Створює незмінну множину<br>
            (nums.toString повертає Set(1, 2, 3))</td>
        </tr>
        <tr>
          <td>nums + 5</td>
          <td>Додає елемент (повертає<br>
            Set(1, 2, 3, 5))</td>
        </tr>
        <tr>
          <td>nums - 3</td>
          <td>Видаляє елемент (повертає Set(1, 2))</td>
        </tr>
        <tr>
          <td>nums ++ List(5, 6)</td>
          <td>Додає декілька елементів (повертає<br>
            Set(1, 2, 3, 5, 6))</td>
        </tr>
        <tr>
          <td>nums -- List(1, 2)</td>
          <td>Видаляє декілька елементів (повертає<br>
            Set(3))</td>
        </tr>
        <tr>
          <td>nums &amp; Set(1, 3, 5, 7)</td>
          <td><br>
            Приймає перетин двох множин (повертає Set(1, 3))</td>
        </tr>
        <tr>
          <td>nums.size</td>
          <td>Повертає розмір множини (повертає 3)</td>
        </tr>
        <tr>
          <td>nums.contains(3)</td>
          <td>Перевіряє включення (повертає true)</td>
        </tr>
        <tr>
          <td>import scala.collection.mutable</td>
          <td>Робить змінну колекцію простою для доступу</td>
        </tr>
        <tr>
          <td>val words = mutable.Set.empty[String]</td>
          <td><br>
            Створює пусту змінну множину<br>
            (words.toString returns Set())</td>
        </tr>
        <tr>
          <td>words += "the"</td>
          <td>Додає елемент (words.toString<br>
            повертає Set(the))</td>
        </tr>
        <tr>
          <td>words -= "the"</td>
          <td>Видаляє елемент, якщо він існує<br>
            (words.toString повертає Set())</td>
        </tr>
        <tr>
          <td>words ++= List("do", "re", "mi")</td>
          <td><br>
            Додає декілька елементів (words.toString повертає Set(do, re, mi))</td>
        </tr>
        <tr>
          <td>words --= List("do", "re")</td>
          <td>Видаляє декілька елементів (words.toString повертає Set(mi))</td>
        </tr>
        <tr>
          <td>words.clear</td>
          <td>Видаляє всі елементи (words.toString<br>
            повертає Set())</td>
        </tr>
      </tbody>
    </table>
    <p>Зауважте, що коли ви створюєте мапу, ви маєте задати два типа. Перший тип
      для ключів мапи, другий для значень. В цьому випадку ключі є рядками та
      цілими значеннями. Всатновлення елементів для мап виглядають подібними до
      встановлення значень масиву:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; map("hello") = 1
scala&gt; map("there") = 2
scala&gt; map
res20: scala.collection.mutable.Map[String,Int] =
Map(hello -&gt; 1, there -&gt; 2)</pre>
    <p>Подібним чином, читання мапи подібне до читання масива:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; map("hello")
res21: Int = 1</pre>
    <p>Складаючи все до купи, ось метод, що підраховує число разів, що кожне
      слово трапляєтсья в рядку:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def countWords(text: String) = {
  val counts = mutable.Map.empty[String, Int]
  for (rawWord &lt;- text.split("[ ,!.]+")) {
    val word = rawWord.toLowerCase
    val oldCount =
      if (counts.contains(word)) counts(word)
      else 0
    counts += (word -&gt; (oldCount + 1))
  }
  counts
}
countWords: (text: String)scala.collection.mutable.Map[String,Int]
<br>scala&gt; countWords("See Spot run! Run, Spot. Run!")
res22: scala.collection.mutable.Map[String,Int]
= Map(see -&gt; 1, run -&gt; 3, spot -&gt; 2)</pre>
    <p>Маючи цей підрахунок, ви можете бачити, що цей текст каже багато про біг,
      але не дуже багато про те, щоб бачити. Спосіб, в який робить цей текст, це
      змінна мапа на ім'я counts, що відображує кожне слово на число разів, яке
      вона трапляється в тексті. Для кожного слова в тексті переглядається старе
      значення в мапі, потім лічильник збільшується на один, на нове значення
      зберігається знову в counts. Зауважете викорастання contains для
      перевірки, чи слово вже зустрічалось, або ні. Якщо counts.contains(word)
      не дорівнює true, тоді слово ще не зустрічалось, та лічильник
      встановлюється в нуль.</p>
    <p>Більшість з найбільш використовуваних методів, загальних для змінних та
      незмінних мап, показані в Таблиці 17.2.</p>
    <p>Таблиця 17.2 Загальні операції для мап</p>
    <table style="width: 674px; height: 202px;" border="1">
      <tbody>
        <tr>
          <td>val nums = Map("i" -&gt; 1, "ii" -&gt; 2)</td>
          <td>Створює незмінну мапу<br>
            (nums.toString повертає Map(i -&gt; 1, ii -&gt; 2))</td>
        </tr>
        <tr>
          <td>nums + ("vi" -&gt; 6)</td>
          <td>Додає елемент (повертає Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6))</td>
        </tr>
        <tr>
          <td>nums - "ii"</td>
          <td>Видаляє елемент (повератє Map(i -&gt; 1))</td>
        </tr>
        <tr>
          <td>nums ++ List("iii" -&gt; 3, "v" -&gt; 5)</td>
          <td>Додає декілька елементів (повертає<br>
            Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5))</td>
        </tr>
        <tr>
          <td>nums -- List("i", "ii")</td>
          <td>Видаляє декілька елементів (повертає Map())</td>
        </tr>
        <tr>
          <td>nums.size</td>
          <td>Повертає розмір мапи (повертає 2)</td>
        </tr>
        <tr>
          <td>nums.contains("ii") </td>
          <td>Перевіряє входження (повертає true)</td>
        </tr>
        <tr>
          <td>nums("ii")</td>
          <td>Повертає значення ключа (повертає 2)</td>
        </tr>
        <tr>
          <td>nums.keys</td>
          <td>Повертає ключі (повертає Iteratable по рядках "i" та "ii")</td>
        </tr>
        <tr>
          <td>nums.keySet</td>
          <td><br>
            Повертає ключі як множину (повертає Set(i, ii))</td>
        </tr>
        <tr>
          <td>nums.values</td>
          <td>Повертає значення (повертає Iterable по цілих 1 та 2)</td>
        </tr>
        <tr>
          <td>nums.isEmpty</td>
          <td>Вказує, чи мапа порожня (повертає false)</td>
        </tr>
        <tr>
          <td>import scala.collection.mutable</td>
          <td><br>
            Робить змінну колекцію простішою для доступу</td>
        </tr>
        <tr>
          <td>val words = mutable.Map.empty[String, Int]</td>
          <td><br>
            Створює пусту змінну мапу</td>
        </tr>
        <tr>
          <td>words += ("one" -&gt; 1)</td>
          <td><br>
            Додає елемент мапи від "one" до 1<br>
            (words.toString повертає Map(one -&gt; 1))</td>
        </tr>
        <tr>
          <td>words -= "one"</td>
          <td>Видаляє елемент мапи, якщо він існує (words.toString повертає
            Map())</td>
        </tr>
        <tr>
          <td>words ++= List("one" -&gt; 1, "two" -&gt; 2, "three" -&gt; 3)</td>
          <td>Додає декілька елементів мапи (words.toString повертає<br>
            Map(one -&gt; 1, two -&gt; 2, three -&gt; 3))</td>
        </tr>
        <tr>
          <td>words --= List("one", "two")</td>
          <td>Видаляє декілька об'єктів (words.toString повертає Map(three -&gt;
            3))</td>
        </tr>
      </tbody>
    </table>
    <h4>Множини та мапи по замовчанню</h4>
    <p>Для більшості застосувань реалізації змінних та незмінних множин та мап,
      що провадяться фабриками Set(), scala.collection.mutable.Map(), тощо,
      вірогідно буде достатнім. Реалізації, що провадяться ціма фабриками,
      використовують алгоритм швидкого перегляду, що звичайно включає хеш
      таблиця, так що вони можуть швидко визначити, є чи нема об'єкта в
      колекції. Метод-фабрика scala.collection.mutable.Set(), наприклад,
      повертає scala.collection.mutable.HashSet, що використовує хеш таблицю
      зсередини. Подібним чином фабрика scala.collection.mutable.Map() повертає
      scala.collection.mutable.HashMap. <br>
    </p>
    <p>Таблиця 17.3 Загальні реалізації множин</p>
    <p>Число елементів <br>
      0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      scala.collection.immutable.EmptySet<br>
      1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set1<br>
      2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set2<br>
      3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set3<br>
      4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Set4<br>
      5 або більше&nbsp; scala.collection.immutable.HashSet</p>
    Історія з незмінними множинами та мапами трохи складніша. Клас, що
    повертається методом-фабрикою scala.collection.immutable.Set(), наприклад,
    залежить від того, як багато елементів ви передаєте в нього, як показане в
    Таблиці 17.3. Для множин з меньше ніж п'ять елементів виділений спеціальний
    клас для множин кожного певного розміру, задля підвищення продуктивності. Як
    тільки ви запитали множину, що має п'ять або більше елементів, метод-фабрика
    буде повертати реалізацію, що використовує хеші. Подібним чином,
    метод-фабрика scala.collection.immutable.Map() буде повертати інший клас, в
    залежності від того, скільки пар ключ-значення ви передаєте йому, як
    показано в Таблиці 17.4. Як і з множинами, для незмінних мап з меньше ніж
    п'ятьма елементами виділений спеціальний клас, ексклюзивно для мап з заданим
    числом елементів, щоб підвищити продуктивність. Однак коли мапа має п'ять
    або більше пар ключ-значення, використовується незмінна реалізація HashMap.
    <p>Таблиця 17.4 Реалізації по замовчанню незмінних мап</p>
    <p>Число елементів<br>
      0 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.EmptyMap<br>
      1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map1<br>
      2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map2<br>
      3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map3<br>
      4 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.immutable.Map4<br>
      5 або більше&nbsp; scala.collection.immutable.HashMap</p>
    <p>Незмінні реалізації класів по замовчанню показані в Таблиці 17.3 та 17.4
      роблять разом, щоб надати вам максимальну продуктивність. Наприклад, якщо
      ви додасте елемент до EmptySet, він повернеться як Set1. Якщо ви додасте
      елемент до цього Set1, він повернеться як Set2. Якщо ви видалите елемент з
      Set2, ви отримаєте новий Set1.</p>
    <h4>Впорядковані множини та мапи</h4>
    <p>Час від часу вам може знадобитись множина або мапа, чий ітератор повертає
      елементи в певному порядку. Для цього бібліотека колекцій Scala провадить
      трейти SortedSet та SortedMap. Ці трейти реалізовані через класи TreeSet
      та TreeMap, що використовують дерева червоне-чорне для зберігання
      елементів (в випадку TreeSet) або ключів (в випадку TreeMap) впорядковано.
      Порядок визначається трейтом Ordered, тип елементів якого для множини або
      тип ключа для мапи, має бути або підмішаний, або до якого є неявна
      конвертація. Ці класи ідуть тільки в незмінних варіаціях. Ось деякі
      приклади TreeSet:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
<br>scala&gt; val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
ts: scala.collection.immutable.TreeSet[Int]
= TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
<br>scala&gt; val cs = TreeSet('f', 'u', 'n')
cs: scala.collection.immutable.TreeSet[Char]
= TreeSet(f, n, u)</pre>
    <p>Та ось деякі приклади TreeMap:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeMap
import scala.collection.immutable.TreeMap
<br>scala&gt; var tm = TreeMap(3 -&gt; 'x', 1 -&gt; 'x', 4 -&gt; 'x')
tm: scala.collection.immutable.TreeMap[Int,Char]
= Map(1 -&gt; x, 3 -&gt; x, 4 -&gt; x)
<br>scala&gt; tm += (2 -&gt; 'x')
<br>scala&gt; tm
res30: scala.collection.immutable.TreeMap[Int,Char]
= Map(1 -&gt; x, 2 -&gt; x, 3 -&gt; x, 4 -&gt; x)
</pre>
    <h3>17.3 Обрання змінних проти незмінних колекцій</h3>
    <p>Для деяких проблем змінні колекції роблять краще, та для інших краще
      роблять незмінні колекції. Коли ви маєте сумнів, краще почати з незмінної
      колекції, та змінити її пізніше, якщо буде потреба, оскільки незмінні
      колекції можуть бути простіше зрозуміти, ніж змінні. Також часом варте
      того пійти зворотнім шляхом. Якщо ви бачите, що код, що використовує
      змінні колекції, стає ускладненим та складним для промислення, розгляньте,
      чи не допоможе змінити деякі з колекцій на незмінні альтернативи. Зокрема,
      якщо ви починаєте турбуватись щодо роблення копій змінних колекцій тільки
      в певних місцях, або забагато міркуєте щодо “володіє” або “містить” змінна
      колекція, розгляньте перехід деяких з колекцій до їх незмінних колекцій. </p>
    <p>Окрім того, що про них краще продумувати, незмінні колекції звичано
      можуть зберігатись більш компактно, ніж змінні, якщо кількість зберігаємих
      в колекції елементів мале. Наприклад, пуста змінна мапа в своїй
      репрезентації по замовчанню HashMap займає приміром 80 байт, та на 16
      більше додається для кожного елемента, що ви додаєте до неї. Пуста
      незмінна мапа Map є єдиний об'єкт, що поділяється між всіма посиланнями,
      так що посилання на неї в основному коштує тільки одного поля посилання.
      Що більше, бібліотека колекцій Scala наразі зберігає незмінні мапи та
      множини до п'яти елементів в одному об'єкті, що, зазвичай займає від 16 до
      40 байтів, в залежності від числа елементів, що зберігаються в колекції.
      Так що для малих мар та множин незмінні версії також значно компакніші, ні
      змінні. Беручи до уваги, що багато колекцій є малими, перехід на незмінні
      може надати важливу економію простору, та вигоди продуктивності.&nbsp;</p>
    <p>Щоб легше переходити на незмінні колекції, та навпаки, Scala провадить
      деякий синтаксичний цукор. Навіть хоча незмінні множини та мапи не
      підтримують справжніх методів +=, Scala дає корисну альтернативну
      інтерпретацію +=. Коли ви пишете a += b, та a не підтримує метод з
      назвою&nbsp; +=, Scala буде намагатись інтерпретувати це як a = a + b.
      Наприклад, незмінні множини не підтримують оператора +=:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane)</pre>
    <p>Цей “єдиний об'єкт” є примірником від Set1 до Set4, або Map1 до Map4, як
      показане в Таблиці 17.3 та 17.4.</p>
    <pre class="prettyprint linenums language-scala">scala&gt; people += "Bob"
&lt;console&gt;:11: error: reassignment to val
people += "Bob"
ˆ
</pre>
    <p>Однак якщо ви визначите people як var, замість val, тоді колекція може
      бути "оповлена" за допомогою операції +=, не зважаючи, що вона незмінна.
      Спершу буде створена нова колекція, та потім people присвоєно до нової
      колекції:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; var people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane)
scala&gt; people += "Bob"
scala&gt; people
res34: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Jane, Bob)</pre>
    <p>Після цієї серії тверджень, змінна people посилається на новий незмінний
      набір, що містить доданий рядок, "Bob". Та ж ідея стосується кожного
      метода, що завершується на =, не тільки метод +=. Це той же синтаксис, що
      і використовується для оператора -=, що видаляє елемент з множини, та
      оператор ++=, що додає до множини елементи колекції:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; people -= "Jane"
scala&gt; people ++= List("Tom", "Harry")
scala&gt; people
res37: scala.collection.immutable.Set[java.lang.String] =
Set(Nancy, Bob, Tom, Harry)</pre>
    <p>Щоб побачити, наскільки це важливо, розглянемо наступну мапу з Розділу
      1.1:</p>
    <pre class="prettyprint linenums language-scala">var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
capital += ("Japan" -&gt; "Tokyo")
println(capital("France"))</pre>
    <p>Цей код використовує незмінні колекції. Якщо ви бажаєте замість цього
      використати змінні колекції, все, що вам потрібно, це імпортувати змінну
      версію Map, та, таким чином, перевизначити імпорт незмінної Map по
      замовчанню:</p>
    <pre class="prettyprint linenums language-scala">import scala.collection.mutable.Map
&nbsp;// все що треба зробити!
var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
capital += ("Japan" -&gt; "Tokyo")
println(capital("France"))</pre>
    <p>Не всі приклади такі прості для конвертації, але особливе трактування
      методів, що закінчуються на знак рівності, часто буде зменшувати кількість
      кода, що треба змінювати.</p>
    <p>Поміж іншим, це синтаксичне трактування діє також на частину значень, не
      тільки на колекції. Наприклад, ось як це робить для чисел з плаваючою
      крапкою:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; var roughlyPi = 3.0
roughlyPi: Double = 3.0
<br>scala&gt; roughlyPi += 0.1
<br>scala&gt; roughlyPi += 0.04
<br>scala&gt; roughlyPi
res40: Double = 3.14</pre>
    <p>Ефект від цього розширення подібний до операторів присвоєння Java, +=,
      -=,<br>
      *=, тощо, але він більш загальний, оскільки кожний оператор, що
      завершується на =, може бути конвертований.</p>
    <h3>17.4&nbsp; Ініціалізація колекцій</h3>
    <p>Як ви бачили напередодні, найбільш загальний шлях створити та
      ініціалізувати колекцію є передати початкові елементи до метода-фабрики
      об'єкта-компанйона вашої обраної колекції. Ви тільки кладете елементи в
      дужки після імені о'бєкта-компанйона, та компілятор Scala буде
      трансформувати це як виклик метода apply на цьому об'єкті-компанйоні:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3)
res41: List[Int] = List(1, 2, 3)
<br>scala&gt; Set('a', 'b', 'c')
res42: scala.collection.immutable.Set[Char] = Set(a, b, c)
<br>scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; mutable.Map("hi" -&gt; 2, "there" -&gt; 5)
res43: scala.collection.mutable.Map[java.lang.String,Int] =
Map(hi -&gt; 2, there -&gt; 5)
<br>scala&gt; Array(1.0, 2.0, 3.0)
res44: Array[Double] = Array(1.0, 2.0, 3.0)</pre>
    <p>Хоча більше часто ви можете дозволити компілятору Scala вивести тип
      елемента колекції з елементів, переданих до його метода-фабрики, іноді ви
      можете побажати створити колекцію, але вказати інший тип, відмміний від
      того, який обирає компілятор. Це особливо проблематично для змінних
      колекцій. Ось приклад:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; val stuff = mutable.Set(42)
stuff: scala.collection.mutable.Set[Int] = Set(42)
<br>scala&gt; stuff += "abracadabra"
&lt;console&gt;:15: error: type mismatch;
found
&nbsp;: java.lang.String("abracadabra")
required: Int
stuff += "abracadabra"
ˆ
</pre>
    <p> Тут проблема в тому, що персонал взяв тип елемента за Int. Якщо ви
      бажаєте мати тип елемента Any, вам треба сказати це явно, поклавши тип
      елемента в квадратні дужки:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val stuff = mutable.Set[Any](42)
stuff: scala.collection.mutable.Set[Any] = Set(42)</pre>
    <p>Інша особлива ситуація - це коли ви бажаєте ініціалізувати колекцію іншою
      колекцією. Наприклад, уявіть, що ви маєте список, але ви бажаєте TreeSet,
      що містить елементи в списку. Ось список:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val colors = List("blue", "yellow", "red", "green")
colors: List[java.lang.String]
= List(blue, yellow, red, green)</pre>
    <p>Ви не можете передати список colors до метода-фабрики TreeSet:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
<br>scala&gt; val treeSet = TreeSet(colors)
&lt;console&gt;:15: error: could not find implicit value for
parameter ord: Ordering[List[java.lang.String]]
val treeSet = TreeSet(colors)
ˆ
</pre>
    <p>Замість цього, вам треба створити пустий TreeSet[String], та додати до
      його елементи списку за допомогою оператора ++ TreeSet:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val treeSet = TreeSet[String]() ++ colors
treeSet: scala.collection.immutable.TreeSet[String]
= TreeSet(blue, green, red, yellow)</pre>
    <h4>Перетворення масива на список</h4>
    <p>З іншого боку, якщо ви бажаєте ініціалізувати список або масив за
      допомогою іншої колекції, це досить прямолінійно. Як ви вже бачили, щоб
      ініціалізувати новий список іншою колекцією, просто викличте toList на цій
      колекції:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; treeSet.toList
res50: List[String] = List(blue, green, red, yellow)
</pre>
    <p>Або, якщо вам потрібен масив, викличте toArray:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; treeSet.toArray
res51: Array[String] = Array(blue, green, red, yellow)</pre>
    <p>Зауважет, що хоча оригінальний список colors не був відсортирований,
      елементи в списку, що спродукований викликом toList на TreeSet знаходяться
      в алфавітному порядку. Коли ви викликаєте toList або toArray на колекції,
      порядок елементів в отриманому списку буде той самий, що і порядок
      елементів, що продукує ітератор, отриманий від виклику елементів на цій
      колекції. Оскільки ітератор TreeSet[String] буде продукувати рядки в
      алфавітному порядку, ці рядки будуть з'являтись в алфавітному порядку в
      списку, що утвориться в результаті виклику toList на цьому TreeSet.</p>
    <p>Майте на увазі, що перетворення на список або масив зазвичай потребує
      копіювання всіх елементів колекції, та, таким чином, може бути повільним
      для великих колекцій. Однак іноді вам треба зробити це через існуюче API.
      Більше того, багато колекцій мають тільки декілька елементів, в якому разі
      це тільки невелике пенальті по швидкості.</p>
    <h4>Перетворення між змінними та незмінними множинами та мапами</h4>
    <p>Інша ситуація, що часом постає, це потреба конвертувати змінну множину
      або мапу до незмінної, або навпаки. Щоб досягти цього, ви можете
      використовувати прийом, показаний на попередній сторінці, де ініціалізуємо
      TreeSet елементами списка. Створіть колекцію нового типа, з використанням
      пустого метода, та потім додайте нові елементи з використанням ++ або ++=,
      як потрібно для цільового типу колекції. Ось як ви конвертуєте незмінний
      TreeSet з попереднього приклада на змінну множину, та знову назад, до
      незмінної:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import scala.collection.mutable
import scala.collection.mutable
<br>scala&gt; treeSet
res52: scala.collection.immutable.TreeSet[String] =
TreeSet(blue, green, red, yellow)
<br>scala&gt; val mutaSet = mutable.Set.empty ++= treeSet
mutaSet: scala.collection.mutable.Set[String] =
Set(yellow, blue, red, green)
<br>scala&gt; val immutaSet = Set.empty ++ mutaSet
immutaSet: scala.collection.immutable.Set[String] =
Set(yellow, blue, red, green)</pre>
    <p>Ви можете використовувати той самий прийом для перетвореня між змінними
      та незмінними мапами:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val muta = mutable.Map("i" -&gt; 1, "ii" -&gt; 2)
muta: scala.collection.mutable.Map[java.lang.String,Int] =
  Map(ii -&gt; 2, i -&gt; 1)
<br>scala&gt; val immu = Map.empty ++ muta
immu: scala.collection.immutable.Map[java.lang.String,Int] =
  Map(ii -&gt; 2, i -&gt; 1)</pre>
    <h3>17.5 Кортежі</h3>
    <p>Як описане в Кроці 9 в Главі 3, кортеж комбінує фіксоване число елементів
      разом, так що вони можуть бути передані далі як одне ціле. На відміну від
      масивів або списків, кортеж може містити об'єкти різних типів. Ось приклад
      кортежу, що містить ціле, рядок та консоль:</p>
    <pre class="prettyprint linenums language-scala">(1, "hello", Console)</pre>
    <p>Кортежі зберігають вас від нудьги визначеня простих класів для збереження
      даних. Навіть не зважаючи на те, що визначення класів просте, воно вимагає
      певного мінімального зусилля, що іноді нічому не служить. Кортежі
      зберігають вас від зусиль по іменуванню класів, обрання поля зору для
      визначення класа, та обрання імен для членів класа. Якщо клас просто
      містить ціле та рядок, ніякої ясності не додається, якщо цей клас названий
      AnIntegerAndAString.</p>
    <p>Оскільки кортежі можуть поєднувати об'єкти різних типів, кортежі не
      походять від Traversable. Якщо ви бажаєте групувати саме одне ціле і один
      рядок, тоді ви бажаєте кортеж, не List або Array. Загальне застосування
      кортежів - повертати декілька значень з метода. Наприклад, ось метод, що
      шукає найдовше слово в колекції, та також повертає його індекс:</p>
    <pre class="prettyprint linenums language-scala">def longestWord(words: Array[String]) = {
  var word = words(0)
  var idx = 0
  for (i &lt;- 1 until words.length)
    if (words(i).length &gt; word.length) {
      word = words(i)
      idx = i
    }
  (word, idx)
}</pre>
    <p>Ось приклад використання цього метода:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val longest =
longestWord("The quick brown fox".split(" "))
longest: (String, Int) = (quick,1)</pre>
    <p>Функція longestWord обчислює тут две елемента: слово, найбільше в масиві
      idx, та індекс цього слова. Щоб утримувати речі протсішими, функція
      вважає, що в списку є щонайменьше одне слово, та вона облишає спроби,
      обираючи слово, що іде раніше в списку. Як тільки функція обрала, яке
      слово з яким індексом повертати, вона повертає обоє разом, використовуючи
      синтаксис кортежа (word, idx).</p>
    <p>Щоб отримати доступ до елемента в кортежі, ви можете використовувати
      метод _1 для доступу до першого елемента, _2 для доступа до другого, і так
      далі:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; longest._1
res53: String = quick
scala&gt; longest._2
res54: Int = 1</pre>
    <p>Додатково, ви можете призначити кожний елемент кортежа до власної
      змінної, ось так:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val (word, idx) = longest
word: String = quick
idx: Int = 1
scala&gt; word
res55: String = quick</pre>
    <p>Проміж іншим, якщо ви лишите дужки, ви отримаєте інший результат:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val word, idx = longest
word: (String, Int) = (quick,1)
idx: (String, Int) = (quick,1)</pre>
    <p>Цей синтаксис надає декільком визначенням один вираз. Кожна змінна
      ініціалізується власним обчисленням з правої сторони. Те, що вираз
      обчислюється до кортежу, в данному випадку не має значення. Обі змінні
      ініціалізовані до цілого кортежу. Дивіться Главу 18 щодо деяких прикладів,
      де множинні визначення є зручними.&nbsp;</p>
    <p>В якості застереження, використання кортежів є дуже простим. Кортежі
      величні, коли ви комбінуєте дані, що не мають значення, окрім “це A та B”.
      Однак, коли комбінація має деяке значення, або ви бажаєте додати деякі
      методи до комбінації, краще піти далі, та створити клас. Наприклад, не
      використовуйте 3-кортеж для комбінації дня, місяця та року. Створіть клас
      Date. Це зробить ваші наміри очевидними, що однаково, прояснює код для
      людей-читачів, та дає компілятору та мові нагоду допомоготи вам виявити
      помилки.&nbsp;</p>
    <h3>17.6 Висновок</h3>
    <p>Ця глава надала огляд бібліотеки колекцій Scala, на найбільш важливих
      класів, що складають її. З цім підгрунтям ви повинні бути в змозі
      ефективно робити з колекціями Scala, та знати, де дивитись в Scaladoc,
      коли вам треба більше інформації. Щодо додаткових деталей відносно
      колекцій Scala дивіться далі в Главі 24 та главі 25. Наразі, в наступній
      главі, ми звернемо нашу увагу знову з бібліотек Scala на саму мову, та
      обсудимо підтримку в Scala змінних об'єктів. </p>
    <h3> Глава 18</h3>
    <h2>Об'єкти зі станом</h2>
    В попередніх главах ми фокусувались на функціональних (незмінних) об'єктах.
    Ми робили так, тому що ідея об'єктів без любого змінного стану заслуговує
    кращого ознайомлення. Однак в Scala також цілком можливо визначати об'єкти
    зі змінним станом. Такі об'єкти зі станом часто виглядають природними, коли
    ви бажаєте змоделювати об'єкти реального світу, що змінюються з часом. <br>
    <br>
    Ця глава пояснює, що таке о'бєкти зі станом, та що провадить Scala в
    термінах синтаксису, щоб виражати їх. Друга частина цієї глави вводить
    бульше дослідження щодо симуляції дискретних подій, що включає об'єкти зі
    станом, так само, як внутрішню галузеву мову (DSL) для визначення
    симульованих цифрових пристроїв.<br>
    <br>
    <h3>18.1 Що робить об'єкт об'єктом зі станом?</h3>
    Ви можете дослідити принципову різницю між чисто функціональним об'єктом, та
    об'єктом зі станом, навіть без погляду на реалізацію об'єкта. Коли ви
    викликаєте метод або отримуєте поле для деякого чистого функціонального
    об'єкта, ви завжди будете отримувати той самий результат. Наприклад, маючи
    список символів:<br>
    <pre class="prettyprint linenums language-scala">val cs = List('a', 'b', 'c')</pre>
    <p>застосування ancs.head буде завжди повертає 'a'. Це буде так, навіть якщо
      є довільне число операцій зі списком cs між точкою, де він визначений, та
      точкою, де здійснюється доступ до cs.head. З іншого боку, для об'єкта зі
      станом результат виклику метода або доступ до поля може залежати від
      операцій, що до цього виконувались з о'бєктом. Гарний приклад о'бєкта зі
      станом є банківській рахунок. Лістинг 18.1 показує спрощену реалізацію
      банківського рахунку:</p>
    <pre class="prettyprint linenums language-scala">class BankAccount {<br>  private var bal: Int = 0
  def balance: Int = bal
  def deposit(amount: Int) {
    require(amount &gt; 0)
    bal += amount
  }
  def withdraw(amount: Int): Boolean =
    if (amount &gt; bal) false
    else {
      bal -= amount
      true
    }
  }</pre>
    <p>Лістинг 18.1 Змінний клас банковського рахунку.</p>
    <p>Клас BankAccount визначає приватну змінну bal, та три публічні методи:
      balance повертає поточний баланс; deposit додає надане значення до bal; та
      withdraw, що намагаєтсья відняти надану суму з bal, при цьому
      переконавшись, що залишений баланс не від'ємний. З withdraw повертається
      результат типу Boolean, що вказує, чи запрошені фонди були успішно
      списані.</p>
    <p>Навіть якщо ви нічого не знаєте щодо внутрішньої роботи класа
      BankAccount, ви все ще можете сказати, що BankAccount є об'єктами зі
      станом:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val account = new BankAccount
account: BankAccount = BankAccount@bf5bb7
<br>scala&gt; account deposit 100
scala&gt; account withdraw 80
res1: Boolean = true
<br>scala&gt; account withdraw 80
res2: Boolean = false</pre>
    <p>Зауважте, що два фінальні списання в попередній взаємодії повертали різні
      значення. Перша операція списання повертала true, оскільки банківський
      рахунок містив досить грошей щоб дозволити списання. Друга операція, хоча
      вона й така сама, як перша, повертає false, оскільки баланс рахунку був
      зменшений, так що він більше не покриває запитані витрати. Так,
      банківський рахунок напевне має змінний стан, оскільки деякі операції
      можуть повертати різні результати в різний час.</p>
    <p>Ви можете думати, що наявність стану BankAccount безпосередньо очевидне,
      оскільки він містить визначення var. Стан та var звичайно ідуть поряд, але
      речі не завжди такі прості. Наприклад, клас може мати стан без визначення
      або наслідування будь яких var, оскільки він передає виклики методів до
      інших об'єктів, що мають змінний стан. Зворотнє також можливе: клас може
      містити var, та бути при цьому чисто функціональним. Прикладом може бути
      клас, що кешує результат коштовної операції в полі задля цілей
      оптимізації. Щоб мати приклад, розглянемо наступний неоптимізований клас
      Keyed з коштовною операцією computeKey :</p>
    <pre class="prettyprint linenums language-scala">class Keyed {
  def computeKey: Int = ... // це займе деякий час
  ...
}</pre>
    <p>Вважаємо, що computeKey ані читає, ані записує жодних var, ви можете
      зробити Keyed більш ефективним за допомогою кеша:</p>
    <pre class="prettyprint linenums language-scala">class MemoKeyed extends Keyed {
  private var keyCache: Option[Int] = None
  override def computeKey: Int = {
    if (!keyCache.isDefined) keyCache = Some(super.computeKey)
    keyCache.get
  }
}</pre>
    <p>Використання MemoKeyed замість Keyed може прискорити речі, оскільки други
      раз запитується результат операції computeKey, може бути повернено
      значення, збережене в полі keyCache, замість виконання computeKey ще один
      раз. Але за винятком цього прискорення, поведінка класа Keyed та MemoKeyed
      така ж сама. Концептуально, якщо Keyed чисто функціональний, тоді також і
      MemoKeyed, навіть якщо він і містить змінну, яку можна переприсвоювати.</p>
    <h3>18.2 Переприсвоювані змінні та властивості</h3>
    <p>Ви можете виконувати дві фундаментальні операції на переприсвоюваних
      змінних: отримати їх значення, на встановити нове значення. В бібліотеках,
      таких, як JavaBeans, ці операції часто інкапсульовані в окремі геттери та
      сеттери, що треба визначати явно. В Scala кожна var, що не є приватним
      членом деякого об'єкта, неявно визначає геттер та сеттер. Ці геттери та
      сеттери, однак, називаються інакше, ніж прийнято в Java. Геттер var x
      називається просто “x”, коли її сеттер називається “ x_= ”. </p>
    <p>Наприклад, якщо в класі визначена така змінна var:</p>
    <pre class="prettyprint linenums language-scala">var hour = 12</pre>
    <p>генеруєтсья геттер “hour”, та сеттер “hour_=”, на додаток до
      перевизначеного поля. Поле завжди марковане як private[this], що означає,
      що до нього може отримувати доступ тільки об'єкт, що містить його. Геттер
      та сеттер, з іншого боку, має ту ж видимість, що і оригінальна var. Якщо
      визначення var є public, такаж видимість в геттера та сеттера, якщо
      protected, вони також protected, і так далі.</p>
    <p>Наприклад, розглянемо клас Time, показаний в Лістингу18.2, що визначає
      дві public var на ім'я hour та minute :</p>
    <pre class="prettyprint linenums language-scala">class Time {
  var hour = 12
  var minute = 0
}</pre>
    <p>Лістинг 18.2 Клас з&nbsp;public var.</p>
    <p>Ця реалізація точно еквівалентна до визначень класа, показаного в
      Лістингу 18.3. Визначенні, показаному в Лістингу 18.3, імена локальних
      полів h та m вибрані довільно, щоб не перетинатись з любими іменами, що
      вже в ужитку.</p>
    <pre class="prettyprint linenums language-scala">class Time {
  private[this] var h = 12
  private[this] var m = 0
  def hour: Int = h
  def hour_=(x: Int) { h = x }
  def minute: Int = m
  def minute_=(x: Int) { m = x }
}
</pre>
    <p>Лістинг 18.3 · How public var s are expanded into getter and setter
      methods.</p>
    <p>Цікавий аспект щодо ціх розширень var до геттерів та сеттерів в тому, що
      ви можете також обрати визначити геттер та сеттер напряму, замість
      визначення var. Визначаючи ці методи доступу напряму, ви можете
      інтерпретувати операції доступу та присвоєння до змінної за власним
      бажанням. Наприклад, варіант класа в Лістингу 18.4 містить вимоги, що
      перехоплюють все присвоєння до годин та хвилин з неможливими значеннями.</p>
    <pre class="prettyprint linenums language-scala">class Time {
  private[this] var h = 12
  private[this] var m = 0
  def hour: Int = h
  def hour_= (x: Int) {
    require(0 &lt;= x &amp;&amp; x &lt; 24)
    h = x
  }
  def minute = m
  def minute_= (x: Int) {
    require(0 &lt;= x &amp;&amp; x &lt; 60)
    m = x
  }
}</pre>
    <p>Listing 18.4 Визначення методів геттерів та сеттерів напряму.</p>
    <p>Деякі мови мають специфічні синтаксичні конструкції для ціх
      змінно-подібних сутностей, що не є простими змінними, в тій частині, що їх
      геттери та сеттери можуть бути перевизначені. Наприклад, C# має
      властивості, що служать цій ролі. Домовленість Scala<br>
      завжди інтерпретувати змінну як пару з методів геттера та сеттера
      ефективно дає ті ж можливості, що і властивості C#, без потреби в
      спеціальному синтаксисі. Властивості можуть служити багатьом різним цілям.
      В прикладі, показаному в Лістингу 18.4, сеттери змушують до
      інваріантності, і, таким чином, захищають від присвоєння недопустимих
      значень. Ви також можете використовувати властивість для журналювання
      всього доступу до геттерів та сеттерів змінної. Або ви можете інтегрувати
      змінні з подіями, наприклад, через повідомлення деякого підписчика кожного
      разу, коли змінна модифікується (ви побачите приклади цього в Главі 35).</p>
    <p><br>
      Також можливо, та підчас корисно, визначити геттер та сеттер без
      асоційованого поля. Прикладом є наступний клас Thermometer, що інкапсулює
      змінну температури, що може бути прочитана та оновлена. Температура може
      бути вираженою в за Цельсієм, або за Фаренгейтом. Клас нижче дозволяє
      отримувати або встановлювати температуру за кожним способом. </p>
    <pre class="prettyprint linenums language-scala">class Thermometer {
  var celsius: Float = _
  def fahrenheit = celsius * 9 / 5 + 32
  def fahrenheit_= (f: Float) {
    celsius = (f - 32) * 5 / 9
  }
  override def toString = fahrenheit +"F/"+ celsius +"C"
}</pre>
    <p>Лістинг 18.5 Визначення геттера та сеттера без асоційованого поля.</p>
    <p>Перший рядок в тілі цього класа визначає змінну var, celsius, що буде
      містити температуру за Цельсієм. Змінна celsius смочатку встановлена в
      значення по замовчанню, вказавши ‘_’ як “значення ініціалізації” для
      змінної. Більш точно, ініціалізатор “ = _ ” поля присвоює значення нуль до
      поля. Значення нуля залежить від типа поля. Це 0 для числових типів, false
      бля логічних, та null для типів-посилань. Це те ж саме, що якби та ж
      змінна була визначена в Java без ініціалізатора. Зауважте, що ви не можете
      просто відкинути ініціалізатор “= _” в Scala. Якщо в запишете:</p>
    <pre class="prettyprint linenums language-scala">var celsius: Float</pre>
    <p>це декларує абстрактну змінну, не просто неініціалізовану. Після
      визначення змінної celsius іде геттер “fahrenheit”, та сеттер
      “fahrenheit_=”, що має доступ до тієї ж температури, але за градусами
      Фаренгейта. Немає окремого поля, що містить поточну температуру за
      Фаренгейтом. Замість цього, методи геттера та сеттера для Фаренгейта
      конвертують значення в обі сторони для Цельсія, відповідно.</p>
    <p>Ось приклад взаємодії з об'єктом Thermometer:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val t = new Thermometer
t: Thermometer = 32.0F/0.0C
<br>scala&gt; t.celsius = 100
scala&gt; t
res3: Thermometer = 212.0F/100.0C
<br>scala&gt; t.fahrenheit = -40
scala&gt; t
res4: Thermometer = -40.0F/-40.0C</pre>
    <h3>18.3 Дослідження проблеми: симуляція дискретних подій</h3>
    <p>Залишок цієї глави показує розширений приклад того, як об'єкти зі станом
      можуть бути скомбіновані зі значеннями&nbsp; першокласних функцій в
      цікавий спосіб. Ви побачите дизайн та реалізацію симулятора цифрових cхем.
      Це завдання розділене на декілька субпроблем, кожна з яких індивідуально
      цікава: зпершу, ви побачите малу мову для цифрових схем. Визначення цієї
      мови покаже головний метод для вбудовування галузевих мов в мову як Scala.
      Друге, ми прежентуємо простий, але загальний фреймворк, що буде
      відстежувати дії, що виконуються в симульованому часі. Нарешті, ми
      покажемо, як програми дискретної симуляції можуть бути структуровані та
      побудовані. Ідея такої симуляції є моделювання фізичних симульованими, та
      використання фреймворка симуляції для моделювання фізичного часу. </p>
    <p>Приклад взятий з класичної книги Структура та інтерпретація комп'ютерних
      програм від Абельсона та Зусмана [Abe96]. Що тут відрізняється, що мова
      інтерпретації тут Scala замість Scheme, та що різні аспекти структуровані
      на чотирьох програмних рівнях: один для фреймворка симуляції, другий для
      пакунку базових схем, третій для бібліотеки визначених користувачем схем,
      та останній рівень для самої кожної симульованої схеми. Кожний рівень
      визначений як клас, та більш специфічні рівні наслідують від більш
      загальних.</p>
    <img alt="Basic Gates" src="18.1.png">
    <p>Малюнок 18.1 Базові вентілі</p>
    <h4>Швидка орієнтація</h4>
    <p>Розуміння приклада симуляції дискрентих подій, представлених в цій главі,
      займе деякий час. Якщо замість цього ви бажаєте швидше повернутись до
      вивчекння Scala, буде безпечним перейти далі до наступної глави.</p>
    <h3>18.4 Мова для цифрових схем</h3>
    <p>Ми почнемо з "малої мови" для опису цифрових схем. Цифрові пристрої
      складаються з дротів та функціональних блоків. Дроти передають сигнали, що
      трансформуються функціональними блоками. Сигнали представлені як логічні
      рівні: true коли сигнал є, та false коли немає. Малюнок 18.1 показує три
      базові функціональні блоки (або вентилі):</p>
    <p>• Інвертор, що обертає сигнал.<br>
      • Блок ТА, що встановлює вихід в кон'юкцію своїх входів<br>
      • Блок АБО, що встановлює вихід в діз'юкцію своїх входів.</p>
    <p>Ціх блоків достатньо для побудови любих інших функціональних блоків.
      Вентилі мають затримкм, так що вихід буде змінюватись тільки через деякий
      час після зміни входу. Ми опишемо елементи цифрових схем наступним набором
      класів та функцій Scala. Першим буде клас Wire для дротів. Ми можемо
      конструювати дроти таким чином:</p>
    <pre class="prettyprint linenums language-scala">val a = new Wire
val b = new Wire
val c = new Wire</pre>
    <p>або, еквівалентно, але коротше, таки чином:</p>
    <pre class="prettyprint linenums language-scala">val a, b, c = new Wire</pre>
    <p>Друге, є три прод'юсера що “виробляють” потрібні нам базові вентилі:</p>
    <pre class="prettyprint linenums language-scala">def inverter(input: Wire, output: Wire)
def andGate(a1: Wire, a2: Wire, output: Wire)
def orGate(o1: Wire, o2: Wire, output: Wire)</pre>
    <p>Що є незвичним, беручи до уваги функціональний нахил Scala, в тому, що ці
      процедури конструюють вентилі як побічний ефект, замість щоб повертати
      сконструйовані блоки як результат. Наприклад, виклик inverter(a, b)
      покладає інвертор між дротами a та b. Як з'ясувалось, ця конструкція через
      побічний ефект робить простішою поступову побудову складних лінцюжків.
      Також, хоча більш часто методи мають імена дієслів, ці мають імена
      іменників, що вказує на той вузол, який вони будують. Це відображує
      декларативну природу DSL: вона повинна декларувати схему, не дії, що
      виробляють її. Більш складні функціональні блоки можуть бути побудовані з
      базових вентилів. Наприклад, метод, показаний в Лістингу 18.6 конструює
      напів-додавач. Метод halfAdder приймає два входи, a та b, та продукує суму
      s, визначену як s = (a + b) % 2 та біт переносу c , визначене як c = (a +
      b) / 2. Діаграма напів-додавача показана на Малюнку 18.2.</p>
    <p><img alt="Half-addded circuits" src="file:///home/ac2epsilon.github.io/TRANS/SCALA/18.2.png"><br>
      Малюнок 18.2 Схама папів-додавача.</p>
    <pre class="prettyprint linenums language-scala">def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
  val d, e = new Wire
  orGate(a, b, d) 
  andGate(a, b, c)
  inverter(c, e)
  andGate(d, e, s)
}</pre>
    <p>&nbsp;Лістинг 18.6 Метод halfAdder.</p>
    <p>Зауважте, що halfAdder є параметризованим функціональним блоком, так
      само, як три методи, що конструюють примітивні вентилі. Ви можете
      використовувати метод halfAdder для конструювання більш складних схем.
      Наприклад, Лістинг 18.7 визначає повний однобітний додавач, показаний на
      Малюнку 18.3, що приймає два входи, a та b, так само, як перенос cin, та
      що продукує вихідну суму, що визначена як sum = (a + b + cin) % 2, та
      вихід переносу, визначений як cout = (a + b + cin) / 2.</p>
    <pre class="prettyprint linenums language-scala">def fullAdder(a: Wire, b: Wire, cin: Wire,
sum: Wire, cout: Wire) {
  val s, c1, c2 = new Wire
  halfAdder(a, cin, s, c1)
  halfAdder(b, s, sum, c2)
  orGate(c1, c2, cout)
}</pre>
    <p>Лістинг 18.7 Метод fullAdder.</p>
    <p>Клас Wire та функції inverter, andGate та orGate представляють невелику
      мову, за допомогою якої користувачі можуть визначати цифрові схеми. Це
      гарний приклад інутрішньої DSL, галузевої мови, визначеної як бібліотеки в
      базовій мові, замість бути реалізованою сама по собі. Реалізація схемної
      DSL все ще потребує бути проробленою. Оскільки призначення визначення
      схеми в DSL є симуляція присторою, має сенс базувати реалізацію DSL на
      загальному API для симуляції дискретних подій. Наступні два розділи будуть
      презентувати зпершу симуляцію API, та потім реалізацію DSL зверху нього.</p>
    <img alt="Full-adder circuit" src="18.3.png">
    <p>Малюнок 18.3 Схема повного додавача.</p>
    <h3>18.5 API симуляції</h3>
    <p>API симуляції показане в Лістингу 18.8. Воно складається з класа
      Simulation в пакунку org.stairwaybook.simulation. Конкретні бібліотеки
      симуляції наслідують цей клас, та доповнюють &nbsp;&nbsp;&nbsp; його за
      допомогою галузевої функціональності. Елементи класа Simulation
      представлені в цьому розділі. Симуляція дискретних подій виконує визначені
      користувачем дії у вказаний час. Дії, що визначені через конкретні
      субкласи симуляції, всі поділяють загальний тип: </p>
    <pre class="prettyprint linenums language-scala">type Action = () =&gt; Unit</pre>
    <p>Це твердження визначає Action, що є псевдонімом типу процедури, що
      приймає пустий список параметрів, та повертає Unit. Action є членом типу
      класа Simulation. Ви можете думати про це, як про більш читабельне ім'я
      для типа () =&gt; Unit. Члени типів будуть описані більш детально в
      Розділі 20.6. Час, коли викликається дія, є симульованим часом; він не має
      нічого загального з дійстним часом "часів на стіні". Симульований час
      представлений просто як ціле. Поточний симульований час утримується в
      приватній змінній: </p>
    <pre class="prettyprint linenums language-scala">private var curtime: Int = 0</pre>
    <p> Змінна має матод для доступу, що повертає поточний час: </p>
    <pre class="prettyprint linenums language-scala">def currentTime: Int = curtime</pre>
    <p>Ця комбінація приватної змінної з публічним доступом використовується,
      щоб переконатись, що поточний час не може бути модифікований за межами
      класа Simulation. Кінець кінцес, ви звичайно не хочете, щоб об'єкти вашої
      симуляції маніпулювали поточним часом, можливо, за винятком якщо ваші
      моделі симуляції подорожують в часі. </p>
    <pre class="prettyprint linenums language-scala">abstract class Simulation {
  type Action = () =&gt; Unit
  case class WorkItem(time: Int, action: Action)
  private var curtime = 0
  def currentTime: Int = curtime
  private var agenda: List[WorkItem] = List()
  private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
      if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag
      else ag.head :: insert(ag.tail, item)
  }
  def afterDelay(delay: Int)(block: =&gt; Unit) {
    val item = WorkItem(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }
  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =&gt;
      agenda = rest
      curtime = item.time
      item.action()
    }
  }
  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
      currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
}</pre>
    <p>Лістинг 18.8 Клас Simulation.</p>
    <p>Акція, що має бути виконана у вказаний час, викликається робочим
      елементом. Робочі елементи&nbsp; реалізовані як наступний клас: </p>
    <pre class="prettyprint linenums language-scala">case class WorkItem(time: Int, action: Action)</pre>
    <p>Ми зробили клас WorkItem кейс класом, оскільки це надає синтаксичних
      зручностей: ви можете використовувати метод-фабрику, WorkItem, щоб
      створити примірники класа, та ви можете отримати доступ до параметрів
      конструктора, time та action, задарма. Також зауважте, що клас WorkItem
      вкладений в клас Simulation. Вкладені класи в Scala розглядаютсья подібно
      до Java. Розділ 20.7 надасть вам більше деталей.&nbsp;</p>
    <p><br>
      Клас Simulation зберігає порядок денний всіх інших робочих елементів, що
      ще не були виконані. Робочі елеменрти впорядковані по симульованому часу,
      коли вони мають виконуватись:</p>
    <pre class="prettyprint linenums language-scala">private var agenda: List[WorkItem] = List()</pre>
    <p>Список розкладу буде утримуватись в відповідному відсортованому порядку
      методом insert, що оновлює його. Ви можете бачити, як insert викликаєтсья
      з afterDelay, що є єдиним шляхом додати робочий елемент до розкладу:</p>
    <pre class="prettyprint linenums language-scala">def afterDelay(delay: Int)(block: =&gt; Unit) {
  val item = WorkItem(currentTime + delay, () =&gt; block)
  agenda = insert(agenda, item)
}</pre>
    <p>Як натякає ім'я, цей метод вставляє дію (задану як блок) в розклад, так
      що він планується на заадний час затримки після поточного симульованого
      часу. Наприклад, наступний виклик буде створювати новий робочий елемент,
      що буде виконаний в симульованому часі currentTime + delay : </p>
    <pre class="prettyprint linenums language-scala">afterDelay(delay) { count += 1 }</pre>
    <p>Код, що буде виконаний, міститься в другому аргументі метода. Формальний
      параметр для цього аргумента має тиа “=&gt; Unit”, тобто, це обчислення
      типу Unit, що передане за ім'ям. Згадайте, що переаметри за-ім'ям не
      обчислюються, коли передаються в метод. Так що в виклику вище count буде
      виконано, тільки коли фреймворк симуляції викликає дію, збережену в
      робочому елементі. Зауважте, що afterDelay є курованою функцією. Це гарний
      приклад принципу, встановленому заздалегідь в Розділі 9.5, що карування
      може бути використане щоб зробити виклик метода подібним на вбудований
      синтаксис. </p>
    <p>Створений робочий елемент все ще потребує бути вставленим в розклад. Це
      робиться методом insert, що підтримує інваріант, що розклад впорядкований
      за часом:</p>
    <pre class="prettyprint linenums language-scala">private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
  if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag 
  else ag.head :: insert(ag.tail, item)
}</pre>
    <p>The core of the Simulation class is defined by the run method:</p>
    <pre class="prettyprint linenums language-scala">def run() {
  afterDelay(0) {
    println("*** simulation started, time = "+
    currentTime +" ***")
  }
  while (!agenda.isEmpty) next()
}</pre>
    <p>Цей метод постійно бере перший елемент в розкладі, видаляє його з
      розклада, та виконує його. Він робить це, доки не буде більше елементів,
      що залишились в розкладі, що очікують виконання. Кожний крок виконується
      через виклик метода next, що визначений таким чином:</p>
    <pre class="prettyprint linenums language-scala">private def next() {
  (agenda: @unchecked) match {
    case item :: rest =&gt;
     agenda = rest
     curtime = item.time
     item.action()
  }
}</pre>
    <p>Метод next декомпонує поточний розклад за допомогою порівняння шаблону в
      перший елемент item, та залишок списку робочих елементів. Він видаляє
      передній елемент з поточного розкладу, встановлює симульований час на час
      робочого елемента, та виконує дію робочого елемента.</p>
    <p>Зауважте, що next може бути викликаний тільки якщо розклад не порожній.
      Для порожнього списка немає випадка, так що ви можете отримати виключення
      MatchError, якщо ви спробуєте виконати next на порожньому розкладі. </p>
    <p>Фактично, компілятор Scala звичайно буде попереджати вас, що ви
      пропустили один з можливих шаблонів:</p>
    <pre class="prettyprint linenums language-scala">Simulator.scala:19: warning: match is not exhaustive!
missing combination
Nil
agenda match {
ˆ
one warning found</pre>
    <p>В цьому випадку відсутній case не є проблемою, оскільки ви знаєте, що
      next викликаний на непустому розкладі. Такиим чином ви можете забажати
      відключити попередження. Ви бачили в Розділі 15.5, що це можна зробити
      через додавання анотації @unchecked до виразу селектора порівняння
      шаблона. Ось чому кож Simulation використовує “(agenda: @unchecked) match
      ” замість “agenda match”.</p>
    <p>Ось і все. Це виглядаючий дивовижно коротким код для фреймворка
      симуляції. Ви можете поцікавитись, як цей фреймворк може підтримувати
      цікаві симуляції, якщо все, що він робить, це виконує список з робочих
      елементів? Фактично, потужність фреймворка симуляції походить від факту,
      що дії, збережені в робочих елементах, самі можуть встановлювати подальші
      робочі елементи в розклад, коли вони виконуються. Це робить можливим мати
      довготривалі симуляції, що розвиваються з простих початків.</p>
    <h3>18.6 Симуляція схеми</h3>
    <p>Наступний крок є використання фреймворка симуляції для реалізації
      галузевої мови для схем, показаної в Розділі 18.4. Згадайте, що наш DSL
      складається з класа для дротів, та методів, що створюють та-вентилі,
      або-вертилі та інвертори. Вони містяться в класі BasicCircuitSimulation,
      що розширює фреймворк симуляції. Цей клас показаний в Лістингах 18.9 та
      18.10.</p>
    <p>Клас BasicCircuitSimulation декларує три абстрактні методи, що
      представляють затримки базових вентелів: InverterDelay, AndGateDelay та
      OrGateDelay. Справжні затримки невідомі на рівні цього класа, оскільки
      вони залежать від техногії з'єднань, що ми симулюємо. Ось чому затримки
      залишені абстрактнимив класі BasicCircuitSimulation, так що їх конкретні
      визначення делеговані до субкласів. Реалізація інших методів класа
      BasicCircuitSimulation слідує далі.</p>
    <pre class="prettyprint linenums language-scala">package org.stairwaybook.simulation
<br>abstract class BasicCircuitSimulation extends Simulation {
  def InverterDelay: Int
  def AndGateDelay: Int
  def OrGateDelay: Int
<br>  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()
    def getSignal = sigVal
    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }
    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }
  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig &amp; a2Sig)
      } 
    }
    a1 addAction andAction
    a2 addAction andAction
  }
  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }
  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
        " new-value = "+ wire.getSignal)
    }
     wire addAction probeAction
  }
}</pre>
    <p>Лістинг 18.9-10 Клас BasicCircuitSimulation.</p>
    <h4>Клас Wire</h4>
    <p>ЛґДріт потрібний, щоб підтримувати три базові операції:</p>
    <p>getSignal: Boolean : повертає поточний сигнал на дроті.<br>
      setSignal(sig: Boolean) : встановлює сигнал на дроті в sig .<br>
      addAction(p: Action) : приєднує вказану процедуру p до дій на дроті. </p>
    <p>Ідея в тому, що всі процедури дій, приєднані до деякого дрота, будуть
      викликатись кожного разу, коли сигнал на дроті змінюється. </p>
    <p>Типово дії додаються до дрота через компоненти, під'єднані до дрота.
      Приєднана дія виконується один раз, коли вона приєднується до дрота, та
      після цього кожного разу, коли сигнал на дроті змінюється. Ось реалізація
      класа Wire:</p>
    <pre class="prettyprint linenums language-scala">class Wire {
  private var sigVal = false
  private var actions: List[Action] = List()
  def getSignal = sigVal
  def setSignal(s: Boolean) =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_ ())
    }
  def addAction(a: Action) = {
    actions = a :: actions
    a()
  }
}</pre>
    <p>Назви ціх методів “затримки” починаються з заглавної літери, бо вони
      представляють константи. Це ті методи, що можуть бути переписані в
      субкласах. Ви знайдете, як робити ті самі речі в Розділі 20.3.</p>
    <p>Дві приватні змінні займаються станом на дроті. Змінна sigVal представляє
      поточний сигнал, та змінна actions представляє процедури дій, що наразі
      приєднані до дроту. Єдина цікава реалізація метода для setSignal: коли
      сигнал на дроті змінюється, нове значення зберігається в змінній sigVal.
      Більше того, виконуються всі дії, приєднані до дроту. Зауважте скорочений
      синтаксис для того, щоб зробити це: “actions foreach (_ ()) ” застосовує
      функцію “_() ” до кожного елемента списка дій. Як описано в Розділі 8.5,
      функція “_ ()” є скороченням для “f =&gt; f ()”, тобто, вона приймає
      функцію (назовемо її f), та застосовує її до пустого списка параметрів.</p>
    <h4>Метод inverter</h4>
    <p>Єдиний ефект від створення інвертора в тому, що на його вхідному дроті
      встановлена дія. Ця дія виконується один раз, коли дія встановлена, та
      після цього кожного разу, коли змінюється вхідний рівень. Ефект дії в
      тому, що значення вихідного значення встановлюється (через setSignal) до
      інверсії вхідного значення. Оскільки інвертор має затримку, ця зміна
      повинна набрати чинності тільки через InverterDelay одиниць симульованого
      часу після того, як вхідне значення було змінене, та дія була викликана. Ц
      епідказує таку реалізацію:</p>
    <pre class="prettyprint linenums language-scala">def inverter(input: Wire, output: Wire) = {
  def invertAction() {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) {
      output setSignal !inputSig
    }
  }
  input addAction invertAction
}</pre>
    <p>Ефект метода inverter є додавання invertAction до вхідного дроту. Ця дія,
      коли викликається, отримує вхідний сигнал, та встановлює іншу дію, що
      інвертує вихідний сигнал в симульований розклад. Ця інша дія буде виконана
      тільки після InverterDelay одиниць симульованого часу. Зауважте, як метод
      використовує метод afterDelay фреймворка симуляції для створення нового
      робочого елемента, що буде виконаний в майбутньому.</p>
    <h4>Методи andGate та orGate</h4>
    <p>Реалізація and-вентилів аналогічна до реалізації інверторів. Призначення
      та-вентилів є вивід кон'юкції своїх вхідних сигналів. Це повинно трапитись
      через AndGateDelay одиниць симульованого часу після зміну любого з двох
      вхідних значень. Таким чином ось і наступна реалізація:</p>
    <pre class="prettyprint linenums language-scala">def andGate(a1: Wire, a2: Wire, output: Wire) = {
  def andAction() = {
&nbsp;&nbsp;&nbsp; val a1Sig = a1.getSignal
&nbsp;&nbsp;&nbsp; val a2Sig = a2.getSignal
&nbsp;&nbsp;&nbsp; afterDelay(AndGateDelay) {
&nbsp;&nbsp; &nbsp;&nbsp; output setSignal (a1Sig &amp; a2Sig)
&nbsp;&nbsp;&nbsp; } 
  }
  a1 addAction andAction
  a2 addAction andAction
}</pre>
    <p>Ефект від метода andGate є додавання andAction до обох з їх вхідних
      дротів, a1 та a2. ця дія, коли викликається, отримує обоє вхідні сигнали,
      та встановлює іншу дію, що встановлює вихідний сигнал до кон'юкції обох
      вхідних сигналів. Ця інша дія буде виконана після AndGateDelay одиниць
      симульованого часу. Зауважте, що вихід має бути переобчислений якщо жодних
      вхід зміниться. ось чому andAction встановлена на кожному з двох входів,
      a1 та a2 . Метод orGate реалізований подібним чином, за винятком того, що
      він виконує логічне АБО замість ТА.</p>
    <h4>Вивід симуляції</h4>
    <p>Щоб виконати симулятор, вам треба спосіб перевірити зміни сигналів на
      дротах. Щоб досягти цього, ви можете симулювати дії через розміщення на
      дротах контрольних точок:</p>
    <pre class="prettyprint linenums language-scala">def probe(name: String, wire: Wire) {
  def probeAction() {
    println(name +" "+ currentTime +
    " new-value = "+ wire.getSignal)
  }
  wire addAction probeAction
}</pre>
    <p>Ефектом від процедури проби буде встановлення probeAction на даному
      дроті. Як звичано, дія виконуєтсья кожного разу, коли змінюється сигнал на
      дроті. В цьому випадку вона просто друкує ім'я дрота (що передається
      першим параметром до probe), а також поточний симульований час, та нове
      значення на дроті.</p>
    <h4>Виконання симулятора</h4>
    <p>Після всіх ціх підготувань прийшов час побачити симуляцію в дії. Щоб
      визначити конкретну симуляцію, вам треба наслідувати від класа фреймворка
      симуляції. Щоб побачити щось цікаве, ми створимо абстракту симуляцію, що
      розширює BasicCircuitSimulation, та містить визначення методів для
      напів-додавача, та повного-додавача, як вони були презентовані раніше в
      цій главі на Лістингу 18.6 та 18.7. Цей клас, що ми назвемо
      CircuitSimulation, показаний на Лістингу 18.11:</p>
    <pre class="prettyprint linenums language-scala">package org.stairwaybook.simulation
<br>abstract class CircuitSimulation extends BasicCircuitSimulation {
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
  def fullAdder(a: Wire, b: Wire, cin: Wire,
    sum: Wire, cout: Wire) {
    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}</pre>
    <p>Лістинг 18.11 Клас CircuitSimulation.</p>
    <p>Симуляція конкретної схеми буде об'єктом, що наслідує від класа
      CircuitSimulation. Об'єт все ще потребує полагодження затримок вентилів,
      відповідно до технології реалізації схеми, що симулюється. Нарешті, вам
      також буде потрібно визначити конкретну схему, що буде симулюватись. Ви
      можете зробити ці кроки в інтерпретаторі Scala:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import org.stairwaybook.simulation._
import org.stairwaybook.simulation._</pre>
    <p>Зпочатку затримки вентилів. Визначимо о'єкт (назвемо його MySimulation),
      що провадить деякі числа:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; object MySimulation extends CircuitSimulation {
  def InverterDelay = 1
  def AndGateDelay = 3
  def OrGateDelay = 5
}<br>defined module MySimulation</pre>
    <p>Оскільки ви збираєтесь отримувати доступ до членів об'єкта MySimulation
      неодноразово, імпорт об'єкта утримує наступний код коротшим:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; import MySimulation._
import MySimulation._</pre>
    <p>Далі схема. Визначимо чотири дроти, та поставимо на два з них контрольні
      точки (проби):</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val input1, input2, sum, carry = new Wire
input1: MySimulation.Wire =
BasicCircuitSimulation$Wire@111089b
input2: MySimulation.Wire =
BasicCircuitSimulation$Wire@14c352e
sum: MySimulation.Wire =
BasicCircuitSimulation$Wire@37a04c
carry: MySimulation.Wire =
BasicCircuitSimulation$Wire@1fd10fa
<br>scala&gt; probe("sum", sum)
sum 0 new-value = false
<br>scala&gt; probe("carry", carry)
carry 0 new-value = false</pre>
    <p>Зауважте, що проби безпосередньо друкують вихід. Це наслідки факту, що
      кожна дія, встановлена на дроті, виконується перший раз, коли
      встановлюється дія.&nbsp;</p>
    <p>Тепер визначимо напів-додавач, підключений до дротів:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; halfAdder(input1, input2, sum, carry)</pre>
    <p>Нарешті, один за одним, ввімкнемо обидва вхідні дроти та почнемо
      симуляцію:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; input1 setSignal true
scala&gt; run()
*** simulation started, time = 0 ***
sum 8 new-value = true
scala&gt; input2 setSignal true
scala&gt; run()
*** simulation started, time = 8 ***
carry 11 new-value = true
sum 15 new-value = false</pre>
    <h3>18.7 Висновок</h3>
    <p>Ця глава зібрала разом дві технологіїї, що виглядають окремими: змінний
      стан та функції вищих порядків. Змінний стан був використаний для
      симуляції фізичних сутностей, чий стан змінюється з часом. Функції вищого
      порядка були використані у фреймворці симуляції для виконання дій в задані
      точки в симульованому часі. Вони також були використані в симуляції схеми
      як тригери, що асоціюють дії зі зміном стану. В продовж цього ви бачили
      простий спосіб для визначення галузевої мови як бібліотеки. Це, здається,
      досить для однієї глави!</p>
    <p>Якщо ви бажаєте зупинитись на цьому довше, ви можете спробувати більше
      прикладів симуляції. Ви можете комбінувати напів-додавач та повний додавач
      для створення довшої схеми, або розробити власні схеми з базових вентилів,
      що вже визначені, та симулювати їх. В наступній главі ви навчитесь щодо
      параметризації типів в Scala, та побачите приклад, в якому комбінація
      функціональних та імперативних підходів дає гарне рішення.</p>
    <h3>Глава 19</h3>
    <h2>Параметризація типів</h2>
    <p>В цій главі я поясню деталі параметризації типів в Scala. Крім цього вона
      демонструє деякі з прийомів для приховування інформації, введеної в Главі
      13, шляхом конкретного прикладу: розробки класа для повністю
      функціональних черг. Ми представляємо параметризацію типів та приховання
      інформації разом, оскільки приховання інформації може бути використана для
      отримання більш загального типа параметризації через анотації варіацій.
      Параметризація типів дозволяє вам писати загальні класи та трейти.
      Наприклад, множини є загальними, та сприймають параметр типу: вони
      визначені як Set[T]. Як результат, любий окремий примірник множини може
      бути Set[String], Set[Int], тощо — але це має бути множина чогось. На
      відміну від Java, яка дозволяє голі типи, Scala вимагає вказати параметр
      типу. Варіація визначає відношення наслідування параметризованих типів,
      так що, наприклад, Set[String], є субтипом до Set[AnyRef] .</p>
    <p>Ця глава містить три частини. Перша частина розробляє структуру даних для
      чисто функціональної черги. Друга частина розробляє прийоми для приховання
      деталей внутрішнього представлення цієї структури. Заключна частина
      пояснює варіації параметрів типу, та як це взаємодіє з прихованням
      інформації.</p>
    <h3>19.1 Функціональні черги</h3>
    <p>Функціональна черга є структурою даних з трьома операціями:</p>
    <p>head - повертає перший елемент черги<br>
      tail - повертає чергу без першого елемента<br>
      enqueue - повертає нову чергу з даним елементом, доданим до кінця<br>
      <br>
      На відміну від змінної черги, функціональна черга не змінює власний зміст,
      коли додається елемент. Замість цього повертається нова черга, що містить
      цей елемент. Ціль ціїє глави буде створити клас, що ми назвемо Queue, що
      робить таки чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val q = Queue(1, 2, 3)
q: Queue[Int] = Queue(1, 2, 3)
<br>scala&gt; val q1 = q enqueue 4
q1: Queue[Int] = Queue(1, 2, 3, 4)
<br>scala&gt; q
res0: Queue[Int] = Queue(1, 2, 3)</pre>
    <p>Якщо Queue було б змінною реалізацією, операції в другому рядку впливали
      б на q; фактично обоє результати, q1 та оригільнае q, будуть містити
      послідовність 1, 2, 3, 4 після цієї операції. Але для функціонального
      запиту додане значення показується тільки в результаті q1, та не в черзі
      q, на якій операція застосована.</p>
    <p>Чисто функціональні черги також мають деяку подібність до списків. Обоє є
      так звані повністю стійки структури даних, де нові версії залишаються
      доступні, навіть після розширення або модифікацій. Обоє підтримують
      операції head та tail. Але де список звичайно розширюється з початку,
      використовуючи операцію ::, черга розширюється з кінця, використовуючи
      enqueue.</p>
    <p>Як це може бути реалізовано ефективно? В ідеалі, функціональна (незмінна)
      черга не повинна мати фундаментально вищі накладні розходи, ніж
      імперативна (змінна). Тобто, всі три операції, head, tail та enqueue
      повинні оперувати за сталий час.</p>
    <p>Один простий підхід до реалізації функціональної черги може бути
      використання списка як представницького типа. Тоді head та tail можуть
      просто транслюватись в такі ж операції зі списком, тоді як enqueue може
      бути конкатенацією. Це може тати таку реалізацію:</p>
    <pre class="prettyprint linenums language-scala">class SlowAppendQueue[T](elems: List[T]) { // Не ефективно
  def head = elems.head
  def tail = new SlowAppendQueue(elems.tail)
  def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
}</pre>
    <p>Проблема з цією реалізацією знаходиться в операції enqueue. Вона займає
      час, пропорційний до числа зберігаємих в черзі елементів. Якщо ви бажаєте
      додавання за сталий час, ви можете також спобувати обернути порядок
      елементів в представницькому списку, так що перший елемент, що був
      доданий, піде першим в списку. Це може призвести до наступної реалізації:</p>
    <pre class="prettyprint linenums language-scala">class SlowHeadQueue[T](smele: List[T]) { // Не ефективно
// smele є обернене elems
  def head = smele.last
  def tail = new SlowHeadQueue(smele.init)
  def enqueue(x: T) = new SlowHeadQueue(x :: smele)
}</pre>
    <p>Тепер enqueue має сталий час, але не head та tail. Тепер вони займають
      час, пропорційний до числа елементів, що зберігаються в черзі. Дивлячись
      на ці два приклади, видається непростим запропонувати реалізацію, де всі
      три операції матимуть сталий час. Фактично, навіть виглядає сумнівним, що
      це взагалі можливо! Однак, комбінуючи дві операції, можна наблизитись дуже
      близько. Ідея в представленні черги двома списками, що називаються leading
      та trailing. Список leading містить елементи починаючи з початку, тоді як
      список trailing містить елементи починаючи з кінця, в зворотньому порядку.
      Вміст всієї черги на кожному кроці є “leading ::: trailing.reverse”.</p>
    <p>Тепер, щоб додати елемент, ви просто cons його до списку trailing з
      використанням оператора ::, так що enqueue буде мати сталий час. Це
      означає, що коли спочатку пуста черга конструююється з послідовних
      операцій enqueue, список trailing буде зростати, тоді як список leading
      буде залишатись пустим. Потім, перед першим виконанням операцій head або
      tail на пустому списку leading, цілий список trailing копіюється до
      leading зі зміною порядка елементів. Це робиться в операції, що
      називається mirror. Лістинг 19.1 показує реалізацію черги, що використовує
      цей підхід.</p>
    <p>Яка складність цієї реалізації черги? Операція mirror може мати час,
      пропорційний до числа елементів, але тільки якщо список leading є пустим.
      Вона повертається напряму, якщо leading не порожнє. Оскільки head та tail
      викликають mirror, їх складність може бути лінійною до розміру черги,
      також. Однак, чим далі стає черга, тим рідше викликається mirror.
      Наприклад, розгляньте чергу довжини n з порожнім списком leading.
      Тоді&nbsp; mirror має скопіювати обернений список довжини n. Однак
      наступного часу mirror не матиме виконати жодну роботу, коли список
      leading знову порожній, що відбудеться після n операцій tail. Це означає,
      що ви можете “зарядити” кожний з ціх n операцій tail однією, зі складністю
      одна n-нна від mirror, що означає сталий обсяг роботи. Вважаючи, що
      операції head, tail, та enqueue з'являються з приблизно однаковою
      частотою, амортизована складність, таким чином, є константою для кожної
      операції. Так що функціональні черги асимптотично такі ж ефективні, як і
      змінні.</p>
    <pre class="prettyprint linenums language-scala">class Queue[T](
  private val leading: List[T],
  private val trailing: List[T]
) {<br>  private def mirror =
    if (leading.isEmpty)
      new Queue(trailing.reverse, Nil)
    else
      this
  def head = mirror.leading.head
  def tail = {
    val q = mirror
    new Queue(q.leading.tail, q.trailing)
  }
  def enqueue(x: T) =
    new Queue(leading, x :: trailing)
}</pre>
    <p>Лістинг 19.1 Базовий функціонал черги.</p>
    <p>Тепер є деякі тонкощі, що треба додати до ціх аргументів. Перше, ця
      дискусія була тільки щодо асимптотичної поведінки, сталі фактори можуть
      буди зовсім іншими. Друге, аргумент покладається на факт, що head, tail та
      enqueue викликаються з тою ж частотою. Якщо head викликається значно
      частіше, ніж інші дві операції, цей досвід не діє, бо кожний head може
      включати коштовну реорганізацію списка за допомогою mirror. Другої пастки
      можна уникнути: можливо розробити функціональні черги таким чином, щоб
      коли є послідовність вдалих операцій head, тільки перша призводила до
      реорганізації. Ви знайдете те, як це робиться, в кінці цієї глави.</p>
    <h3>19.2 Приховання інформації</h3>
    <p>Реалізація Queue, показана в Лістингу 19.1, тепер є досить гарна з точки
      зору ефективності. Однак ви можете помітити, що ця ефективність оплачена
      показом непотрібних деталей реалізації. Конструктор Queue, доступний
      глобально, приймає два списка як параметри, де один є реверсований&nbsp; —
      навряд чи інтуітивне представлення для черги. Що потрібне, це спосіб
      приховати цей конструктор від клієнтського кода. В цьому розділі ми
      покажемо вам деякі шляхи досягти цього в Scala.</p>
    <h4>Приватні конструктори та методи-фабрики</h4>
    <p>В Java ви можете приховати конструктор, зробивши його приватним. В Scala
      первинний конструктор не має явного визначення; він визначається неявно,
      через параметри та тіло класа. Тим не менш все ще можливо приховати
      первинний конструктор через додавання модифікатора private перед списком
      параметрів класа, як показано в Лістингу 19.2:</p>
    <pre class="prettyprint linenums language-scala">class Queue[T] private (
  private val leading: List[T],
  private val trailing: List[T]
)</pre>
    <p>Лістинг 19.2 Приховання первинного конструктора через маркування його як
      приватний.</p>
    <p>Модифікатор приватності між іменем класа, та його параметрами, індикує,
      що конструктор Queue є приватним: він може бути доступний тільки з самого
      класа, та його об'єкта-компанйона. Ім'я класа Queue є все ще публічним,
      так що ви можете використовувати його як клас, але ви не можете викликатий
      його конструктор:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; new Queue(List(1, 2), List(3))
&lt;console&gt;:6: error: constructor Queue cannot be accessed in
object $iw
new Queue(List(1, 2), List(3))
ˆ</pre>
    <p>Тепер, коли первинний конструктор класа Queue більше не може бути
      викликаний з клієнтського кода, повинен бути деякий інший спосіб створити
      нові черги. Одна можливість є додати додатковий конструктор, таким чином:</p>
    <pre class="prettyprint linenums language-scala">def this() = this(Nil, Nil)</pre>
    <p>Додатковий конструктор, показаний в попередньому прикладі, будує порожню
      чергу. Як покращення, додатковий конструктор може приймати список
      початкових елементів черги:</p>
    <pre class="prettyprint linenums language-scala">def this(elems: T*) = this(elems.toList, Nil)</pre>
    <p>Згадайте, що T* є нотацією для повторюваних параметрів, як описано в
      Розділі 8.8.</p>
    <p>Інша можливість є додати метод-фабрику, що будує чергу з такої
      послідовності початкових елементів. Милий спосіб зробити це є додати
      об'єкт Queue, що має те є ім'я, що і визначений клас, та містить метод
      apply, як показано в Лістингу 19.3:</p>
    <pre class="prettyprint linenums language-scala">object Queue {
// конструює чергу за початковими елементами ‘xs’
  def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}</pre>
    <p>Лістинг 19.3 ·Метод-фабрика apply в об'єкті-компанйоні.</p>
    <p>Покладаючи цей об'єкт в той же файл, що і клас Queue, ви робите об'єкт
      о'бєктом-компанйоном класа. Ви бачили в Розділі 13.5, що о'бєкт-компанйон
      має ті самі права доступа, що і клас. Завдяки цьому, метод apply об'єкта
      Queue може створити новий об'єкт Queue, навіть якщо конструктор класа
      Queue є приватним.</p>
    <p>Зауважте, що оскільки метод-фабрика має назву apply, клієнти можуть
      створювати черги за допомогою виразів, таких, як Queue(1, 2, 3). Цей вираз
      розширюється до Queue.apply(1, 2, 3), оскільки Queue є об'єктом, а не
      функцією. Як результат, Queue вигладає для клієнта, як якщо це була б
      глобально визначена метод-фабрика. Насправді, Scala не має глобально
      видімих методів; кожний метод повинен міститись в об'єкті або класі. Однак
      використання методів з назвою apply в глобальних об'єктах, ви можете
      підтримувати шаблони використання, що виглядають як виклики глобальних
      методів.</p>
    <h4>Альтернатива: приватні класи</h4>
    <pre class="prettyprint linenums language-scala">trait Queue[T] {
  def head: T
  def tail: Queue[T]
  def enqueue(x: T): Queue[T]
}
object Queue {
  def apply[T](xs: T*): Queue[T] =
    new QueueImpl[T](xs.toList, Nil)
  private class QueueImpl[T](
  private val leading: List[T],
  private val trailing: List[T]
) extends Queue[T] {
  def mirror =
    if (leading.isEmpty)
      new QueueImpl(trailing.reverse, Nil)
    else
      this
  def head: T = mirror.leading.head
  def tail: QueueImpl[T] = {
    val q = mirror
    new QueueImpl(q.leading.tail, q.trailing)
  }
  def enqueue(x: T) =
    new QueueImpl(leading, x :: trailing)
  }
}</pre>
    <p>Лістинг 19.4 Абстракція типа для функціональних черг.</p>
    <p>Приватні конструктори та приватні члени є одним шляхом для приховання
      ініціалізації та репрезентації классів. Інший, більш радикальний шлях є
      приховати сам клас, та тільки експортувати трейт, що демонструє публічний
      інтерфейс класа. Код в Лістингу 19.4 реалізує цей дизайн. Існує трейт
      Queue, що декларує методи head, tail та enqueue. Всі три методи
      реалізовані в субкласі QueueImpl, що сам є приватним внутрішнім класом
      об'єкта Queue. Це показує клієнту ту ж саму інформацію як і раніше, але
      використовує інший прийом. Замість приховання індивідуальні конструктори
      та методи, ця версія приховує повну реалізацію класа.</p>
    <h3>19.3 Анотації варіацій</h3>
    <p>Черга, що визначена в Лістингу 19.4, є трейтом, але не типом. Черга не є
      типом, оскільки приймає параметр типа. Як результат, ви не не можете
      створити змінні типу Queue :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def doesNotCompile(q: Queue) {}
&lt;console&gt;:5: error: trait Queue takes type parameters
def doesNotCompile(q: Queue) {}
ˆ</pre>
    <p>Замість цього трейт Queue дозвоялє вам задати параметр типа, такий, як
      Queue[String], Queue[Int] , або Queue[AnyRef] :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; def doesCompile(q: Queue[AnyRef]) {}
doesCompile: (Queue[AnyRef])Unit</pre>
    <p>Таким чином, Queue є трейтом, та Queue[String] є типом. Queue також
      називається конструктором типа, оскільки з ним ви можете конструювати тип,
      задавши параметр типу. (Це аналогічно до конструювання примірника об'єкта
      за допомогою старого-звичайного конструктора, перадавши значення
      параметра). Конструктор типу Queue “генерує” сімейство типів, що включає
      Queue[Int], Queue[String] та Queue[AnyRef] .</p>
    <p>Ви також можете скзати, що Queue є трейтом-дженеріком. (Класи та трейти,
      що приймають параметри типу є “дженеріками”, але типи, що вони генерують,
      є “параметризованими”, не загальними). Термін “дженерік” означає, що ви
      визначаєте багато окремих типів з одного, загально написаного, класа або
      трейта. Наприклад, трейт Queue в лістингу 19.4 визначає загальну чергу.
      Queue[Int] та Queue[String], тощо, будуть спецефічними чергами.</p>
    <p>Комбінація параметрів типу та субтіпів викриває деякі цікаві питання.
      Наприклад, чи є любі особливі віношення субтипів між членами сім'ї типів,
      згенерованих Queue[T]. Більш точно, чи має Queue[String] розглядатись
      субтипом до Queue[AnyRef]? Або більш загально, якщо S є підтипом типа T,
      тоді чи має Queue[S] розглядатись як субтип Queue[T]? Якщо так, ви можете
      сказати, що трейт Queue є коваріантним (або “гнучким”) в своєму параметрі
      типа T. Або, оскільки він має тільки один параметр типа, можна просто
      сказати, що Queue є коваріантом. </p>
    <p>Коваріантність Queue може, наприклад, означати, що ви можете передати
      Queue[String] до метода doesCompile, показаний раніше, що приймає значення
      параметра типу Queue[AnyRef] .</p>
    <p>Інтуітивно, все це виглядає добре, оскільки черга String виглядає як
      окремий випадок черги AnyRef. Однак в Scala узагальнені типи мають по
      замовчанню нонваріантну (або “ригідну”) субтипізацію. Тобто, коли Queue
      визначене як в Лістингу 19.4, черги з різними типами елементів ніколи не
      будуть в відношенні субтипів. Queue[String] не буде корисним в якості
      Queue[AnyRef]. Однак ви можете вимагати коваріантної (гнучкої)
      субтипізації черг, через зміну першого рядка визначення класа Queue таким
      чином:</p>
    <pre class="prettyprint linenums language-scala">trait Queue[+T] { ... }</pre>
    <p>Префікс формального параметра типа в вигляді + вказує, що субтипізація є
      коваріантною (гнучкою) для цього параметра. Через додавання цього єдиного
      символа, ви кажете Scala, що ви бажаєте, щоб Queue[String], наприклад,
      розглядалось як субтип для Queue[AnyRef]. Компілятор буде перевіряти, що
      Queue визначений в спосіб, що ця субтипізація має сенс. Окрім + є також
      префікс -, що індикує контрваріантну типізацію. Якщо Queue було визначене
      таким чином:</p>
    <pre class="prettyprint linenums language-scala">trait Queue[-T] { ... }</pre>
    <p>тоді якщо T є субтипом типа S, це означає, що Queue[S] є субтипом
      Queue[T] (що в випадку черг було б скоріше сюрпризом)! Коли параметр є
      коваріантним, контрваріантним, або нонваріантним, це називається
      варіантністю параметрва. Символи + та -, які ви можете поставити поряд з
      параметрами типів, називаються анотаціями варіації.</p>
    <p>В повністю функціональному світі багато типів є природно коваріантними
      (гнучкими). Однак ситуація змінюється, коли ви вводите змінні дані. Щоб
      зрозуміти чому, розглянемо простий тип з одноелементних клітин, що можуть
      бути прочитані або записані, показанй на Лістингу 19.5.</p>
    <pre class="prettyprint linenums language-scala">class Cell[T](init: T) {
  private[this] var current = init
  def get = current
  def set(x: T) { current = x }
}</pre>
    <p>Лістинг 19.5 Нонваріантний (ригідний) клас Cell.</p>
    <p>Тип Cell на Лістингу 19.5 декларований як нонваріантний (рігидний). Для
      цілей аргументації, уявіть на момент, що Cell був би, навпаки,
      декларований як коваріантний — тобто, він був декларований як клас
      Cell[+T] — та що це б пройшло через компілятор Scala. (Цього не буде, і ми
      через мить пояснимо чому). Тоді ви б могли сконструювати наступну
      проблематичну послідовність тверджень:</p>
    <pre class="prettyprint linenums language-scala">val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get</pre>
    <p>Взяті поодинці, кожен з ціх чотирьох рядків виглядає добре. Перший рядок
      створює клітину рядків, та зберігає її в val на ім'я c1. Друий рядок
      визначає нову val c2, типу Cell[Any], що ініційований c1. Це можливо,
      оскільки Cell розглядається як коваріант. Третій рядок встановлює значення
      клітини c2 в 1. Це також можливе, оскільки присвоєне значення 1 є
      примірником типа елемента c2, Any. Нарешті, останнє присвоєння значення
      елемента c1 до рядка. Тут нічого дивного, бо обоє частини є одного типа.
      Але взяті разом, ці три рядка завершуються присвоєнням цілого 1 рядку s.
      Це явне порушення міцності типів.</p>
    <p>Яка операція призведе до відмови часу виконання? Це має бути друга, що
      використовує коваріантну субтипізацію. Інші твердження дуже прості та
      фундаментальні. Таким чином, Cell з String не є також Cell з Any, оскільки
      є речі, що ви можете робити з Cell з Any, що ви не можете робити з Cell зі
      String. Наприклад, ви не можете використовувати set з аргументом Int на
      Cell зі String.</p>
    <p>Фактично, коли ви передасте коваріантну версію Cell до компілятора&nbsp;
      Scala, ви отримаєте помилку часу компіляці:</p>
    <pre class="prettyprint linenums language-scala">Cell.scala:7: error: covariant type T occurs in
contravariant position in type T of value x
def set(x: T) = current = x
ˆ</pre>
    <h4>Варіації та масиви</h4>
    <p>Цікаво порівняти цю поведінку з масивами в Java. В принципі масиви є
      тільки клітини, за тим винятком, що вони можуть зберігати більше одного
      елемента. Тим не менш, масиви трактуються як коваріантні в Java. Ви можете
      спробувати приклад, подібний до взаємодії з клітиною вище з масивами Java:</p>
    <pre class="prettyprint linenums language-scala">// це Java
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];</pre>
    <p>Якщо ви спробуєте цей приклад, ви будете бачити, що це компілюється, але
      виконання програми спричинить виключення ArrayStore під час, коли до a2[0]
      присвоюється Integer :</p>
    <pre class="prettyprint linenums language-scala">Exception in thread "main" java.lang.ArrayStoreException:
java.lang.Integer
at JavaArrays.main(JavaArrays.java:8)</pre>
    <p>Що тут відбуваєтсья, це те, що Java зберігає тип елементу масива під час
      виконання. Потім, кожного разу, коли елемент масива оновлюється, нове
      значення елемента перевіряється на привід збереженого типу. Якщо це не
      примірник цього типу, підіймається виключення ArrayStore.</p>
    <p>Ви можете спитати, чому Java прийняла цей дизайн, що виглядає обоє,
      небезпечним та коштовним. Коли йому задавали це питання, James Gosling,
      головний винахідник мови Java, відповідав, що вони бажали мати простий
      спосіб розглядати масиви загалом. Наприклад, вони бажали бути в змозі
      написати метод, який сортує всі елемменти в масиві, використовуючи
      сигнатуру, як показано нижче, що приймає масив типу Object :</p>
    <pre class="prettyprint linenums language-scala">void sort(Object[] a, Comparator cmp) { ... }</pre>
    <p>Коваріантність масивів була потрібна, так що масиви довільних типів
      посилань можуть бути передані цьому методу сортування. Звичайно, з появою
      Java дженериків, такий метод сортування тепер може буде написаний з
      параметро типу, так що коваріантність масивів більше не потрібна. Однак з
      причин сумісності вона збережена в Java досьогодні.</p>
    <p>Scala намагається бути чистішою, ніж Java, не розглядаючи масиви як
      коваріанти.&nbsp;&nbsp; Ось що ви отримаєте, якщо транслюєте перші два
      рядка приклада з масивом на Scala:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val a1 = Array("abc")
a1: Array[java.lang.String] = Array(abc)
<br>scala&gt; val a2: Array[Any] = a1
&lt;console&gt;:5: error: type mismatch;
found: Array[java.lang.String]
required: Array[Any]
<br>val a2: Array[Any] = a1
      </pre>
    Що тут відбувається, це те, що Scala розглядає масиви як неваріантні
    (негнучкі), так що Array[String] не розглядається як відповідаючий
    Array[Any] . Однак, іноді потрібно взаємодіяти зі старими методами в Java,
    що використовують масив Object як спосіб емулювати масив-дженерік.
    Наприклад, ви можете побажати викликати метод сортування, як такий, що
    тільки що був описаний для String s в якості аргумента. Щоб зробити це
    можливим, Scala дозволяє вам кастинг масиву типа T s&nbsp; до масиву любого
    типу&nbsp; :
    <p></p>
    <pre class="prettyprint linenums language-scala">scala&gt; val a2: Array[Object] = a1.asInstanceOf[Array[Object]]
a2: Array[java.lang.Object] = Array(abc)</pre>
    <p>Кастинг завжди легальний під час компіляції, та він завжди буде успішний
      від час виконання, оскільки модель підлеглого рантайму&nbsp; JVM&nbsp;
      розглядає масиви коваріантно, так само, як це робить мова Java. Але після
      цього ви можете отримати виключення ArrayStore, знову так само, як це
      можливо в Java.</p>
    <h4>19.4 Перевірка анотацій варіантності</h4>
    <p>Тепер, коли ви побачили деякі приклади, де варіантність непридатна, ви
      можете поцікавитись, який різновид визначення класів мають бути відкинуті,
      та які є прийнятні. До цього часу всі порушення придатності типів включали
      деяке перепризначуване поле або елемент масиву. Повністю функціональна
      реалізація черг, з іншого боку, виглядає як гарна кандидатура на
      коваріантність. Однак, наступний приклад показує, що ви можете
      "зінженерити" неприйнятну ситуацію, навіть якщо немає перепризначуваного
      поля. </p>
    <p>Щоб налаштувати приклад, уявімо, що черги, як визначено в Лістингу
      Listing 19.4, є коваріантні. Тепер створимо субклас черг, що вказує тип
      елементів як&nbsp; Int, та перекриває метод поставлення в чергу:</p>
    <pre class="prettyprint linenums language-scala">class StrangeIntQueue extends Queue[Int] {
  override def enqueue(x: Int) = {
    println(math.sqrt(x))
    super.enqueue(x)
  }
}</pre>
    <p>Метод enqueue в StrangeIntQueue друкує квадратний корінь від свого
      (цілого) аргументу, перед тим, як зробити саме приєднання. Тепер ви можете
      написати анти-приклад з двох рядків:</p>
    <pre class="prettyprint linenums language-scala">val x: Queue[Any] = new StrangeIntQueue
x.enqueue("abc")</pre>
    <p>Перший з ціх двох рядків валідний, оскільки StrangeIntQueue є субкласом
      до Queue[Int] , та, вважаючи що черги коваріантні, Queue[Int] є субтипом
      до Queue[Any] . Другий рядок валідний, оскільки ви можете додати String до
      Queue[Any] . Однак, беручи ці два рядка рязом, ми отримаємо застосування
      квадраного кореня до рядка, що не має сенсу. Очевидно, змінні поля не є
      єдиною причиною, що роблять коваріантні типи безглуздими. </p>
    <p>Проблема є більш загальною. З'ясовується, що як тільки дженерік параметр
      типу з'являється як тип параметру метода, містящий його клас або трейт не
      може бути коваріантним по цьому параметру типа. Для черг метод&nbsp;
      enqueue порушує цю умову:</p>
    <pre class="prettyprint linenums language-scala">class Queue[+T] {
  def enqueue(x: T) =
    ...
  }</pre>
    <p>Виконання класу модифікованої черги, яка показана вище, в компіляторі
      Scala буде давати таке:</p>
    <pre class="prettyprint linenums language-scala">Queues.scala:11: error: covariant type T occurs in
      contravariant position in type T of value x
      def enqueue(x: T) =
      ˆ</pre>
    <p>Переприсвоювані поля є особливим випадком правила, що не дозволяє
      параметрам, анотованим з + , бути використаними як типи параметрів метода.
      Як зазначалось в Розділі 18.2, переприсвоюване поле “ var x: T ”
      розглядається в Scala метод-геттер&nbsp; “ def x: T ”, та
      метод-сеттер&nbsp; def x_=(y: T) ”. Як ви можете бачити, метод-сеттер має
      параметр з типом параметру T . Так що цей тип не може бути коваріантним.</p>
    <h4>Швидкий шлях</h4>
    <p>В залишку цього розділу ми опишемо механізм, за допомгою якого компілятор
      Scala перевіряє анотації варіантності. Якщо ви не зацікавлені в таких
      деталях саме зараз, ви можете вільно перейти до Розділу 19.5. Найбільш
      важлива річ, що треба зрозуміти, це що компілятор Scala буде перевіряти
      любі анотації варіантності, що ви покладете як типи параметрів. Наприклад,
      якщо ви спробуєте декларувати тип параметру як коваріантний (додаючи + ),
      але це може призвести до помилок часу виконання, програма не буде
      компілюватись.</p>
    <p>Щоб перевірити коректність анотацій варіантності, колмпілятор Scala
      класифікує всі позиції в тілі класа або трейта як позитивні, негативні або
      нейтральні. “Позиція” я любим розташуванням в тілі класу (або трейту, але
      відтепер ми будемо писати просто “клас”), де можуть використовуватись
      параметри типів. Як приклад, кожне значення параметру метода є позицією,
      оскільки значення параметру метода має тип, і, таким чином, в цій позиції
      може з'являтись параметр типу. Компілятор перевіряє кожне використання
      кожного з параметрів типу класа. Параметри типу, анонсовані з +, можуть
      тільки бути використані в позитивних позиціях, тоді як позиції, анотовані
      з допомогою -, можуть бути використані тільки в негативних позиціях.
      Параметр типу без анотації варіантності може бути використаний в любій
      позиції, і, таким чином, це єдиний різновид параметра типу, що може бути
      використаний в нейтральних позиціях тіла класу.</p>
    <p>Щоб класифікувати позицію, компілятор починає від декларації параметра
      типу, та потім просуваєтся далі, через глибші рівні вкладення. Позиції на
      вищому рівні декларованого класу класифікуються як позитивні. По
      замовченню позиції на нижчих рівнях класифікуються так саме, що і на
      оточуючому рівні, але є декілька виключень, коли класифікація змінюється.
      Позиції значень параметрів метода класифікуються як змінені, відносно до
      позицій за межами метода, де змінене позначає позитивне для негативного,
      та навпаки, та нейтральна класифікація не змінюється, та залишається
      нейтральною.</p>
    <p>Крім позицій значень параметрів методів, поточна класифікація також
      змінюється на параметрах типів методів. Класифікація часом змінюється в
      позиції аргумента типа, як Arg в C[Arg] , в залежності від варіантності
      відповідного параметра типу. Як параметр типу&nbsp; C анотований з + ,
      тоді класифікація залишається тою самою. Якщо параметр типу анотований за
      допомогою -, тоді поточна класифікація змінюється. Якщо параметр типу C не
      має анотації варіантності, тоді поточна класифікація змінюється на
      нейтральну.</p>
    <p>Як дещо надуманий приклад, розглянемо наступне визначення класу, де
      варіантність деяких позицій анотована за допомогою + (для позитивних), або
      − (для негативних):</p>
    <pre class="prettyprint linenums language-scala">abstract class Cat[-T, +U] {
  def meow[W − ](volume: T − , listener: Cat[U + , T − ] − )
    : Cat[Cat[U + , T − ] − , U + ] +
}</pre>
    <p>Позиції переметру типа, та два значення параметрів, volume та listener,
      всі є негативними. Дивлячись на тип результату meow, позиція першого
      аргументу Cat[U, T] є негативним, оскільки параметр типу першого аргументу
      Cat, T , анотований з&nbsp; - . Тип U в аргументі є знову позитивною
      позицією (двічі змінений), тоді як тип T всередині цього аргументу знову в
      негативній позиції.</p>
    <p>Ви бачите з цієї дискусії, що є досить складно прослідкувати варіантність
      позицій. Ось чому ми вітаємо послаблення, яке робить копілятор Scala,
      роблячи цю роботу за вас. </p>
    <p>Коли варіантність вже обчислена, компілятор перевіряє, що кожний параметр
      типу використовується тільки в позиціях, де вони відповідно класифіковані.
      В цьому випадку, T використовується лише в негативних позиціях, та U
      використовується тільки в позитивних позиціях. Так що клас Cat типово
      коректний.</p>
    <h3>19.5 Нижні межі</h3>
    <p>Повернемось до класу Queue. Ви бачите, що попереднє визначення Queue[T],
      показане в Лістингу 19.4 не можна зробити коваріантним щодо T, оскільки T
      з'являється як тип параметру метода enqueue, та це негативна позиція.
      Нащастя, існує спосіб розрішити це ускладення: ви можете узагальнити
      enqueue, зробивши його поліморфним (тобто, надати самому методу enqueue
      параметр типу), та використовуючи нижню межу для цього параметру типа.
      Лістинг 19.6 показує нове формулювання Queue, що реалізує цю ідею.</p>
    <pre class="prettyprint linenums language-scala">class Queue[+T] (private val leading: List[T], private val trailing: List[T] ) {
  def enqueue[U &gt;: T](x: U) =
    new Queue[U](leading, x :: trailing) <br>  // ...
}</pre>
    <p>Лістинг 19.6 · Параметр типу з нижньою межою.</p>
    <p>Нове визначення надає enqueue параметр типу U , ті з цім синтаксисом “ U
      &gt;: T ” визначає T як нижню межу для U. Як результат, U потребує бути
      супертипом T. Параметр enqueue тепер стає типу U, замість типу T , та тип
      значення повернення метода тепер Queue[U] замість Queue[T]. Як приклад,
      уявімо, що є клас Fruit з двома субкласами, Apple та Orange. З новим
      визначенням класу Queue , можливо додати Orange до Queue[Apple]. Результат
      буде Queue[Fruit]. Це переглянуте визначення enqueue є типово коректним.
      Інтуітивно, якщо T є більш специфічним типом, ніж очікувалось (наприклад,
      Apple замість Fruit ), виклик enqueue буде все ще робити, оскільки U (
      Fruit ) все ще буде супертипом T ( Apple ).</p>
    <p>Нове визначення enqueue можливо краще, ніж старе, оскільки є більш
      загальним. На відміну від старої версії, нове визначення дозволяє вам
      додавати довільні супертипи U як елементи черги типу T. Результатом цього
      буде Queue[U] . Разом з коваріантністю черги, це надає гарний тип
      гнучкості для моделювання черг з різними типами елементів в природний
      спосіб. Це показує, що анотації варіантності та нижня межа гарно грають
      разом. Вони є гарним прикладом типо-залежного дизайну, де типи інтерфейсу
      направляють детальну розробку та реалізаці. В випадку черг, вам, можливо,
      не слідує міркувати про покрещену реалізацію enqueue з нижньрю межею, але
      ви можете вирішити зробити черги коваріантними. В цьому випадку компілятор
      може вказати на помилку варіантності в enqueue. Коректування помилки
      варіантності через додавання нижньої межі більш загальне, та загалом
      більше корисне.</p>
    <p>Зауваження: </p>
    <p>1. Відношення супертипу та субтипу є рефлексивним, що означає що тип є
      одночасно супертипом та субтипом самого себе. Навіть якщо T є новою межею
      для U, ви все ще можете передати T до enqueue .<br>
    </p>
    <p>2 Технічно, що відбувається, це зміна знаку для нижньої межі. Параметр
      типу U є в негативній позиції (1 зміна), тоді як нижня межа ( &gt;: T ) є
      в позитивній позиції (2 зміни).</p>
    <p>Це дослідження також є головною причиною, чому Scala віддає перевагу
      декларативно-визначеній варіантності над використання-визначеній
      варіантності, як це спостерігається з зірочками Java. Коли варіантність
      визначається в місці використання, ви стаєте наодинці з собою, коли
      розробляєте клас. Клієн є саме тим, кому знадобиться вставляти зірочки, та
      якщо вони помиляться, деякі важливі методи інтерфейсу будуть більше не
      застосовні. Варіантність залишається важкою справою, користувачі часто
      розуміють її невірно, та вони йдуть геть, думаючи, що зірочки та дженеріки
      є дуже заскладними. Коли варіантність застосовується в місці визначення,
      ви повідомляєте свої наміри компілятору, та компілятор двічі перевірить,
      що методи, які ви зробили доступними, будуть саме доступними.</p>
    <h3>19.6 Контрваріантність</h3>
    <p>Доки в цій главі всі приклади, що ви бачили, були або коваріантними, або
      безваріантними. Але також існують випадки, коли контрваріантність є
      природною. Наприклад, розглянемо трейт вихідних каналів, показаний в
      Лістингу 19.7:</p>
    <pre class="prettyprint linenums language-scala">trait OutputChannel[-T] {
  def write(x: T)
}</pre>
    <p>Лістинг 19.7 Контрваріантний вихідний канал.</p>
    <p>Тут OutputChannel визначений як контрваріантний по T. Так що вихідний
      канал зі, скажімо, AnyRef, є субтипом вихідного канала String. Хоча це
      може виглядати неінтуітивним, насправді це має сенс. Щоб побачити чому,
      розглянемо, що ми можемо робити з OutputChannel[String]. Єдина
      підтримувана операція є писання рядка String до нього. Така сама операція
      також може бути зроблена на OutputChannel[AnyRef]. Так що бещпечно
      підставити OutputChannel[AnyRef] для OutputChannel[String]. Для контрасту,
      це може не бути безпечним поставити OutputChannel[String], коли вимагаєтся
      OutputChannel[AnyRef]. В кінці кінців, ви можете надіслати любий об'єкт до
      OutputChannel[AnyRef], тоді як OutputChannel[String] потребує, щоб всі
      записані значення були рядками.</p>
    <p>Ці міркуівання вказує на головний принцип в розробці систем типів:
      безпечно вважати, що тип T є субтипом типу U, якщо ви можете замінити
      значення типу T, там, де потрібне значення типу U. Це називається
      принципом підстановки Ліскова. Принцип підтримужться, якщо T підтримує ті
      самі операції, що і U, та всі з операцій T потребують менше, та провадять
      більше, ніж відповідні операції в U. В випадку вихідних каналів,
      OutputChannel[AnyRef] може бути субтипом OutputChannel[String], оскільки
      обоє підтримують ті самі операції, та ці самі операції потребують менше в
      OutputChannel[AnyRef], ніж в OutputChannel[String]. “Меньше” означає, що
      від аргумента тільки вимагається бути тільки AnyRef в першому випадку, чи
      він потрібен бути String у другому випадку.</p>
    <pre class="prettyprint linenums language-scala">trait Function1[-S, +T] {
  def apply(x: S): T
}</pre>
    <p>Лістинг 19.8 Коваріантність та контрваріантність Function1.</p>
    <p></p>
    <p>Іноді коваріантність та контрваріантність змішані в тому самому типі.
      Яскравим прикладом є функціональні трейти Scala. Наприклад, коли ви пишете
      функціональний тип A =&gt; B , Scala розширює його до Function1[A, B].
      Визначення Function1 в стандартній бібліотеці використовує обоє,
      коваріантність та контрваріантність: трейт Function1 коваріантний по
      функціональному аргументу типу S, та контраваріантний по типу результата
      T, як показано на Лістингу 19.8. Це задовільняє принципу підстановки
      Ліскова, оскільки аргументи є дечим, що вимагається, тоді як результат є
      дечим, що провадитья. Як приклад, розглянемо застосування, показане в
      Лістингу 19.9. В цьому прикладі клас Publication містить одне
      параметризоване поле, title типу String. Клас Book розширює Publication,
      та переправляє свій рядковий параметр title до конструктора суперкласа.
      Об'єкт-сінглтон Library визначає множину книжок, та метод printBookList,
      що приймає функцію на ім' я info, тип якої Book =&gt; AnyRef. Іншими
      словами, тип поодинокого параметру printBookList є функцією, що приймає
      один аргумент Book, та повертає AnyRef. Застосування Customer визначає
      метод getTitle, що приймає Publication в якості свого єдиного параметра,
      та повертає String, заголовок переданної Publication .</p>
    <p>Тепер погляньте на останній рядок Customer. Цей рядок викликає метод
      Library printBookList, та передає getTitle, огорнуте в значення функції:
      Library.printBookList(getTitle)</p>
    <p>Цей рядок коду перевіряє тип, навіть якщо String, тип, повернутий
      функцією, є субтипом AnyRef, результующий тип параметра info в
      printBookList. Цей код проходить компілятор, оскільки результуючі типи
      функції є clared to be covariant (the +T in Listing 19.8). If you look
      inside the body of printBookList , you can get a glimpse of why this makes
      sense. The printBookList method iterates through its book list, and
      invokes the passed function on each book. It passes the AnyRef result
      returned by info to println , which invokes toString on it and prints the
      result. This activity will work with String as well as any other subclass
      of AnyRef , which is what covariance of function result types means. </p>
    <pre class="prettyprint linenums language-scala">class Publication(val title: String)
  class Book(title: String) extends Publication(title)
    object Library {
      val books: Set[Book] = Set(
        new Book("Programming in Scala"),
        new Book("Walden")
      )
      def printBookList(info: Book =&gt; AnyRef) {
        for (book &lt;- books) println(info(book))
      }
    }<br>object Customer extends Application {
  def getTitle(p: Publication): String = p.title
  Library.printBookList(getTitle)
}</pre>
    <p>Лістинг 19.9&nbsp; Демонстрація варіантності функціонального параметру
      типу.</p>
    Тепер розглянемо параметр типу функції, що була передана до метода
    printBookList. Хоча параметр типу printBookList декларований як Book,
    getTitle, ми передаємо туди Publication, супертип Book. Причина, з якох це
    робить, те, що оскільки параметр printBookList має тип Book, тілу метода
    printBookList буде дозволене тільки передавати Book в функцію. Та тому, що
    тип параметра getTitle є Publication, тіло функції буде здатне мати доступ
    до свого параметра, p, членів, що визначені в класі Publication. Оскільки
    любий метод, визначений в Publication, також доступний в його субкласі Book,
    все буде працювати, і це то що означає контрваріантність функціональних
    параметрів типів. Ви можете бачити все це графічно на Малюнку 19.1.
    <p>тип аргументу Publication &lt;= Book<br>
    </p>
    <p>Book =&gt; AnyRef<br>
      ^ ^ ^ ^ <br>
      Publication =&gt; String<br>
    </p>
    <p>тип результату&nbsp; String =&gt; AnyRef</p>
    <p>Малюнок 19.1 Коваріантність та контрваріантність в параметрах типу
      функції.</p>
    <p>Код в Лістингу 19.9 компілюється, бо Publication =&gt; String є субтипом
      до Book =&gt; AnyRef , як показано по центру Малюнка 19.1. Оскільки
      результуючий тип Function1 визначений я коваріантний, відношення
      наслідування двох отриманих типів, показаних зправа діаграми, в тому ж
      напрямку, що і для двох функцій, показаних по центру. І навпаки, оскільки
      параметр типу Function1 визначений як коваріантний, відношення
      наслідування двох параметрів типу, показаних зліва діаграми, є в
      протилежних напрямках, ніж для двох функцій.</p>
    <h3>19.7 Об’єкт-приватні дані</h3>
    <p>Клас Queue, що ми вже бачили, має проблему в тому, що&nbsp; операція
      mirror може повторно копіювати залишок trailing в список leading, якщо
      вона викликається декілька разів поспіль на списку, де leading порожній.
      Марного копіювання можна уникнути через додавання деякого розважливого
      побічного ефекту. Лістинг 19.10 представляє нову реалізацію Queue, що
      виконує щонайменьше одне вирівнювання trailing до leading для кожної
      послідовності операцій head.</p>
    <p>Що змінилось з точки зору попередньої версії, це те, що тепер leading та
      trailing є переприсвоювані значення, та mirror виконує зворотнє копіювання
      з trailing до leading як побічний ефект на поточній черзі, замість
      повертати нову чергу. Цей побічний ефект повністю внутрішній до реалізації
      операцій Queue; оскікльи leading та trailing є приватними змінними, ефект
      не видимий для клієнтів Queue. Так що за термінологією, встановленою в
      Главі 18, нова версія Queue все ще виражає чисто функціональні об’єкти, не
      зважаючи на факт, що тепер вони містять перепризначувані поля.</p>
    <pre class="prettyprint linenums language-scala">class Queue[+T] private (
  private[this] var leading: List[T],
  private[this] var trailing: List[T]
) {
  private def mirror() =
    if (leading.isEmpty) {
      while (!trailing.isEmpty) {
        leading = trailing.head :: leading
        trailing = trailing.tail
      }
    }
  def head: T = {
    mirror()
    leading.head
  }
  def tail: Queue[T] = {
    mirror()
    new Queue(leading.tail, trailing)
  }
  def enqueue[U &gt;: T](x: U) =
    new Queue[U](leading, x :: trailing)
}</pre>
    <p>Лістинг 19.10 Оптимізована функціональна черга.</p>
    <p>Ви можете поцікавитись, чи цей код пройде первірку типів Scala. В кінці
      кінців, тепер він містить два перепризначувані поля коваріантного
      параметра типу T. Чи це не порушення правил варіації? Це могло б бути так,
      за винятком деталі, що leading та trailing мають модифікатор
      private[this], і, таким чином, визначені як приватні до об’єкта.</p>
    <p>Як згадувалось в Розділі 13.5, об’єктно-праватні члени можуть отримати
      доступ тільки з середини об’єкта, в якому вони визначені. Виявляється, що
      доступ до змінних з того ж об’єкта, в якому вони визначені, не викликає
      проблеми з варіантністю. Інтуітивним поясненням до цього в тому, що щоб
      сконструювати випадок, де варіантність може призвести до помилок типу, вам
      треба мати посилання на містячий об’єкт, що має статично слабший тип, ніж
      тип об’єкта, в якому він визначений. Однак для об’єкт-приватних значень це
      не можливо.&nbsp;</p>
    <p>Правила перевірки варіацій Scala містять спеціальний випадок для
      об’єктно-приватних визначень. Такі визначення опускаються, коли
      перевірено, що параметр типу з анотацією + або - з’являється тільки в
      позиціях, що мають ту ж класифікацію варіації. Таким чином, код в Лістингу
      19.10 компілюється без помилок. З іншого боку, якщо ви відкинете
      кваліфікатори [this] з двох приватних модифікаторів, ви побачите длві
      помилки типу:</p>
    <pre class="prettyprint linenums language-scala">Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter leading_=
class Queue[+T] private (private var leading: List[T],
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter trailing_=
private var trailing: List[T]) {
ˆ</pre>
    <h3>19.8 Верхня межа</h3>
    <p>В Лістингу 16.1 ми показалу функцію сортування злиттям для списків, що
      приймають функцію порівняння як перший аргумент, та список для сортування
      як другий, карований, аргумент. Інший шлях, як ви можете організувати таку
      функцію sort є вимагати від типу списка підміксувати трейт Ordered. Як
      згадувалось в Розділі 12.4, міксуючи Ordered до класа та реалізуючи один
      абстрактний метод, compare, ви дозволяєте клієнтам порівнювати примірники
      цього класа за допомогою &lt; , &gt; , &lt;= , та &gt;= . Наприклад,
      Лістинг&nbsp; 19.11 показує, як Ordered домішується до класа Person. Як
      результат, ви можете порівнювати особи таким чином:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val robert = new Person("Robert", "Jones")
robert: Person = Robert Jones
scala&gt; val sally = new Person("Sally", "Smith")
sally: Person = Sally Smith
scala&gt; robert &lt; sally
res0: Boolean = true

class Person(val firstName: String, val lastName: String)
  extends Ordered[Person] {
  def compare(that: Person) = {
    val lastNameComparison =
      lastName.compareToIgnoreCase(that.lastName)
    if (lastNameComparison != 0)
      lastNameComparison
    else
      firstName.compareToIgnoreCase(that.firstName)
  }
  override def toString = firstName +" "+ lastName
}</pre>
    <p>Лістинг 19.11 Клас Person, що міксується&nbsp; з трейтом Ordered.</p>
    <pre class="prettyprint linenums language-scala">def orderedMergeSort[T &lt;: Ordered[T]](xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) =&gt; ys
      case (_, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (x &lt; y) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
    val n = xs.length / 2
    if (n == 0) xs
    else {
      val (ys, zs) = xs splitAt n
      merge(orderedMergeSort(ys), orderedMergeSort(zs))
    }
}</pre>
    <p>Лістинг 19.12 Функція сортування злиттям з верхньою межою.</p>
    <p>Щоб вимагати, щоб тип списка, переданого до вашої нової функції sort
      міксувався з Ordered, вам треба використати верхню межу. Верхня межа
      виглядає подібно до нижньої межі, за винятком того, що замість
      симовла&nbsp; &gt;: для нижньої межі ви використовуєте символ &lt;:, як
      показано в Лістингу 19.12. З синтаксисом "T &lt;: Ordered[T] ” ви
      вказуєте, що параметр типу T має верхню межу, Ordered[T]. Це означає, що
      елемент типу списку, переданого до orderedMergeSort має бути субтипом до
      Ordered. Таким чином, ви можете передати List[Person] до orderedMergeSort,
      оскільки Person підмішує Ordered. Наприклад, розглянемо цей список:</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val people = List(
new Person("Larry", "Wall"),
new Person("Anders", "Hejlsberg"),
new Person("Guido", "van Rossum"),
new Person("Alan", "Kay"),
new Person("Yukihiro", "Matsumoto")
)
people: List[Person] = List(Larry Wall, Anders Hejlsberg,
Guido van Rossum, Alan Kay, Yukihiro Matsumoto)</pre>
    <p>Оскільки&nbsp; тип елемента цього списка, Person, підмішується (та є,
      таким чином, підтипом) Ordered[People], ви можете передати список до
      orderedMergeSort :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val sortedPeople = orderedMergeSort(people)
sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
Yukihiro Matsumoto, Guido van Rossum, Larry Wall)</pre>
    <p>Тепер, хоча функція sort, показана в Лістингу 19.12 прислуговується як
      корисна ілюстрація верньої межі, насправді це не найбільш загальний спосіб
      в Scala розробити функцію sort, що приймає вигоду трейта Ordered.
      Наприклад, ви не можете використовувати функцію orderedMergeSort для
      сортування списка цілих, оскільки клас Int не є субтипом Ordered[Int] :</p>
    <pre class="prettyprint linenums language-scala">scala&gt; val wontCompile = orderedMergeSort(List(3, 2, 1))
&lt;console&gt;:5: error: inferred type arguments [Int] do
not conform to method orderedMergeSort's type
parameter bounds [T &lt;: Ordered[T]]
val wontCompile = orderedMergeSort(List(3, 2, 1))
ˆ</pre>
    <p>В Розділі 21.6 ми покажемо вам, як використовувати неявні параметри та
      межі поля зору для досяження більш загального рішення.</p>
    <h4>19.9 Висновок</h4>
    <p>В цій главі ви бачили декілька прийомів для приховання інформації:
      приватні конструктори, методи-фабрики, абстракції типів приватні члени
      об’єктів. Ви також вивчили, як вказати варіантність типів даних, та що це
      накладає на реалізації класів. Нарешті, ви бачили два прийоми, що
      допомагають в отриманні гнучких анотацій варіації: нижчі межі для
      параметрів типів метода, та анотації private[this] для локальних полів та
      методів. </p>
    <h2>Chapter 20</h2>
    <p>Abstract Members<br>
      A member of a class or trait is abstract if the member does not have a
      com-<br>
      plete definition in the class. Abstract members are intended to be imple-<br>
      mented in subclasses of the class in which they are declared. This idea is<br>
      found in many object-oriented languages. For instance, Java lets you
      declare<br>
      abstract methods. Scala also lets you declare such methods, as you saw in<br>
      Section 10.2. But Scala goes beyond that and implements the idea in its
      full<br>
      generality: besides methods, you can also declare abstract fields and even<br>
      abstract types as members of classes and traits.<br>
      In this chapter we’ll describe all four kinds of abstract member: val s,<br>
      var s, methods, and types. Along the way we’ll discuss pre-initialized
      fields,<br>
      lazy val s, path-dependent types, and enumerations.<br>
      20.1<br>
      A quick tour of abstract members<br>
      The following trait declares one of each kind of abstract member: an
      abstract<br>
      type ( T ), method ( transform ), val ( initial ), and var ( current ):<br>
      trait Abstract {<br>
      type T<br>
      def transform(x: T): T<br>
      val initial: T<br>
      var current: T<br>
      }<br>
      A concrete implementation of Abstract needs to fill in definitions for
      each<br>
      of its abstract members. Here is an example implementation that provides<br>
      these definitions:</p>
    <p><br>
      class Concrete extends Abstract {<br>
      type T = String<br>
      def transform(x: String) = x + x<br>
      val initial = "hi"<br>
      var current = initial<br>
      }</p>
    <p>The implementation gives a concrete meaning to the type name T by
      defining<br>
      it as an alias of type String . The transform operation concatenates a
      given<br>
      string with itself, and the initial and current values are both set to
      "hi" .<br>
      This example gives you a rough first idea of what kinds of abstract mem-<br>
      bers exist in Scala. The remainder of the chapter will present the details
      and<br>
      explain what the new forms of abstract members, as well as type members<br>
      in general, are good for.</p>
    <h3>20.2 Type members</h3>
    <p>As you can see from the example in the previous section, the term
      abstract<br>
      type in Scala means a type declared (with the “ type ” keyword) to be a
      mem-<br>
      ber of a class or trait, without specifying a definition. Classes
      themselves<br>
      may be abstract, and traits are by definition abstract, but neither of
      these are<br>
      what are referred to as abstract types in Scala. An abstract type in Scala
      is<br>
      always a member of some class or trait, such as type T in trait Abstract .<br>
      You can think of a non-abstract (or, “concrete”) type member, such as<br>
      type T in class Concrete , as a way to define a new name, or alias, for a<br>
      type. In class Concrete , for example, the type String is given the alias<br>
      T . As a result, anywhere T appears in the definition of class Concrete ,
      it<br>
      means String . This includes the parameter and result types of transform ,<br>
      initial , and current , which mention T when they are declared in super-<br>
      trait Abstract . Thus, when class Concrete implements these methods,<br>
      those T s are interpreted to mean String .<br>
      One reason to use a type member is to define a short, descriptive alias<br>
      for a type whose real name is more verbose, or less obvious in meaning,
      than<br>
      the alias. Such type members can help clarify the code of a class or
      trait.<br>
      The other main use of type members is to declare abstract types that must
      be defined in subclasses. This use, which was demonstrated in the previous
      section, will be described in detail later in this chapter <br>
      20.3 Abstract val s<br>
      An abstract val declaration has a form like:</p>
    <p><br>
      val initial: String</p>
    <p>It gives a name and type for a val , but not its value. This value has to<br>
      be provided by a concrete val definition in a subclass. For instance,
      class<br>
      Concrete implemented the val using:<br>
      val initial = "hi"</p>
    <p>You use an abstract val declaration in a class when you do not know the<br>
      correct value in the class, but you do know that the variable will have an<br>
      unchangeable value in each instance of the class.<br>
      An abstract val declaration resembles an abstract parameterless method<br>
      declaration such as:</p>
    <p>def initial: String</p>
    <p>Client code would refer to both the val and the method in exactly the
      same<br>
      way, i.e., obj.initial . However, if initial is an abstract val , the
      client<br>
      is guaranteed that obj.initial will yield the same value every time it is<br>
      referenced. If initial were an abstract method, that guarantee would not<br>
      hold, because in that case initial could be implemented by a concrete<br>
      method that returns a different value every time it’s called.<br>
      In other words, an abstract val constrains its legal implementation: any<br>
      implementation must be a val definition; it may not be a var or a def .<br>
      Abstract method declarations, on the other hand, may be implemented by<br>
      both concrete method definitions and concrete val definitions. Given the<br>
      abstract class Fruit shown in Listing 20.1, class Apple would be a legal<br>
      subclass implementation, but class BadApple would not.<br>
      <br>
      abstract class Fruit {<br>
      val v: String // ‘v’ for value<br>
      def m: String // ‘m’ for method<br>
      }<br>
      abstract class Apple extends Fruit {<br>
      val v: String<br>
      val m: String // OK to override a ‘def’ with a ‘val’<br>
      }<br>
      abstract class BadApple extends Fruit {<br>
      def v: String // ERROR: cannot override a ‘val’ with a ‘def’<br>
      def m: String<br>
      }<br>
      Listing 20.1 · Overriding abstract val s and parameterless methods.<br>
      20.4<br>
      Abstract var s<br>
      Like an abstract val , an abstract var declares just a name and a type,
      but<br>
      not an initial value. For instance, Listing 20.2 shows a trait
      AbstractTime ,<br>
      which declares two abstract variables named hour and minute :<br>
      trait AbstractTime {<br>
      var hour: Int<br>
      var minute: Int<br>
      }<br>
      Listing 20.2 · Declaring abstract var s.<br>
      What is the meaning of abstract var s like hour and minute ? You saw in<br>
      Section 18.2 that var s declared as members of classes come equipped with<br>
      getter and setter methods. This holds for abstract var s as well. If you
      declare<br>
      an abstract var named hour , for example, you implicitly declare an
      abstract<br>
      getter method, hour , and an abstract setter method, hour_= . There’s no<br>
      reassignable field to be defined—that will come in subclasses that define
      the<br>
      concrete implementation of the abstract var . For instance, the definition
      of<br>
      AbstractTime shown in Listing 20.2 is exactly equivalent to the definition<br>
      shown in Listing 20.3.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      450Section 20.5<br>
      Chapter 20 · Abstract Members<br>
      trait AbstractTime {<br>
      def hour: Int // getter for ‘hour’<br>
      def hour_=(x: Int) // setter for ‘hour’<br>
      def minute: Int // getter for ‘minute’<br>
      def minute_=(x: Int) // setter for ‘minute’<br>
      }<br>
      Listing 20.3 · How abstract var s are expanded into getters and setters.<br>
      20.5<br>
      Initializing abstract val s<br>
      Abstract val s sometimes play a role analogous to superclass parameters:<br>
      they let you provide details in a subclass that are missing in a
      superclass. This<br>
      is particularly important for traits, because traits don’t have a
      constructor to<br>
      which you could pass parameters. So the usual notion of parameterizing<br>
      a trait works via abstract val s that are implemented in subclasses. As an<br>
      example, consider a reformulation of class Rational from Chapter 6, as<br>
      shown in Listing 6.5 on page 155, as a trait:<br>
      trait RationalTrait {<br>
      val numerArg: Int<br>
      val denomArg: Int<br>
      }<br>
      The Rational class from Chapter 6 had two parameters: n for the numerator<br>
      of the rational number, and d for the denominator. The RationalTrait<br>
      trait given here defines instead two abstract val s: numerArg and denomArg
      .<br>
      To instantiate a concrete instance of that trait, you need to implement
      the<br>
      abstract val definitions. Here’s an example:<br>
      new RationalTrait {<br>
      val numerArg = 1<br>
      val denomArg = 2<br>
      }<br>
      Here the keyword new appears in front of a trait name, RationalTrait ,<br>
      which is followed by a class body in curly braces. This expression yields
      an<br>
      instance of an anonymous class that mixes in the trait and is defined by
      the<br>
      body. This particular anonymous class instantiation has an effect
      analogous<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      451Section 20.5<br>
      Chapter 20 · Abstract Members<br>
      to the instance creation new Rational(1, 2) . The analogy is not perfect,<br>
      however. There’s a subtle difference concerning the order in which expres-<br>
      sions are initialized. When you write:<br>
      new Rational(expr1, expr2)<br>
      the two expressions, expr1 and expr2 , are evaluated before class Rational<br>
      is initialized, so the values of expr1 and expr2 are available for the
      initial-<br>
      ization of class Rational . For traits, however, the situation is the
      opposite.<br>
      When you write:<br>
      new RationalTrait {<br>
      val numerArg = expr1<br>
      val denomArg = expr2<br>
      }<br>
      the expressions, expr1 and expr2 , are evaluated as part of the
      initializa-<br>
      tion of the anonymous class, but the anonymous class is initialized after
      the<br>
      RationalTrait . So the values of numerArg and denomArg are not avail-<br>
      able during the initialization of RationalTrait (more precisely, a
      selection<br>
      of either value would yield the default value for type Int , 0). For the
      def-<br>
      inition of RationalTrait given previously, this is not a problem, because<br>
      the trait’s initialization does not make use of values numerArg or
      denomArg .<br>
      However, it does become a problem in the variant of RationalTrait shown<br>
      in Listing 20.4, which defines normalized numerators and denominators:<br>
      trait RationalTrait {<br>
      val numerArg: Int<br>
      val denomArg: Int<br>
      require(denomArg != 0)<br>
      private val g = gcd(numerArg, denomArg)<br>
      val numer = numerArg / g<br>
      val denom = denomArg / g<br>
      private def gcd(a: Int, b: Int): Int =<br>
      if (b == 0) a else gcd(b, a % b)<br>
      override def toString = numer +"/"+ denom<br>
      }<br>
      Listing 20.4 · A trait that uses its abstract val s.<br>
      <br>
      If you try to instantiate this trait with some numerator and denominator<br>
      expressions that are not simple literals, you’ll get an exception:<br>
      scala&gt; val x = 2<br>
      x: Int = 2<br>
      scala&gt; new RationalTrait {<br>
      val numerArg = 1 * x<br>
      val denomArg = 2 * x<br>
      }<br>
      java.lang.IllegalArgumentException: requirement failed<br>
      at scala.Predef$.require(Predef.scala:134)<br>
      at RationalTrait$class.$init$(&lt;console&gt;:8)<br>
      at $anon$1.&lt;init&gt;(&lt;console&gt;:8)<br>
      ...<br>
      The exception in this example was thrown because denomArg still had its<br>
      default value of 0 when class RationalTrait was initialized, which caused<br>
      the require invocation to fail.<br>
      This example demonstrates that initialization order is not the same for<br>
      class parameters and abstract fields. A class parameter argument is
      evaluated<br>
      before it is passed to the class constructor (unless the parameter is
      by-name).<br>
      An implementing val definition in a subclass, by contrast, is evaluated
      only<br>
      after the superclass has been initialized.<br>
      Now that you understand why abstract val s behave differently from pa-<br>
      rameters, it would be good to know what can be done about this. Is it
      possible<br>
      to define a RationalTrait that can be initialized robustly, without
      fearing<br>
      errors due to uninitialized fields? In fact, Scala offers two alternative
      solu-<br>
      tions to this problem, pre-initialized fields and lazy val s. They are
      presented<br>
      in the remainder of this section.<br>
      Pre-initialized fields<br>
      The first solution, pre-initialized fields, lets you initialize a field of
      a subclass<br>
      before the superclass is called. To do this, simply place the field
      definition<br>
      in braces before the superclass constructor call. As an example, Listing
      20.5<br>
      shows another attempt to create an instance of RationalTrait . As you see<br>
      from this example, the initialization section comes before the mention of
      the<br>
      supertrait RationalTrait . Both are separated by a with .</p>
    <p><br>
      scala&gt; new {<br>
      val numerArg = 1 * x<br>
      val denomArg = 2 * x<br>
      } with RationalTrait<br>
      res1: java.lang.Object with RationalTrait = 1/2<br>
      Listing 20.5 · Pre-initialized fields in an anonymous class expression.<br>
      object twoThirds extends {<br>
      val numerArg = 2<br>
      val denomArg = 3<br>
      } with RationalTrait<br>
      Listing 20.6 · Pre-initialized fields in an object definition.<br>
      Pre-initialized fields are not restricted to anonymous classes; they can<br>
      also be used in objects or named subclasses. Two examples are shown<br>
      in Listings 20.6 and 20.7. As you can see from these examples, the pre-<br>
      initialization section comes in each case after the extends keyword of the<br>
      defined object or class. Class RationalClass , shown in Listing 20.7,
      exem-<br>
      plifies a general schema of how class parameters can be made available for<br>
      the initialization of a supertrait.<br>
      Because pre-initialized fields are initialized before the superclass con-<br>
      structor is called, their initializers cannot refer to the object that’s
      being con-<br>
      structed. Consequently, if such an initializer refers to this , the
      reference<br>
      goes to the object containing the class or object that’s being
      constructed, not<br>
      the constructed object itself. Here’s an example:<br>
      scala&gt; new {<br>
      val numerArg = 1<br>
      val denomArg = this.numerArg * 2<br>
      } with RationalTrait<br>
      &lt;console&gt;:9: error: value numerArg is not a member of object<br>
      $iw<br>
      val denomArg = this.numerArg * 2<br>
      ˆ<br>
      The example did not compile because the reference this.numerArg was<br>
      looking for a numerArg field in the object containing the new (which in
      this<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      454Section 20.5<br>
      Chapter 20 · Abstract Members<br>
      class RationalClass(n: Int, d: Int) extends {<br>
      val numerArg = n<br>
      val denomArg = d<br>
      } with RationalTrait {<br>
      def + (that: RationalClass) = new RationalClass(<br>
      numer * that.denom + that.numer * denom,<br>
      denom * that.denom<br>
      )<br>
      }<br>
      Listing 20.7 · Pre-initialized fields in a class definition.<br>
      case was the synthetic object named $iw , into which the interpreter puts
      user<br>
      input lines). Once more, pre-initialized fields behave in this respect
      like class<br>
      constructor arguments.<br>
      Lazy val s<br>
      You can use pre-initialized fields to simulate precisely the
      initialization be-<br>
      havior of class constructor arguments. Sometimes, however, you might pre-<br>
      fer to let the system itself sort out how things should be initialized.
      This can<br>
      be achieved by making your val definitions lazy. If you prefix a val
      defini-<br>
      tion with a lazy modifier, the initializing expression on the right-hand
      side<br>
      will only be evaluated the first time the val is used.<br>
      For an example, define an object Demo with a val as follows:</p>
    <p>scala&gt; object Demo {<br>
      val x = { println("initializing x"); "done" }<br>
      }<br>
      defined module Demo<br>
      Now, first refer to Demo , then to Demo.x :<br>
      scala&gt; Demo<br>
      initializing x<br>
      res3: Demo.type = Demo$@17469af<br>
      scala&gt; Demo.x<br>
      res4: java.lang.String = done<br>
      <br>
      As you can see, the moment you use Demo , its x field becomes initialized.<br>
      The initialization of x forms part of the initialization of Demo . The
      situation<br>
      changes, however, if you define the x field to be lazy :<br>
      scala&gt; object Demo {<br>
      lazy val x = { println("initializing x"); "done" }<br>
      }<br>
      defined module Demo<br>
      scala&gt; Demo<br>
      res5: Demo.type = Demo$@11dda2d<br>
      scala&gt; Demo.x<br>
      initializing x<br>
      res6: java.lang.String = done<br>
      Now, initializing Demo does not involve initializing x . The
      initialization of x<br>
      will be deferred until the first time x is used.<br>
      This is similar to the situation where x is defined as a parameterless<br>
      method, using a def . However, unlike a def a lazy val is never evaluated<br>
      more than once. In fact, after the first evaluation of a lazy val the
      result of the<br>
      evaluation is stored, to be reused when the same val is used subsequently.<br>
      trait LazyRationalTrait {<br>
      val numerArg: Int<br>
      val denomArg: Int<br>
      lazy val numer = numerArg / g<br>
      lazy val denom = denomArg / g<br>
      override def toString = numer +"/"+ denom<br>
      private lazy val g = {<br>
      require(denomArg != 0)<br>
      gcd(numerArg, denomArg)<br>
      }<br>
      private def gcd(a: Int, b: Int): Int =<br>
      if (b == 0) a else gcd(b, a % b)<br>
      }<br>
      Listing 20.8 · Initializing a trait with lazy val s.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      456Section 20.5<br>
      Chapter 20 · Abstract Members<br>
      Looking at this example, it seems that objects like Demo themselves be-<br>
      have like lazy val s, in that they are also initialized on demand, the
      first time<br>
      they are used. This is correct. In fact an object definition can be seen
      as<br>
      a shorthand for the definition of a lazy val with an anonymous class that<br>
      describes the object’s contents.<br>
      Using lazy val s, you could reformulate RationalTrait as shown in<br>
      Listing 20.8. In the new trait definition, all concrete fields are defined
      lazy .<br>
      Another change with respect to the previous definition of RationalTrait ,<br>
      shown in Listing 20.4, is that the require clause was moved from the body<br>
      of the trait to the initializer of the private field, g , which computes
      the greatest<br>
      common divisor of numerArg and denomArg . With these changes, there’s<br>
      nothing that remains to be done when LazyRationalTrait is initialized; all<br>
      initialization code is now part of the right-hand side of a lazy val .
      Therefore,<br>
      it is safe to initialize the abstract fields of LazyRationalTrait after
      the class<br>
      is defined. Here’s an example:<br>
      scala&gt; val x = 2<br>
      x: Int = 2<br>
      scala&gt; new LazyRationalTrait {<br>
      val numerArg = 1 * x<br>
      val denomArg = 2 * x<br>
      }<br>
      res7: java.lang.Object with LazyRationalTrait = 1/2<br>
      No pre-initialization is needed. It’s instructive to trace the sequence of
      ini-<br>
      tializations that lead to the string 1/2 to be printed in the code above:<br>
      1. First, a fresh instance of LazyRationalTrait gets created, and the<br>
      initialization code of LazyRationalTrait is run. This initialization<br>
      code is empty—none of the fields of LazyRationalTrait is as yet<br>
      initialized.<br>
      2. Next, the primary constructor of the anonymous subclass defined by<br>
      the new expression is executed. This involves the initialization of<br>
      numerArg with 2 and denomArg with 4 .<br>
      3. Next, the toString method is invoked on the constructed object by<br>
      the interpreter, so that the resulting value can be printed.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      457Section 20.5<br>
      Chapter 20 · Abstract Members<br>
      4. Next, the numer field is accessed for the first time by the toString<br>
      method in trait LazyRationalTrait , so its initializer is evaluated.<br>
      5. The initializer of numer accesses the private field, g , so g is
      evaluated<br>
      next. This evaluation accesses numerArg and denomArg , which were<br>
      defined in Step 2.<br>
      6. Next, the toString method accesses the value of denom , which causes<br>
      denom ’s evaluation. The evaluation of denom accesses the values of<br>
      denomArg and g . The initializer of the g field is not re-evaluated, be-<br>
      cause it was already evaluated in Step 5.<br>
      7. Finally, the result string "1/2" is constructed and printed.<br>
      Note that the definition of g comes textually after the definitions of
      numer<br>
      and denom in class LazyRationalTrait . Nevertheless, because all three<br>
      values are lazy, g gets initialized before the initialization of numer and
      denom<br>
      is completed. This shows an important property of lazy val s: the textual<br>
      order of their definitions does not matter, because values get initialized
      on<br>
      demand. Therefore, lazy vals can free you as a programmer from having to<br>
      think hard how to arrange val definitions to ensure that everything is
      defined<br>
      when it is needed.<br>
      However, this advantage holds only as long as the initialization of lazy<br>
      val s neither produces side effects nor depends on them. In the presence
      of<br>
      side effects, initialization order starts to matter. And then it can be
      quite<br>
      difficult to trace in what order initialization code is run, as the
      previous ex-<br>
      ample has demonstrated. So lazy val s are an ideal complement to
      functional<br>
      objects, where the order of initializations does not matter, as long as
      every-<br>
      thing gets initialized eventually. They are less well suited for code
      that’s<br>
      predominantly imperative.<br>
      Lazy functional languages<br>
      Scala is by no means the first language to have exploited the perfect<br>
      match of lazy definitions and functional code. In fact, there is a cate-<br>
      gory of “lazy functional programming languages” in which every value<br>
      and parameter is initialized lazily. The best known member of this class<br>
      of languages is Haskell [SPJ02].<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      458Section 20.6<br>
      20.6<br>
      Chapter 20 · Abstract Members<br>
      Abstract type s<br>
      In the beginning of this chapter, you saw, “ type T ”, an abstract type
      decla-<br>
      ration. The rest of this chapter discusses what such an abstract type
      decla-<br>
      ration means and what it’s good for. Like all other abstract declarations,
      an<br>
      abstract type declaration is a placeholder for something that will be
      defined<br>
      concretely in subclasses. In this case, it is a type that will be defined
      further<br>
      down the class hierarchy. So T above refers to a type that is at yet
      unknown<br>
      at the point where it is declared. Different subclasses can provide
      different<br>
      realizations of T .<br>
      Here is a well-known example where abstract types show up naturally.<br>
      Suppose you are given the task of modeling the eating habits of animals.
      You<br>
      might start with a class Food and a class Animal with an eat method:<br>
      class Food<br>
      abstract class Animal {<br>
      def eat(food: Food)<br>
      }<br>
      You might then attempt to specialize these two classes to a class of Cow s
      that<br>
      eat Grass :<br>
      class Grass extends Food<br>
      class Cow extends Animal {<br>
      override def eat(food: Grass) {} // This won’t compile<br>
      }<br>
      However, if you tried to compile the new classes, you’d get the following<br>
      compilation errors:<br>
      BuggyAnimals.scala:7: error: class Cow needs to be<br>
      abstract, since method eat in class Animal of type<br>
      (Food)Unit is not defined<br>
      class Cow extends Animal {<br>
      ˆ<br>
      BuggyAnimals.scala:8: error: method eat overrides nothing<br>
      override def eat(food: Grass) {}<br>
      ˆ<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      459Section 20.6<br>
      Chapter 20 · Abstract Members<br>
      What happened is that the eat method in class Cow does not override the
      eat<br>
      method in class Animal , because its parameter type is different—it’s
      Grass<br>
      in class Cow vs. Food in class Animal .<br>
      Some people have argued that the type system is unnecessarily strict in<br>
      refusing these classes. They have said that it should be OK to specialize
      a<br>
      parameter of a method in a subclass. However, if the classes were allowed<br>
      as written, you could get yourself in unsafe situations very quickly. For<br>
      instance, the following script would pass the type checker:<br>
      class Food<br>
      abstract class Animal {<br>
      def eat(food: Food)<br>
      }<br>
      class Grass extends Food<br>
      class Cow extends Animal {<br>
      override def eat(food: Grass) {} // This won’t compile,<br>
      }<br>
      // but if it did,...<br>
      class Fish extends Food<br>
      val bessy: Animal = new Cow<br>
      bessy eat (new Fish)<br>
      // ...you could feed fish to cows.<br>
      The program would compile if the restriction were eased, because Cow s are<br>
      Animal s and Animal s do have an eat method that accepts any kind of Food
      ,<br>
      including Fish . But surely it would do a cow no good to eat a fish!<br>
      What you need to do instead is apply some more precise modeling.<br>
      Animal s do eat Food , but what kind of Food each Animal eats depends on<br>
      the Animal . This can be neatly expressed with an abstract type, as shown
      in<br>
      Listing 20.9:<br>
      class Food<br>
      abstract class Animal {<br>
      type SuitableFood &lt;: Food<br>
      def eat(food: SuitableFood)<br>
      }<br>
      Listing 20.9 · Modeling suitable food with an abstract type.<br>
      With the new class definition, an Animal can eat only food that’s
      suitable.<br>
      What food is suitable cannot be determined at the level of the Animal
      class.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      460Section 20.7<br>
      Chapter 20 · Abstract Members<br>
      That’s why SuitableFood is modeled as an abstract type. The type has an<br>
      upper bound, Food , which is expressed by the “ &lt;: Food ” clause. This
      means<br>
      that any concrete instantiation of SuitableFood (in a subclass of Animal )<br>
      must be a subclass of Food . For example, you would not be able to
      instantiate<br>
      SuitableFood with class IOException .<br>
      class Grass extends Food<br>
      class Cow extends Animal {<br>
      type SuitableFood = Grass<br>
      override def eat(food: Grass) {}<br>
      }<br>
      Listing 20.10 · Implementing an abstract type in a subclass.<br>
      With Animal defined, you can now progress to cows, as shown in List-<br>
      ing 20.10. Class Cow fixes its SuitableFood to be Grass and also defines a<br>
      concrete eat method for this kind of food. These new class definitions
      com-<br>
      pile without errors. If you tried to run the “cows-that-eat-fish”
      counterex-<br>
      ample with the new class definitions, you would get the following compiler<br>
      error:<br>
      scala&gt; class Fish extends Food<br>
      defined class Fish<br>
      scala&gt; val bessy: Animal = new Cow<br>
      bessy: Animal = Cow@2e3919<br>
      scala&gt; bessy eat (new Fish)<br>
      &lt;console&gt;:12: error: type mismatch;<br>
      found<br>
      : Fish<br>
      required: bessy.SuitableFood<br>
      bessy eat (new Fish)<br>
      ˆ<br>
      20.7<br>
      Path-dependent types<br>
      Have a look at the last error message: What’s interesting about it is the
      type<br>
      required by the eat method: bessy.SuitableFood . This type consists of an<br>
      object reference, bessy , which is followed by a type field, SuitableFood
      ,<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      461Section 20.7<br>
      Chapter 20 · Abstract Members<br>
      of the object. So this shows that objects in Scala can have types as
      members.<br>
      The meaning of bessy.SuitableFood is “the type SuitableFood that is a<br>
      member of the object referenced from bessy ,” or alternatively, the type
      of<br>
      food that’s suitable for bessy . A type like bessy.SuitableFood is called
      a<br>
      path-dependent type. The word “path” here means a reference to an object.<br>
      It could be a single name, such as bessy , or a longer access path, such
      as<br>
      farm.barn.bessy.SuitableFood , where each of farm , barn , and bessy<br>
      are variables (or singleton object names) that refer to objects.<br>
      As the term “path-dependent type” says, the type depends on the path:<br>
      in general, different paths give rise to different types. For instance,
      say you<br>
      defined classes DogFood and Dog , like this:<br>
      class DogFood extends Food<br>
      class Dog extends Animal {<br>
      type SuitableFood = DogFood<br>
      override def eat(food: DogFood) {}<br>
      }<br>
      If you attempted to feed a dog with food fit for a cow, your code would
      not<br>
      compile:<br>
      scala&gt; val bessy = new Cow<br>
      bessy: Cow = Cow@e7bbeb<br>
      scala&gt; val lassie = new Dog<br>
      lassie: Dog = Dog@ce38f1<br>
      scala&gt; lassie eat (new bessy.SuitableFood)<br>
      &lt;console&gt;:14: error: type mismatch;<br>
      found<br>
      : Grass<br>
      required: DogFood<br>
      lassie eat (new bessy.SuitableFood)<br>
      ˆ<br>
      The problem here is that the type of the SuitableFood object passed to the<br>
      eat method, bessy.SuitableFood , is incompatible with the parameter type<br>
      of eat , lassie.SuitableFood . The case would be different for two Dog s<br>
      however. Because Dog ’s SuitableFood type is defined to be an alias for<br>
      class DogFood , the SuitableFood types of two Dog s are in fact the same.<br>
      As a result, the Dog instance named lassie could actually eat the suitable<br>
      food of a different Dog instance (which we’ll name bootsie ):<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      462Section 20.7<br>
      Chapter 20 · Abstract Members<br>
      scala&gt; val bootsie = new Dog<br>
      bootsie: Dog = Dog@66db21<br>
      scala&gt; lassie eat (new bootsie.SuitableFood)<br>
      A path-dependent type resembles the syntax for an inner class type in<br>
      Java, but there is a crucial difference: a path-dependent type names an
      outer<br>
      object, whereas an inner class type names an outer class. Java-style inner<br>
      class types can also be expressed in Scala, but they are written
      differently.<br>
      Consider these two classes, Outer and Inner :<br>
      class Outer {<br>
      class Inner<br>
      }<br>
      In Scala, the inner class is addressed using the expression Outer#Inner
      in-<br>
      stead of Java’s Outer.Inner . The ‘ . ’ syntax is reserved for objects.
      For<br>
      example, imagine you instantiate two objects of type Outer , like this:<br>
      val o1 = new Outer<br>
      val o2 = new Outer<br>
      Here o1.Inner and o2.Inner are two path-dependent types (and they are<br>
      different types). Both of these types conform to (are subtypes of) the
      more<br>
      general type Outer#Inner , which represents the Inner class with an arbi-<br>
      trary outer object of type Outer . By contrast, type o1.Inner refers to
      the<br>
      Inner class with a specific outer object (the one referenced from o1 ).
      Like-<br>
      wise, type o2.Inner refers to the Inner class with a different, specific
      outer<br>
      object (the one referenced from o2 ).<br>
      In Scala, as in Java, inner class instances hold a reference to an
      enclosing<br>
      outer class instance. This allows an inner class, for example, to access
      mem-<br>
      bers of its outer class. Thus you can’t instantiate an inner class without
      in<br>
      some way specifying an outer class instance. One way to do this is to
      instan-<br>
      tiate the inner class inside the body of the outer class. In this case,
      the current<br>
      outer class instance (referenced from this ) will be used. Another way is
      to<br>
      use a path-dependent type. For example, because the type, o1.Inner , names<br>
      a specific outer object, you can instantiate it:<br>
      scala&gt; new o1.Inner<br>
      res11: o1.Inner = Outer$Inner@1df6ed6<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      463Section 20.8<br>
      Chapter 20 · Abstract Members<br>
      The resulting inner object will contain a reference to its outer object,
      the<br>
      object referenced from o1 . By contrast, because the type Outer#Inner does<br>
      not name any specific instance of Outer , you can’t create an instance of
      it:<br>
      scala&gt; new Outer#Inner<br>
      &lt;console&gt;:7: error: Outer is not a legal prefix for<br>
      a constructor<br>
      new Outer#Inner<br>
      ˆ<br>
      20.8<br>
      Structural subtyping<br>
      When a class inherits from another, the first class is said to be a
      nominal sub-<br>
      type of the other one. It’s a nominal subtype because each type has a
      name,<br>
      and the names are explicitly declared to have a subtyping relationship.
      Scala<br>
      additionally supports structural subtyping, where you get a subtyping
      rela-<br>
      tionship simply because two types have the same members. To get structural<br>
      subtyping in Scala, use Scala’s refinement types.<br>
      Nominal subtyping is usually more convenient, so you should try nom-<br>
      inal types first with any new design. A name is a single short identifier<br>
      and thus is more concise than an explicit listing of member types. Fur-<br>
      ther, structural subtyping is often more flexible than you want. A widget<br>
      can draw() , and a Western cowboy can draw() , but they aren’t really sub-<br>
      stitutable. You’d typically prefer to get a compilation error if you tried
      to<br>
      substitute a cowboy for a widget.<br>
      Nonetheless, structural subtyping has its own advantages. One is that<br>
      sometimes there really is no more to a type than its members. For example,<br>
      suppose you want to define a Pasture class that can contain animals that<br>
      eat grass. One option would be to define a trait AnimalThatEatsGrass and<br>
      mix it into every class where it applies. It would be verbose, however.
      Class<br>
      Cow has already declared that it’s an animal and that it eats grass, and
      now it<br>
      would have to declare that it is also an animal-that-eats-grass.<br>
      Instead of defining AnimalThatEatsGrass , you can use a refinement<br>
      type. Simply write the base type, Animal , followed by a sequence of mem-<br>
      bers listed in curly braces. The members in the curly braces further
      specify—<br>
      or refine, if you will—the types of members from the base class. Here is
      how<br>
      you write the type, “animal that eats grass”:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      464Section 20.8<br>
      Chapter 20 · Abstract Members<br>
      Animal { type SuitableFood = Grass }<br>
      Given this type, you can now write the pasture class like this:<br>
      class Pasture {<br>
      var animals: List[Animal { type SuitableFood = Grass }] = Nil<br>
      // ...<br>
      }<br>
      Another place structural subtyping is helpful is if you want to group to-<br>
      gether a number of classes that were written by someone else. For example,<br>
      suppose you want to generalize the loan pattern example from Section 9.4.<br>
      The original example worked only for type PrintWriter , and you might<br>
      want to have it work for any type with a close method. That is, one caller<br>
      might use the routine to clean up an open file:<br>
      using(new PrintWriter("date.txt")) { writer =&gt;<br>
      writer.println(new Date)<br>
      }<br>
      Another caller, meanwhile, might want to clean up an open socket:<br>
      using(serverSocket.accept()) { socket =&gt;<br>
      socket.getOutputStream().write("hello, world\n".getBytes)<br>
      }<br>
      Implementing using is mostly straightforward. The method performs<br>
      an operation and then closes an object, so it must take two arguments: the<br>
      operation and the object. The operation is a function from any type to any<br>
      other type, so using must have two type parameters as well. Here is a
      first<br>
      try at implementing this method:<br>
      def using[T, S](obj: T)(operation: T =&gt; S) = {<br>
      val result = operation(obj)<br>
      obj.close()<br>
      // type error!<br>
      result<br>
      }<br>
      This attempt almost works, but it will get a type error where close() is<br>
      called. The problem is that, as written, T can be any type at all. To
      indicate<br>
      that it only really supports types with close() methods, the &lt;:
      notation can<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      465Section 20.9<br>
      Chapter 20 · Abstract Members<br>
      be used to give an upper bound to T . In this case, the desired upper
      bound is<br>
      { def close(): Unit } . Here’s a complete working definition:<br>
      def using[T &lt;: { def close(): Unit }, S](obj: T)<br>
      (operation: T =&gt; S) = {<br>
      val result = operation(obj)<br>
      obj.close()<br>
      result<br>
      }<br>
      Note two small differences in this refinement type from the one for ani-<br>
      mals that eat grass. One is that no base type is specified. If no base
      type is<br>
      specified, Scala uses AnyRef automatically. The other difference is that
      the<br>
      close method does not appear at all in the base type. Class AnyRef simply<br>
      doesn’t have a close method. Technically speaking, that means the second<br>
      type is a structural type.<br>
      20.9<br>
      Enumerations<br>
      An interesting application of path-dependent types is found in Scala’s
      sup-<br>
      port for enumerations. Some other languages, including Java and C#, have<br>
      enumerations as a built-in language construct to define new types. Scala
      does<br>
      not need special syntax for enumerations. Instead, there’s a class in its
      stan-<br>
      dard library, scala.Enumeration . To create a new enumeration, you define<br>
      an object that extends this class, as in the following example, which
      defines<br>
      a new enumeration of Color s:<br>
      object Color extends Enumeration {<br>
      val Red = Value<br>
      val Green = Value<br>
      val Blue = Value<br>
      }<br>
      Scala lets you also shorten several successive val or var definitions with
      the<br>
      same right-hand side. Equivalently to the above you could write:<br>
      object Color extends Enumeration {<br>
      val Red, Green, Blue = Value<br>
      }<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      466Section 20.9<br>
      Chapter 20 · Abstract Members<br>
      This object definition provides three values: Color.Red , Color.Green ,
      and<br>
      Color.Blue . You could also import everything in Color with:<br>
      import Color._<br>
      and then just use Red , Green , and Blue . But what is the type of these
      values?<br>
      Enumeration defines an inner class named Value , and the same-named pa-<br>
      rameterless Value method returns a fresh instance of that class. This
      means<br>
      that a value such as Color.Red is of type Color.Value . Color.Value is the<br>
      type of all enumeration values defined in object Color . It’s a
      path-dependent<br>
      type, with Color being the path and Value being the dependent type. What’s<br>
      significant about this is that it is a completely new type, different from
      all<br>
      other types. In particular, if you would define another enumeration, such
      as:<br>
      object Direction extends Enumeration {<br>
      val North, East, South, West = Value<br>
      }<br>
      then Direction.Value would be different from Color.Value because the<br>
      path parts of the two types differ.<br>
      Scala’s Enumeration class also offers many other features found in the<br>
      enumeration designs of other languages. You can associate names with enu-<br>
      meration values by using a different overloaded variant of the Value
      method:<br>
      object Direction extends Enumeration {<br>
      val North = Value("North")<br>
      val East = Value("East")<br>
      val South = Value("South")<br>
      val West = Value("West")<br>
      }<br>
      You can iterate over the values of an enumeration via the set returned by
      the<br>
      enumeration’s values method:<br>
      scala&gt; for (d &lt;- Direction.values) print(d +" ")<br>
      North East South West<br>
      Values of an enumeration are numbered from 0 , and you can find out the<br>
      number of an enumeration value by its id method:<br>
      scala&gt; Direction.East.id<br>
      res14: Int = 1<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      467Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      It’s also possible to go the other way, from a non-negative integer number
      to<br>
      the value that has this number as id in an enumeration:<br>
      scala&gt; Direction(1)<br>
      res15: Direction.Value = East<br>
      This should be enough to get you started with enumerations. You can find<br>
      more information in the Scaladoc comments of class scala.Enumeration .<br>
      20.10<br>
      Case study: Currencies<br>
      The rest of this chapter presents a case study that explains how abstract
      types<br>
      can be used in Scala. The task is to design a class Currency . A typical<br>
      instance of Currency would represent an amount of money in dollars, euros,<br>
      yen, or some other currency. It should be possible to do some arithmetic
      on<br>
      currencies. For instance, you should be able to add two amounts of the
      same<br>
      currency. Or you should be able to multiply a currency amount by a factor<br>
      representing an interest rate.<br>
      These thoughts lead to the following first design for a currency class:<br>
      // A first (faulty) design of the Currency class<br>
      abstract class Currency {<br>
      val amount: Long<br>
      def designation: String<br>
      override def toString = amount +" "+ designation<br>
      def + (that: Currency): Currency = ...<br>
      def * (x: Double): Currency = ...<br>
      }<br>
      The amount of a currency is the number of currency units it represents.
      This<br>
      is a field of type Long so that very large amounts of money such as the
      market<br>
      capitalization of Google or Microsoft can be represented. It’s left
      abstract<br>
      here, waiting to be defined when a subclass talks about concrete amounts
      of<br>
      money. The designation of a currency is a string that identifies it. The<br>
      toString method of class Currency indicates an amount and a designation.<br>
      It would yield results such as:<br>
      79 USD<br>
      11000 Yen<br>
      99 Euro<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      468Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      Finally, there are methods + , for adding currencies, and * , for
      multiplying a<br>
      currency with a floating-point number. You can create a concrete currency<br>
      value by supplying concrete amount and designation values, like this:<br>
      new Currency {<br>
      val amount = 79L<br>
      def designation = "USD"<br>
      }<br>
      This design would be OK if all we wanted to model was a single currency<br>
      such as only dollars or only euros. But it fails once we need to deal with<br>
      several currencies. Assume you model dollars and euros as two subclasses<br>
      of class currency:<br>
      abstract class Dollar extends Currency {<br>
      def designation = "USD"<br>
      }<br>
      abstract class Euro extends Currency {<br>
      def designation = "Euro"<br>
      }<br>
      At first glance this looks reasonable. But it would let you add dollars to<br>
      euros. The result of such an addition would be of type Currency . But it<br>
      would be a funny currency that was made up of a mix of euros and dollars.<br>
      What you want instead is a more specialized version of the + method: when<br>
      implemented in class Dollar , it should take Dollar arguments and yield a<br>
      Dollar result; when implemented in class Euro , it should take Euro argu-<br>
      ments and yield a Euro result. So the type of the addition method would<br>
      change depending on which class you are in. Nonetheless, you would like to<br>
      write the addition method just once, not each time a new currency is
      defined.<br>
      In Scala, there’s a simple technique to deal with situations like this: if<br>
      something is not known at the point where a class is defined, make it
      abstract<br>
      in the class. This applies to both values and types. In the case of
      currencies,<br>
      the exact argument and result type of the addition method are not known,
      so<br>
      it is a good candidate for an abstract type. This would lead to the
      following<br>
      sketch of class AbstractCurrency :<br>
      // A second (still imperfect) design of the Currency class<br>
      abstract class AbstractCurrency {<br>
      type Currency &lt;: AbstractCurrency<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      469Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      val amount: Long<br>
      def designation: String<br>
      override def toString = amount +" "+ designation<br>
      def + (that: Currency): Currency = ...<br>
      def * (x: Double): Currency = ...<br>
      }<br>
      The only differences from the previous situation are that the class is now<br>
      called AbstractCurrency , and that it contains an abstract type Currency ,<br>
      which represents the real currency in question. Each concrete subclass of<br>
      AbstractCurrency would need to fix the Currency type to refer to the<br>
      concrete subclass itself, thereby “tying the knot.”<br>
      For instance, here is a new version of class Dollar , which now extends<br>
      class AbstractCurrency :<br>
      abstract class Dollar extends AbstractCurrency {<br>
      type Currency = Dollar<br>
      def designation = "USD"<br>
      }<br>
      This design is workable, but it is still not perfect. One problem is
      hidden by<br>
      the ellipses that indicate the missing method definitions of + and * in
      class<br>
      AbstractCurrency . In particular, how should addition be implemented<br>
      in this class? It’s easy enough to calculate the correct amount of the new<br>
      currency as this.amount + that.amount , but how would you convert the<br>
      amount into a currency of the right type? You might try something like:<br>
      def + (that: Currency): Currency = new Currency {<br>
      val amount = this.amount + that.amount<br>
      }<br>
      However, this would not compile:<br>
      error: class type required<br>
      def + (that: Currency): Currency = new Currency {<br>
      ˆ<br>
      One of the restrictions of Scala’s treatment of abstract types is that you
      can<br>
      neither create an instance of an abstract type, nor have an abstract type
      as a<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      470Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      supertype of another class. 1 So the compiler would refuse the example
      code<br>
      above that attempted to instantiate Currency .<br>
      However, you can work around this restriction using a factory method.<br>
      Instead of creating an instance of an abstract type directly, declare an
      abstract<br>
      method that does it. Then, wherever the abstract type is fixed to be some<br>
      concrete type, you also need to give a concrete implementation of the
      factory<br>
      method. For class AbstractCurrency , this would look as follows:<br>
      abstract class AbstractCurrency {<br>
      type Currency &lt;: AbstractCurrency // abstract type<br>
      def make(amount: Long): Currency // factory method<br>
      ... // rest of class<br>
      }<br>
      A design like this could be made to work, but it looks rather suspicious.<br>
      Why place the factory method inside class AbstractCurrency ? This looks<br>
      dubious, for at least two reasons. First, if you have some amount of
      currency<br>
      (say, one dollar), you also hold in your hand the ability to make more of
      the<br>
      same currency, using code such as:<br>
      myDollar.make(100)<br>
      // here are a hundred more!<br>
      In the age of color copying this might be a tempting scenario, but
      hopefully<br>
      not one which you would be able to do for very long without being caught.<br>
      The second problem with this code is that you can make more Currency<br>
      objects if you already have a reference to a Currency object, but how do<br>
      you get the first object of a given Currency ? You’d need another creation<br>
      method, which does essentially the same job as make . So you have a case
      of<br>
      code duplication, which is a sure sign of a code smell.<br>
      The solution, of course, is to move the abstract type and the factory<br>
      method outside class AbstractCurrency . You need to create another class<br>
      that contains the AbstractCurrency class, the Currency type, and the make<br>
      factory method. We’ll call this a CurrencyZone :<br>
      abstract class CurrencyZone {<br>
      type Currency &lt;: AbstractCurrency<br>
      def make(x: Long): Currency<br>
      1<br>
      There’s some promising recent research on virtual classes, which would
      allow this, but<br>
      virtual classes are not currently supported in Scala.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      471Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      abstract class AbstractCurrency {<br>
      val amount: Long<br>
      def designation: String<br>
      override def toString = amount +" "+ designation<br>
      def + (that: Currency): Currency =<br>
      make(this.amount + that.amount)<br>
      def * (x: Double): Currency =<br>
      make((this.amount * x).toLong)<br>
      }<br>
      }<br>
      An example concrete CurrencyZone is the US, which could be defined as:<br>
      object US extends CurrencyZone {<br>
      abstract class Dollar extends AbstractCurrency {<br>
      def designation = "USD"<br>
      }<br>
      type Currency = Dollar<br>
      def make(x: Long) = new Dollar { val amount = x }<br>
      }<br>
      Here, US is an object that extends CurrencyZone . It defines a class
      Dollar ,<br>
      which is a subclass of AbstractCurrency . So the type of money in this<br>
      zone is US.Dollar . The US object also fixes the type Currency to be an<br>
      alias for Dollar , and it gives an implementation of the make factory
      method<br>
      to return a dollar amount.<br>
      This is a workable design. There are only a few refinements to be added.<br>
      The first refinement concerns subunits. So far, every currency was
      measured<br>
      in a single unit: dollars, euros, or yen. However, most currencies have
      sub-<br>
      units: for instance, in the US, it’s dollars and cents. The most
      straightforward<br>
      way to model cents is to have the amount field in US.Currency represent<br>
      cents instead of dollars. To convert back to dollars, it’s useful to
      introduce<br>
      a field CurrencyUnit into class CurrencyZone , which contains the amount<br>
      of one standard unit in that currency:<br>
      class CurrencyZone {<br>
      ...<br>
      val CurrencyUnit: Currency<br>
      }<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      472Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      The US object could define the quantities Cent , Dollar , and CurrencyUnit<br>
      as shown in Listing 20.11. This definition is just like the previous
      definition<br>
      of the US object, except that it adds three new fields. The field Cent
      repre-<br>
      sents an amount of 1 US.Currency . It’s an object analogous to a one-cent<br>
      coin. The field Dollar represents an amount of 100 US.Currency . So the US<br>
      object now defines the name Dollar in two ways. The type Dollar (defined<br>
      by the abstract inner class named Dollar ) represents the generic name of<br>
      the Currency valid in the US currency zone. By contrast, the value Dollar<br>
      (referenced from the val field named Dollar ) represents a single US
      dollar,<br>
      analogous to a one-dollar bill. The third field definition of CurrencyUnit<br>
      specifies that the standard currency unit in the US zone is the Dollar
      (i.e.,<br>
      the value Dollar , referenced from the field, not the type Dollar ).<br>
      object US extends CurrencyZone {<br>
      abstract class Dollar extends AbstractCurrency {<br>
      def designation = "USD"<br>
      }<br>
      type Currency = Dollar<br>
      def make(cents: Long) = new Dollar {<br>
      val amount = cents<br>
      }<br>
      val Cent = make(1)<br>
      val Dollar = make(100)<br>
      val CurrencyUnit = Dollar<br>
      }<br>
      Listing 20.11 · The US currency zone.<br>
      The toString method in class Currency also needs to be adapted to<br>
      take subunits into account. For instance, the sum of ten dollars and
      twenty<br>
      three cents should print as a decimal number: 10.23 USD. To achieve this,<br>
      you could implement Currency ’s toString method as follows:<br>
      override def toString =<br>
      ((amount.toDouble / CurrencyUnit.amount.toDouble)<br>
      formatted (" % ."+ decimals(CurrencyUnit.amount) +"f")<br>
      +" "+ designation)<br>
      Here, formatted is a method that Scala makes available on several classes,<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      473Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      including Double . 2 The formatted method returns the string that results<br>
      from formatting the original string on which formatted was invoked ac-<br>
      cording to a format string passed as the formatted method’s right-hand<br>
      operand. The syntax of format strings passed to formatted is the same<br>
      as that of Java’s String.format method. For instance, the format string<br>
      %.2f formats a number with two decimal digits. The format string used<br>
      in the toString shown previously is assembled by calling the decimals<br>
      method on CurrencyUnit.amount . This method returns the number of dec-<br>
      imal digits of a decimal power minus one. For instance, decimals(10) is 1
      ,<br>
      decimals(100) is 2 , and so on. The decimals method is implemented by<br>
      a simple recursion:<br>
      private def decimals(n: Long): Int =<br>
      if (n == 1) 0 else 1 + decimals(n / 10)<br>
      Listing 20.12 shows some other currency zones. As another refinement<br>
      you can add a currency conversion feature to the model. As a first step,
      you<br>
      could write a Converter object that contains applicable exchange rates be-<br>
      tween currencies, as shown in Listing 20.13. Then, you could add a conver-<br>
      sion method, from , to class Currency , which converts from a given source<br>
      currency into the current Currency object:<br>
      def from(other: CurrencyZone#AbstractCurrency): Currency =<br>
      make(math.round(<br>
      other.amount.toDouble * Converter.exchangeRate<br>
      (other.designation)(this.designation)))<br>
      The from method takes an arbitrary currency as argument. This is expressed<br>
      by its formal parameter type, CurrencyZone#AbstractCurrency , which<br>
      indicates that the argument passed as other must be an AbstractCurrency<br>
      type in some arbitrary and unknown CurrencyZone . It produces its result<br>
      by multiplying the amount of the other currency with the exchange rate<br>
      between the other and the current currency. 3<br>
      The final version of the CurrencyZone class is shown in Listing 20.14.<br>
      You can test the class in the Scala command shell. We’ll assume that the<br>
      2 Scala<br>
      uses rich wrappers, described in Section 5.9, to make formatted available.<br>
      the way, in case you think you’re getting a bad deal on Japanese yen, the
      exchange<br>
      rates convert currencies based on their CurrencyZone amounts. Thus, 1.211
      is the exchange<br>
      rate between US cents to Japanese yen.<br>
      3 By<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      474Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      object Europe extends CurrencyZone {<br>
      abstract class Euro extends AbstractCurrency {<br>
      def designation = "EUR"<br>
      }<br>
      type Currency = Euro<br>
      def make(cents: Long) = new Euro {<br>
      val amount = cents<br>
      }<br>
      val Cent = make(1)<br>
      val Euro = make(100)<br>
      val CurrencyUnit = Euro<br>
      }<br>
      object Japan extends CurrencyZone {<br>
      abstract class Yen extends AbstractCurrency {<br>
      def designation = "JPY"<br>
      }<br>
      type Currency = Yen<br>
      def make(yen: Long) = new Yen {<br>
      val amount = yen<br>
      }<br>
      val Yen = make(1)<br>
      val CurrencyUnit = Yen<br>
      }<br>
      Listing 20.12 · Currency zones for Europe and Japan.<br>
      CurrencyZone class and all concrete CurrencyZone objects are defined in<br>
      a package org.stairwaybook.currencies . The first step is to import ev-<br>
      erything in this package into the command shell:<br>
      scala&gt; import org.stairwaybook.currencies._<br>
      You can then do some currency conversions:<br>
      scala&gt; Japan.Yen from US.Dollar * 100<br>
      res16: Japan.Currency = 12110 JPY<br>
      scala&gt; Europe.Euro from res16<br>
      res17: Europe.Currency = 75.95 EUR<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      475Section 20.10<br>
      Chapter 20 · Abstract Members<br>
      476<br>
      object Converter {<br>
      var exchangeRate = Map(<br>
      "USD" -&gt; Map("USD" -&gt; 1.0<br>
      , "EUR" -&gt; 0.7596,<br>
      "JPY" -&gt; 1.211 , "CHF" -&gt; 1.223),<br>
      "EUR" -&gt; Map("USD" -&gt; 1.316 , "EUR" -&gt; 1.0<br>
      ,<br>
      "JPY" -&gt; 1.594 , "CHF" -&gt; 1.623),<br>
      "JPY" -&gt; Map("USD" -&gt; 0.8257, "EUR" -&gt; 0.6272,<br>
      "JPY" -&gt; 1.0<br>
      , "CHF" -&gt; 1.018),<br>
      "CHF" -&gt; Map("USD" -&gt; 0.8108, "EUR" -&gt; 0.6160,<br>
      "JPY" -&gt; 0.982 , "CHF" -&gt; 1.0<br>
      )<br>
      )<br>
      }<br>
      Listing 20.13 · A converter object with an exchange rates map.<br>
      scala&gt; US.Dollar from res17<br>
      res18: US.Currency = 99.95 USD<br>
      The fact that we obtain almost the same amount after three conversions im-<br>
      plies that these are some pretty good exchange rates!<br>
      You can also add up values of the same currency:<br>
      scala&gt; US.Dollar * 100 + res18<br>
      res19: US.Currency = 199.95 USD<br>
      On the other hand, you cannot add amounts of different currencies:<br>
      scala&gt; US.Dollar + Europe.Euro<br>
      &lt;console&gt;:10: error: type mismatch;<br>
      found<br>
      : Europe.Euro<br>
      required: US.Currency<br>
      US.Dollar + Europe.Euro<br>
      ˆ<br>
      By preventing the addition of two values with different units (in this
      case,<br>
      currencies), the type abstraction has done its job. It prevents us from
      per-<br>
      forming calculations that are unsound. Failures to convert correctly
      between<br>
      different units may seem like trivial bugs, but they have caused many
      seri-<br>
      ous systems faults. An example is the crash of the Mars Climate Orbiter<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      20.10<br>
      Chapter 20 · Abstract Members<br>
      abstract class CurrencyZone {<br>
      type Currency &lt;: AbstractCurrency<br>
      def make(x: Long): Currency<br>
      abstract class AbstractCurrency {<br>
      val amount: Long<br>
      def designation: String<br>
      def + (that: Currency): Currency =<br>
      make(this.amount + that.amount)<br>
      def * (x: Double): Currency =<br>
      make((this.amount * x).toLong)<br>
      def - (that: Currency): Currency =<br>
      make(this.amount - that.amount)<br>
      def / (that: Double) =<br>
      make((this.amount / that).toLong)<br>
      def / (that: Currency) =<br>
      this.amount.toDouble / that.amount<br>
      def from(other: CurrencyZone#AbstractCurrency): Currency =<br>
      make(math.round(<br>
      other.amount.toDouble * Converter.exchangeRate<br>
      (other.designation)(this.designation)))<br>
      private def decimals(n: Long): Int =<br>
      if (n == 1) 0 else 1 + decimals(n / 10)<br>
      override def toString =<br>
      ((amount.toDouble / CurrencyUnit.amount.toDouble)<br>
      formatted (" % ."+ decimals(CurrencyUnit.amount) +"f")<br>
      +" "+ designation)<br>
      }<br>
      val CurrencyUnit: Currency<br>
      }<br>
      Listing 20.14 · The full code of class CurrencyZone .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      477Section 20.11<br>
      Chapter 20 · Abstract Members<br>
      spacecraft on September 23, 1999, which was caused because one engineer-<br>
      ing team used metric units while another used English units. If units had<br>
      been coded in the same way as currencies are coded in this chapter, this
      error<br>
      would have been detected by a simple compilation run. Instead, it caused
      the<br>
      crash of the orbiter after a near ten-month voyage.<br>
      20.11<br>
      Conclusion<br>
      Scala offers systematic and very general support for object-oriented
      abstrac-<br>
      tion. It enables you to not only abstract over methods, but also over
      values,<br>
      variables, and types. This chapter has shown how to take advantage of ab-<br>
      stract members. They support a simple yet effective principle for systems<br>
      structuring: when designing a class, make everything that is not yet known<br>
      into an abstract member. The type system will then drive the development
      of<br>
      your model, just as you saw with the currency case study. It does not
      matter<br>
      whether the unknown is a type, method, variable or value. In Scala, all of<br>
      these can be declared abstract.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      478Chapter 21<br>
      Implicit Conversions and Parameters<br>
      There’s a fundamental difference between your own code and libraries of<br>
      other people: you can change or extend your own code as you wish, but if<br>
      you want to use someone else’s libraries, you usually have to take them as<br>
      they are.<br>
      A number of constructs have sprung up in programming languages to<br>
      alleviate this problem. Ruby has modules, and Smalltalk lets packages add<br>
      to each other’s classes. These are very powerful, but also dangerous, in
      that<br>
      you modify the behavior of a class for an entire application, some parts
      of<br>
      which you might not know. C# 3.0 has static extension methods, which are<br>
      more local, but also more restrictive in that you can only add methods,
      not<br>
      fields, to a class, and you can’t make a class implement new interfaces.<br>
      Scala’s answer is implicit conversions and parameters. These can make<br>
      existing libraries much more pleasant to deal with by letting you leave
      out<br>
      tedious, obvious details that obscure the interesting parts of your code.
      Used<br>
      tastefully, this results in code that is focused on the interesting,
      non-trivial<br>
      parts of your program. This chapter shows you how implicits work, and it<br>
      presents some of the most common ways they are used.<br>
      21.1<br>
      Implicit conversions<br>
      Before delving into the details of implicit conversions, take a look at a
      typical<br>
      example of their use. Implicit conversions are often helpful for working
      with<br>
      two bodies of software that were developed without each other in mind.
      Each<br>
      library has its own way to encode a concept that is essentially the same
      thing.<br>
      Implicit conversions help by reducing the number of explicit conversions
      that<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      21.1<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      are needed from one type to another.<br>
      Java includes a library named Swing for implementing cross-platform<br>
      user interfaces. One of the things Swing does is process events from the<br>
      operating system, convert them to platform-independent event objects, and<br>
      pass those events to parts of an application called event listeners.<br>
      If Swing had been written with Scala in mind, event listeners would prob-<br>
      ably have been represented by a function type. Callers could then use the<br>
      function literal syntax as a lightweight way to specify what should happen<br>
      for a certain class of events. Since Java doesn’t have function literals,
      Swing<br>
      uses the next best thing, an inner class that implements a one-method
      inter-<br>
      face. In the case of action listeners, the interface is ActionListener .<br>
      Without the use of implicit conversions, a Scala program that uses Swing<br>
      must use inner classes just like in Java. Here’s an example that creates a
      but-<br>
      ton and hooks up an action listener to it. The action listener is invoked
      when-<br>
      ever the button is pressed, at which point it prints the string "pressed!"
      :<br>
      val button = new JButton<br>
      button.addActionListener(<br>
      new ActionListener {<br>
      def actionPerformed(event: ActionEvent) {<br>
      println("pressed!")<br>
      }<br>
      }<br>
      )<br>
      This code has a lot of information-free boilerplate. The fact that this
      lis-<br>
      tener is an ActionListener , the fact that the callback method is named<br>
      actionPerformed , and the fact that the argument is an ActionListener<br>
      are all implied for any argument to addActionListener . The only new<br>
      information here is the code to be performed, namely the call to println .<br>
      This new information is drowned out by the boilerplate. Someone reading<br>
      this code must have an eagle’s eye to pick through the noise and find the<br>
      informative part.<br>
      A more Scala-friendly version would take a function as an argument,<br>
      greatly reducing the amount of boilerplate.<br>
      button.addActionListener( // Type mismatch!<br>
      (_: ActionEvent) =&gt; println("pressed!")<br>
      )<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      480Section 21.1<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      As written so far, this code doesn’t work. The addActionListener method<br>
      wants an action listener but is getting a function. With implicit
      conversions,<br>
      however, this code can be made to work.<br>
      The first step is to write an implicit conversion between the two types.<br>
      Here is an implicit conversion from functions to action listeners:<br>
      implicit def function2ActionListener(f: ActionEvent =&gt; Unit) =<br>
      new ActionListener {<br>
      def actionPerformed(event: ActionEvent) = f(event)<br>
      }<br>
      This is a one-argument method that takes a function and returns an action<br>
      listener. Like any other one-argument method, it can be called directly
      and<br>
      have its result passed on to another expression:<br>
      button.addActionListener(<br>
      function2ActionListener(<br>
      (_: ActionEvent) =&gt; println("pressed!")<br>
      )<br>
      )<br>
      This much is already an improvement on the version with the inner class.<br>
      Note how arbitrary amounts of boilerplate end up replaced by a function<br>
      literal and a call to a method. It gets better, though, with implicit
      conversions.<br>
      Because function2ActionListener is marked as implicit, it can be left out<br>
      and the compiler will insert it automatically. The result is the
      following, very<br>
      tight code:<br>
      // Now this works<br>
      button.addActionListener(<br>
      (_: ActionEvent) =&gt; println("pressed!")<br>
      )<br>
      The way this code works is that the compiler first tries to compile it as
      is, but<br>
      it sees a type error. Before giving up, it looks for an implicit
      conversion that<br>
      can repair the problem. In this case, it finds function2ActionListener .
      It<br>
      tries that conversion method, sees that it works, and moves on. The
      compiler<br>
      works hard here so that the developer can ignore one more fiddly detail.<br>
      Action listener? Action event function? Either one will work—use the one<br>
      that’s more convenient.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      481Section 21.2<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      This section has shown you some of the power of implicit conversions,<br>
      and how they let you dress up existing libraries. In the next sections
      you’ll<br>
      learn the rules that determine when implicit conversions are tried and how<br>
      they are found.<br>
      21.2<br>
      Rules for implicits<br>
      Implicit definitions are those that the compiler is allowed to insert into
      a<br>
      program in order to fix any of its type errors. For example, if x + y does<br>
      not type check, then the compiler might change it to convert(x) + y ,
      where<br>
      convert is some available implicit conversion. If convert changes x into<br>
      something that has a + method, then this change might fix a program so
      that it<br>
      type checks and runs correctly. If convert really is just a simple
      conversion<br>
      function, then leaving it out of the source code can be a clarification.<br>
      Implicit conversions are governed by the following general rules:<br>
      Marking Rule: Only definitions marked implicit are available. The<br>
      implicit keyword is used to mark which declarations the compiler may<br>
      use as implicits. You can use it to mark any variable, function, or object<br>
      definition. Here’s an example of an implicit function definition: 1<br>
      implicit def intToString(x: Int) = x.toString<br>
      The compiler will only change x + y to convert(x) + y if convert is marked<br>
      as implicit . This way, you avoid the confusion that would result if the<br>
      compiler picked random functions that happen to be in scope and inserted<br>
      them as “conversions.” The compiler will only select among the definitions<br>
      you have explicitly marked as implicit.<br>
      Scope Rule: An inserted implicit conversion must be in scope as a single<br>
      identifier, or be associated with the source or target type of the conver-<br>
      sion. The Scala compiler will only consider implicit conversions that are<br>
      in scope. To make an implicit conversion available, therefore, you must in<br>
      some way bring it into scope. Moreover, with one exception, the implicit<br>
      conversion must be in scope as a single identifier. The compiler will not
      in-<br>
      sert a conversion of the form someVariable.convert . For example, it will<br>
      1 Variables<br>
      and singleton objects marked implicit can be used as implicit parameters.<br>
      This use case will be described later in this chapter.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      482Section 21.2<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      not expand x + y to someVariable.convert(x) + y . If you want to make<br>
      someVariable.convert available as an implicit, therefore, you would need<br>
      to import it, which would make it available as a single identifier. Once
      im-<br>
      ported, the compiler would be free to apply it as convert(x) + y . In
      fact, it<br>
      is common for libraries to include a Preamble object including a number of<br>
      useful implicit conversions. Code that uses the library can then do a
      single<br>
      “ import Preamble._ ” to access the library’s implicit conversions.<br>
      There’s one exception to the “single identifier” rule. The compiler will<br>
      also look for implicit definitions in the companion object of the source
      or<br>
      expected target types of the conversion. For example, if you’re attempting<br>
      to pass a Dollar object to a method that takes a Euro , the source type is<br>
      Dollar and the target type is Euro . You could, therefore, package an
      implicit<br>
      conversion from Dollar to Euro in the companion object of either class,<br>
      Dollar or Euro . Here’s an example in which the implicit definition is
      placed<br>
      in Dollar ’s companion object:<br>
      object Dollar {<br>
      implicit def dollarToEuro(x: Dollar): Euro = ...<br>
      }<br>
      class Dollar { ... }<br>
      In this case, the conversion dollarToEuro is said to be associated to the<br>
      type Dollar . The compiler will find such an associated conversion every<br>
      time it needs to convert from an instance of type Dollar . There’s no need
      to<br>
      import the conversion separately into your program.<br>
      The Scope Rule helps with modular reasoning. When you read code in<br>
      a file, the only things you need to consider from other files are those
      that are<br>
      either imported or are explicitly referenced through a fully qualified
      name.<br>
      This benefit is at least as important for implicits as for explicitly
      written code.<br>
      If implicits took effect system-wide, then to understand a file you would
      have<br>
      to know about every implicit introduced anywhere in the program!<br>
      One-at-a-time Rule: Only one implicit is tried. The compiler will never<br>
      rewrite x + y to convert1(convert2(x)) + y . Doing so would cause com-<br>
      pile times to increase dramatically on erroneous code, and it would
      increase<br>
      the difference between what the programmer writes and what the program<br>
      actually does. For sanity’s sake, the compiler does not insert further im-<br>
      plicit conversions when it is already in the middle of trying another
      implicit.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      483Section 21.2<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      However, it’s possible to circumvent this restriction by having implicits
      take<br>
      implicit parameters, which will be described later in this chapter.<br>
      Explicits-First Rule: Whenever code type checks as it is written, no<br>
      implicits are attempted. The compiler will not change code that already<br>
      works. A corollary of this rule is that you can always replace implicit
      iden-<br>
      tifiers by explicit ones, thus making the code longer but with less
      apparent<br>
      ambiguity. You can trade between these choices on a case-by-case basis.<br>
      Whenever you see code that seems repetitive and verbose, implicit conver-<br>
      sions can help you decrease the tedium. Whenever code seems terse to the<br>
      point of obscurity, you can insert conversions explicitly. The amount of
      im-<br>
      plicits you leave the compiler to insert is ultimately a matter of style.<br>
      Naming an implicit conversion. Implicit conversions can have arbitrary<br>
      names. The name of an implicit conversion matters only in two situations:
      if<br>
      you want to write it explicitly in a method application, and for
      determining<br>
      which implicit conversions are available at any place in the program.<br>
      To illustrate the second point, say you have an object with two implicit<br>
      conversions:<br>
      object MyConversions {<br>
      implicit def stringWrapper(s: String):<br>
      IndexedSeq[Char] = ...<br>
      implicit def intToString(x: Int): String = ...<br>
      }<br>
      In your application, you want to make use of the stringWrapper conver-<br>
      sion, but you don’t want integers to be converted automatically to strings
      by<br>
      means of the intToString conversion. You can achieve this by importing<br>
      only one conversion, but not the other:<br>
      import MyConversions.stringWrapper<br>
      ... // code making use of stringWrapper<br>
      In this example, it was important that the implicit conversions had names,<br>
      because only that way could you selectively import one and not the other.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      484Section 21.3<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      Where implicits are tried. There are three places implicits are used in<br>
      the language: conversions to an expected type, conversions of the receiver<br>
      of a selection, and implicit parameters. Implicit conversions to an
      expected<br>
      type let you use one type in a context where a different type is expected.<br>
      For example, you might have a String and want to pass it to a method<br>
      that requires an IndexedSeq[Char] . Conversions of the receiver let you<br>
      adapt the receiver of a method call, i.e., the object on which a method is<br>
      invoked, if the method is not applicable on the original type. An example<br>
      is "abc".exists , which is converted to stringWrapper("abc").exists<br>
      because the exists method is not available on String s but is available on<br>
      IndexedSeq s. Implicit parameters, on the other hand, are usually used to<br>
      provide more information to the called function about what the caller
      wants.<br>
      Implicit parameters are especially useful with generic functions, where
      the<br>
      called function might otherwise know nothing at all about the type of one<br>
      or more arguments. Each of the following three sections will discuss one
      of<br>
      these three kinds of implicits.<br>
      21.3<br>
      Implicit conversion to an expected type<br>
      Implicit conversion to an expected type is the first place the compiler
      will use<br>
      implicits. The rule is simple. Whenever the compiler sees an X, but needs<br>
      a Y, it will look for an implicit function that converts X to Y. For
      example,<br>
      normally a double cannot be used as an integer, because it loses
      precision:<br>
      scala&gt; val i: Int = 3.5<br>
      &lt;console&gt;:4: error: type mismatch;<br>
      found<br>
      : Double(3.5)<br>
      required: Int<br>
      val i: Int = 3.5<br>
      ˆ<br>
      However, you can define an implicit conversion to smooth this over:<br>
      scala&gt; implicit def doubleToInt(x: Double) = x.toInt<br>
      doubleToInt: (x: Double)Int<br>
      scala&gt; val i: Int = 3.5<br>
      i: Int = 3<br>
      What happens here is that the compiler sees a Double , specifically 3.5 ,
      in<br>
      a context where it requires an Int . So far, the compiler is looking at an<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      485Section 21.4<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      ordinary type error. Before giving up, though, it searches for an implicit<br>
      conversion from Double to Int . In this case, it finds one: doubleToInt ,
      be-<br>
      cause doubleToInt is in scope as a single identifier. (Outside the
      interpreter,<br>
      you might bring doubleToInt into scope via an import or possibly through<br>
      inheritance.) The compiler then inserts a call to doubleToInt
      automatically.<br>
      Behind the scenes, the code becomes:<br>
      val i: Int = doubleToInt(3.5)<br>
      This is literally an implicit conversion. You did not explicitly ask for
      conver-<br>
      sion. Instead, you marked doubleToInt as an available implicit conversion<br>
      by bringing it into scope as a single identifier, and then the compiler
      auto-<br>
      matically used it when it needed to convert from a Double to an Int .<br>
      Converting Double s to Int s might raise some eyebrows, because it’s a<br>
      dubious idea to have something that causes a loss in precision happen in-<br>
      visibly. So this is not really a conversion we recommend. It makes much<br>
      more sense to go the other way, from some more constrained type to a more<br>
      general one. For instance, an Int can be converted without loss of
      precision<br>
      to a Double , so an implicit conversion from Int to Double makes sense. In<br>
      fact, that’s exactly what happens. The scala.Predef object, which is im-<br>
      plicitly imported into every Scala program, defines implicit conversions
      that<br>
      convert “smaller” numeric types to “larger” ones. For instance, you will
      find<br>
      in Predef the following conversion:<br>
      implicit def int2double(x: Int): Double = x.toDouble<br>
      That’s why in Scala Int values can be stored in variables of type Double .<br>
      There’s no special rule in the type system for this; it’s just an implicit
      con-<br>
      version that gets applied. 2<br>
      21.4<br>
      Converting the receiver<br>
      Implicit conversions also apply to the receiver of a method call, the
      object on<br>
      which the method is invoked. This kind of implicit conversion has two main<br>
      uses. First, receiver conversions allow smoother integration of a new
      class<br>
      into an existing class hierarchy. And second, they support writing domain-<br>
      specific languages (DSLs) within the language.<br>
      2 The<br>
      Scala compiler backend will treat the conversion specially, however,
      translating it<br>
      to a special “ i2d ” bytecode. So the compiled image is the same as in
      Java.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      486Section 21.4<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      To see how it works, suppose you write down obj.doIt , and obj does<br>
      not have a member named doIt . The compiler will try to insert conversions<br>
      before giving up. In this case, the conversion needs to apply to the
      receiver,<br>
      obj . The compiler will act as if the expected “type” of obj were “has a<br>
      member named doIt .” This “has a doIt ” type is not a normal Scala type,<br>
      but it is there conceptually and is why the compiler will insert an
      implicit<br>
      conversion in this case.<br>
      Interoperating with new types<br>
      As mentioned previously, one major use of receiver conversions is allowing<br>
      smoother integration of new with existing types. In particular, they allow<br>
      you to enable client programmers to use instances of existing types as if
      they<br>
      were instances of your new type. Take, for example, class Rational shown<br>
      in Listing 6.5 on page 155. Here’s a snippet of that class again:<br>
      class Rational(n: Int, d: Int) {<br>
      ...<br>
      def + (that: Rational): Rational = ...<br>
      def + (that: Int): Rational = ...<br>
      }<br>
      Class Rational has two overloaded variants of the + method, which take<br>
      Rational s and Int s, respectively, as arguments. So you can either add
      two<br>
      rational numbers or a rational number and an integer:<br>
      scala&gt; val oneHalf = new Rational(1, 2)<br>
      oneHalf: Rational = 1/2<br>
      scala&gt; oneHalf + oneHalf<br>
      res0: Rational = 1/1<br>
      scala&gt; oneHalf + 1<br>
      res1: Rational = 3/2<br>
      What about an expression like 1 + oneHalf , however? This expression is<br>
      tricky because the receiver, 1 , does not have a suitable + method. So the<br>
      following gives an error:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      487Section 21.4<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      scala&gt; 1 + oneHalf<br>
      &lt;console&gt;:6: error: overloaded method value + with<br>
      alternatives (Double)Double &lt;and&gt; ... cannot be applied<br>
      to (Rational)<br>
      1 + oneHalf<br>
      ˆ<br>
      To allow this kind of mixed arithmetic, you need to define an implicit
      con-<br>
      version from Int to Rational :<br>
      scala&gt; implicit def intToRational(x: Int) =<br>
      new Rational(x, 1)<br>
      intToRational: (x: Int)Rational<br>
      With the conversion in place, converting the receiver does the trick:<br>
      scala&gt; 1 + oneHalf<br>
      res2: Rational = 3/2<br>
      What happens behind the scenes here is that Scala compiler first tries to
      type<br>
      check the expression 1 + oneHalf as it is. This fails because Int has
      several<br>
      + methods, but none that takes a Rational argument. Next, the compiler<br>
      searches for an implicit conversion from Int to another type that has a +<br>
      method which can be applied to a Rational . It finds your conversion and<br>
      applies it, which yields:<br>
      intToRational(1) + oneHalf<br>
      In this case, the compiler found the implicit conversion function because
      you<br>
      entered its definition into the interpreter, which brought it into scope
      for the<br>
      remainder of the interpreter session.<br>
      Simulating new syntax<br>
      The other major use of implicit conversions is to simulate adding new
      syntax.<br>
      Recall that you can make a Map using syntax like this:<br>
      Map(1 -&gt; "one", 2 -&gt; "two", 3 -&gt; "three")<br>
      Have you wondered how the -&gt; is supported? It’s not syntax! Instead,
      -&gt; is<br>
      a method of the class ArrowAssoc , a class defined inside the standard
      Scala<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      488Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      preamble ( scala.Predef ). The preamble also defines an implicit conver-<br>
      sion from Any to ArrowAssoc . When you write 1 -&gt; "one" , the compiler<br>
      inserts a conversion from 1 to ArrowAssoc so that the -&gt; method can be<br>
      found. Here are the relevant definitions:<br>
      package scala<br>
      object Predef {<br>
      class ArrowAssoc[A](x: A) {<br>
      def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)<br>
      }<br>
      implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =<br>
      new ArrowAssoc(x)<br>
      ...<br>
      }<br>
      This “rich wrappers” pattern is common in libraries that provide
      syntax-like<br>
      extensions to the language, so you should be ready to recognize the
      pattern<br>
      when you see it. Whenever you see someone calling methods that appear not<br>
      to exist in the receiver class, they are probably using implicits.
      Similarly, if<br>
      you see a class named RichSomething , e.g., RichInt or RichBoolean , that<br>
      class is likely adding syntax-like methods to type Something .<br>
      You have already seen this rich wrappers pattern for the basic types de-<br>
      scribed in Chapter 5. As you can now see, these rich wrappers apply more<br>
      widely, often letting you get by with an internal DSL defined as a library<br>
      where programmers in other languages might feel the need to develop an<br>
      external DSL.<br>
      21.5<br>
      Implicit parameters<br>
      The remaining place the compiler inserts implicits is within argument
      lists.<br>
      The compiler will sometimes replace someCall(a) with someCall(a)(b) ,<br>
      or new SomeClass(a) with new SomeClass(a)(b) , thereby adding a miss-<br>
      ing parameter list to complete a function call. It is the entire last
      curried<br>
      parameter list that’s supplied, not just the last parameter. For example,
      if<br>
      someCall ’s missing last parameter list takes three parameters, the
      compiler<br>
      might replace someCall(a) with someCall(a)(b, c, d) . For this usage,<br>
      not only must the inserted identifiers, such as b , c , and d in (b, c, d)
      , be<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      489Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      marked implicit where they are defined, but also the last parameter list
      in<br>
      someCall ’s or someClass ’s definition must be marked implicit .<br>
      Here’s a simple example. Suppose you have a class PreferredPrompt ,<br>
      which encapsulates a shell prompt string (such as, say "$ " or "&gt; " )
      that is<br>
      preferred by a user:<br>
      class PreferredPrompt(val preference: String)<br>
      Also, suppose you have a Greeter object with a greet method, which takes<br>
      two parameter lists. The first parameter list takes a string user name,
      and the<br>
      second parameter list takes a PreferredPrompt :<br>
      object Greeter {<br>
      def greet(name: String)(implicit prompt: PreferredPrompt) {<br>
      println("Welcome, "+ name +". The system is ready.")<br>
      println(prompt.preference)<br>
      }<br>
      }<br>
      The last parameter list is marked implicit , which means it can be
      supplied<br>
      implicitly. But you can still provide the prompt explicitly, like this:<br>
      scala&gt; val bobsPrompt = new PreferredPrompt("relax&gt; ")<br>
      bobsPrompt: PreferredPrompt = PreferredPrompt@74a138<br>
      scala&gt; Greeter.greet("Bob")(bobsPrompt)<br>
      Welcome, Bob. The system is ready.<br>
      relax&gt;<br>
      To let the compiler supply the parameter implicitly, you must first define<br>
      a variable of the expected type, which in this case is PreferredPrompt .
      You<br>
      could do this, for example, in a preferences object:<br>
      object JoesPrefs {<br>
      implicit val prompt = new PreferredPrompt("Yes, master&gt; ")<br>
      }<br>
      Note that the val itself is marked implicit. If it wasn’t, the compiler
      would<br>
      not use it to supply the missing parameter list. It will also not use it
      if it isn’t<br>
      in scope as a single identifier. For example:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      490Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      scala&gt; Greeter.greet("Joe")<br>
      &lt;console&gt;:10: error: could not find implicit value for<br>
      parameter prompt: PreferredPrompt<br>
      Greeter.greet("Joe")<br>
      ˆ<br>
      Once you bring it into scope via an import, however, it will be used to
      supply<br>
      the missing parameter list:<br>
      scala&gt; import JoesPrefs._<br>
      import JoesPrefs._<br>
      scala&gt; Greeter.greet("Joe")<br>
      Welcome, Joe. The system is ready.<br>
      Yes, master&gt;<br>
      Note that the implicit keyword applies to an entire parameter list, not<br>
      to individual parameters. Listing 21.1 shows an example in which the last
      pa-<br>
      rameter list of Greeter ’s greet method, which is again marked implicit ,<br>
      has two parameters: prompt (of type PreferredPrompt ) and drink (of type<br>
      PreferredDrink ):<br>
      class PreferredPrompt(val preference: String)<br>
      class PreferredDrink(val preference: String)<br>
      object Greeter {<br>
      def greet(name: String)(implicit prompt: PreferredPrompt,<br>
      drink: PreferredDrink) {<br>
      println("Welcome, "+ name +". The system is ready.")<br>
      print("But while you work, ")<br>
      println("why not enjoy a cup of "+ drink.preference +"?")<br>
      println(prompt.preference)<br>
      }<br>
      }<br>
      object JoesPrefs {<br>
      implicit val prompt = new PreferredPrompt("Yes, master&gt; ")<br>
      implicit val drink = new PreferredDrink("tea")<br>
      }<br>
      Listing 21.1 · An implicit parameter list with multiple parameters.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      491Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      Singleton object JoesPrefs in Listing 21.1 declares two implicit val s,<br>
      prompt of type PreferredPrompt and drink of type PreferredDrink . As<br>
      before, however, so long as these are not in scope as single identifiers,
      they<br>
      won’t be used to fill in a missing parameter list to greet :<br>
      scala&gt; Greeter.greet("Joe")<br>
      &lt;console&gt;:14: error: could not find implicit value for<br>
      parameter prompt: PreferredPrompt<br>
      Greeter.greet("Joe")<br>
      ˆ<br>
      You can bring both implicit val s into scope with an import:<br>
      scala&gt; import JoesPrefs._<br>
      import JoesPrefs._<br>
      Because both prompt and drink are now in scope as single identifiers, you<br>
      can use them to supply the last parameter list explicitly, like this:<br>
      scala&gt; Greeter.greet("Joe")(prompt, drink)<br>
      Welcome, Joe. The system is ready.<br>
      But while you work, why not enjoy a cup of tea?<br>
      Yes, master&gt;<br>
      And because all the rules for implicit parameters are now met, you can
      alter-<br>
      natively let the Scala compiler supply prompt and drink for you by leaving<br>
      off the last parameter list:<br>
      scala&gt; Greeter.greet("Joe")<br>
      Welcome, Joe. The system is ready.<br>
      But while you work, why not enjoy a cup of tea?<br>
      Yes, master&gt;<br>
      One thing to note about the previous examples is that we didn’t use<br>
      String as the type of prompt or drink , even though ultimately it was a<br>
      String that each of them provided through their preference fields. Be-<br>
      cause the compiler selects implicit parameters by matching types of
      parame-<br>
      ters against types of values in scope, implicit parameters usually have
      “rare”<br>
      or “special” enough types that accidental matches are unlikely. For
      example,<br>
      the types PreferredPrompt and PreferredDrink in Listing 21.1 were de-<br>
      fined solely to serve as implicit parameter types. As a result, it is
      unlikely<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      492Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      that implicit variables of these types will be in scope if they aren’t
      intended<br>
      to be used as implicit parameters to Greeter.greet .<br>
      Another thing to know about implicit parameters is that they are perhaps<br>
      most often used to provide information about a type mentioned explicitly
      in<br>
      an earlier parameter list, similar to the type classes of Haskell. As an
      ex-<br>
      ample, consider the maxListUpBound function shown in Listing 21.2, which<br>
      returns the maximum element of the passed list:<br>
      def maxListUpBound[T &lt;: Ordered[T]](elements: List[T]): T =<br>
      elements match {<br>
      case List() =&gt;<br>
      throw new IllegalArgumentException("empty list!")<br>
      case List(x) =&gt; x<br>
      case x :: rest =&gt;<br>
      val maxRest = maxListUpBound(rest)<br>
      if (x &gt; maxRest) x<br>
      else maxRest<br>
      }<br>
      Listing 21.2 · A function with an upper bound.<br>
      The signature of maxListUpBound is similar to that of orderedMergeSort ,<br>
      shown in Listing 19.12 on page 444: it takes a List[T] as its argument,
      and<br>
      specifies via an upper bound that T must be a subtype of Ordered[T] . As<br>
      mentioned at the end of Section 19.8, one weakness with this approach is<br>
      that you can’t use the function with lists whose element type isn’t
      already a<br>
      subtype of Ordered . For example, you couldn’t use the maxListUpBound<br>
      function to find the maximum of a list of integers, because class Int is
      not a<br>
      subtype of Ordered[Int] .<br>
      Another, more general way to organize maxListUpBound would be to<br>
      require a separate, second argument, in addition to the List[T] argument:<br>
      a function that converts a T to an Ordered[T] . This approach is shown in<br>
      Listing 21.3. In this example, the second argument, orderer , is placed in
      a<br>
      separate argument list and marked implicit.<br>
      The orderer parameter in this example is used to describe the ordering<br>
      of T s. In the body of maxListImpParm , this ordering is used in two
      places: a<br>
      recursive call to maxListImpParm , and an if expression that checks
      whether<br>
      the head of the list is larger than the maximum element of the rest of the
      list.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      493Section 21.5<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      def maxListImpParm[T](elements: List[T])<br>
      (implicit orderer: T =&gt; Ordered[T]): T =<br>
      elements match {<br>
      case List() =&gt;<br>
      throw new IllegalArgumentException("empty list!")<br>
      case List(x) =&gt; x<br>
      case x :: rest =&gt;<br>
      val maxRest = maxListImpParm(rest)(orderer)<br>
      if (orderer(x) &gt; maxRest) x<br>
      else maxRest<br>
      }<br>
      Listing 21.3 · A function with an implicit parameter.<br>
      The maxListImpParm function, shown in Listing 21.3, is an example of<br>
      an implicit parameter used to provide more information about a type men-<br>
      tioned explicitly in an earlier parameter list. To be specific, the
      implicit<br>
      parameter orderer , of type T =&gt; Ordered[T] , provides more information<br>
      about type T —in this case, how to order T s. Type T is mentioned in
      List[T] ,<br>
      the type of parameter elements , which appears in the earlier parameter
      list.<br>
      Because elements must always be provided explicitly in any invocation of<br>
      maxListImpParm , the compiler will know T at compile time, and can there-<br>
      fore determine whether an implicit definition of type T =&gt; Ordered[T]
      is in<br>
      scope. If so, it can pass in the second parameter list, orderer ,
      implicitly.<br>
      This pattern is so common that the standard Scala library provides im-<br>
      plicit “orderer” methods for many common types. You could therefore use<br>
      this maxListImpParm method with a variety of types:<br>
      scala&gt; maxListImpParm(List(1,5,10,3))<br>
      res9: Int = 10<br>
      scala&gt; maxListImpParm(List(1.5, 5.2, 10.7, 3.14159))<br>
      res10: Double = 10.7<br>
      scala&gt; maxListImpParm(List("one", "two", "three"))<br>
      res11: java.lang.String = two<br>
      In the first case, the compiler inserted an orderer function for Int s; in
      the<br>
      second case, for Double s; in the third case, for String s.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      494Section 21.6<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      A style rule for implicit parameters As a style rule, it is best to use a<br>
      custom named type in the types of implicit parameters. For example, the<br>
      types of prompt and drink in the previous example was not String , but<br>
      PreferredPrompt and PreferredDrink , respectively. As a counterexam-<br>
      ple, consider that the maxListImpParm function could just as well have
      been<br>
      written with the following type signature:<br>
      def maxListPoorStyle[T](elements: List[T])<br>
      (implicit orderer: (T, T) =&gt; Boolean): T<br>
      To use this version of the function, though, the caller would have to
      supply an<br>
      orderer parameter of type (T, T) =&gt; Boolean . This is a fairly generic
      type<br>
      that includes any function from two T s to a Boolean . It does not
      indicate<br>
      anything at all about what the type is for; it could be an equality test,
      a less-<br>
      than test, a greater-than test, or something else entirely.<br>
      The actual code for maxListImpParm , given in Listing 21.3, shows better<br>
      style. It uses an orderer parameter of type T =&gt; Ordered[T] . The word<br>
      Ordered in this type indicates exactly what the implicit parameter is used<br>
      for: it is for ordering elements of T . Because this orderer type is more<br>
      explicit, it becomes no trouble to add implicit conversions for this type
      in<br>
      the standard library. To contrast, imagine the chaos that would ensue if
      you<br>
      added an implicit of type (T, T) =&gt; Boolean in the standard library,
      and the<br>
      compiler started sprinkling it around in people’s code. You would end up<br>
      with code that compiles and runs, but that does fairly arbitrary tests
      against<br>
      pairs of items!<br>
      Thus the style rule: use at least one role-determining name within the<br>
      type of an implicit parameter.<br>
      21.6<br>
      View bounds<br>
      The previous example had an opportunity to use an implicit but did not.
      Note<br>
      that when you use implicit on a parameter, then not only will the compiler<br>
      try to supply that parameter with an implicit value, but the compiler will
      also<br>
      use that parameter as an available implicit in the body of the method!
      Thus,<br>
      both uses of orderer within the body of the method can be left out.<br>
      When the compiler examines the code in Listing 21.4, it will see that the<br>
      types do not match up. For example, x of type T does not have a &gt;
      method,<br>
      and so x &gt; maxRest does not work. The compiler will not immediately
      stop,<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      495Section 21.6<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      def maxList[T](elements: List[T])<br>
      (implicit orderer: T =&gt; Ordered[T]): T =<br>
      elements match {<br>
      case List() =&gt;<br>
      throw new IllegalArgumentException("empty list!")<br>
      case List(x) =&gt; x<br>
      case x :: rest =&gt;<br>
      val maxRest = maxList(rest) // (orderer) is implicit<br>
      if (x &gt; maxRest) x // orderer(x) is implicit<br>
      else maxRest<br>
      }<br>
      Listing 21.4 · A function that uses an implicit parameter internally.<br>
      however. It will first look for implicit conversions to repair the code.
      In<br>
      this case, it will notice that orderer is available, so it can convert the
      code<br>
      to orderer(x) &gt; maxRest . Likewise for the expression maxList(rest) ,<br>
      which can be converted to maxList(rest)(orderer) . After these two in-<br>
      sertions of implicits, the method fully type checks.<br>
      Look closely at maxList . There is not a single mention of the orderer<br>
      parameter in the text of the method. All uses of orderer are implicit.
      Sur-<br>
      prisingly, this coding pattern is actually fairly common. The implicit
      param-<br>
      eter is used only for conversions, and so it can itself be used
      implicitly.<br>
      Now, because the parameter name is never used explicitly, the name<br>
      could have been anything. For example, maxList would behave identically<br>
      if you left its body alone but changed the parameter name:<br>
      def maxList[T](elements: List[T])<br>
      (implicit converter: T =&gt; Ordered[T]): T =<br>
      // same body...<br>
      For that matter, it could just as well be:<br>
      def maxList[T](elements: List[T])<br>
      (implicit iceCream: T =&gt; Ordered[T]): T =<br>
      // same body...<br>
      Because this pattern is common, Scala lets you leave out the name of this
      pa-<br>
      rameter and shorten the method header by using a view bound. Using a view<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      496Section 21.6<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      def maxList[T &lt; % Ordered[T]](elements: List[T]): T =<br>
      elements match {<br>
      case List() =&gt;<br>
      throw new IllegalArgumentException("empty list!")<br>
      case List(x) =&gt; x<br>
      case x :: rest =&gt;<br>
      val maxRest = maxList(rest) // (orderer) is implicit<br>
      if (x &gt; maxRest) x // orderer(x) is implicit<br>
      else maxRest<br>
      }<br>
      Listing 21.5 · A function with a view bound.<br>
      bound, you would write the signature of maxList as shown in Listing 21.5.<br>
      You can think of “ T &lt; % Ordered[T] ” as saying, “I can use any T , so
      long<br>
      as T can be treated as an Ordered[T] .” This is different from saying that
      T is<br>
      an Ordered[T] , which is what an upper bound, “ T &lt;: Ordered[T] ”,
      would<br>
      say. For example, even though class Int is not a subtype of Ordered[Int] ,<br>
      you could still pass a List[Int] to maxList so long as an implicit conver-<br>
      sion from Int to Ordered[Int] is available. Moreover, if type T happens<br>
      to already be an Ordered[T] , you can still pass a List[T] to maxList .
      The<br>
      compiler will use an implicit identity function, declared in Predef :<br>
      implicit def identity[A](x: A): A = x<br>
      In this case, the conversion is a no-op; it simply returns the object it
      is given.<br>
      View bounds and upper bounds<br>
      The maxListUpBound function, of Listing 21.2, specifies that T is an<br>
      Ordered[T] with its upper bound, T &lt;: Ordered[T] . By contrast, the<br>
      maxList function, of Listing 21.5, specifies that T can be treated as an<br>
      Ordered[T] with its view bound, T &lt; % Ordered[T] . If you compare<br>
      the code of maxListUpBound with that of maxList , you’ll find that the<br>
      only non-cosmetic difference between the two is that the upper bound<br>
      symbol, &lt;: , is changed to a view bound symbol, &lt; %. But maxList of<br>
      Listing 21.5 can work with many more types.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      497Section 21.7<br>
      21.7<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      When multiple conversions apply<br>
      It can happen that multiple implicit conversions are in scope that would
      each<br>
      work. For the most part, Scala refuses to insert a conversion in such a
      case.<br>
      Implicits work well when the conversion left out is completely obvious and<br>
      thus is pure boilerplate. If multiple conversions apply, then the choice
      isn’t<br>
      so obvious after all.<br>
      Here’s a simple example. There is a method that takes a sequence, a<br>
      conversion that turns an integer into a range, and a conversion that turns
      an<br>
      integer into an array of digits:<br>
      scala&gt; def printLength(seq: Seq[Int]) = println(seq.length)<br>
      printLength: (seq: Seq[Int])Unit<br>
      scala&gt; implicit def intToRange(i: Int) = 1 to i<br>
      intToRange: (i: Int)scala.collection.immutable.Range.Inclusive<br>
      with scala.collection.immutable.Range.ByOne<br>
      scala&gt; implicit def intToDigits(i: Int) =<br>
      i.toString.toList.map(_.toInt)<br>
      intToDigits: (i: Int)List[Int]<br>
      scala&gt; printLength(12)<br>
      &lt;console&gt;:21: error: type mismatch;<br>
      found<br>
      : Int(12)<br>
      required: Seq[Int]<br>
      Note that implicit conversions are not applicable because<br>
      they are ambiguous:<br>
      ...<br>
      The ambiguity here is real. Converting an integer to a sequence of dig-<br>
      its is completely different from converting it to a range. In this case,
      the<br>
      programmer should specify which one is intended and be explicit.<br>
      Up through Scala 2.7, that was the end of the story. Whenever mul-<br>
      tiple implicit conversions applied, the compiler refused to choose between<br>
      them. The situation was just as with method overloading. If you try to
      call<br>
      foo(null) , and there are two different foo overloads that accept null ,
      the<br>
      compiler will refuse. It will say that the method call’s target is
      ambiguous.<br>
      Scala 2.8 loosens this rule. If one of the available conversions is
      strictly<br>
      more specific than the others, then the compiler will choose the more
      specific<br>
      one. The idea is that whenever there is a reason to believe a programmer<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      498Section 21.7<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      would always choose one of the conversions over the others, don’t require<br>
      the programmer to write it explicitly. After all, method overloading has
      the<br>
      same relaxation. Continuing the previous example, if one of the available<br>
      foo methods takes a String while the other takes an Any , then choose the<br>
      String version after all. It’s clearly more specific.<br>
      To be more precise, one implicit conversion is more specific than another<br>
      if one of the following applies:<br>
      • The argument type of the former is a subtype of the latter’s.<br>
      • Both conversions are methods, and the enclosing class of the former<br>
      extends the enclosing class of the latter.<br>
      The motivation to revisit this issue and revise the rule was to improve
      in-<br>
      teroperation between Java collections, Scala collections, and strings.
      Here’s<br>
      a simple example among many:<br>
      val cba = "abc".reverse<br>
      What is the type inferred for cba ? Intuitively, the type should be String
      .<br>
      Reversing a string should yield another string, right? However, in Scala
      2.7,<br>
      what happened is that "abc" was converted to a Scala collection. Reversing<br>
      a Scala collection yields a Scala collection, so the type of cba would be<br>
      a collection. There’s also an implicit conversion back to a string, but
      that<br>
      didn’t patch up every problem. For example, in versions prior to Scala
      2.8,<br>
      "abc" == "abc".reverse.reverse was false!<br>
      In Scala 2.8, the type of cba is String . The old implicit conversion to<br>
      a Scala collection (now named WrappedString ) is retained. However, there<br>
      is a more specific conversion supplied from String to a new type called<br>
      StringOps . StringOps has many methods such as reverse , but instead of<br>
      returning a collection, they return a String . The conversion to StringOps<br>
      is defined directly in Predef , whereas the conversion to a scala
      collection<br>
      is defined in a new class, LowPriorityImplicits , which is extended by<br>
      Predef . Whenever a choice exists between these two conversions, the com-<br>
      piler chooses the conversion to StringOps , because it’s defined in a
      subclass<br>
      of the class where the other conversion is defined.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      499Section 21.7<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      object Mocha extends Application {<br>
      class PreferredDrink(val preference: String)<br>
      implicit val pref = new PreferredDrink("mocha")<br>
      def enjoy(name: String)(implicit drink: PreferredDrink) {<br>
      print("Welcome, "+ name)<br>
      print(". Enjoy a ")<br>
      print(drink.preference)<br>
      println("!")<br>
      }<br>
      enjoy("reader")<br>
      }<br>
      Listing 21.6 · Sample code that uses an implicit parameter.<br>
      $ scalac -Xprint:typer mocha.scala<br>
      [[syntax trees at end of typer]]// Scala source: mocha.scala<br>
      package &lt;empty&gt; {<br>
      final object Mocha extends java.lang.Object with Application<br>
      with ScalaObject {<br>
      // ...<br>
      private[this] val pref: Mocha.PreferredDrink =<br>
      new Mocha.this.PreferredDrink("mocha");<br>
      implicit &lt;stable&gt; &lt;accessor&gt;<br>
      def pref: Mocha.PreferredDrink = Mocha.this.pref;<br>
      def enjoy(name: String)<br>
      (implicit drink: Mocha.PreferredDrink): Unit = {<br>
      scala.this.Predef.print("Welcome, ".+(name));<br>
      scala.this.Predef.print(". Enjoy a ");<br>
      scala.this.Predef.print(drink.preference);<br>
      scala.this.Predef.println("!")<br>
      };<br>
      Mocha.this.enjoy("reader")(Mocha.this.pref)<br>
      }<br>
      }<br>
      Listing 21.7 · Sample code after type checking and insertion of implicits.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      500Section 21.8<br>
      21.8<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      Debugging implicits<br>
      Implicits are an powerful feature in Scala, but one which is sometimes
      diffi-<br>
      cult to get right. This section contains a few tips for debugging
      implicits.<br>
      Sometimes you might wonder why the compiler did not find an implicit<br>
      conversion that you think should apply. In that case it helps to write the<br>
      conversion out explicitly. If that also gives an error message, you then
      know<br>
      why the compiler could not apply your implicit. For instance, assume that<br>
      you mistakenly took wrapString to be a conversion from String s to List s,<br>
      instead of IndexedSeq s. You would wonder why the following code does<br>
      not work:<br>
      scala&gt; val chars: List[Char] = "xyz"<br>
      &lt;console&gt;:19: error: type mismatch;<br>
      found<br>
      : java.lang.String("xyz")<br>
      required: List[Char]<br>
      val chars: List[Char] = "xyz"<br>
      In that case it helps to write the<br>
      out what went wrong:<br>
      ˆ<br>
      wrapString<br>
      conversion explicitly, to find<br>
      scala&gt; val chars: List[Char] = wrapString("xyz")<br>
      &lt;console&gt;:19: error: type mismatch;<br>
      found<br>
      : scala.collection.immutable.WrappedString<br>
      required: List[Char]<br>
      val chars: List[Char] = wrapString("xyz")<br>
      ˆ<br>
      wrapString has the wrong<br>
      With this, you have found the cause of the error:<br>
      return type. On the other hand, it’s also possible that inserting the
      conversion<br>
      explicitly will make the error go away. In that case you know that one of
      the<br>
      other rules (such as the Scope Rule) was preventing the implicit
      conversion<br>
      from being applied.<br>
      When you are debugging a program, it can sometimes help to see what<br>
      implicit conversions the compiler is inserting. The -Xprint:typer option<br>
      to the compiler is useful for this. If you run scalac with this option,
      then<br>
      the compiler will show you what your code looks like after all implicit
      con-<br>
      versions have been added by the type checker. An example is shown in<br>
      Listing 21.6 and Listing 21.7. If you look at the last statement in each
      of<br>
      these listings, you’ll see that the second parameter list to enjoy , which
      was<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      501Section 21.9<br>
      Chapter 21 · Implicit Conversions and Parameters<br>
      left off in the code in Listing 21.6, “ enjoy("reader") ,” was inserted by
      the<br>
      compiler, as shown in Listing 21.7:<br>
      Mocha.this.enjoy("reader")(Mocha.this.pref)<br>
      If you are brave, try scala -Xprint:typer to get an interactive shell<br>
      that prints out the post-typing source code it uses internally. If you do
      so, be<br>
      prepared to see an enormous amount of boilerplate surrounding the meat of<br>
      your code.<br>
      21.9<br>
      Conclusion<br>
      Implicits are a powerful, code-condensing feature of Scala. This chapter<br>
      has shown you Scala’s rules about implicits, and it has shown you several<br>
      common programming situations where you can profit from using implicits.<br>
      As a word of warning, implicits can make code confusing if they are<br>
      used too frequently. Thus, before adding a new implicit conversion, first<br>
      ask whether you can achieve a similar effect through other means, such as<br>
      inheritance, mixin composition, or method overloading. If all of these
      fail,<br>
      however, and you feel like a lot of your code is still tedious and
      redundant,<br>
      then implicits might just be able to help you out.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      502Chapter 22<br>
      Implementing Lists<br>
      Lists have been ubiquitous in this book. Class List is probably the most<br>
      commonly used structured data type in Scala. Chapter 16 showed you how<br>
      to use lists. This chapter “opens up the covers” and explains a bit how
      lists<br>
      are implemented in Scala.<br>
      Knowing the internals of the List class is useful for several reasons. You<br>
      gain a better idea of the relative efficiency of list operations, which
      will help<br>
      you in writing fast and compact code using lists. You also learn a toolbox
      of<br>
      techniques that you can apply in the design of your own libraries.
      Finally,<br>
      the List class is a sophisticated application of Scala’s type system in
      general<br>
      and its genericity concepts in particular. So studying class List will
      deepen<br>
      your knowledge in these areas.<br>
      22.1<br>
      The List class in principle<br>
      Lists are not “built-in” as a language construct in Scala; they are
      defined by<br>
      an abstract class List in the scala package, which comes with two sub-<br>
      classes for :: and Nil . In the following we present a quick tour through<br>
      class List . This section presents a somewhat simplified account of the
      class,<br>
      compared to its real implementation in the Scala standard library, which
      is<br>
      covered in Section 22.3.<br>
      package scala<br>
      abstract class List[+T] {<br>
      List is an abstract class, so you cannot define elements by calling the
      empty<br>
      List constructor. For instance the expression “ new List ” would be ille-<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      22.1<br>
      Chapter 22 · Implementing Lists<br>
      scala<br>
      List[+T]<br>
      «sealed abstract»<br>
      scala<br>
      scala<br>
      ::[T] Nil<br>
      «final case» «case object»<br>
      Figure 22.1 · Class hierarchy for Scala lists.<br>
      gal. The class has a type parameter T . The + in front of this type
      parameter<br>
      specifies that lists are covariant, as discussed in Chapter 19. Because of
      this<br>
      property, you can assign a value of type List[Int] , say, to a variable of
      type<br>
      List[Any] :<br>
      scala&gt; val xs = List(1, 2, 3)<br>
      xs: List[Int] = List(1, 2, 3)<br>
      scala&gt; var ys: List[Any] = xs<br>
      ys: List[Any] = List(1, 2, 3)<br>
      All list operations can be defined in terms of three basic methods:<br>
      def isEmpty: Boolean<br>
      def head: T<br>
      def tail: List[T]<br>
      These three methods are all abstract in class List . They are defined in
      the<br>
      subobject Nil and the subclass :: . The hierarchy for List is shown in
      Fig-<br>
      ure 22.1.<br>
      The Nil object<br>
      The Nil object defines an empty list. Its definition is shown in Listing
      22.1.<br>
      The Nil object inherits from type List[Nothing] . Because of covariance,<br>
      this means that Nil is compatible with every instance of the List type.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      504Section 22.1<br>
      Chapter 22 · Implementing Lists<br>
      case object Nil extends List[Nothing] {<br>
      override def isEmpty = true<br>
      def head: Nothing =<br>
      throw new NoSuchElementException("head of empty list")<br>
      def tail: List[Nothing] =<br>
      throw new NoSuchElementException("tail of empty list")<br>
      }<br>
      Listing 22.1 · The definition of the Nil singleton object.<br>
      The three abstract methods of class List are implemented in the Nil<br>
      object in a straightforward way: the isEmpty method returns true and the<br>
      head and tail methods both throw an exception. Note that throwing an<br>
      exception is not only reasonable, but practically the only possible thing
      to do<br>
      for head : Because Nil is a List of Nothing , the result type of head must<br>
      be Nothing . Since there is no value of this type, this means that head
      cannot<br>
      return a normal value. It has to return abnormally by throwing an
      exception. 1<br>
      The :: class<br>
      Class :: , pronounced “cons” for “construct,” represents non-empty lists.
      It’s<br>
      named that way in order to support pattern matching with the infix :: .
      You<br>
      have seen in Section 16.5 that every infix operation in a pattern is
      treated<br>
      as a constructor application of the infix operator to its arguments. So
      the<br>
      pattern x :: xs is treated as ::(x, xs) where :: is a case class. Here is
      the<br>
      definition of the :: class:<br>
      final case class ::[T](hd: T, tl: List[T]) extends List[T] {<br>
      def head = hd<br>
      def tail = tl<br>
      override def isEmpty: Boolean = false<br>
      }<br>
      The implementation of the :: class is straightforward. It takes two
      parame-<br>
      ters hd and tl , representing the head and the tail of the list to be
      constructed.<br>
      1 To<br>
      be precise, the types would also permit for head to always go into an
      infinite loop<br>
      instead of throwing an exception, but this is clearly not what’s wanted.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      505Section 22.1<br>
      Chapter 22 · Implementing Lists<br>
      The definitions of the head and tail method simply return the correspond-<br>
      ing parameter. In fact, this pattern can be abbreviated by letting the
      parame-<br>
      ters directly implement the head and tail methods of the superclass List ,<br>
      as in the following equivalent but shorter definition of the :: class:<br>
      final case class ::[T](head: T, tail: List[T])<br>
      extends List[T] {<br>
      override def isEmpty: Boolean = false<br>
      }<br>
      This works because every case class parameter is implicitly also a field
      of the<br>
      class (it’s like the parameter declaration was prefixed with val ). Recall
      from<br>
      Section 20.3 that Scala allows you to implement an abstract parameterless<br>
      method such as head or tail with a field. So the code above directly uses<br>
      the parameters head and tail as implementations of the abstract methods<br>
      head and tail that were inherited from class List .<br>
      Some more methods<br>
      All other List methods can be written using the basic three. For instance:<br>
      def length: Int =<br>
      if (isEmpty) 0 else 1 + tail.length<br>
      or:<br>
      def drop(n: Int): List[T] =<br>
      if (isEmpty) Nil<br>
      else if (n &lt;= 0) this<br>
      else tail.drop(n - 1)<br>
      or:<br>
      def map[U](f: T =&gt; U): List[U] =<br>
      if (isEmpty) Nil<br>
      else f(head) :: tail.map(f)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      506Section 22.1<br>
      Chapter 22 · Implementing Lists<br>
      List construction<br>
      The list construction methods :: and ::: are special. Because they end in<br>
      a colon, they are bound to their right operand. That is, an operation such<br>
      as x :: xs is treated as the method call xs.::(x) , not x.::(xs) . In
      fact,<br>
      x.::(xs) would not make sense, as x is of the list element type, which can<br>
      be arbitrary, so we cannot assume that this type would have a :: method.<br>
      For this reason, the :: method should take an element value and yield<br>
      a new list. What is the required type of the element value? You might be<br>
      tempted to say, it should be the same as the list’s element type, but in
      fact this<br>
      is more restrictive than necessary. To see why, consider this class
      hierarchy:<br>
      abstract class Fruit<br>
      class Apple extends Fruit<br>
      class Orange extends Fruit<br>
      Listing 22.2 shows what happens when you construct lists of fruit:<br>
      scala&gt; val apples = new Apple :: Nil<br>
      apples: List[Apple] = List(Apple@585fa9)<br>
      scala&gt; val fruits = new Orange :: apples<br>
      fruits: List[Fruit] = List(Orange@cd6798, Apple@585fa9)<br>
      Listing 22.2 · Prepending a supertype element to a subtype list.<br>
      The apples value is treated as a List of Apple s, as expected. However,<br>
      the definition of fruits shows that it’s still possible to add an element
      of<br>
      a different type to that list. The element type of the resulting list is
      Fruit ,<br>
      which is the most precise common supertype of the original list element<br>
      type (i.e., Apple ) and the type of the element to be added (i.e., Orange
      ).<br>
      This flexibility is obtained by defining the :: method (cons) as shown in<br>
      Listing 22.3:<br>
      def ::[U &gt;: T](x: U): List[U] = new scala.::(x, this)<br>
      Listing 22.3 · The definition of method :: (cons) in class List .<br>
      Note that the method is itself polymorphic—it takes a type parameter<br>
      named U . Furthermore, U is constrained in [U &gt;: T] to be a supertype
      of the<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      507Section 22.1<br>
      Chapter 22 · Implementing Lists<br>
      508<br>
      Orange<br>
      head<br>
      head<br>
      ::<br>
      ::<br>
      tail<br>
      fruits<br>
      Apple<br>
      tail<br>
      apples<br>
      Nil<br>
      Figure 22.2 · The structure of the Scala lists shown in Listing 22.2.<br>
      list element type T . The element to be added is required to be of type U
      and<br>
      the result is a List[U] .<br>
      With the formulation of :: shown in Listing 22.3, you can check how the<br>
      definition of fruits shown in Listing 22.2 works out type-wise: in that
      def-<br>
      inition the type parameter U of :: is instantiated to Fruit . The
      lower-bound<br>
      constraint of U is satisfied, because the list apples has type List[Apple]<br>
      and Fruit is a supertype of Apple . The argument to the :: is new Orange ,<br>
      which conforms to type Fruit . Therefore, the method application is type-<br>
      correct with result type List[Fruit] . Figure 22.2 illustrates the
      structure<br>
      of the lists that result from executing the code shown in Listing 22.3.<br>
      In fact, the polymorphic definition of :: with the lower bound T is not<br>
      only convenient; it is also necessary to render the definition of class
      List<br>
      type-correct. This is because List s are defined to be covariant. Assume
      for<br>
      a moment that we had defined :: like this:<br>
      // A thought experiment (which wouldn’t work)<br>
      def ::(x: T): List[T] = new scala.::(x, this)<br>
      You saw in Chapter 19 that method parameters count as contravariant posi-<br>
      tions, so the list element type T is in contravariant position in the
      definition<br>
      above. But then List cannot be declared covariant in T . The lower bound<br>
      [U &gt;: T] thus kills two birds with one stone: it removes a typing
      problem,<br>
      and it leads to a :: method that’s more flexible to use.<br>
      The list concatenation method ::: is defined in a similar way to :: , as<br>
      shown in Listing 22.4.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      22.2<br>
      Chapter 22 · Implementing Lists<br>
      def :::[U &gt;: T](prefix: List[U]): List[U] =<br>
      if (prefix.isEmpty) this<br>
      else prefix.head :: prefix.tail ::: this<br>
      Listing 22.4 · The definition of method ::: in class List .<br>
      Like cons, concatenation is polymorphic. The result type is “widened”<br>
      as necessary to include the types of all list elements. Note also that
      again the<br>
      order of the arguments is swapped between an infix operation and an
      explicit<br>
      method call. Because both ::: and :: end in a colon, they both bind to<br>
      the right and are both right associative. For instance, the else part of
      the<br>
      definition of ::: shown in Listing 22.4 contains infix operations of both
      ::<br>
      and ::: . These infix operations can be expanded to equivalent method
      calls<br>
      as follows:<br>
      prefix.head :: prefix.tail ::: this<br>
      equals (because :: and ::: are right-associative)<br>
      prefix.head :: (prefix.tail ::: this)<br>
      equals (because :: binds to the right)<br>
      (prefix.tail ::: this).::(prefix.head)<br>
      equals (because ::: binds to the right)<br>
      this.:::(prefix.tail).::(prefix.head)<br>
      22.2<br>
      The ListBuffer class<br>
      The typical access pattern for a list is recursive. For instance, to
      increment<br>
      every element of a list without using map you could write:<br>
      def incAll(xs: List[Int]): List[Int] = xs match {<br>
      case List() =&gt; List()<br>
      case x :: xs1 =&gt; x + 1 :: incAll(xs1)<br>
      }<br>
      One shortcoming of this program pattern is that it is not tail recursive.
      Note<br>
      that the recursive call to incAll above occurs inside a :: operation.
      There-<br>
      fore each recursive call requires a new stack frame. On today’s virtual
      ma-<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      509Section 22.2<br>
      Chapter 22 · Implementing Lists<br>
      chines this means that you cannot apply incAll to lists of much more than<br>
      about 30,000 to 50,000 elements. This is a pity.<br>
      How do you write a version of incAll that can work on lists of arbitrary<br>
      size (as much as heap-capacity allows)? One approach is to use a loop:<br>
      for (x &lt;- xs) // ??<br>
      But what should go in the loop body? Note that where incAll above con-<br>
      structs the list by prepending elements to the result of the recursive
      call, the<br>
      loop needs to append new elements at the end of the result list. One, very<br>
      inefficient possibility is to use ::: , the list append operator:<br>
      var result = List[Int]()<br>
      // a very inefficient approach<br>
      for (x &lt;- xs) result = result ::: List(x + 1)<br>
      result<br>
      This has terrible efficiency, though. Because ::: takes time proportional
      to<br>
      the length of its first operand, the whole operation takes time
      proportional to<br>
      the square of the length of the list. This is clearly unacceptable.<br>
      A better alternative is to use a list buffer. List buffers let you
      accumulate<br>
      the elements of a list. To do this, you use an operation such as “ buf +=
      elem ”,<br>
      which appends the element elem at the end of the list buffer buf . Once
      you<br>
      are done appending elements, you can turn the buffer into a list using the<br>
      toList operation.<br>
      ListBuffer is a class in package scala.collection.mutable . To use<br>
      the simple name only, you can import ListBuffer from its package:<br>
      import scala.collection.mutable.ListBuffer<br>
      Using a list buffer, the body of incAll can now be written as follows:<br>
      val buf = new ListBuffer[Int]<br>
      for (x &lt;- xs) buf += x + 1<br>
      buf.toList<br>
      This is a very efficient way to build lists. In fact, the list buffer
      implemen-<br>
      tation is organized so that both the append operation ( += ) and the
      toList<br>
      operation take (very short) constant time.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      510Section 22.3<br>
      22.3<br>
      Chapter 22 · Implementing Lists<br>
      The List class in practice<br>
      The implementations of list methods given in Section 22.1 are concise and<br>
      clear, but suffer from the same stack overflow problem as the non-tail re-<br>
      cursive implementation of incAll . Therefore, most methods in the real im-<br>
      plementation of class List avoid recursion and use loops with list buffers<br>
      instead. For example, Listing 22.5 shows the real implementation of map in<br>
      class List :<br>
      final override def map[U](f: T =&gt; U): List[U] = {<br>
      val b = new ListBuffer[U]<br>
      var these = this<br>
      while (!these.isEmpty) {<br>
      b += f(these.head)<br>
      these = these.tail<br>
      }<br>
      b.toList<br>
      }<br>
      Listing 22.5 · The definition of method map in class List .<br>
      This revised implementation traverses the list with a simple loop, which<br>
      is highly efficient. A tail recursive implementation would be similarly
      ef-<br>
      ficient, but a general recursive implementation would be slower and less<br>
      scalable. But what about the operation b.toList at the end? What is its<br>
      complexity? In fact, the call to the toList method takes only a small num-<br>
      ber of cycles, which is independent of the length of the list.<br>
      To understand why, take a second look at class :: , which constructs non-<br>
      empty lists. In practice, this class does not quite correspond to its
      idealized<br>
      definition given previously in Section 22.1. The real definition is shown
      in<br>
      Listing 22.6.<br>
      There’s one peculiarity: the tl argument is a var ! This means that it is<br>
      possible to modify the tail of a list after the list is constructed.
      However, be-<br>
      cause the variable tl has the modifier private[scala] , it can be accessed<br>
      only from within package scala . Client code outside this package can nei-<br>
      ther read nor write tl .<br>
      Since the ListBuffer class is contained in a subpackage of package<br>
      scala , scala.collection.mutable , ListBuffer can access the tl field<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      511Section 22.3<br>
      Chapter 22 · Implementing Lists<br>
      final case class ::[U](hd: U,<br>
      private[scala] var tl: List[U]) extends List[U] {<br>
      def head = hd<br>
      def tail = tl<br>
      override def isEmpty: Boolean = false<br>
      }<br>
      Listing 22.6 · The definition of the :: subclass of List .<br>
      of a cons cell. In fact the elements of a list buffer are represented as a
      list<br>
      and appending new elements involves a modification of tl field of the last<br>
      :: cell in that list. Here’s the start of class ListBuffer :<br>
      package scala.collection.immutable<br>
      final class ListBuffer[T] extends Buffer[T] {<br>
      private var start: List[T] = Nil<br>
      private var last0: ::[T] = _<br>
      private var exported: Boolean = false<br>
      ...<br>
      You see three private fields that characterize a ListBuffer :<br>
      start<br>
      last0<br>
      exported<br>
      points to the list of all elements stored in the buffer<br>
      points to the last :: cell in that list<br>
      indicates whether the buffer has been turned into<br>
      a list using a toList operation<br>
      The toList operation is very simple:<br>
      override def toList: List[T] = {<br>
      exported = !start.isEmpty<br>
      start<br>
      }<br>
      It returns the list of elements referred to by start and also sets
      exported<br>
      to true if that list is nonempty. So toList is very efficient, because it
      does<br>
      not copy the list which is stored in a ListBuffer . But what happens if
      the<br>
      list is further extended after the toList operation? Of course, once a
      list<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      512Section 22.4<br>
      Chapter 22 · Implementing Lists<br>
      is returned from toList , it must be immutable. However, appending to the<br>
      last0 element will modify the list which is referred to by start .<br>
      To maintain the correctness of the list buffer operations, you need to
      work<br>
      on a fresh list instead. This is achieved by the first line in the
      implementation<br>
      of the += operation:<br>
      override def += (x: T) {<br>
      if (exported) copy()<br>
      if (start.isEmpty) {<br>
      last0 = new scala.::(x, Nil)<br>
      start = last0<br>
      } else {<br>
      val last1 = last0<br>
      last0 = new scala.::(x, Nil)<br>
      last1.tl = last0<br>
      }<br>
      }<br>
      You see that += copies the list pointed to by start if exported is true.
      So,<br>
      in the end, there is no free lunch. If you want to go from lists which can<br>
      be extended at the end to immutable lists, there needs to be some copying.<br>
      However, the implementation of ListBuffer is such that copying is neces-<br>
      sary only for list buffers that are further extended after they have been
      turned<br>
      into lists. This case is quite rare in practice. Most use cases of list
      buffers<br>
      add elements incrementally and then do one toList operation at the end. In<br>
      such cases, no copying is necessary.<br>
      22.4<br>
      Functional on the outside<br>
      The previous section showed key elements of the implementation of Scala’s<br>
      List and ListBuffer classes. You saw that lists are purely functional on<br>
      the “outside” but have an imperative implementation using list buffers on
      the<br>
      “inside.” This is a typical strategy in Scala programming: trying to com-<br>
      bine purity with efficiency by carefully delimiting the effects of impure
      op-<br>
      erations. You might ask, why insist on purity? Why not just open up the<br>
      definition of lists, making the tail field, and maybe also the head field,
      mu-<br>
      table? The disadvantage of such an approach is that it would make programs<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      513Section 22.5<br>
      Chapter 22 · Implementing Lists<br>
      much more fragile. Note that constructing lists with :: re-uses the tail
      of the<br>
      constructed list. So when you write:<br>
      val ys = 1 :: xs<br>
      val zs = 2 :: xs<br>
      the tails of lists ys and zs are shared; they point to the same data
      structure.<br>
      This is essential for efficiency; if the list xs was copied every time you
      added<br>
      a new element onto it, this would be much slower. Because sharing is per-<br>
      vasive, changing list elements, if it were possible, would be quite
      dangerous.<br>
      For instance, taking the code above, if you wanted to truncate list ys to
      its<br>
      first two elements by writing:<br>
      ys.drop(2).tail = Nil<br>
      // can’t do this in Scala!<br>
      you would also truncate lists zs and xs as a side effect. Clearly, it
      would be<br>
      quite difficult to keep track of what gets changed. That’s why Scala opts
      for<br>
      pervasive sharing and no mutation for lists. The ListBuffer class still
      al-<br>
      lows you to build up lists imperatively and incrementally, if you wish to.
      But<br>
      since list buffers are not lists, the types keep mutable buffers and
      immutable<br>
      lists separate.<br>
      The design of Scala’s List and ListBuffer is quite similar to what’s<br>
      done in Java’s pair of classes String and StringBuffer . This is no
      coinci-<br>
      dence. In both situations the designers wanted to maintain a pure
      immutable<br>
      data structure but also wanted to provide an efficient way to construct
      this<br>
      structure incrementally. For Java and Scala strings, StringBuffer s (or,
      in<br>
      Java 5, StringBuilder s) provide a way to construct a string
      incrementally.<br>
      For Scala’s lists, you have a choice: You can either construct lists
      incremen-<br>
      tally by adding elements to the beginning of a list using :: , or you use
      a<br>
      list buffer for adding elements to the end. Which one is preferable
      depends<br>
      on the situation. Usually, :: lends itself well to recursive algorithms in
      the<br>
      divide-and-conquer style. List buffers are often used in a more
      traditional<br>
      loop-based style.<br>
      22.5<br>
      Conclusion<br>
      In this chapter, you saw how lists are implemented in Scala. List is one
      of<br>
      the most heavily used data structures in Scala, and it has a refined
      implemen-<br>
      tation. List ’s two subclasses, Nil and :: , are both case classes.
      Instead of<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      514Section 22.5<br>
      Chapter 22 · Implementing Lists<br>
      recursing through this structure, however, many core list methods are
      imple-<br>
      mented using a ListBuffer . ListBuffer , in turn, is carefully implemented<br>
      so that it can efficiently build lists without allocating extraneous
      memory.<br>
      It is functional on the outside, but uses mutation internally to speed up
      the<br>
      common case where a buffer is discarded after toList is been called. After<br>
      studying all of this, you now know the list classes inside and out, and
      you<br>
      might have learned an implementation trick or two.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      515Chapter 23<br>
      For Expressions Revisited<br>
      Chapter 16 demonstrated that higher-order functions such as map , flatMap
      ,<br>
      and filter provide powerful constructions for dealing with lists. But
      some-<br>
      times the level of abstraction required by these functions makes a program
      a<br>
      bit hard to understand. Here’s an example. Say you are given a list of
      per-<br>
      sons, each defined as an instance of a class Person . Class Person has
      fields<br>
      indicating the person’s name, whether (s)he is male, and his/her children.<br>
      Here’s the class definition:<br>
      scala&gt; case class Person(name: String,<br>
      isMale: Boolean,<br>
      children: Person*)<br>
      Here’s a list of some sample person s:<br>
      val lara = Person("Lara", false)<br>
      val bob = Person("Bob", true)<br>
      val julie = Person("Julie", false, lara, bob)<br>
      val persons = List(lara, bob, julie)<br>
      Now, say you want to find out the names of all pairs of mothers and their<br>
      children in that list. Using map , flatMap and filter , you can formulate
      the<br>
      following query:<br>
      scala&gt; persons filter (p =&gt; !p.isMale) flatMap (p =&gt;<br>
      (p.children map (c =&gt; (p.name, c.name))))<br>
      res0: List[(String, String)] = List((Julie,Lara),<br>
      (Julie,Bob))<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      23.1<br>
      Chapter 23 · For Expressions Revisited<br>
      You could optimize this example bit by using a withFilter call instead of<br>
      filter . This would avoid the creation of an intermediate data structure
      for<br>
      male persons:<br>
      scala&gt; persons withFilter (p =&gt; !p.isMale) flatMap (p =&gt;<br>
      (p.children map (c =&gt; (p.name, c.name))))<br>
      res1: List[(String, String)] = List((Julie,Lara),<br>
      (Julie,Bob))<br>
      These queries do their job, but they are not exactly trivial to write or
      un-<br>
      derstand. Is there a simpler way? In fact, there is. Remember the for<br>
      expressions in Section 7.3? Using a for expression, the same example can<br>
      be written as follows:<br>
      scala&gt; for (p &lt;- persons; if !p.isMale; c &lt;- p.children)<br>
      yield (p.name, c.name)<br>
      res2: List[(String, String)] = List((Julie,Lara),<br>
      (Julie,Bob))<br>
      The result of this expression is exactly the same as the result of the
      previous<br>
      expression. What’s more, most readers of the code would likely find the<br>
      for expression much clearer than the previous query, which used the
      higher-<br>
      order functions, map , flatMap , and withFilter .<br>
      However, the last two queries are not as dissimilar as it might seem.<br>
      In fact, it turns out that the Scala compiler will translate the second
      query<br>
      into the first one. More generally, all for expressions that yield a re-<br>
      sult are translated by the compiler into combinations of invocations of
      the<br>
      higher-order methods map , flatMap , and withFilter . All for loops with-<br>
      out yield are translated into a smaller set of higher-order functions:
      just<br>
      withFilter and foreach .<br>
      In this chapter, you’ll find out first about the precise rules of writing
      for<br>
      expressions. After that, you’ll see how they can make combinatorial prob-<br>
      lems easier to solve. Finally, you’ll learn how for expressions are
      translated,<br>
      and how as a result, for expressions can help you “grow” the Scala
      language<br>
      into new application domains.<br>
      23.1<br>
      For expressions<br>
      Generally, a for expression is of the form:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      517Section 23.1<br>
      Chapter 23 · For Expressions Revisited<br>
      for ( seq ) yield expr<br>
      Here, seq is a sequence of generators, definitions, and filters, with
      semi-<br>
      colons between successive elements. An example is the for expression:<br>
      for (p &lt;- persons; n = p.name; if (n startsWith "To"))<br>
      yield n<br>
      This for expression contains one generator, one definition, and one
      filter. As<br>
      mentioned in Section 7.3 on page 167, you can also enclose the sequence in<br>
      braces instead of parentheses. Then the semicolons become optional:<br>
      for {<br>
      p &lt;- persons // a generator<br>
      n = p.name // a definition<br>
      if (n startsWith "To") // a filter<br>
      } yield n<br>
      A generator is of the form:<br>
      pat &lt;- expr<br>
      The expression expr typically returns a list, even though you will see
      later<br>
      that this can be generalized. The pattern pat gets matched one-by-one
      against<br>
      all elements of that list. If the match succeeds, the variables in the
      pattern get<br>
      bound to the corresponding parts of the element, just the way it is
      described<br>
      in Chapter 15. But if the match fails, no MatchError is thrown. Instead,
      the<br>
      element is simply discarded from the iteration.<br>
      In the most common case, the pattern pat is just a variable x, as in<br>
      x &lt;- expr . In that case, the variable x simply iterates over all
      elements<br>
      returned by expr.<br>
      A definition is of the form:<br>
      pat = expr<br>
      This definition binds the pattern pat to the value of expr. So it has the
      same<br>
      effect as a val definition:<br>
      val x = expr<br>
      The most common case is again where the pattern is a simple variable x ,
      e.g.,<br>
      x = expr . This defines x as a name for the value expr.<br>
      A filter is of the form:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      518Section 23.2<br>
      Chapter 23 · For Expressions Revisited<br>
      if expr<br>
      Here, expr is an expression of type Boolean . The filter drops from the
      itera-<br>
      tion all elements for which expr returns false .<br>
      Every for expression starts with a generator. If there are several genera-<br>
      tors in a for expression, later generators vary more rapidly than earlier
      ones.<br>
      You can verify this easily with the following simple test:<br>
      scala&gt; for (x &lt;- List(1, 2); y &lt;- List("one", "two"))<br>
      yield (x, y)<br>
      res3: List[(Int, java.lang.String)] =<br>
      List((1,one), (1,two), (2,one), (2,two))<br>
      23.2<br>
      The n-queens problem<br>
      A particularly suitable application area of for expressions are
      combinatorial<br>
      puzzles. An example of such a puzzle is the 8-queens problem: Given a<br>
      standard chess-board, place eight queens such that no queen is in check
      from<br>
      any other (a queen can check another piece if they are on the same column,<br>
      row, or diagonal). To find a solution to this problem, it’s actually
      simpler to<br>
      generalize it to chess-boards of arbitrary size. Hence, the problem is to
      place<br>
      N queens on a chess-board of N × N squares, where the size N is arbitrary.<br>
      We’ll start numbering cells at one, so the upper-left cell of an N × N
      board<br>
      has coordinate (1, 1), and the lower-right cell has coordinate (N, N).<br>
      To solve the N-queens problem, note that you need to place a queen in<br>
      each row. So you could place queens in successive rows, each time checking<br>
      that a newly placed queen is not in check from any other queens that have<br>
      already been placed. In the course of this search, it might arrive that a
      queen<br>
      that needs to be placed in row k would be in check in all fields of that
      row<br>
      from queens in row 1 to k − 1. In that case, you need to abort that part
      of<br>
      the search in order to continue with a different configuration of queens
      in<br>
      columns 1 to k − 1.<br>
      An imperative solution to this problem would place queens one by one,<br>
      moving them around on the board. But it looks difficult to come up with a<br>
      scheme that really tries all possibilities.<br>
      A more functional approach represents a solution directly, as a value. A<br>
      solution consists of a list of coordinates, one for each queen placed on
      the<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      519Section 23.2<br>
      Chapter 23 · For Expressions Revisited<br>
      board. Note, however, that a full solution can not be found in a single
      step.<br>
      It needs to be built up gradually, by occupying successive rows with
      queens.<br>
      This suggests a recursive algorithm. Assume you have already generated<br>
      all solutions of placing k queens on a board of size N ×N, where k is less
      than<br>
      N. Each such solution can be presented by a list of length k of
      coordinates<br>
      (row, column) , where both row and column numbers range from 1 to N. It’s<br>
      convenient to treat these partial solution lists as stacks, where the
      coordinates<br>
      of the queen in row k come first in the list, followed by the coordinates
      of<br>
      the queen in row k − 1, and so on. The bottom of the stack is the
      coordinate<br>
      of the queen placed in the first row of the board. All solutions together
      are<br>
      represented as a list of lists, with one element for each solution.<br>
      Now, to place the next queen in row k + 1, generate all possible exten-<br>
      sions of each previous solution by one more queen. This yields another
      list of<br>
      solution lists, this time of length k + 1. Continue the process until you
      have<br>
      obtained all solutions of the size of the chess-board N. This algorithmic
      idea<br>
      is embodied in function placeQueens below:<br>
      def queens(n: Int): List[List[(Int, Int)]] = {<br>
      def placeQueens(k: Int): List[List[(Int, Int)]] =<br>
      if (k == 0)<br>
      List(List())<br>
      else<br>
      for {<br>
      queens &lt;- placeQueens(k - 1)<br>
      column &lt;- 1 to n<br>
      queen = (k, column)<br>
      if isSafe(queen, queens)<br>
      } yield queen :: queens<br>
      placeQueens(n)<br>
      }<br>
      The outer function queens in the program above simply calls placeQueens<br>
      with the size of the board n as its argument. The task of the function
      applica-<br>
      tion placeQueens(k) is to generate all partial solutions of length k in a
      list.<br>
      Every element of the list is one solution, represented by a list of length
      k . So<br>
      placeQueens returns a list of lists.<br>
      If the parameter k to placeQueens is 0 , this means that it needs to gen-<br>
      erate all solutions of placing zero queens on zero rows. There is exactly<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      520Section 23.2<br>
      Chapter 23 · For Expressions Revisited<br>
      one such solution: place no queen at all. This solution is represented by
      the<br>
      empty list. So if k is zero, placeQueens returns List(List()) , a list
      con-<br>
      sisting of a single element that is the empty list. Note that this is
      quite differ-<br>
      ent from the empty list List() . If placeQueens returns List() , this
      means<br>
      no solutions, instead of a single solution consisting of no placed queens.<br>
      In the other case, where k is not zero, all the work of placeQueens is<br>
      done in a for expression. The first generator of that for expression
      iterates<br>
      through all solutions of placing k - 1 queens on the board. The second
      gen-<br>
      erator iterates through all possible column s on which the k ’th queen
      might<br>
      be placed. The third part of the for expression defines the newly consid-<br>
      ered queen position to be the pair consisting of row k and each produced<br>
      column . The fourth part of the for expression is a filter which checks
      with<br>
      isSafe whether the new queen is safe from check of all previous queens
      (the<br>
      definition of isSafe will be discussed a bit later).<br>
      If the new queen is not in check from any other queens, it can form part
      of<br>
      a partial solution, so placeQueens generates with queen :: queens a new<br>
      solution. If the new queen is not safe from check, the filter returns
      false , so<br>
      no solution is generated.<br>
      The only remaining bit is the isSafe method, which is used to check<br>
      whether a given queen is in check from any other element in a list of
      queens .<br>
      Here is its definition:<br>
      def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =<br>
      queens forall (q =&gt; !inCheck(queen, q))<br>
      def inCheck(q1: (Int, Int), q2: (Int, Int)) =<br>
      q1._1 == q2._1 || // same row<br>
      q1._2 == q2._2 || // same column<br>
      (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // on diagonal<br>
      The isSafe method expresses that a queen is safe with respect to some
      other<br>
      queens if it is not in check from any other queen. The inCheck method<br>
      expresses that queens q1 and q2 are mutually in check. It returns true in<br>
      one of three cases:<br>
      1. If the two queens have the same row coordinate,<br>
      2. If the two queens have the same column coordinate,<br>
      3. If the two queens are on the same diagonal, i.e., the difference
      between<br>
      their rows and the difference between their columns are the same.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      521Section 23.3<br>
      Chapter 23 · For Expressions Revisited<br>
      The first case, that the two queens have the same row coordinate, cannot<br>
      happen in the application because placeQueens already takes care to place<br>
      each queen in a different row. So you could remove the test without
      changing<br>
      the functionality of the program as a whole.<br>
      23.3<br>
      Querying with for expressions<br>
      The for notation is essentially equivalent to common operations of
      database<br>
      query languages. For instance, say you are given a database named books ,<br>
      represented as a list of books, where Book is defined as follows:<br>
      case class Book(title: String, authors: String*)<br>
      Here is a small example database, represented as an in-memory list:<br>
      val books: List[Book] =<br>
      List(<br>
      Book(<br>
      "Structure and Interpretation of Computer Programs",<br>
      "Abelson, Harold", "Sussman, Gerald J."<br>
      ),<br>
      Book(<br>
      "Principles of Compiler Design",<br>
      "Aho, Alfred", "Ullman, Jeffrey"<br>
      ),<br>
      Book(<br>
      "Programming in Modula-2",<br>
      "Wirth, Niklaus"<br>
      ),<br>
      Book(<br>
      "Elements of ML Programming",<br>
      "Ullman, Jeffrey"<br>
      ),<br>
      Book(<br>
      "The Java Language Specification", "Gosling, James",<br>
      "Joy, Bill", "Steele, Guy", "Bracha, Gilad"<br>
      )<br>
      )<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      522Section 23.3<br>
      Chapter 23 · For Expressions Revisited<br>
      Then, to find the titles of all books whose author’s last name is
      “Gosling”:<br>
      scala&gt; for (b &lt;- books; a &lt;- b.authors<br>
      if a startsWith "Gosling")<br>
      yield b.title<br>
      res4: List[String] = List(The Java Language Specification)<br>
      Or, to find the titles of all books that have the string “Program” in
      their title:<br>
      scala&gt; for (b &lt;- books if (b.title indexOf "Program") &gt;= 0)<br>
      yield b.title<br>
      res5: List[String] = List(Structure and Interpretation of<br>
      Computer Programs, Programming in Modula-2, Elements<br>
      of ML Programming)<br>
      Or, to find the names of all authors that have written at least two books
      in the<br>
      database:<br>
      scala&gt; for (b1 &lt;- books; b2 &lt;- books if b1 != b2;<br>
      a1 &lt;- b1.authors; a2 &lt;- b2.authors if a1 == a2)<br>
      yield a1<br>
      res6: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)<br>
      The last solution is not yet perfect, because authors will appear several
      times<br>
      in the list of results. You still need to remove duplicate authors from
      result<br>
      lists. This can be achieved with the following function:<br>
      scala&gt; def removeDuplicates[A](xs: List[A]): List[A] = {<br>
      if (xs.isEmpty) xs<br>
      else<br>
      xs.head :: removeDuplicates(<br>
      xs.tail filter (x =&gt; x != xs.head)<br>
      )<br>
      }<br>
      removeDuplicates: [A](xs: List[A])List[A]<br>
      scala&gt; removeDuplicates(res6)<br>
      res7: List[String] = List(Ullman, Jeffrey)<br>
      It’s worth noting that the last expression in method removeDuplicates can<br>
      be equivalently expressed using a for expression:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      523Section 23.4<br>
      Chapter 23 · For Expressions Revisited<br>
      xs.head :: removeDuplicates(<br>
      for (x &lt;- xs.tail if x != xs.head) yield x<br>
      )<br>
      23.4<br>
      Translation of for expressions<br>
      Every for expression can be expressed in terms of the three higher-order<br>
      functions map , flatMap , and withFilter . This section describes the
      trans-<br>
      lation scheme, which is also used by the Scala compiler.<br>
      Translating for expressions with one generator<br>
      First, assume you have a simple for expression:<br>
      for ( x &lt;- expr 1 ) yield expr 2<br>
      where x is a variable. Such an expression is translated to:<br>
      expr 1 .map( x =&gt; expr 2 )<br>
      Translating for expressions starting with a generator and a filter<br>
      Now, consider for expressions that combine a leading generator with some<br>
      other elements. A for expression of the form:<br>
      for ( x &lt;- expr 1 if expr 2 ) yield expr 3<br>
      is translated to:<br>
      for ( x &lt;- expr 1 withFilter ( x =&gt; expr 2 )) yield expr 3<br>
      This translation gives another for expression that is shorter by one
      element<br>
      than the original, because an if element is transformed into an
      application of<br>
      withFilter on the first generator expression. The translation then
      continues<br>
      with this second expression, so in the end you obtain:<br>
      expr 1 withFilter ( x =&gt; expr 2 ) map ( x =&gt; expr 3 )<br>
      The same translation scheme also applies if there are further elements
      fol-<br>
      lowing the filter. If seq is an arbitrary sequence of generators,
      definitions<br>
      and filters, then:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      524Section 23.4<br>
      Chapter 23 · For Expressions Revisited<br>
      for ( x &lt;- expr 1 if expr 2 ; seq) yield expr 3<br>
      is translated to:<br>
      for ( x &lt;- expr 1 withFilter expr 2 ; seq) yield expr 3<br>
      Then translation continues with the second expression, which is again
      shorter<br>
      by one element than the original one.<br>
      Translating for expressions starting with two generators<br>
      The next case handles for expressions that start with two generators, as
      in:<br>
      for ( x &lt;- expr 1 ; y &lt;- expr 2 ; seq) yield expr 3<br>
      Again, assume that seq is an arbitrary sequence of generators, definitions
      and<br>
      filters. In fact, seq might also be empty, and in that case there would
      not be a<br>
      semicolon after expr 2 . The translation scheme stays the same in each
      case.<br>
      The for expression above is translated to an application of flatMap :<br>
      expr 1 .flatMap( x =&gt; for ( y &lt;- expr 2 ; seq) yield expr 3 )<br>
      This time, there is another for expression in the function value passed to<br>
      flatMap . That for expression (which is again simpler by one element than<br>
      the original) is in turn translated with the same rules.<br>
      The three translation schemes given so far are sufficient to translate all<br>
      for expressions that contain just generators and filters, and where
      generators<br>
      bind only simple variables. Take for instance the query, “find all authors
      who<br>
      have published at least two books,” from Section 23.3:<br>
      for (b1 &lt;- books; b2 &lt;- books if b1 != b2;<br>
      a1 &lt;- b1.authors; a2 &lt;- b2.authors if a1 == a2)<br>
      yield a1<br>
      This query translates to the following map / flatMap / filter combination:<br>
      books flatMap (b1 =&gt;<br>
      books withFilter (b2 =&gt; b1 != b2) flatMap (b2 =&gt;<br>
      b1.authors flatMap (a1 =&gt;<br>
      b2.authors withFilter (a2 =&gt; a1 == a2) map (a2 =&gt;<br>
      a1))))<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      525Section 23.4<br>
      Chapter 23 · For Expressions Revisited<br>
      The translation scheme presented so far does not yet handle generators
      that<br>
      bind whole patterns instead of simple variables. It also does not yet
      cover<br>
      definitions. These two aspects will be explained in the next two
      sub-sections.<br>
      Translating patterns in generators<br>
      The translation scheme becomes more complicated if the left hand side of<br>
      generator is a pattern, pat, other than a simple variable. Still
      relatively easy<br>
      to handle is the case where the for expression binds a tuple of variables.<br>
      In that case, almost the same scheme as for single variables applies. A
      for<br>
      expression of the form:<br>
      for (( x 1 , ..., x n ) &lt;- expr 1 ) yield expr 2<br>
      translates to:<br>
      expr 1 .map { case ( x 1 , ..., x n ) =&gt; expr 2 }<br>
      Things become a bit more involved if the left hand side of the generator
      is<br>
      an arbitrary pattern pat instead of a single variable or a tuple. In this
      case:<br>
      for (pat &lt;- expr 1 ) yield expr 2<br>
      translates to:<br>
      expr 1 withFilter {<br>
      case pat =&gt; true<br>
      case _ =&gt; false<br>
      } map {<br>
      case pat =&gt; expr 2<br>
      }<br>
      That is, the generated items are first filtered and only those that match
      pat<br>
      are mapped. Therefore, it’s guaranteed that a pattern-matching generator<br>
      will never throw a MatchError .<br>
      The scheme above only treated the case where the for expression con-<br>
      tains a single pattern-matching generator. Analogous rules apply if the
      for<br>
      expression contains other generators, filters, or definitions. Because
      these<br>
      additional rules don’t add much new insight, they are omitted from discus-<br>
      sion here. If you are interested, you can look them up in the Scala
      Language<br>
      Specification [Ode08].<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      526Section 23.4<br>
      Chapter 23 · For Expressions Revisited<br>
      Translating definitions<br>
      The last missing situation is where a for expression contains embedded
      def-<br>
      initions. Here’s a typical case:<br>
      for ( x &lt;- expr 1 ; y = expr 2 ; seq) yield expr 3<br>
      Assume again that seq is a (possibly empty) sequence of generators,
      defini-<br>
      tions, and filters. This expression is translated to the following one:<br>
      for (( x , y ) &lt;- for ( x &lt;- expr 1 ) yield ( x , expr 2 ); seq)<br>
      yield expr 3<br>
      So you see that expr 2 is evaluated each time there is a new x value being<br>
      generated. This re-evaluation is necessary, because expr 2 might refer to<br>
      x and so needs to be re-evaluated for changing values of x. For you as a<br>
      programmer the conclusion is that it’s probably not a good idea to have
      defi-<br>
      nitions embedded in for expressions that do not refer to variables bound
      by<br>
      some preceding generator, because re-evaluating such expressions would be<br>
      wasteful. For instance, instead of:<br>
      for (x &lt;- 1 to 1000; y = expensiveComputationNotInvolvingX)<br>
      yield x * y<br>
      it’s usually better to write:<br>
      val y = expensiveComputationNotInvolvingX<br>
      for (x &lt;- 1 to 1000) yield x * y<br>
      Translating for loops<br>
      The previous subsections showed how for expressions that contain a yield<br>
      are translated. What about for loops that simply perform a side effect
      with-<br>
      out returning anything? Their translation is similar, but simpler than for<br>
      expressions. In principle, wherever the previous translation scheme used a<br>
      map or a flatMap in the translation, the translation scheme for for loops<br>
      uses just a foreach . For instance, the expression:<br>
      for ( x &lt;- expr 1 ) body<br>
      translates to:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      527Section 23.5<br>
      Chapter 23 · For Expressions Revisited<br>
      expr 1 foreach ( x =&gt; body)<br>
      A larger example is the expression:<br>
      for ( x &lt;- expr 1 ; if expr 2 ; y &lt;- expr 3 ) body<br>
      This expression translates to:<br>
      expr 1 withFilter ( x =&gt; expr 2 ) foreach ( x =&gt;<br>
      expr 3 foreach ( y =&gt; body))<br>
      For example, the following expression sums up all elements of a matrix
      rep-<br>
      resented as a list of lists:<br>
      var sum = 0<br>
      for (xs &lt;- xss; x &lt;- xs) sum += x<br>
      This loop is translated into two nested foreach applications:<br>
      var sum = 0<br>
      xss foreach (xs =&gt;<br>
      xs foreach (x =&gt;<br>
      sum += x))<br>
      23.5<br>
      Going the other way<br>
      The previous section showed that for expressions can be translated into
      ap-<br>
      plications of the higher-order functions map , flatMap , and withFilter .
      In<br>
      fact, you could equally well go the other way: every application of a map
      ,<br>
      flatMap , or filter can be represented as a for expression. Here are im-<br>
      plementations of the three methods in terms of for expressions. The meth-<br>
      ods are contained in an object Demo , to distinguish them from the
      standard<br>
      operations on List s. To be concrete, the three functions all take a List
      as<br>
      parameter, but the translation scheme would work just as well with other<br>
      collection types:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      528Section 23.6<br>
      Chapter 23 · For Expressions Revisited<br>
      object Demo {<br>
      def map[A, B](xs: List[A], f: A =&gt; B): List[B] =<br>
      for (x &lt;- xs) yield f(x)<br>
      def flatMap[A, B](xs: List[A], f: A =&gt; List[B]): List[B] =<br>
      for (x &lt;- xs; y &lt;- f(x)) yield y<br>
      def filter[A](xs: List[A], p: A =&gt; Boolean): List[A] =<br>
      for (x &lt;- xs if p(x)) yield x<br>
      }<br>
      Not surprisingly, the translation of the for expression used in the body
      of<br>
      Demo.map will produce a call to map in class List . Similarly,
      Demo.flatMap<br>
      and Demo.filter translate to flatMap and withFilter in class List .<br>
      So this little demonstration has shown that for expressions really are<br>
      equivalent in their expressiveness to applications of the three functions
      map ,<br>
      flatMap , and withFilter .<br>
      23.6<br>
      Generalizing for<br>
      Because the translation of for expressions only relies on the presence of<br>
      methods map , flatMap , and withFilter , it is possible to apply the for<br>
      notation to a large class of data types.<br>
      You have already seen for expressions over lists and arrays. These are<br>
      supported because lists, as well as arrays, define operations map ,
      flatMap ,<br>
      and withFilter . Because they define a foreach method as well, for loops<br>
      over these data types are also possible.<br>
      Besides lists and arrays, there are also many other types in the Scala
      stan-<br>
      dard library that support the same four methods and therefore allow for
      ex-<br>
      pressions. Examples are ranges, iterators, streams, and all
      implementations<br>
      of sets. It’s also perfectly possible for your own data types to support
      for ex-<br>
      pressions by defining the necessary methods. To support the full range of
      for<br>
      expressions and for loops, you need to define map , flatMap , withFilter ,<br>
      and foreach as methods of your data type. But it’s also possible to define<br>
      a subset of these methods, and thereby support a subset of all possible
      for<br>
      expressions or loops. Here are the precise rules:<br>
      • If your type defines just map , it allows for expressions consisting of
      a<br>
      single generator.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      529Section 23.6<br>
      Chapter 23 · For Expressions Revisited<br>
      • If it defines flatMap as well as map , it allows for expressions
      consist-<br>
      ing of several generators.<br>
      • If it defines foreach , it allows for loops (both with single and multi-<br>
      ple generators).<br>
      • If it defines withFilter , it allows for filter expressions starting
      with<br>
      an if in the for expression.<br>
      The translation of for expressions happens before type checking. This al-<br>
      lows for maximal flexibility, because it is only required that the result
      of<br>
      expanding a for expression type checks. Scala defines no typing rules for<br>
      the for expressions themselves, and does not require that methods map ,<br>
      flatMap , withFilter , or foreach to have any particular type signatures.<br>
      Nevertheless, there is a typical setup that captures the most common<br>
      intention of the higher order methods to which for expressions translate.<br>
      Say you have a parameterized class, C , which typically would stand for
      some<br>
      sort of collection. Then it’s quite natural to pick the following type
      signatures<br>
      for map , flatMap , withFilter , and foreach :<br>
      abstract class C[A] {<br>
      def map[B](f: A =&gt; B): C[B]<br>
      def flatMap[B](f: A =&gt; C[B]): C[B]<br>
      def withFilter(p: A =&gt; Boolean): C[A]<br>
      def foreach(b: A =&gt; Unit): Unit<br>
      }<br>
      That is, the map function takes a function from the collection’s element
      type<br>
      A to some other type B . It produces a new collection of the same kind C ,
      but<br>
      with B as the element type. The flatMap method takes a function f from A
      to<br>
      some C -collection of B s and produces a C -collection of B s. The
      withFilter<br>
      method takes a predicate function from the collection’s element type A to<br>
      Boolean . It produces a collection of the same type as the one on which it
      is<br>
      invoked. Finally, the foreach method takes a function from A to Unit , and<br>
      produces a Unit result.<br>
      In class C above, the withFilter method produces a new collection of<br>
      the same class. That means that every invocation of withFilter creates a<br>
      new C object, just the same as filter would work. Now, in the translation<br>
      of for expressions, any calls to withFilter are always followed by calls
      to<br>
      one of the other three methods. Therefore, the object created by
      withFilter<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      530Section 23.7<br>
      Chapter 23 · For Expressions Revisited<br>
      will be immediately afterwards taken apart by one of the other methods. If<br>
      objects of class C are large (think long sequences), you might want to
      avoid<br>
      the creation of such an intermediate object. A standard technique is to
      let<br>
      withFilter return not a C object but just a wrapper object that
      “remembers”<br>
      that elements need to be filtered before being processed further.<br>
      Concentrating on just the first three functions of class C , the following<br>
      facts are noteworthy. In functional programming, there’s a general concept<br>
      called a monad, which can explain a large number of types with computa-<br>
      tions, ranging from collections, to computations with state and I/O, back-<br>
      tracking computations, and transactions, to name but a few. You can for-<br>
      mulate functions map , flatMap , and withFilter on a monad, and, if you<br>
      do, they end up having exactly the types given above. Furthermore, you can<br>
      characterize every monad by map , flatMap , and withFilter , plus a “unit”<br>
      constructor that produces a monad from an element value. In an object-<br>
      oriented language, this “unit” constructor is simply an instance
      constructor<br>
      or a factory method. Therefore, map , flatMap and withFilter can be seen<br>
      as an object-oriented version of the functional concept of monad. Because<br>
      for expressions are equivalent to applications of these three methods,
      they<br>
      can be seen as syntax for monads.<br>
      All this suggests that the concept of for expression is more general than<br>
      just iteration over a collection, and indeed it is. For instance, for
      expressions<br>
      also play an important role in asynchronous I/O, or as an alternative
      notation<br>
      for optional values. Watch out in the Scala libraries for occurrences of
      map ,<br>
      flatMap , and withFilter —when they are present, for expressions suggest<br>
      themselves as a concise way of manipulating elements of the type.<br>
      23.7<br>
      Conclusion<br>
      In this chapter, you were given a peek under the hood of for expressions
      and<br>
      for loops. You learned that they translate into applications of a standard
      set<br>
      of higher-order methods. As a consequence of this, you saw that for
      expres-<br>
      sions are really much more general than mere iterations over collections,
      and<br>
      that you can design your own classes to support them.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      531Chapter 24<br>
      The Scala Collections API<br>
      In the eyes of many, the new collections framework is the most significant<br>
      change in Scala 2.8. Scala had collections before (and in fact the new
      frame-<br>
      work is largely compatible with them). But it’s only 2.8 that provides a<br>
      common, uniform, and all-encompassing framework for collection types.<br>
      Even though the additions to collections are subtle at first glance, the<br>
      changes they can provoke in your programming style can be profound. In<br>
      fact, quite often it’s as if you work on a higher level with the basic
      building<br>
      blocks of a program being whole collections instead of their elements.
      This<br>
      new style of programming requires some adaptation. Fortunately, the adap-<br>
      tation is helped by several nice properties of the new Scala collections.
      They<br>
      are easy to use, concise, safe, fast, and universal.<br>
      Easy to use: A small vocabulary of twenty to fifty methods is enough to<br>
      solve most collection problems in a couple of operations. No need<br>
      to wrap your head around complicated looping structures or recur-<br>
      sions. Persistent collections and side-effect-free operations mean that<br>
      you need not worry about accidentally corrupting existing collections<br>
      with new data. Interference between iterators and collection updates<br>
      is eliminated.<br>
      Concise: You can achieve with a single word what used to take one or sev-<br>
      eral loops. You can express functional operations with lightweight<br>
      syntax and combine operations effortlessly, so that the result feels like<br>
      a custom algebra.<br>
      Safe: This one has to be experienced to sink in. The statically typed and<br>
      functional nature of Scala’s collections means that the overwhelming<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      24.1<br>
      Chapter 24 · The Scala Collections API<br>
      majority of errors you might make are caught at compile-time. The<br>
      reason is that (1) the collection operations themselves are heavily used<br>
      and therefore well tested. (2) the usages of the collection operation<br>
      make inputs and output explicit as function parameters and results. (3)<br>
      These explicit inputs and outputs are subject to static type checking.<br>
      The bottom line is that the large majority of misuses will manifest<br>
      themselves as type errors. It’s not at all uncommon to have programs<br>
      of several hundred lines run at first try.<br>
      Fast: Collection operations are tuned and optimized in the libraries. As a
      re-<br>
      sult, using collections is typically quite efficient. You might be able to<br>
      do a little bit better with carefully hand-tuned data structures and oper-<br>
      ations, but you might also do a lot worse by making some suboptimal<br>
      implementation decisions along the way. What’s more, collections are<br>
      currently being adapted to parallel execution on multi-cores. Paral-<br>
      lel collections will support the same operations as sequential ones, so<br>
      no new operations need to be learned and no code needs to be rewrit-<br>
      ten. You will be able to turn a sequential collection into a parallel one<br>
      simply by invoking the par method.<br>
      Universal: Collections provide the same operations on any type where it<br>
      makes sense to do so. So you can achieve a lot with a fairly small<br>
      vocabulary of operations. For instance, a string is conceptually a se-<br>
      quence of characters. Consequently, in Scala collections, strings sup-<br>
      port all sequence operations. The same holds for arrays.<br>
      This chapter describes in depth the APIs of the Scala 2.8 collection<br>
      classes from a user perspective. You’ve already seen a quick tour of the<br>
      collections library, in Chapter 17. This chapter takes you on a more
      detailed<br>
      tour, showing all the collection classes and all the methods they define,
      so<br>
      it includes everything you need to know to use Scala collections. Looking<br>
      ahead, Chapter 25 will concentrate on the architecture and extensibility
      as-<br>
      pects of the library, for people implementing new collection types.<br>
      24.1<br>
      Mutable and immutable collections<br>
      As is now familiar to you, Scala collections systematically distinguish
      be-<br>
      tween mutable and immutable collections. A mutable collection can be up-<br>
      dated or extended in place. This means you can change, add, or remove<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      533Section 24.1<br>
      Chapter 24 · The Scala Collections API<br>
      elements of a collection as a side effect. Immutable collections, by
      contrast,<br>
      never change. You still have operations that simulate additions, removals,
      or<br>
      updates, but those operations will in each case return a new collection
      and<br>
      leave the old collection unchanged.<br>
      All collection classes are found in the package scala.collection or<br>
      one of its subpackages: mutable , immutable , and generic . Most collec-<br>
      tion classes needed by client code exist in three variants, each of which
      has<br>
      different characteristics with respect to mutability. The three variants
      are<br>
      located in packages scala.collection , scala.collection.immutable ,<br>
      and scala.collection.mutable .<br>
      A collection in package scala.collection.immutable is guaranteed<br>
      to be immutable for everyone. Such a collection will never change after<br>
      it is created. Therefore, you can rely on the fact that accessing the same<br>
      collection value repeatedly at different points in time will always yield
      a<br>
      collection with the same elements.<br>
      A collection in package scala.collection.mutable is known to have<br>
      some operations that change the collection in place. These operations let
      you<br>
      write code to mutate the collection yourself. However, you must be careful<br>
      to understand and defend against any updates performed by other parts of<br>
      the code base.<br>
      A collection in package scala.collection can be either mutable or im-<br>
      mutable. For instance, scala.collection.IndexedSeq[T] is a supertrait<br>
      of both scala.collection.immutable.IndexedSeq[T] and its mutable<br>
      sibling scala.collection.mutable.IndexedSeq[T] . Generally, the root<br>
      collections in package scala.collection define the same interface as the<br>
      immutable collections. And typically, the mutable collections in package<br>
      scala.collection.mutable add some side-effecting modification opera-<br>
      tions to this immutable interface.<br>
      The difference between root collections and immutable collections is that<br>
      clients of an immutable collection have a guarantee that nobody can mutate<br>
      the collection, whereas clients of a root collection only know that they
      can’t<br>
      change the collection themselves. Even though the static type of such a<br>
      collection provides no operations for modifying the collection, it might
      still<br>
      be possible that the run-time type is a mutable collection that can be
      changed<br>
      by other clients.<br>
      By default, Scala always picks immutable collections. For instance, if<br>
      you just write Set without any prefix or without having imported anything,<br>
      you get an immutable set, and if you write Iterable you get an immutable<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      534Section 24.2<br>
      Chapter 24 · The Scala Collections API<br>
      iterable, because these are the default bindings imported from the scala<br>
      package. To get the mutable default versions, you need to write explicitly<br>
      collection.mutable.Set , or collection.mutable.Iterable .<br>
      The last package in the collection hierarchy is collection.generic .<br>
      This package contains building blocks for implementing collections. Typ-<br>
      ically, collection classes defer the implementations of some of their
      opera-<br>
      tions to classes in generic . Everyday users of the collection framework
      on<br>
      the other hand should need to refer to classes in generic only in
      exceptional<br>
      circumstances.<br>
      24.2<br>
      Collections consistency<br>
      The most important collection classes are shown in Figure 24.1. There is<br>
      quite a bit of commonality shared by all these classes. For instance,
      every<br>
      kind of collection can be created by the same uniform syntax, writing the<br>
      collection class name followed by its elements:<br>
      Traversable(1, 2, 3)<br>
      Iterable("x", "y", "z")<br>
      Map("x" -&gt; 24, "y" -&gt; 25, "z" -&gt; 26)<br>
      Set(Color.Red, Color.Green, Color.Blue)<br>
      SortedSet("hello", "world")<br>
      Buffer(x, y, z)<br>
      IndexedSeq(1.0, 2.0)<br>
      LinearSeq(a, b, c)<br>
      The same principle also applies for specific collection implementations:<br>
      List(1, 2, 3)<br>
      HashMap("x" -&gt; 24, "y" -&gt; 25, "z" -&gt; 26)<br>
      The toString methods for all collections produce output written as above,<br>
      with a type name followed by the elements of the collection in
      parentheses.<br>
      All collections support the API provided by Traversable , but their meth-<br>
      ods all return their own class rather than the root class Traversable .
      For<br>
      instance, the map method on List has a return type of List , whereas the
      map<br>
      method on Set has a return type of Set . Thus the static return type of
      these<br>
      methods is fairly precise:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      535Section 24.2<br>
      Chapter 24 · The Scala Collections API<br>
      Traversable<br>
      Iterable<br>
      Seq<br>
      IndexedSeq<br>
      Vector<br>
      ResizableArray<br>
      GenericArray<br>
      LinearSeq<br>
      MutableList<br>
      List<br>
      Stream<br>
      Buffer<br>
      ListBuffer<br>
      ArrayBuffer<br>
      Set<br>
      SortedSet<br>
      TreeSet<br>
      HashSet (mutable)<br>
      LinkedHashSet<br>
      HashSet (immutable)<br>
      BitSet<br>
      EmptySet, Set1, Set2, Set3, Set4<br>
      Map<br>
      SortedMap<br>
      TreeMap<br>
      HashMap (mutable)<br>
      LinkedHashMap (mutable)<br>
      HashMap (immutable)<br>
      EmptyMap, Map1, Map2, Map3, Map4<br>
      Figure 24.1 · Collection hierarchy.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      536Section 24.3<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; List(1, 2, 3) map (_ + 1)<br>
      res0: List[Int] = List(2, 3, 4)<br>
      scala&gt; Set(1, 2, 3) map (_ * 2)<br>
      res1: scala.collection.immutable.Set[Int] = Set(2, 4, 6)<br>
      Equality is also organized uniformly for all collection classes; more on
      this<br>
      in Section 24.14.<br>
      Most of the classes in Figure 24.1 exist in three variants: root, mutable,<br>
      and immutable. The only exception is the Buffer trait, which only exists
      as<br>
      a mutable collection.<br>
      In the remainder of this chapter, we will review these classes one by one.<br>
      24.3<br>
      Trait Traversable<br>
      At the top of the collection hierarchy is trait Traversable . Its only
      abstract<br>
      operation is foreach :<br>
      def foreach[U](f: Elem =&gt; U)<br>
      Collection classes implementing Traversable just need to define this<br>
      method; all other methods can be inherited from Traversable .<br>
      The foreach method is meant to traverse all elements of the collection,<br>
      and apply the given operation, f , to each element. The type of the
      operation<br>
      is Elem =&gt; U , where Elem is the type of the collection’s elements and
      U is an<br>
      arbitrary result type. The invocation of f is done for its side effect
      only; in<br>
      fact any function result of f is discarded by foreach .<br>
      Traversable also defines many concrete methods, which are all listed<br>
      in Table 24.1 on page 539. These methods fall into the following
      categories:<br>
      Addition ++ , which appends two traversables together, or appends all ele-<br>
      ments of an iterator to a traversable.<br>
      Map operations map , flatMap , and collect , which produce a new collec-<br>
      tion by applying some function to collection elements.<br>
      Conversions toIndexedSeq , toIterable , toStream , toArray , toList ,<br>
      toSeq , toSet , and toMap , which turn a Traversable collection into a<br>
      more specific collection. All these conversions return the receiver ob-<br>
      ject if it already matches the demanded collection type. For instance,<br>
      applying toList to a list will yield the list itself.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      537Section 24.3<br>
      Chapter 24 · The Scala Collections API<br>
      Copying operations copyToBuffer and copyToArray . As their names im-<br>
      ply, these copy collection elements to a buffer or array, respectively.<br>
      Size operations isEmpty , nonEmpty , size , and hasDefiniteSize . Col-<br>
      lections that are traversable can be finite or infinite. An example<br>
      of an infinite traversable collection is the stream of natural numbers<br>
      Stream.from(0) . The method hasDefiniteSize indicates whether<br>
      a collection is possibly infinite. If hasDefiniteSize returns true, the<br>
      collection is certainly finite. If it returns false, the collection might
      be<br>
      infinite, in which case size will emit an error or not return.<br>
      Element retrieval operations head , last , headOption , lastOption , and<br>
      find . These select the first or last element of a collection, or else the<br>
      first element matching a condition. Note, however, that not all collec-<br>
      tions have a well-defined meaning of what “first” and “last” means.<br>
      For instance, a hash set might store elements according to their hash<br>
      keys, which might change from run to run. In that case, the “first”<br>
      element of a hash set could also be different for different runs of a<br>
      program. A collection is ordered if it always yields its elements in the<br>
      same order. Most collections are ordered, but some (such as hash sets)<br>
      are not—dropping the ordering provides a little bit of extra efficiency.<br>
      Ordering is often essential to give reproducible tests and help in de-<br>
      bugging. That’s why Scala collections provide ordered alternatives for<br>
      all collection types. For instance, the ordered alternative for HashSet<br>
      is LinkedHashSet .<br>
      Subcollection retrieval operations takeWhile , tail , init , slice , take
      ,<br>
      drop , filter , dropWhile , filterNot , and withFilter . These all<br>
      return some subcollection identified by an index range or a predicate.<br>
      Subdivision operations splitAt , span , partition , and groupBy , which<br>
      split the elements of this collection into several subcollections.<br>
      Element tests exists , forall , and count , which test collection elements<br>
      with a given predicate.<br>
      Folds foldLeft , foldRight , /: , :\ , reduceLeft , reduceRight , which<br>
      apply a binary operation to successive elements.<br>
      Specific folds sum , product , min , and max , which work on collections
      of<br>
      specific types (numeric or comparable).<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      538Section 24.3<br>
      Chapter 24 · The Scala Collections API<br>
      String operations mkString , addString , and stringPrefix , which pro-<br>
      vide alternative ways of converting a collection to a string.<br>
      View operations consisting of two overloaded variants of the view method.<br>
      A view is a collection that’s evaluated lazily. You’ll learn more about<br>
      views in Section 24.15.<br>
      Table 24.1 · Operations in trait Traversable<br>
      What it is<br>
      What it does<br>
      Abstract method:<br>
      xs foreach f<br>
      Executes function f for every element of xs .<br>
      Addition:<br>
      xs ++ ys A collection consisting of the elements of both xs<br>
      and ys . ys is a TraversableOnce collection, i.e.,<br>
      either a Traversable or an Iterator .<br>
      xs map f The collection obtained from applying the<br>
      function f to every element in xs .<br>
      Maps:<br>
      xs flatMap f The collection obtained from applying the<br>
      collection-valued function f to every element in<br>
      xs and concatenating the results.<br>
      xs collect f The collection obtained from applying the partial<br>
      function f to every element in xs for which it is<br>
      defined and collecting the results.<br>
      Conversions:<br>
      xs.toArray<br>
      xs.toList<br>
      Converts the collection to an array.<br>
      Converts the collection to a list.<br>
      xs.toIterable Converts the collection to an iterable.<br>
      xs.toSeq Converts the collection to a sequence.<br>
      xs.toIndexedSeq<br>
      xs.toStream<br>
      Converts the collection to an indexed sequence.<br>
      Converts the collection to a stream (a lazily<br>
      computed sequence).<br>
      xs.toSet Converts the collection to a set.<br>
      xs.toMap Converts a collection of key/value pairs to a map.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      539Section 24.3<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.1 · continued<br>
      Copying:<br>
      xs copyToBuffer buf<br>
      xs copyToArray(arr, s, len)<br>
      Copies all elements of the collection to buffer<br>
      buf .<br>
      Copies at most len elements of arr , starting at<br>
      index s . The last two arguments are optional.<br>
      Size info:<br>
      xs.isEmpty<br>
      xs.nonEmpty<br>
      xs.size<br>
      xs.hasDefiniteSize<br>
      Tests whether the collection is empty.<br>
      Tests whether the collection contains elements.<br>
      The number of elements in the collection.<br>
      True if xs is known to have finite size.<br>
      Element retrieval:<br>
      xs.head<br>
      xs.headOption<br>
      The first element of the collection (or, some<br>
      element, if no order is defined).<br>
      The first element of xs in an option value, or<br>
      None if xs is empty.<br>
      xs.last<br>
      xs.lastOption<br>
      xs find p<br>
      The last element of the collection (or, some<br>
      element, if no order is defined).<br>
      The last element of xs in an option value, or None<br>
      if xs is empty.<br>
      An option containing the first element in xs that<br>
      satisfies p , or None if no element qualifies.<br>
      Subcollections:<br>
      xs.tail The rest of the collection except xs.head .<br>
      xs.init The rest of the collection except xs.last .<br>
      xs slice (from, to)<br>
      A collection consisting of elements in some index<br>
      range of xs (from from , up to and excluding to ).<br>
      xs take n A collection consisting of the first n elements of<br>
      xs (or, some arbitrary n elements, if no order is<br>
      defined).<br>
      xs drop n The rest of the collection except xs take n .<br>
      xs takeWhile p The longest prefix of elements in the collection<br>
      that all satisfy p .<br>
      xs dropWhile p The collection without the longest prefix of<br>
      elements that all satisfy p .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      540Section 24.3<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.1 · continued<br>
      xs filter p The collection consisting of those elements of xs<br>
      that satisfy the predicate p .<br>
      xs withFilter p A non-strict filter of this collection. All<br>
      operations on the resulting filter will only apply<br>
      to those elements of xs for which the condition p<br>
      is true.<br>
      xs filterNot p The collection consisting of those elements of xs<br>
      that do not satisfy the predicate p .<br>
      Subdivisions:<br>
      xs splitAt n<br>
      xs span p<br>
      xs partition p<br>
      xs groupBy f<br>
      Splits xs at a position, giving the pair of<br>
      collections (xs take n, xs drop n) .<br>
      Splits xs according to a predicate, giving the pair<br>
      of collections (xs takeWhile p,<br>
      xs.dropWhile p) .<br>
      Splits xs into a pair of collections; one with<br>
      elements that satisfy the predicate p , the other<br>
      with elements that do not, giving the pair of<br>
      collections (xs filter p, xs.filterNot p) .<br>
      Partitions xs into a map of collections according<br>
      to a discriminator function f .<br>
      Element conditions:<br>
      xs forall p A boolean indicating whether the predicate p<br>
      holds for all elements of xs .<br>
      xs exists p A boolean indicating whether the predicate p<br>
      holds for some element in xs .<br>
      xs count p The number of elements in xs that satisfy the<br>
      predicate p .<br>
      Folds:<br>
      (z /: xs)(op) Applies binary operation op between successive<br>
      elements of xs , going left to right, starting with z .<br>
      (xs :\ z)(op) Applies binary operation op between successive<br>
      elements of xs , going right to left, starting with z .<br>
      xs.foldLeft(z)(op) Same as (z /: xs)(op) .<br>
      xs.foldRight(z)(op) Same as (xs :\ z)(op) .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      541Section 24.4<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.1 · continued<br>
      xs reduceLeft op Applies binary operation op between successive<br>
      elements of non-empty collection xs , going left<br>
      to right.<br>
      xs reduceRight op Applies binary operation op between successive<br>
      elements of non-empty collection xs , going right<br>
      to left.<br>
      Specific folds:<br>
      xs.sum<br>
      xs.product<br>
      The sum of the numeric element values of<br>
      collection xs .<br>
      The product of the numeric element values of<br>
      collection xs .<br>
      xs.min The minimum of the ordered element values of<br>
      collection xs .<br>
      xs.max The maximum of the ordered element values of<br>
      collection xs .<br>
      Strings:<br>
      xs addString (b, start,<br>
      sep, end) Adds a string to StringBuilder b that shows all<br>
      elements of xs between separators sep enclosed<br>
      in strings start and end . start , sep , and end<br>
      are all optional.<br>
      xs mkString (start,<br>
      sep, end) Converts the collection to a string that shows all<br>
      elements of xs between separators sep enclosed<br>
      in strings start and end . start , sep , and end<br>
      are all optional.<br>
      xs.stringPrefix<br>
      The collection name at the beginning of the string<br>
      returned from xs.toString .<br>
      Views:<br>
      xs.view<br>
      xs view (from, to)<br>
      24.4<br>
      Produces a view over xs .<br>
      Produces a view that represents the elements in<br>
      some index range of xs .<br>
      Trait Iterable<br>
      The next trait from the top in Figure 24.1 is Iterable . All methods in<br>
      this trait are defined in terms of an an abstract method, iterator , which<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      542Section 24.4<br>
      Chapter 24 · The Scala Collections API<br>
      yields the collection’s elements one by one. The foreach method from trait<br>
      Traversable is implemented in Iterable in terms of iterator . Here is<br>
      the actual implementation:<br>
      def foreach[U](f: Elem =&gt; U): Unit = {<br>
      val it = iterator<br>
      while (it.hasNext) f(it.next())<br>
      }<br>
      Quite a few subclasses of Iterable override this standard implementation<br>
      of foreach in Iterable , because they can provide a more efficient imple-<br>
      mentation. Remember that foreach is the basis of the implementation of all<br>
      operations in Traversable , so its performance matters.<br>
      Two more methods exist in Iterable that return iterators: grouped and<br>
      sliding . These iterators, however, do not return single elements but
      whole<br>
      subsequences of elements of the original collection. The maximal size of<br>
      these subsequences is given as an argument to these methods. The grouped<br>
      method chunks its elements into increments, whereas sliding yields a slid-<br>
      ing window over the elements. The difference between the two should be-<br>
      come clear by looking at the following interpreter interaction:<br>
      scala&gt; val xs = List(1, 2, 3, 4, 5)<br>
      xs: List[Int] = List(1, 2, 3, 4, 5)<br>
      scala&gt; val git = xs grouped 3<br>
      git: Iterator[List[Int]] = non-empty iterator<br>
      scala&gt; git.next()<br>
      res2: List[Int] = List(1, 2, 3)<br>
      scala&gt; git.next()<br>
      res3: List[Int] = List(4, 5)<br>
      scala&gt; val sit = xs sliding 3<br>
      sit: Iterator[List[Int]] = non-empty iterator<br>
      scala&gt; sit.next()<br>
      res4: List[Int] = List(1, 2, 3)<br>
      scala&gt; sit.next()<br>
      res5: List[Int] = List(2, 3, 4)<br>
      scala&gt; sit.next()<br>
      res6: List[Int] = List(3, 4, 5)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      543Section 24.4<br>
      Chapter 24 · The Scala Collections API<br>
      Trait Iterable also adds some other methods to Traversable that can be<br>
      implemented efficiently only if an iterator is available. They are
      summarized<br>
      in Table 24.2:<br>
      Table 24.2 · Operations in trait Iterable<br>
      What it is<br>
      What it does<br>
      Abstract method:<br>
      xs.iterator<br>
      An iterator that yields every element in xs , in the<br>
      same order as foreach traverses elements<br>
      Other iterators:<br>
      xs grouped size An iterator that yields fixed-sized “chunks” of<br>
      this collection<br>
      xs sliding size An iterator that yields a sliding fixed-sized<br>
      window of elements in this collection<br>
      Subcollections:<br>
      xs takeRight n A collection consisting of the last n elements of<br>
      xs (or, some arbitrary n elements, if no order is<br>
      defined)<br>
      xs dropRight n The rest of the collection except xs takeRight n<br>
      Zippers:<br>
      xs zip ys An iterable of pairs of corresponding elements<br>
      from xs and ys<br>
      xs zipAll (ys, x, y) An iterable of pairs of corresponding elements<br>
      from xs and ys , where the shorter sequence is<br>
      extended to match the longer one by appending<br>
      elements x or y<br>
      xs.zipWithIndex<br>
      An iterable of pairs of elements from xs with<br>
      their indicies<br>
      Comparison:<br>
      xs sameElements ys<br>
      Tests whether xs and ys contain the same<br>
      elements in the same order<br>
      Why have both Traversable and Iterable ?<br>
      You might wonder why the extra trait Traversable is above Iterable .<br>
      Can we not do everything with an iterator ? So what’s the point of having<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      544Section 24.4<br>
      Chapter 24 · The Scala Collections API<br>
      a more abstract trait that defines its methods in terms of foreach instead<br>
      of iterator ? One reason for having Traversable is that sometimes it is<br>
      easier or more efficient to provide an implementation of foreach than to<br>
      provide an implementation of iterator . Here’s a simple example. Let’s<br>
      say you want a class hierarchy for binary trees that have integer elements
      at<br>
      the leaves. You might design this hierarchy like this:<br>
      sealed abstract class Tree<br>
      case class Branch(left: Tree, right: Tree) extends Tree<br>
      case class Node(elem: Int) extends Tree<br>
      Now assume you want to make trees traversable. To do this, have Tree<br>
      inherit from Traversable[Int] and define a foreach method like this:<br>
      sealed abstract class Tree extends Traversable[Int] {<br>
      def foreach[U](f: Int =&gt; U) = this match {<br>
      case Node(elem) =&gt; f(elem)<br>
      case Branch(l, r) =&gt; l foreach f; r foreach f<br>
      }<br>
      }<br>
      That’s not too hard, and it is also very efficient—traversing a balanced
      tree<br>
      takes time proportional to the number of elements in the tree. To see
      this,<br>
      consider that for a balanced tree with N leaves you will have N - 1
      interior<br>
      nodes of class Branch . So the total number of steps to traverse the tree
      is<br>
      N + N - 1 .<br>
      Now, compare this with making trees iterable. To do this, have Tree<br>
      inherit from Iterable[Int] and define an iterator method like this:<br>
      sealed abstract class Tree extends Iterable[Int] {<br>
      def iterator: Iterator[Int] = this match {<br>
      case Node(elem) =&gt; Iterator.single(elem)<br>
      case Branch(l, r) =&gt; l.iterator ++ r.iterator<br>
      }<br>
      }<br>
      At first glance, this looks no harder than the foreach solution. However,<br>
      there’s an efficiency problem that has to do with the implementation of
      the<br>
      iterator concatenation method, ++ . Every time an element is produced by a<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      545Section 24.5<br>
      Chapter 24 · The Scala Collections API<br>
      concatenated iterator such as l.iterator ++ r.iterator , the computation<br>
      needs to follow one indirection to get at the right iterator (either
      l.iterator ,<br>
      or r.iterator ). Overall, that makes log(N) indirections to get at a leaf
      of<br>
      a balanced tree with N leaves. So the cost of visiting all elements of a
      tree<br>
      went up from about 2N for the foreach traversal method to N log (N) for
      the<br>
      traversal with iterator . If the tree has a million elements that means
      about<br>
      two million steps for foreach and about twenty million steps for iterator
      .<br>
      So the foreach solution has a clear advantage.<br>
      Subcategories of Iterable<br>
      In the inheritance hierarchy below Iterable you find three traits: Seq ,
      Set ,<br>
      and Map . A common aspect of these three traits is that they all implement
      the<br>
      PartialFunction trait 1 with its apply and isDefinedAt methods. How-<br>
      ever, the way each trait implements PartialFunction differs.<br>
      For sequences, apply is positional indexing, where elements are always<br>
      numbered from 0 . That is, Seq(1, 2, 3)(1) == 2 . For sets, apply is a<br>
      membership test. For instance, Set('a', 'b', 'c')('b') == true whereas<br>
      Set()('a') == false . Finally for maps, apply is a selection. For
      instance,<br>
      Map('a' -&gt; 1, 'b' -&gt; 10, 'c' -&gt; 100)('b') == 10 .<br>
      In the following three sections, we will explain each of the three kinds
      of<br>
      collections in more detail.<br>
      24.5<br>
      The sequence traits Seq , IndexedSeq , and<br>
      LinearSeq<br>
      The Seq trait represents sequences. A sequence is a kind of iterable that
      has<br>
      a length and whose elements have fixed index positions, starting from 0 .<br>
      The operations on sequences, summarized in Figure 24.3, fall into the<br>
      following categories:<br>
      Indexing and length operations apply , isDefinedAt , length , indices ,<br>
      and lengthCompare . For a Seq , the apply operation means index-<br>
      ing; hence a sequence of type Seq[T] is a partial function that takes<br>
      an Int argument (an index) and yields a sequence element of type T .<br>
      1 Partial<br>
      functions were described in Section 15.7.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      546Section 24.5<br>
      Chapter 24 · The Scala Collections API<br>
      In other words Seq[T] extends PartialFunction[Int, T] . The el-<br>
      ements of a sequence are indexed from zero up to the length of the<br>
      sequence minus one. The length method on sequences is an alias of<br>
      the size method of general collections. The lengthCompare method<br>
      allows you to compare the lengths of two sequences even if one of the<br>
      sequences has infinite length.<br>
      Index search operations indexOf , lastIndexOf , indexOfSlice , lastIn -<br>
      dexOfSlice , indexWhere , lastIndexWhere , segmentLength , and<br>
      prefixLength , which return the index of an element equal to a given<br>
      value or matching some predicate.<br>
      Addition operations +: , :+ , and padTo , which return new sequences ob-<br>
      tained by adding elements at the front or the end of a sequence.<br>
      Update operations updated and patch , which return a new sequence ob-<br>
      tained by replacing some elements of the original sequence.<br>
      Sorting operations sorted , sortWith , and sortBy , which sort sequence<br>
      elements according to various criteria.<br>
      Reversal operations reverse , reverseIterator , and reverseMap , which<br>
      yield or process sequence elements in reverse order, from last to first.<br>
      Comparison operations startsWith , endsWith , contains , corresponds ,<br>
      and containsSlice , which relate two sequences or search an element<br>
      in a sequence.<br>
      Multiset operations intersect , diff , union , and distinct , which per-<br>
      form set-like operations on the elements of two sequences or remove<br>
      duplicates.<br>
      If a sequence is mutable, it offers in addition a side-effecting update
      method,<br>
      which lets sequence elements be updated. Recall from Chapter 3 that syntax<br>
      like seq(idx) = elem is just a shorthand for seq.update(idx, elem) . Note<br>
      the difference between update and updated . The update method changes<br>
      a sequence element in place, and is only available for mutable sequences.<br>
      The updated method is available for all sequences and always returns a new<br>
      sequence instead of modifying the original.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      547Section 24.5<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.3 · Operations in trait Seq<br>
      What it is<br>
      What it does<br>
      Indexing and length:<br>
      xs(i)<br>
      xs isDefinedAt i<br>
      xs.length<br>
      xs.lengthCompare ys<br>
      xs.indices<br>
      (or, written out, xs apply i ) The element of xs at<br>
      index i .<br>
      Tests whether i is contained in xs.indices .<br>
      The length of the sequence (same as size ).<br>
      Returns -1 if xs is shorter than ys , +1 if it is<br>
      longer, and 0 is they have the same length. Works<br>
      even if one if the sequences is infinite.<br>
      The index range of xs , extending from 0 to<br>
      xs.length - 1 .<br>
      Index search:<br>
      xs indexOf x The index of the first element in xs equal to x<br>
      (several variants exist).<br>
      xs lastIndexOf x The index of the last element in xs equal to x<br>
      (several variants exist).<br>
      xs indexOfSlice ys<br>
      The first index of xs such that successive<br>
      elements starting from that index form the<br>
      sequence ys .<br>
      xs lastIndexOfSlice ys The last index of xs such that successive elements<br>
      starting from that index form the sequence ys .<br>
      xs indexWhere p The index of the first element in xs that satisfies p<br>
      (several variants exist).<br>
      xs segmentLength (p, i)<br>
      xs prefixLength p<br>
      The length of the longest uninterrupted segment<br>
      of elements in xs , starting with xs(i) , that all<br>
      satisfy the predicate p .<br>
      The length of the longest prefix of elements in xs<br>
      that all satisfy the predicate p .<br>
      Additions:<br>
      x +: xs A new sequence consisting of x prepended to xs .<br>
      xs :+ x A new sequence that consists of x append to xs .<br>
      xs padTo (len, x) The sequence resulting from appending the value<br>
      x to xs until length len is reached.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      548Section 24.5<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.3 · continued<br>
      Updates:<br>
      xs patch (i, ys, r) The sequence resulting from replacing r elements<br>
      of xs starting with i by the patch ys .<br>
      xs updated (i, x) A copy of xs with the element at index i replaced<br>
      by x .<br>
      xs(i) = x (or, written out, xs.update(i, x) , only available<br>
      for mutable.Seq s) Changes the element of xs at<br>
      index i to y .<br>
      xs.sorted A new sequence obtained by sorting the elements<br>
      of xs using the standard ordering of the element<br>
      type of xs .<br>
      xs sortWith lessThan A new sequence obtained by sorting the elements<br>
      of xs , using lessThan as comparison operation.<br>
      xs sortBy f A new sequence obtained by sorting the elements<br>
      of xs . Comparison between two elements<br>
      proceeds by mapping the function f over both<br>
      and comparing the results.<br>
      Sorting:<br>
      Reversals:<br>
      xs.reverse<br>
      A sequence with the elements of xs in reverse<br>
      order.<br>
      xs.reverseIterator An iterator yielding all the elements of xs in<br>
      reverse order.<br>
      xs reverseMap f A sequence obtained by mapping f over the<br>
      elements of xs in reverse order.<br>
      Comparisons:<br>
      xs startsWith ys Tests whether xs starts with sequence ys (several<br>
      variants exist).<br>
      xs endsWith ys Tests whether xs ends with sequence ys (several<br>
      variants exist).<br>
      xs contains x Tests whether xs has an element equal to x .<br>
      xs containsSlice ys<br>
      (xs corresponds ys)(p)<br>
      Tests whether xs has a contiguous subsequence<br>
      equal to ys .<br>
      Tests whether corresponding elements of xs and<br>
      ys satisfy the binary predicate p .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      549Section 24.5<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.3 · continued<br>
      Multiset operations:<br>
      xs intersect ys<br>
      The multi-set intersection of sequences xs and ys<br>
      that preserves the order of elements in xs .<br>
      xs diff ys The multi-set difference of sequences xs and ys<br>
      that preserves the order of elements in xs .<br>
      xs union ys Multiset union; same as xs ++ ys .<br>
      xs.distinct<br>
      A subsequence of xs that contains no duplicated<br>
      element.<br>
      Each Seq trait has two subtraits, LinearSeq and IndexedSeq . These do<br>
      not add any new operations, but each offers different performance charac-<br>
      teristics. A linear sequence has efficient head and tail operations,
      whereas<br>
      an indexed sequence has efficient apply , length , and (if mutable) update<br>
      operations. List is a frequently used linear sequence, as is Stream . Two
      fre-<br>
      quently used indexed sequences are Array and ArrayBuffer . The Vector<br>
      class provides an interesting compromise between indexed and linear
      access.<br>
      It has both effectively constant time indexing overhead and constant time
      lin-<br>
      ear access overhead. Because if this, vectors are a good foundation for
      mixed<br>
      access patterns where both indexed and linear accesses are used. More on<br>
      vectors in Section 24.9.<br>
      Buffers<br>
      An important sub-category of mutable sequences is buffers. Buffers allow<br>
      not only updates of existing elements but also element insertions, element<br>
      removals, and efficient additions of new elements at the end of the
      buffer.<br>
      The principal new methods supported by a buffer are += and ++= , for
      element<br>
      addition at the end, +=: and ++=: for addition at the front, insert and<br>
      insertAll for element insertions, as well as remove and -= for element<br>
      removal. These operations are summarized in Table 24.4.<br>
      Two Buffer implementations that are commonly used are ListBuffer<br>
      and ArrayBuffer . As the name implies, a ListBuffer is backed by a<br>
      List and supports efficient conversion of its elements to a List , whereas
      an<br>
      ArrayBuffer is backed by an array, and can be quickly converted into one.<br>
      You saw a glimpse of the implementation of ListBuffer in Section 22.2.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      550Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.4 · Operations in trait Buffer<br>
      What it is<br>
      What it does<br>
      Additions:<br>
      buf += x<br>
      buf += (x, y, z)<br>
      buf ++= xs<br>
      x +=: buf<br>
      Appends element x to buffer buf , and returns buf<br>
      itself as result<br>
      Appends given elements to buffer<br>
      Appends all elements in xs to buffer<br>
      Prepends element x to buffer<br>
      xs ++=: buf Prepends all elements in xs to buffer<br>
      buf insert (i, x) Inserts element x at index i in buffer<br>
      buf insertAll (i, xs)<br>
      Inserts all elements in xs at index i in buffer<br>
      Removals:<br>
      buf -= x<br>
      buf remove i<br>
      buf remove (i, n)<br>
      Removes element x from buffer<br>
      Removes element at index i from buffer<br>
      Removes n elements starting at index i from<br>
      buffer<br>
      buf trimStart n Removes first n elements from buffer<br>
      buf trimEnd n Removes last n elements from buffer<br>
      buf.clear() Removes all elements from buffer<br>
      Cloning:<br>
      buf.clone<br>
      24.6<br>
      A new buffer with the same elements as buf<br>
      Sets<br>
      Set s are Iterable s that contain no duplicate elements. The operations on<br>
      sets are summarized in Table 24.5 for general sets and Table 24.6 for
      mutable<br>
      sets. They fall into the following categories:<br>
      Tests contains , apply , and subsetOf . The contains method indicates<br>
      whether a set contains a given element. The apply method for a set<br>
      is the same as contains , so set(elem) is the same as set contains<br>
      elem . That means sets can also be used as test functions that return<br>
      true for the elements they contain. For example:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      551Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; val fruit = Set("apple", "orange", "peach", "banana")<br>
      fruit: scala.collection.immutable.Set[java.lang.String] =<br>
      Set(apple, orange, peach, banana)<br>
      scala&gt; fruit("peach")<br>
      res7: Boolean = true<br>
      scala&gt; fruit("potato")<br>
      res8: Boolean = false<br>
      Additions + and ++ , which add one or more elements to a set, yielding a
      new<br>
      set as a result.<br>
      Removals - and -- , which remove one or more elements from a set, yielding<br>
      a new set.<br>
      Set operations for union, intersection, and set difference. These set
      oper-<br>
      ations exist in two forms: alphabetic and symbolic. The alphabetic<br>
      versions are intersect , union , and diff , whereas the symbolic ver-<br>
      sions are &amp; , | , and &amp; ~ . The ++ that Set inherits from
      Traversable<br>
      can be seen as yet another alias of union or | , except that ++ takes a<br>
      Traversable argument whereas union and | take sets.<br>
      Table 24.5 · Operations in trait Set<br>
      What it is<br>
      What it does<br>
      Tests:<br>
      xs contains x<br>
      xs(x)<br>
      xs subsetOf ys<br>
      Tests whether x is an element of xs<br>
      Same as xs contains x<br>
      Tests whether xs is a subset of ys<br>
      Additions:<br>
      xs + x<br>
      The set containing all elements of xs as well as x<br>
      xs + (x, y, z) The set containing all elements of xs as well as<br>
      the given additional elements<br>
      xs ++ ys The set containing all elements of xs as well as<br>
      all elements of ys<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      552Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.5 · continued<br>
      Removals:<br>
      xs - x<br>
      The set containing all elements of xs except x<br>
      xs - (x, y, z) The set containing all elements of xs except the<br>
      given elements<br>
      xs -- ys The set containing all elements of xs except the<br>
      elements of ys<br>
      xs.empty<br>
      An empty set of the same class as xs<br>
      Binary operations:<br>
      xs &amp; ys<br>
      xs intersect ys<br>
      xs | ys<br>
      xs union ys<br>
      xs &amp; ~ ys<br>
      xs diff ys<br>
      The set intersection of xs and ys<br>
      Same as xs &amp; ys<br>
      The set union of xs and ys<br>
      Same as xs | ys<br>
      The set difference of xs and ys<br>
      Same as xs &amp; ~ ys<br>
      Mutable sets have methods that add, remove, or update elements, which<br>
      are summarized in Table 24.6:<br>
      Table 24.6 · Operations in trait mutable.Set<br>
      What it is<br>
      What it does<br>
      Additions:<br>
      xs += x<br>
      Adds element x to set xs as a side effect and<br>
      returns xs itself<br>
      xs += (x, y, z) Adds the given elements to set xs as a side effect<br>
      and returns xs itself<br>
      xs ++= ys Adds all elements in ys to set xs as a side effect<br>
      and returns xs itself<br>
      xs add x Adds element x to xs and returns true if x was<br>
      not previously contained in the set, false if it<br>
      was previously contained<br>
      xs -= x Removes element x from set xs as a side effect<br>
      and returns xs itself<br>
      Removals:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      553Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.6 · continued<br>
      xs -= (x, y, z) Removes the given elements from set xs as a side<br>
      effect and returns xs itself<br>
      xs --= ys Removes all elements in ys from set xs as a side<br>
      effect and returns xs itself<br>
      xs remove x Removes element x from xs and returns true if x<br>
      was previously contained in the set, false if it<br>
      was not previously contained<br>
      xs retain p Keeps only those elements in xs that satisfy<br>
      predicate p<br>
      xs.clear() Removes all elements from xs<br>
      Update:<br>
      xs(x) = b (or, written out, xs.update(x, b) ) If boolean<br>
      argument b is true , adds x to xs , otherwise<br>
      removes x from xs<br>
      xs.clone A new mutable set with the same elements as xs<br>
      Cloning:<br>
      Just like an immutable set, a mutable set offers the + and ++ operations<br>
      for element additions and the - and -- operations for element removals.
      But<br>
      these are less often used for mutable sets since they involve copying the
      set.<br>
      As a more efficient alternative, mutable sets offer the update methods +=
      and<br>
      -= . The operation s += elem adds elem to the set s as a side effect, and<br>
      returns the mutated set as a result. Likewise, s -= elem removes elem from<br>
      the set, and returns the mutated set as a result. Besides += and -= there
      are<br>
      also the bulk operations ++= and --= , which add or remove all elements of
      a<br>
      traversable or an iterator.<br>
      The choice of the method names += and -= means that very similar code<br>
      can work with either mutable or immutable sets. Consider first the
      following<br>
      interpreter dialogue that uses an immutable set s :<br>
      scala&gt; var s = Set(1, 2, 3)<br>
      s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)<br>
      scala&gt; s += 4; s -= 2<br>
      scala&gt; s<br>
      res9: scala.collection.immutable.Set[Int] = Set(1, 3, 4)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      554Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      In this example, we used += and -= on a var of type immutable.Set . As<br>
      was explained in Step 10 in Chapter 3, a statement such as s += 4 is an<br>
      abbreviation for s = s + 4 . So this invokes the addition method + on the
      set s<br>
      and then assigns the result back to the s variable. Consider now an
      analogous<br>
      interaction with a mutable set:<br>
      scala&gt; val s = collection.mutable.Set(1, 2, 3)<br>
      s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)<br>
      scala&gt; s += 4<br>
      res10: s.type = Set(1, 4, 2, 3)<br>
      scala&gt; s -= 2<br>
      res11: s.type = Set(1, 4, 3)<br>
      The end effect is very similar to the previous interaction; we start with
      a<br>
      Set(1, 2, 3) and end up with a Set(1, 3, 4) . However, even though the<br>
      statements look the same as before, they do something different. The s +=
      4<br>
      statement now invokes the += method on the mutable set value s , changing<br>
      the set in place. Likewise, the s -= 2 statement now invokes the -= method<br>
      on the same set.<br>
      Comparing the two interactions shows an important principle. You often<br>
      can replace a mutable collection stored in a val by an immutable
      collection<br>
      stored in a var , and vice versa. This works at least as long as there are
      no<br>
      alias references to the collection through which you can observe whether
      it<br>
      was updated in place or a new collection was created.<br>
      Mutable sets also provide add and remove as variants of += and -= . The<br>
      difference is that add and remove return a boolean result indicating
      whether<br>
      the operation had an effect on the set.<br>
      The current default implementation of a mutable set uses a hash table<br>
      to store the set’s elements. The default implementation of an immutable
      set<br>
      uses a representation that adapts to the number of elements of the set. An<br>
      empty set is represented by just a singleton object. Sets of sizes up to
      four<br>
      are represented by a single object that stores all elements as fields.
      Beyond<br>
      that size, immutable sets are implemented as hash tries. 2<br>
      A consequence of these representation choices is that for sets of small<br>
      sizes, up to about four, immutable sets are more compact and more
      efficient<br>
      2 Hash<br>
      tries are described in Section 24.9.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      555Section 24.6<br>
      Chapter 24 · The Scala Collections API<br>
      than mutable sets. So if you expect the size of a set to be small, try to
      make<br>
      it immutable.<br>
      Two Set subtraits are SortedSet and BitSet . These are explained in<br>
      the following subsections.<br>
      Sorted sets<br>
      A SortedSet is a set where, no matter what order elements were added to<br>
      the set, the elements are traversed in sorted order. The default
      representation<br>
      of a SortedSet is an ordered binary tree maintaining the invariant that
      all<br>
      elements in the left subtree of a node are smaller than all elements in
      the right<br>
      subtree. That way, a simple in-order traversal can return all tree
      elements<br>
      in increasing order. Scala’s class immutable.TreeSet uses a red-black tree<br>
      implementation to maintain this ordering invariant, and at the same time
      keep<br>
      the tree balanced—meaning that all paths from the root of the tree to a
      leaf<br>
      have about the same length.<br>
      To create an empty tree set, you could first specify the desired ordering.<br>
      For example, here is an ordering that puts strings in reverse order:<br>
      scala&gt; val myOrdering = Ordering.fromLessThan[String](_ &gt; _)<br>
      myOrdering: scala.math.Ordering[String] = ...<br>
      Then, to create an empty tree set with that ordering, use:<br>
      scala&gt; import scala.collection.immutable.TreeSet<br>
      import scala.collection.immutable.TreeSet<br>
      scala&gt; TreeSet.empty(myOrdering)<br>
      res12: scala.collection.immutable.TreeSet[String] = TreeSet()<br>
      Or you can leave out the ordering argument but give an element type or the<br>
      empty set. In that case, the default ordering on the element type will be
      used:<br>
      scala&gt; val set = TreeSet.empty[String]<br>
      set: scala.collection.immutable.TreeSet[String] = TreeSet()<br>
      If you create new sets from a tree set (for instance by concatenation or
      filter-<br>
      ing), they will keep the same ordering as the original set. For example:<br>
      scala&gt; val numbers = set + ("one", "two", "three", "four")<br>
      numbers: scala.collection.immutable.TreeSet[String] =<br>
      TreeSet(four, one, three, two)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      556Section 24.7<br>
      Chapter 24 · The Scala Collections API<br>
      Sorted sets also support ranges of elements. For instance, the range
      method<br>
      returns all elements from a starting element up to, but excluding, an end<br>
      element. Or, the from method returns all elements greater than or equal to
      a<br>
      starting element in the set’s ordering. The result of calls to both
      methods is<br>
      again a sorted set. Here are some examples:<br>
      scala&gt; numbers range ("one", "two")<br>
      res13: scala.collection.immutable.TreeSet[String]<br>
      = TreeSet(one, three)<br>
      scala&gt; numbers from "three"<br>
      res14: scala.collection.immutable.TreeSet[String]<br>
      = TreeSet(three, two)<br>
      Bit sets<br>
      Bit sets are sets of non-negative integer elements that are implemented in
      one<br>
      or more words of packed bits. The internal representation of a bit set
      uses<br>
      an array of Long s. The first Long covers elements from 0 to 63, the
      second<br>
      from 64 to 127, and so on. 3 For every Long , each of its 64 bits is set
      to 1 if<br>
      the corresponding element is contained in the set, and is unset otherwise.
      It<br>
      follows that the size of a bit set depends on the largest integer that’s
      stored<br>
      in it. If N is that largest integer, then the size of the set is N/64 Long
      words,<br>
      or N/8 bytes, plus a small number of extra bytes for status information.<br>
      Bitsets are hence more compact than other sets if they contain many<br>
      small elements. Another advantage of bit sets is that operations such as<br>
      membership test with contains , or element addition and removal with +=<br>
      and -= , are all extremely efficient.<br>
      24.7<br>
      Maps<br>
      Map s are Iterable s of pairs of keys and values (also named mappings or
      as-<br>
      sociations). As explained in Section 21.4, Scala’s Predef class offers an
      im-<br>
      plicit conversion that lets you write key -&gt; value as an alternate
      syntax for<br>
      the pair (key, value) . Therefore, Map("x" -&gt; 24, "y" -&gt; 25, "z"
      -&gt; 26)<br>
      3 Immutable bit sets of elements in the range of 0 to 127 optimize the
      array away and<br>
      store the bits directly in a one or two Long fields.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      557Section 24.7<br>
      Chapter 24 · The Scala Collections API<br>
      means exactly the same as Map(("x", 24), ("y", 25), ("z", 26)) , but<br>
      reads better.<br>
      The fundamental operations on maps, summarized in Table 24.7, are<br>
      similar to those on sets. Mutable maps additionally support the operations<br>
      shown in Table 24.8. Map operations fall into the following categories:<br>
      Lookups apply , get , getOrElse , contains , and isDefinedAt . These op-<br>
      erations turn maps into partial functions from keys to values. The fun-<br>
      damental lookup method for a map is:<br>
      def get(key): Option[Value]<br>
      The operation “ m get key ” tests whether the map contains an associa-<br>
      tion for the given key . If so, it returns the associated value in a Some
      .<br>
      If no key is defined in the map, get returns None . Maps also define<br>
      an apply method that returns the value associated with a given key<br>
      directly, without wrapping it in an Option . If the key is not defined in<br>
      the map, an exception is raised.<br>
      Additions and updates + , ++ , and updated , which let you add new
      bindings<br>
      to a map or change existing bindings.<br>
      Removals - and -- , which remove bindings from a map.<br>
      Subcollection producers keys , keySet , keysIterator , valuesIterator ,<br>
      and values , which return a map’s keys and values separately in vari-<br>
      ous forms.<br>
      Transformations filterKeys and mapValues , which produce a new map<br>
      by filtering and transforming bindings of an existing map.<br>
      Table 24.7 · Operations in trait Map<br>
      What it is<br>
      What it does<br>
      Lookups:<br>
      ms get k<br>
      ms(k)<br>
      The value associated with key k in map ms as an<br>
      option, or None if not found<br>
      (or, written out, ms apply k ) The value associated<br>
      with key k in map ms , or a thrown exception if not<br>
      found<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      558Section 24.7<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.7 · continued<br>
      ms getOrElse (k, d)<br>
      ms contains k<br>
      ms isDefinedAt k<br>
      The value associated with key k in map ms , or the<br>
      default value d if not found<br>
      Tests whether ms contains a mapping for key k<br>
      Same as contains<br>
      Additions and updates:<br>
      ms + (k -&gt; v) The map containing all mappings of ms as well as<br>
      the mapping k -&gt; v from key k to value v<br>
      ms + (k -&gt; v, l -&gt; w) The map containing all mappings of ms as well
      as<br>
      the given key/value pairs<br>
      ms ++ kvs The map containing all mappings of ms as well as<br>
      all key/value pairs of kvs<br>
      ms updated (k, v)<br>
      Same as ms + (k -&gt; v)<br>
      Removals:<br>
      ms - k The map containing all mappings of ms except for<br>
      any mapping of key k<br>
      ms - (k, l, m) The map containing all mappings of ms except for<br>
      any mapping with the given keys<br>
      ms -- ks The map containing all mappings of ms except for<br>
      any mapping with a key in ks<br>
      Subcollections:<br>
      ms.keys<br>
      ms.keySet<br>
      ms.keysIterator<br>
      An iterable containing each key in ms<br>
      A set containing each key in ms<br>
      An iterator yielding each key in ms<br>
      ms.values An iterable containing each value associated with<br>
      a key in ms<br>
      ms.valuesIterator An iterator yielding each value associated with a<br>
      key in ms<br>
      Transformation:<br>
      ms filterKeys p<br>
      ms mapValues f<br>
      A map view containing only those mappings in<br>
      ms where the key satisfies predicate p<br>
      A map view resulting from applying function f to<br>
      each value associated with a key in ms<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      559Section 24.7<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.8 · Operations in trait mutable.Map<br>
      What it is<br>
      What it does<br>
      Additions and updates:<br>
      ms(k) = v (or, written out, ms.update(k, v) ) Adds<br>
      mapping from key k to value v to map ms as a side<br>
      effect, overwriting any previous mapping of k<br>
      ms += (k -&gt; v) Adds mapping from key k to value v to map ms as<br>
      a side effect and returns ms itself<br>
      ms += (k -&gt; v, l -&gt; w) Adds the given mappings to ms as a side
      effect<br>
      and returns ms itself<br>
      ms ++= kvs Adds all mappings in kvs to ms as a side effect<br>
      and returns ms itself<br>
      ms put (k, v) Adds mapping from key k to value v to ms and<br>
      returns any value previously associated with k as<br>
      an option<br>
      ms getOrElseUpdate (k, d) If key k is defined in map ms , returns its<br>
      associated value. Otherwise, updates ms with the<br>
      mapping k -&gt; d and returns d<br>
      Removals:<br>
      ms -= k Removes mapping with key k from ms as a side<br>
      effect and returns ms itself<br>
      ms -= (k, l, m) Removes mappings with the given keys from ms<br>
      as a side effect and returns ms itself<br>
      ms --= ks Removes all keys in ks from ms as a side effect<br>
      and returns ms itself<br>
      ms remove k Removes any mapping with key k from ms and<br>
      returns any value previously associated with k as<br>
      an option<br>
      ms retain p Keeps only those mappings in ms that have a key<br>
      satisfying predicate p .<br>
      ms.clear() Removes all mappings from ms<br>
      Transformation and cloning:<br>
      ms transform f<br>
      ms.clone<br>
      Transforms all associated values in map ms with<br>
      function f<br>
      Returns a new mutable map with the same<br>
      mappings as ms<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      560Section 24.7<br>
      Chapter 24 · The Scala Collections API<br>
      The addition and removal operations for maps mirror those for sets. As<br>
      for sets, mutable maps also support the non-destructive addition
      operations<br>
      + , - , and updated , but they are used less frequently because they
      involve a<br>
      copying of the mutable map. Instead, a mutable map m is usually updated<br>
      “in place,” using the two variants m(key) = value or m += (key -&gt;
      value) .<br>
      There is also the variant m put (key, value) , which returns an Option
      value<br>
      that contains the value previously associated with key , or None if the
      key did<br>
      not exist in the map before.<br>
      The getOrElseUpdate is useful for accessing maps that act as caches.<br>
      Say you have an expensive computation triggered by invoking a function f :<br>
      scala&gt; def f(x: String) = {<br>
      println("taking my time."); Thread.sleep(100)<br>
      x.reverse }<br>
      f: (x: String)String<br>
      Assume further that f has no side-effects, so invoking it again with the
      same<br>
      argument will always yield the same result. In that case you could save
      time<br>
      by storing previously computed bindings of argument and results of f in a<br>
      map, and only computing the result of f if a result of an argument was not<br>
      found there. You could say the map is a cache for the computations of the<br>
      function f .<br>
      scala&gt; val cache = collection.mutable.Map[String, String]()<br>
      cache: scala.collection.mutable.Map[String,String] = Map()<br>
      You can now create a more efficient caching version of the f function:<br>
      scala&gt; def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))<br>
      cachedF: (s: String)String<br>
      scala&gt; cachedF("abc")<br>
      taking my time.<br>
      res15: String = cba<br>
      scala&gt; cachedF("abc")<br>
      res16: String = cba<br>
      Note that the second argument to getOrElseUpdate is “by-name,” so the<br>
      computation of f("abc") above is only performed if getOrElseUpdate<br>
      requires the value of its second argument, which is precisely if its first
      ar-<br>
      gument is not found in the cache map. You could also have implemented<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      561Section 24.8<br>
      Chapter 24 · The Scala Collections API<br>
      cachedF directly, using just basic map operations, but it would have have<br>
      taken more code to do so:<br>
      def cachedF(arg: String) = cache get arg match {<br>
      case Some(result) =&gt; result<br>
      case None =&gt;<br>
      val result = f(arg)<br>
      cache(arg) = result<br>
      result<br>
      }<br>
      24.8<br>
      Synchronized sets and maps<br>
      In Section 1.1, we mentioned that if you needed a thread-safe map, you<br>
      could mix the SynchronizedMap trait into whatever particular map imple-<br>
      mentation you desired. For example, you could mix SynchronizedMap into<br>
      HashMap , as shown in Listing 24.1. This example begins with an import of<br>
      two traits, Map and SynchronizedMap , and one class, HashMap , from pack-<br>
      age scala.collection.mutable . The rest of the example is the definition<br>
      of singleton object MapMaker , which declares one method, makeMap . The<br>
      makeMap method declares its result type to be a mutable map of string keys<br>
      to string values.<br>
      The first statement inside the body of makeMap constructs a new mutable<br>
      HashMap that mixes in the SynchronizedMap trait:<br>
      new HashMap[String, String] with<br>
      SynchronizedMap[String, String]<br>
      Given this code, the Scala compiler will generate a synthetic subclass of<br>
      HashMap that mixes in SynchronizedMap , and create (and return) an in-<br>
      stance of it. This synthetic class will also override a method named
      default ,<br>
      because of this code:<br>
      override def default(key: String) =<br>
      "Why do you want to know?"<br>
      If you ask a map to give you the value for a particular key, but it
      doesn’t have<br>
      a mapping for that key, you’ll by default get a NoSuchElementException .
      If<br>
      you define a new map class and override the default method, however, your<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      562Section 24.8<br>
      Chapter 24 · The Scala Collections API<br>
      import scala.collection.mutable.{Map,<br>
      SynchronizedMap, HashMap}<br>
      object MapMaker {<br>
      def makeMap: Map[String, String] = {<br>
      new HashMap[String, String] with<br>
      SynchronizedMap[String, String] {<br>
      override def default(key: String) =<br>
      "Why do you want to know?"<br>
      }<br>
      }<br>
      }<br>
      Listing 24.1 · Mixing in the SynchronizedMap trait.<br>
      new map will return the value returned by default when queried with a non-<br>
      existent key. Thus, the synthetic HashMap subclass generated by the
      compiler<br>
      from the code in Listing 24.1 will return the somewhat curt response
      string,<br>
      "Why do you want to know?" , when queried with a non-existent key.<br>
      Because the mutable map returned by the makeMap method mixes in the<br>
      SynchronizedMap trait, it can be used by multiple threads at once. Each<br>
      access to the map will be synchronized. Here’s an example of the map being<br>
      used, by one thread, in the interpreter:<br>
      scala&gt; val capital = MapMaker.makeMap<br>
      capital: scala.collection.mutable.Map[String,String] = Map()<br>
      scala&gt; capital ++= List("US" -&gt; "Washington",<br>
      "France" -&gt; "Paris", "Japan" -&gt; "Tokyo")<br>
      res17: scala.collection.mutable.Map[String,String] =<br>
      Map((France,Paris), (US,Washington), (Japan,Tokyo))<br>
      scala&gt; capital("Japan")<br>
      res18: String = Tokyo<br>
      scala&gt; capital("New Zealand")<br>
      res19: String = Why do you want to know?<br>
      scala&gt; capital += ("New Zealand" -&gt; "Wellington")<br>
      res20: capital.type = Map((New Zealand,Wellington),...<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      563Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; capital("New Zealand")<br>
      res21: String = Wellington<br>
      You can create synchronized sets similarly to the way you create syn-<br>
      chronized maps. For example, you could create a synchronized HashSet by<br>
      mixing in the SynchronizedSet trait, like this:<br>
      import scala.collection.mutable<br>
      val synchroSet =<br>
      new mutable.HashSet[Int] with<br>
      mutable.SynchronizedSet[Int]<br>
      Finally, if you are thinking of using synchronized collections, you may<br>
      also wish to consider the concurrent collections of java.util.concurrent<br>
      instead. Alternatively, you may prefer to use unsynchronized collections<br>
      with Scala actors. Actors will be covered in detail in Chapter 32.<br>
      24.9<br>
      Concrete immutable collection classes<br>
      Scala provides many concrete immutable collection classes for you to
      choose<br>
      from. They differ in the traits they implement (maps, sets, sequences),<br>
      whether they can be infinite, and the speed of various operations. We’ll
      start<br>
      by reviewing the most common immutable collection types.<br>
      Lists<br>
      Lists are finite immutable sequences. They provide constant-time access to<br>
      their first element as well as the rest of the list, and they have a
      constant-time<br>
      cons operation for adding a new element to the front of the list. Many
      other<br>
      operations take linear time. See Chapters 16 and 22 for extensive
      discussions<br>
      about lists.<br>
      Streams<br>
      A stream is like a list except that its elements are computed lazily.
      Because<br>
      of this, a stream can be infinitely long. Only those elements requested
      will<br>
      be computed. Otherwise, streams have the same performance characteristics<br>
      as lists.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      564Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      Whereas lists are constructed with the :: operator, streams are con-<br>
      structed with the similar-looking #:: . Here is a simple example of a
      stream<br>
      containing the integers 1, 2, and 3:<br>
      scala&gt; val str = 1 #:: 2 #:: 3 #:: Stream.empty<br>
      str: scala.collection.immutable.Stream[Int] = Stream(1, ?)<br>
      The head of this stream is 1, and the tail of it has 2 and 3. The tail is
      not<br>
      printed here, though, because it hasn’t been computed yet! Streams are re-<br>
      quired to compute lazily, and the toString method of a stream is careful
      not<br>
      to force any extra evaluation.<br>
      Below is a more complex example. It computes a stream that contains<br>
      a Fibonacci sequence starting with the given two numbers. A Fibonacci<br>
      sequence is one where each element is the sum of the previous two elements<br>
      in the series:<br>
      scala&gt; def fibFrom(a: Int, b: Int): Stream[Int] =<br>
      a #:: fibFrom(b, a + b)<br>
      fibFrom: (a: Int,b: Int)Stream[Int]<br>
      This function is deceptively simple. The first element of the sequence is<br>
      clearly a , and the rest of the sequence is the Fibonacci sequence
      starting<br>
      with b followed by a + b . The tricky part is computing this sequence
      without<br>
      causing an infinite recursion. If the function used :: instead of #:: ,
      then<br>
      every call to the function would result in another call, thus causing an
      infinite<br>
      recursion. Since it uses #:: , though, the right-hand side is not
      evaluated until<br>
      it is requested.<br>
      Here are the first few elements of the Fibonacci sequence starting with<br>
      two ones:<br>
      scala&gt; val fibs = fibFrom(1, 1).take(7)<br>
      fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)<br>
      scala&gt; fibs.toList<br>
      res22: List[Int] = List(1, 1, 2, 3, 5, 8, 13)<br>
      Vectors<br>
      Lists are very efficient when the algorithm processing them is careful to
      only<br>
      process their heads. Accessing, adding, and removing the head of a list
      takes<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      565Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      only constant time, whereas accessing or modifying elements later in the
      list<br>
      takes time linear in the depth into the list.<br>
      Vectors are a new collection type in Scala 2.8 that give efficient access<br>
      to elements beyond the head. Access to any elements of a vector take only<br>
      “effectively constant time,” as defined below. It’s a larger constant than
      for<br>
      access to the head of a list or for reading an element of an array, but
      it’s a<br>
      constant nonetheless. As a result, algorithms using vectors do not have to<br>
      be careful about accessing just the head of the sequence. They can access<br>
      and modify elements at arbitrary locations, and thus they can be much more<br>
      convenient to write.<br>
      Vectors are built and modified just like any other sequence:<br>
      scala&gt; val vec = scala.collection.immutable.Vector.empty<br>
      vec: scala.collection.immutable.Vector[Nothing] = Vector()<br>
      scala&gt; val vec2 = vec :+ 1 :+ 2<br>
      vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)<br>
      scala&gt; val vec3 = 100 +: vec2<br>
      vec3: scala.collection.immutable.Vector[Int]<br>
      = Vector(100, 1, 2)<br>
      scala&gt; vec3(0)<br>
      res23: Int = 100<br>
      Vectors are represented as broad, shallow trees. Every tree node contains<br>
      up to 32 elements of the vector or contains up to 32 other tree nodes.
      Vectors<br>
      with up to 32 elements can be represented in a single node. Vectors with<br>
      up to 32 * 32 = 1024 elements can be represented with a single
      indirection.<br>
      Two hops from the root of the tree to the final element node are
      sufficient<br>
      for vectors with up to 2 15 elements, three hops for vectors with 2 20 ,
      four<br>
      hops for vectors with 2 25 elements and five hops for vectors with up to 2
      30<br>
      elements. So for all vectors of reasonable size, an element selection
      involves<br>
      up to five primitive array selections. This is what we meant when we wrote<br>
      that element access is “effectively constant time.”<br>
      Vectors are immutable, so you cannot change an element of a vector in<br>
      place. However, with the updated method you can create a new vector that<br>
      differs from a given vector only in a single element:<br>
      scala&gt; val vec = Vector(1, 2, 3)<br>
      vec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      566Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; vec updated (2, 4)<br>
      res24: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)<br>
      scala&gt; vec<br>
      res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)<br>
      As the last line above shows, a call to updated has no effect on the
      original<br>
      vector vec . Like selection, functional vector updates are also
      “effectively<br>
      constant time.” Updating an element in the middle of a vector can be done
      by<br>
      copying the node that contains the element, and every node that points to
      it,<br>
      starting from the root of the tree. This means that a functional update
      creates<br>
      between one and five nodes that each contain up to 32 elements or
      subtrees.<br>
      This is certainly more expensive than an in-place update in a mutable
      array,<br>
      but still a lot cheaper than copying the whole vector.<br>
      Because vectors strike a good balance between fast random selections<br>
      and fast random functional updates, they are currently the default
      implemen-<br>
      tation of immutable indexed sequences:<br>
      scala&gt; collection.immutable.IndexedSeq(1, 2, 3)<br>
      res26: scala.collection.immutable.IndexedSeq[Int]<br>
      = Vector(1, 2, 3)<br>
      Immutable stacks<br>
      If you need a last-in-first-out sequence, you can use a Stack . You push
      an<br>
      element onto a stack with push , pop an element with pop , and peek at the<br>
      top of the stack without removing it with top . All of these operations
      are<br>
      constant time.<br>
      Here are some simple operations performed on a stack:<br>
      scala&gt; val stack = scala.collection.immutable.Stack.empty<br>
      stack: scala.collection.immutable.Stack[Nothing] = Stack()<br>
      scala&gt; val hasOne = stack.push(1)<br>
      hasOne: scala.collection.immutable.Stack[Int] = Stack(1)<br>
      scala&gt; stack<br>
      res27: scala.collection.immutable.Stack[Nothing] = Stack()<br>
      scala&gt; hasOne.top<br>
      res28: Int = 1<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      567Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; hasOne.pop<br>
      res29: scala.collection.immutable.Stack[Int] = Stack()<br>
      Immutable stacks are used rarely in Scala programs because their func-<br>
      tionality is subsumed by lists: A push on an immutable stack is the same
      as<br>
      a :: on a list, and a pop on a stack is the same a tail on a list.<br>
      Immutable queues<br>
      A queue is just like a stack except that it is first-in-first-out rather
      than last-in-<br>
      first-out. A simplified implementation of immutable queues was discussed<br>
      in Chapter 19. Here’s how you can create an empty immutable queue:<br>
      scala&gt; val empty = scala.collection.immutable.Queue[Int]()<br>
      empty: scala.collection.immutable.Queue[Int] = Queue()<br>
      You can append an element to an immutable queue with enqueue :<br>
      scala&gt; val has1 = empty.enqueue(1)<br>
      has1: scala.collection.immutable.Queue[Int] = Queue(1)<br>
      To append multiple elements to a queue, call enqueue with a collection as
      its<br>
      argument:<br>
      scala&gt; val has123 = has1.enqueue(List(2, 3))<br>
      has123: scala.collection.immutable.Queue[Int]<br>
      = Queue(1, 2, 3)<br>
      To remove an element from the head of the queue, use dequeue :<br>
      scala&gt; val (element, has23) = has123.dequeue<br>
      element: Int = 1<br>
      has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)<br>
      Note that dequeue returns a pair consisting of the element removed and the<br>
      rest of the queue.<br>
      Ranges<br>
      A range is an ordered sequence of integers that are equally spaced apart.
      For<br>
      example, “1, 2, 3” is a range, as is “5, 8, 11, 14.” To create a range in
      Scala,<br>
      use the predefined methods to and by . Here are some examples:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      568Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; 1 to 3<br>
      res30: scala.collection.immutable.Range.Inclusive<br>
      with scala.collection.immutable.Range.ByOne<br>
      = Range(1, 2, 3)<br>
      scala&gt; 5 to 14 by 3<br>
      res31: scala.collection.immutable.Range<br>
      = Range(5, 8, 11, 14)<br>
      If you want to create a range that is exclusive of its upper limit, use
      the<br>
      convenience method until instead of to :<br>
      scala&gt; 1 until 3<br>
      res32: scala.collection.immutable.Range<br>
      with scala.collection.immutable.Range.ByOne = Range(1, 2)<br>
      Ranges are represented in constant space, because they can be defined<br>
      by just three numbers: their start, their end, and the stepping value.
      Because<br>
      of this representation, most operations on ranges are extremely fast.<br>
      Hash tries<br>
      Hash tries 4 are a standard way to implement immutable sets and maps effi-<br>
      ciently. Their representation is similar to vectors in that they are also
      trees<br>
      where every node has 32 elements or 32 subtrees, but selection is done
      based<br>
      on a hash code. For instance, to find a given key in a map, you use the
      lowest<br>
      five bits of the hash code of the key to select the first subtree, the
      next five<br>
      bits the next subtree, and so on. Selection stops once all elements stored
      in a<br>
      node have hash codes that differ from each other in the bits that are
      selected<br>
      so far. Thus, not all the bits of the hash code are necessarily used.<br>
      Hash tries strike a nice balance between reasonably fast lookups and<br>
      reasonably efficient functional insertions (+) and deletions (-) . That’s
      why<br>
      they underlie Scala’s default implementations of immutable maps and sets.<br>
      In fact, Scala has a further optimization for immutable sets and maps that<br>
      contain less than five elements. Sets and maps with one to four elements
      are<br>
      stored as single objects that just contain the elements (or key/value
      pairs in<br>
      the case of a map) as fields. The empty immutable set and empty immutable<br>
      map is in each case a singleton object—there’s no need to duplicate
      storage<br>
      for those because an empty immutable set or map will always stay empty.<br>
      4 “Trie”<br>
      comes from the word "retrieval" and is pronounced tree or try.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      569Section 24.9<br>
      Chapter 24 · The Scala Collections API<br>
      Red-black trees<br>
      Red-black trees are a form of balanced binary trees where some nodes are<br>
      designated “red” and others “black.” Like any balanced binary tree, opera-<br>
      tions on them reliably complete in time logarithmic to the size of the
      tree.<br>
      Scala provides implementations of sets and maps that use a red-black<br>
      tree internally. You access them under the names TreeSet and TreeMap :<br>
      scala&gt; val set = collection.immutable.TreeSet.empty[Int]<br>
      set: scala.collection.immutable.TreeSet[Int] = TreeSet()<br>
      scala&gt; set + 1 + 3 + 3<br>
      res33: scala.collection.immutable.TreeSet[Int]<br>
      = TreeSet(1, 3)<br>
      Red-black trees are also the standard implementation of SortedSet in
      Scala,<br>
      because they provide an efficient iterator that returns all elements of
      the set<br>
      in sorted order.<br>
      Immutable bit sets<br>
      A bit set represents a collection of small integers as the bits of a
      larger integer.<br>
      For example, the bit set containing 3, 2, and 0 would be represented as
      the<br>
      integer 1101 in binary, which is 13 in decimal.<br>
      Internally, bit sets use an array of 64-bit Long s. The first Long in the<br>
      array is for integers 0 through 63, the second is for 64 through 127, and
      so<br>
      on. Thus, bit sets are very compact so long as the largest integer in the
      set is<br>
      less than a few hundred or so.<br>
      Operations on bit sets are very fast. Testing for inclusion takes constant<br>
      time. Adding an item to the set takes time proportional to the number of<br>
      Long s in the bit set’s array, which is typically a small number. Here are
      some<br>
      simple examples of the use of a bit set:<br>
      scala&gt; val bits = scala.collection.immutable.BitSet.empty<br>
      bits: scala.collection.immutable.BitSet = BitSet()<br>
      scala&gt; val moreBits = bits + 3 + 4 + 4<br>
      moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)<br>
      scala&gt; moreBits(3)<br>
      res34: Boolean = true<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      570Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; moreBits(0)<br>
      res35: Boolean = false<br>
      List maps<br>
      A list map represents a map as a linked list of key-value pairs. In
      general,<br>
      operations on a list map might have to iterate through the entire list.
      Thus,<br>
      operations on a list map take time linear in the size of the map. In fact
      there<br>
      is little usage for list maps in Scala because standard immutable maps are<br>
      almost always faster. The only possible difference is if the map is for
      some<br>
      reason constructed in such a way that the first elements in the list are
      selected<br>
      much more often than the other elements.<br>
      scala&gt; val map = collection.immutable.ListMap(<br>
      1 -&gt; "one", 2 -&gt; "two")<br>
      map: scala.collection.immutable.ListMap[Int,java.lang.String]<br>
      = Map((1,one), (2,two))<br>
      scala&gt; map(2)<br>
      res36: java.lang.String = two<br>
      24.10<br>
      Concrete mutable collection classes<br>
      Now that you’ve seen the most commonly used immutable collection classes<br>
      that Scala provides in its standard library, take a look at the mutable
      collec-<br>
      tion classes.<br>
      Array buffers<br>
      You’ve already seen array buffers in Section 17.1. An array buffer holds
      an<br>
      array and a size. Most operations on an array buffer have the same speed<br>
      as an array, because the operations simply access and modify the
      underlying<br>
      array. Additionally, array buffers can have data efficiently added to the
      end.<br>
      Appending an item to an array buffer takes amortized constant time. Thus,<br>
      array buffers are useful for efficiently building up a large collection
      whenever<br>
      the new items are always added to the end. Here are some examples:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      571Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; val buf = collection.mutable.ArrayBuffer.empty[Int]<br>
      buf: scala.collection.mutable.ArrayBuffer[Int]<br>
      = ArrayBuffer()<br>
      scala&gt; buf += 1<br>
      res37: buf.type = ArrayBuffer(1)<br>
      scala&gt; buf += 10<br>
      res38: buf.type = ArrayBuffer(1, 10)<br>
      scala&gt; buf.toArray<br>
      res39: Array[Int] = Array(1, 10)<br>
      List buffers<br>
      You’ve also already seen list buffers in Section 17.1. A list buffer is
      like an<br>
      array buffer except that it uses a linked list internally instead of an
      array. If<br>
      you plan to convert the buffer to a list once it is built up, use a list
      buffer<br>
      instead of an array buffer. Here’s an example: 5<br>
      scala&gt; val buf = collection.mutable.ListBuffer.empty[Int]<br>
      buf: scala.collection.mutable.ListBuffer[Int]<br>
      = ListBuffer()<br>
      scala&gt; buf += 1<br>
      res40: buf.type = ListBuffer(1)<br>
      scala&gt; buf += 10<br>
      res41: buf.type = ListBuffer(1, 10)<br>
      scala&gt; buf.toList<br>
      res42: List[Int] = List(1, 10)<br>
      String builders<br>
      Just like an array buffer is useful for building arrays, and a list buffer
      is<br>
      useful for building lists, a string builder is useful for building
      strings. String<br>
      builders are so commonly used that they are already imported into the
      default<br>
      namespace. Create them with a simple new StringBuilder , like this:<br>
      5 The “ buf.type ” that appears in the interpreter responses in this and
      several other ex-<br>
      amples in this section is a singleton type. As will be explained in
      Section 29.6, buf.type<br>
      means the variable holds exactly the object referred to by buf .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      572Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; val buf = new StringBuilder<br>
      buf: StringBuilder = StringBuilder()<br>
      scala&gt; buf += 'a'<br>
      res43: buf.type = StringBuilder(a)<br>
      scala&gt; buf ++= "bcdef"<br>
      res44: buf.type = StringBuilder(a, b, c, d, e, f)<br>
      scala&gt; buf.toString<br>
      res45: String = abcdef<br>
      Linked lists<br>
      Linked lists are mutable sequences that consist of nodes that are linked
      with<br>
      next pointers. In most languages null would be picked as the empty linked<br>
      list. That does not work for Scala collections, because even empty
      sequences<br>
      must support all sequence methods. LinkedList.empty.isEmpty , in par-<br>
      ticular, should return true and not throw a NullPointerException . Empty<br>
      linked lists are encoded instead in a special way: Their next field points
      back<br>
      to the node itself.<br>
      Like their immutable cousins, linked lists are best operated on sequen-<br>
      tially. In addition, linked lists make it easy to insert an element or
      linked list<br>
      into another linked list.<br>
      Double linked lists<br>
      DoubleLinkedList s are like the single linked lists described in the
      previous<br>
      subsection, except besides next , they have another mutable field, prev ,
      that<br>
      points to the element preceding the current node. The main benefit of that<br>
      additional link is that it makes element removal very fast.<br>
      Mutable lists<br>
      A MutableList consists of a single linked list together with a pointer
      that<br>
      refers to the terminal empty node of that list. This makes list append a
      con-<br>
      stant time operation because it avoids having to traverse the list in
      search for<br>
      its terminal node. MutableList is currently the standard implementation of<br>
      mutable.LinearSeq in Scala.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      573Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      Queues<br>
      Scala provides mutable queues in addition to immutable ones. You use a<br>
      mutable queue similarly to the way you use an immutable one, but instead<br>
      of enqueue , you use the += and ++= operators to append. Also, on a muta-<br>
      ble queue, the dequeue method will just remove the head element from the<br>
      queue and return it. Here’s an example:<br>
      scala&gt; val queue = new scala.collection.mutable.Queue[String]<br>
      queue: scala.collection.mutable.Queue[String] = Queue()<br>
      scala&gt; queue += "a"<br>
      res46: queue.type = Queue(a)<br>
      scala&gt; queue ++= List("b", "c")<br>
      res47: queue.type = Queue(a, b, c)<br>
      scala&gt; queue<br>
      res48: scala.collection.mutable.Queue[String] = Queue(a, b, c)<br>
      scala&gt; queue.dequeue<br>
      res49: String = a<br>
      scala&gt; queue<br>
      res50: scala.collection.mutable.Queue[String] = Queue(b, c)<br>
      Array sequences<br>
      Array sequences are mutable sequences of fixed size that store their
      elements<br>
      internally in an Array[AnyRef] . They are implemented in Scala by class<br>
      ArraySeq .<br>
      You would typically use an ArraySeq if you want an array for its per-<br>
      formance characteristics, but you also want to create generic instances of
      the<br>
      sequence where you do not know the type of the elements and do not have<br>
      a ClassManifest to provide it at run-time. You will find out about these<br>
      issues with arrays shortly, in Section 24.11.<br>
      Stacks<br>
      You saw immutable stacks earlier. There is also a mutable version. It
      works<br>
      exactly the same as the immutable version except that modifications happen<br>
      in place. Here’s an example:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      574Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; val stack = new scala.collection.mutable.Stack[Int]<br>
      stack: scala.collection.mutable.Stack[Int] = Stack()<br>
      scala&gt; stack.push(1)<br>
      res51: stack.type = Stack(1)<br>
      scala&gt; stack<br>
      res52: scala.collection.mutable.Stack[Int] = Stack(1)<br>
      scala&gt; stack.push(2)<br>
      res53: stack.type = Stack(2, 1)<br>
      scala&gt; stack<br>
      res54: scala.collection.mutable.Stack[Int] = Stack(2, 1)<br>
      scala&gt; stack.top<br>
      res55: Int = 2<br>
      scala&gt; stack<br>
      res56: scala.collection.mutable.Stack[Int] = Stack(2, 1)<br>
      scala&gt; stack.pop<br>
      res57: Int = 2<br>
      scala&gt; stack<br>
      res58: scala.collection.mutable.Stack[Int] = Stack(1)<br>
      Array stacks<br>
      ArrayStack is an alternative implementation of a mutable stack, which is<br>
      backed by an Array that gets resized as needed. It provides fast indexing<br>
      and is generally slightly more efficient for most operations than a normal<br>
      mutable stack.<br>
      Hash tables<br>
      A hash table stores its elements in an underlying array, placing each item
      at<br>
      a position in the array determined by the hash code of that item. Adding
      an<br>
      element to a hash table takes only constant time, so long as there isn’t
      already<br>
      another element in the array that has the same hash code. Hash tables are
      thus<br>
      very fast so long as the objects placed in them have a good distribution
      of<br>
      hash codes. As a result, the default mutable map and set types in Scala
      are<br>
      based on hash tables.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      575Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      Hash sets and maps are used just like any other set or map. Here are<br>
      some simple examples:<br>
      scala&gt; val map = collection.mutable.HashMap.empty[Int,String]<br>
      map: scala.collection.mutable.HashMap[Int,String] = Map()<br>
      scala&gt; map += (1 -&gt; "make a web site")<br>
      res59: map.type = Map((1,make a web site))<br>
      scala&gt; map += (3 -&gt; "profit!")<br>
      res60: map.type = Map((1,make a web site), (3,profit!))<br>
      scala&gt; map(1)<br>
      res61: String = make a web site<br>
      scala&gt; map contains 2<br>
      res62: Boolean = false<br>
      Iteration over a hash table is not guaranteed to occur in any particular<br>
      order. Iteration simply proceeds through the underlying array in whichever<br>
      order it happens to be. To get a guaranteed iteration order, use a linked
      hash<br>
      map or set instead of a regular one. A linked hash map or set is just like<br>
      a regular hash map or set except that it also includes a linked list of
      the<br>
      elements in the order they were added. Iteration over such a collection is<br>
      always in the same order that the elements were initially added.<br>
      Weak hash maps<br>
      A weak hash map is a special kind of hash map in which the garbage
      collector<br>
      does not follow links from the map to the keys stored in it. This means
      that a<br>
      key and its associated value will disappear from the map if there is no
      other<br>
      reference to that key. Weak hash maps are useful for tasks such as
      caching,<br>
      where you want to re-use an expensive function’s result if the function is<br>
      called again on the same key. If keys and function results are stored in a<br>
      regular hash map, the map could grow without bounds, and no key would<br>
      ever become garbage. Using a weak hash map avoids this problem. As soon<br>
      as a key object becomes unreachable, it’s entry is removed from the weak<br>
      hash map. Weak hash maps in Scala are implemented as a wrapper of an<br>
      underlying Java implementation, java.util.WeakHashMap .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      576Section 24.10<br>
      Chapter 24 · The Scala Collections API<br>
      Concurrent Maps<br>
      A concurrent map can be accessed by several threads at once. In addition
      to<br>
      the usual Map operations, it provides the following atomic operations:<br>
      Table 24.9 · Operations in trait ConcurrentMap<br>
      What it is<br>
      What it does<br>
      m putIfAbsent(k, v) Adds key/value binding k -&gt; m unless k is already<br>
      defined in m<br>
      m remove (k, v) Removes entry for k if it is currently mapped to v<br>
      m replace (k, old, new) Replaces value associated with key k to new , if
      it<br>
      was previously bound to old<br>
      m replace (k, v)<br>
      Replaces value associated with key k to v , if it<br>
      was previously bound to some value<br>
      ConcurrentMap is a trait in the Scala collections library. Currently, its<br>
      only implementation is Java’s java.util.concurrent.ConcurrentMap ,<br>
      which can be converted automatically into a Scala map using the standard<br>
      Java/Scala collection conversions, which will be described in Section
      24.18.<br>
      Mutable bit sets<br>
      A mutable bit set is just like an immutable one, except that it can be
      mod-<br>
      ified in place. Mutable bit sets are slightly more efficient at updating
      than<br>
      immutable ones, because they don’t have to copy around Long s that haven’t<br>
      changed. Here is an example:<br>
      scala&gt; val bits = scala.collection.mutable.BitSet.empty<br>
      bits: scala.collection.mutable.BitSet = BitSet()<br>
      scala&gt; bits += 1<br>
      res63: bits.type = BitSet(1)<br>
      scala&gt; bits += 3<br>
      res64: bits.type = BitSet(1, 3)<br>
      scala&gt; bits<br>
      res65: scala.collection.mutable.BitSet = BitSet(1, 3)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      577Section 24.11<br>
      24.11<br>
      Chapter 24 · The Scala Collections API<br>
      Arrays<br>
      Arrays are a special kind of collection in Scala. One the one hand, Scala
      ar-<br>
      rays correspond one-to-one to Java arrays. That is, a Scala array
      Array[Int]<br>
      is represented as a Java int[] , an Array[Double] is represented as a Java<br>
      double[] and an Array[String] is represented as a Java String[] . But<br>
      at the same time, Scala arrays offer much more their Java analogues.
      First,<br>
      Scala arrays can be generic. That is, you can have an Array[T] , where T
      is<br>
      a type parameter or abstract type. Second, Scala arrays are compatible
      with<br>
      Scala sequences—you can pass an Array[T] where a Seq[T] is required.<br>
      Finally, Scala arrays also support all sequence operations. Here’s an
      exam-<br>
      ple of this in action:<br>
      scala&gt; val a1 = Array(1, 2, 3)<br>
      a1: Array[Int] = Array(1, 2, 3)<br>
      scala&gt; val a2 = a1 map (_ * 3)<br>
      a2: Array[Int] = Array(3, 6, 9)<br>
      scala&gt; val a3 = a2 filter (_ % 2 != 0)<br>
      a3: Array[Int] = Array(3, 9)<br>
      scala&gt; a3.reverse<br>
      res1: Array[Int] = Array(9, 3)<br>
      Given that Scala arrays are represented just like Java arrays, how can
      these<br>
      additional features be supported in Scala? In fact, the answer to this
      question<br>
      differs between Scala 2.8 and earlier versions. Previously, the Scala com-<br>
      piler somewhat “magically” wrapped and unwrapped arrays to and from Seq<br>
      objects, when required, in a process called boxing and unboxing. The
      details<br>
      of this were quite complicated, in particular when you created a new array<br>
      of generic type Array[T] . There were some puzzling corner cases and the<br>
      performance of array operations was not all that predictable.<br>
      The Scala 2.8 design is much simpler. Almost all compiler magic is gone.<br>
      Instead the Scala 2.8 array implementation makes systematic use of
      implicit<br>
      conversions. In Scala 2.8 an array does not pretend to be a sequence. It
      can’t<br>
      really be that because the data type representation of a native array is
      not a<br>
      subtype of Seq . Instead there is an implicit “wrapping” conversion
      between<br>
      arrays and instances of class scala.collection.mutable.WrappedArray ,<br>
      which is a subclass of Seq . Here you see it in action:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      578Section 24.11<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; val seq: Seq[Int] = a1<br>
      seq: Seq[Int] = WrappedArray(1, 2, 3)<br>
      scala&gt; val a4: Array[Int] = seq.toArray<br>
      a4: Array[Int] = Array(1, 2, 3)<br>
      scala&gt; a1 eq a4<br>
      res2: Boolean = true<br>
      This interaction demonstrates that arrays are compatible with sequences,
      be-<br>
      cause there’s an implicit conversion from Array to WrappedArray . To go<br>
      the other way, from a WrappedArray to an Array , you can use the toArray<br>
      method defined in Traversable . The last interpreter line above shows that<br>
      wrapping then unwrapping with toArray gives you back the same array you<br>
      started with.<br>
      There is yet another implicit conversion that gets applied to arrays. This<br>
      conversion simply “adds” all sequence methods to arrays but does not turn<br>
      the array itself into a sequence. “Adding” means that the array is wrapped<br>
      in another object of type ArrayOps , which supports all sequence methods.<br>
      Typically, this ArrayOps object is short-lived; it will usually be
      inaccessible<br>
      after the call to the sequence method and its storage can be recycled.
      Modern<br>
      VMs often avoid creating this object entirely.<br>
      The difference between the two implicit conversions on arrays is demon-<br>
      strated here:<br>
      scala&gt; val seq: Seq[Int] = a1<br>
      seq: Seq[Int] = WrappedArray(1, 2, 3)<br>
      scala&gt; seq.reverse<br>
      res2: Seq[Int] = WrappedArray(3, 2, 1)<br>
      scala&gt; val ops: collection.mutable.ArrayOps[Int] = a1<br>
      ops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)<br>
      scala&gt; ops.reverse<br>
      res3: Array[Int] = Array(3, 2, 1)<br>
      You see that calling reverse on seq , which is a WrappedArray , will give<br>
      again a WrappedArray . That’s logical, because wrapped arrays are Seq s,<br>
      and calling reverse on any Seq will give again a Seq . On the other hand,<br>
      calling reverse on the ops value of class ArrayOps will result in an Array
      ,<br>
      not a Seq .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      579Section 24.11<br>
      Chapter 24 · The Scala Collections API<br>
      The ArrayOps example above was quite artificial, intended only to show<br>
      the difference to WrappedArray . Normally, you’d never define a value of<br>
      class ArrayOps . You’d just call a Seq method on an array:<br>
      scala&gt; a1.reverse<br>
      res4: Array[Int] = Array(3, 2, 1)<br>
      The ArrayOps object gets inserted automatically by the implicit
      conversion.<br>
      So the line above is equivalent to the following line, where intArrayOps<br>
      was the conversion that was implicitly inserted previously:<br>
      scala&gt; intArrayOps(a1).reverse<br>
      res5: Array[Int] = Array(3, 2, 1)<br>
      This raises the question how the compiler picked intArrayOps over the<br>
      other implicit conversion to WrappedArray in the line above. After all,
      both<br>
      conversions map an array to a type that supports a reverse method, which
      is<br>
      what the input specified. The answer to that question is that the two
      implicit<br>
      conversions are prioritized. The ArrayOps conversion has a higher priority<br>
      than the WrappedArray conversion. The first is defined in the Predef
      object<br>
      whereas the second is defined in a class scala.LowPriorityImplicits ,<br>
      which is a superclass of Predef . Implicits in subclasses and subobjects
      take<br>
      precedence over implicits in base classes. So if both conversions are ap-<br>
      plicable, the one in Predef is chosen. A very similar scheme, which was<br>
      described in Section 21.7, works for strings.<br>
      So now you know how arrays can be compatible with sequences and how<br>
      they can support all sequence operations. What about genericity? In Java<br>
      you cannot write a T[] where T is a type parameter. How then is Scala’s<br>
      Array[T] represented? In fact a generic array like Array[T] could be at<br>
      run-time any of Java’s eight primitive array types byte[] , short[] ,
      char[] ,<br>
      int[] , long[] , float[] , double[] , boolean[] , or it could be an array
      of<br>
      objects. The only common run-time type encompassing all of these types<br>
      is AnyRef (or, equivalently java.lang.Object ), so that’s the type to
      which<br>
      the Scala compiler maps Array[T] . At run-time, when an element of an ar-<br>
      ray of type Array[T] is accessed or updated there is a sequence of type
      tests<br>
      that determine the actual array type, followed by the correct array
      operation<br>
      on the Java array. These type tests slow down array operations somewhat.<br>
      You can expect accesses to generic arrays to be three to four times slower<br>
      than accesses to primitive or object arrays. This means that if you need
      max-<br>
      imal performance, you should prefer concrete over generic arrays.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      580Section 24.11<br>
      Chapter 24 · The Scala Collections API<br>
      Representing the generic array type is not enough, however, There must<br>
      also be a way to create generic arrays. This is an even harder problem,
      which<br>
      requires a little bit of help from you. To illustrate the problem,
      consider the<br>
      following attempt to write a generic method that creates an array:<br>
      // This is wrong!<br>
      def evenElems[T](xs: Vector[T]): Array[T] = {<br>
      val arr = new Array[T]((xs.length + 1) / 2)<br>
      for (i &lt;- 0 until xs.length by 2)<br>
      arr(i / 2) = xs(i)<br>
      arr<br>
      }<br>
      The evenElems method returns a new array that consists of all elements of<br>
      the argument vector xs that are at even positions in the vector. The first<br>
      line of the body of evenElems creates the result array, which has the same<br>
      element type as the argument. So depending on the actual type parameter
      for<br>
      T , this could be an Array[Int] , or an Array[Boolean] , or an array of
      some<br>
      of the other primitive types in Java, or an array of some reference type.
      But<br>
      these types all have different runtime representations, so how is the
      Scala<br>
      runtime going to pick the correct one? In fact, it can’t do that based on
      the<br>
      information it is given, because the actual type that corresponds to the
      type<br>
      parameter T is erased at runtime. That’s why you will get the following
      error<br>
      message if you attempt to compile the code above:<br>
      error: cannot find class manifest for element type T<br>
      val arr = new Array[T]((arr.length + 1) / 2)<br>
      ˆ<br>
      What’s required here is that you help the compiler by providing a runtime<br>
      hint of what the actual type parameter of evenElems is. This runtime hint<br>
      takes the form of a class manifest of type scala.reflect.ClassManifest .<br>
      A class manifest is a type descriptor object that describes what the
      top-level<br>
      class of a type is. Alternatively to class manifests there are also full
      manifests<br>
      of type scala.reflect.Manifest , which describe all aspects of a type. But<br>
      for array creation, only class manifests are needed.<br>
      The Scala compiler will generate code to construct and pass class man-<br>
      ifests automatically if you instruct it to do so. “Instructing” means that
      you<br>
      demand a class manifest as an implicit parameter, like this:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      581Section 24.11<br>
      Chapter 24 · The Scala Collections API<br>
      def evenElems[T](xs: Vector[T])<br>
      (implicit m: ClassManifest[T]): Array[T] = ...<br>
      Using an alternative and shorter syntax, you can also demand that the type<br>
      comes with a class manifest by using a context bound. This means following<br>
      the type with a colon and the class name ClassManifest , like this:<br>
      // This works<br>
      def evenElems[T: ClassManifest](xs: Vector[T]): Array[T] = {<br>
      val arr = new Array[T]((xs.length + 1) / 2)<br>
      for (i &lt;- 0 until xs.length by 2)<br>
      arr(i / 2) = xs(i)<br>
      arr<br>
      }<br>
      The two revised versions of evenElems mean exactly the same. What hap-<br>
      pens in either case is that when the Array[T] is constructed, the compiler<br>
      will look for a class manifest for the type parameter T , that is, it will
      look for<br>
      an implicit value of type ClassManifest[T] . If such a value is found, the<br>
      manifest is used to construct the right kind of array. Otherwise, you’ll
      see an<br>
      error message like the one shown previously.<br>
      Here is an interpreter interaction that uses the evenElems method:<br>
      scala&gt; evenElems(Vector(1, 2, 3, 4, 5))<br>
      res6: Array[Int] = Array(1, 3, 5)<br>
      scala&gt; evenElems(Vector("this", "is", "a", "test", "run"))<br>
      res7: Array[java.lang.String] = Array(this, a, run)<br>
      In both cases, the Scala compiler automatically constructed a class
      manifest<br>
      for the element type (first Int , then String ) and passed it to the
      implicit<br>
      parameter of the evenElems method. The compiler can do that for all con-<br>
      crete types, but not if the argument is itself another type parameter
      without<br>
      its class manifest. For instance, the following fails:<br>
      scala&gt; def wrap[U](xs: Vector[U]) = evenElems(xs)<br>
      &lt;console&gt;:6: error: could not find implicit value for<br>
      evidence parameter of type ClassManifest[U]<br>
      def wrap[U](xs: Vector[U]) = evenElems(xs)<br>
      ˆ<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      582Section 24.12<br>
      Chapter 24 · The Scala Collections API<br>
      What happened here is that the evenElems demands a class manifest for the<br>
      type parameter U , but none was found. The solution in this case is, of
      course,<br>
      to demand another implicit class manifest for U . So the following works:<br>
      scala&gt; def wrap[U: ClassManifest](xs: Vector[U]) =<br>
      evenElems(xs)<br>
      wrap: [U](xs: Vector[U])(implicit evidence$1:<br>
      ClassManifest[U])Array[U]<br>
      This example also shows that the context bound in the definition of U is<br>
      just a shorthand for an implicit parameter named here evidence$1 of type<br>
      ClassManifest[U] .<br>
      In summary, generic array creation demands class manifests. Whenever<br>
      you create an array of a type parameter T , you also need to provide an
      implicit<br>
      class manifest for T . The easiest way to do this is to declare the type
      param-<br>
      eter with a ClassManifest context bound, as in [T: ClassManifest] .<br>
      24.12<br>
      Strings<br>
      Like arrays, strings are not directly sequences, but they can be converted
      to<br>
      them, and they also support all sequence operations. Here are some
      examples<br>
      of operations you can invoke on strings:<br>
      scala&gt; val str = "hello"<br>
      str: java.lang.String = hello<br>
      scala&gt; str.reverse<br>
      res6: String = olleh<br>
      scala&gt; str.map(_.toUpper)<br>
      res7: String = HELLO<br>
      scala&gt; str drop 3<br>
      res8: String = lo<br>
      scala&gt; str slice (1, 4)<br>
      res9: String = ell<br>
      scala&gt; val s: Seq[Char] = str<br>
      s: Seq[Char] = WrappedString(h, e, l, l, o)<br>
      These operations are supported by two implicit conversions, which were ex-<br>
      plained in Section 21.7. The first, low-priority conversion maps a String<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      583Section 24.13<br>
      Chapter 24 · The Scala Collections API<br>
      to a WrappedString , which is a subclass of immutable.IndexedSeq . This<br>
      conversion was applied in the last line of the previous example in which a<br>
      string was converted into a Seq . The other, high-priority conversion maps<br>
      a string to a StringOps object, which adds all methods on immutable se-<br>
      quences to strings. This conversion was implicitly inserted in the method<br>
      calls of reverse , map , drop , and slice in the previous example.<br>
      24.13<br>
      Performance characteristics<br>
      As the previous explanations have shown, different collection types have<br>
      different performance characteristics. That’s often the primary reason for<br>
      picking one collection type over another. You can see the performance
      char-<br>
      acteristics of some common operations on collections summarized in two<br>
      tables, Table 24.10 and Table 24.11.<br>
      The entries in these two tables are explained as follows:<br>
      C<br>
      eC<br>
      aC<br>
      Log<br>
      L<br>
      -<br>
      The operation takes (fast) constant time.<br>
      The operation takes effectively constant time, but<br>
      this might depend on some assumptions such as the<br>
      maximum length of a vector or the distribution of<br>
      hash keys.<br>
      The operation takes amortized constant time. Some<br>
      invocations of the operation might take longer, but<br>
      if many operations are performed on average only<br>
      constant time per operation is taken.<br>
      The operation takes time proportional to the loga-<br>
      rithm of the collection size.<br>
      The operation is linear, that is it takes time propor-<br>
      tional to the collection size.<br>
      The operation is not supported.<br>
      Table 24.10 treats sequence types—both immutable and mutable—with<br>
      the following operations:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      584Section 24.14<br>
      Chapter 24 · The Scala Collections API<br>
      head<br>
      tail<br>
      apply<br>
      update<br>
      prepend<br>
      append<br>
      insert<br>
      Selecting the first element of the sequence.<br>
      Producing a new sequence that consists of all ele-<br>
      ments except the first one.<br>
      Indexing.<br>
      Functional update (with updated ) for immutable<br>
      sequences, side-effecting update (with update ) for<br>
      mutable sequences.<br>
      Adding an element to the front of the sequence.<br>
      For immutable sequences, this produces a new se-<br>
      quence. For mutable sequences it modifies the exist-<br>
      ing sequence.<br>
      Adding an element at the end of the sequence.<br>
      For immutable sequences, this produces a new se-<br>
      quence. For mutable sequences it modifies the exist-<br>
      ing sequence.<br>
      Inserting an element at an arbitrary position in the<br>
      sequence. This is only supported directly for muta-<br>
      ble sequences.<br>
      Table 24.11 treats mutable and immutable sets and maps with the follow-<br>
      ing operations:<br>
      lookup<br>
      add<br>
      remove<br>
      min<br>
      24.14<br>
      Testing whether an element is contained in set, or<br>
      selecting a value associated with a key.<br>
      Adding a new element to a set or a new key/value<br>
      pair to a map.<br>
      Removing an element from a set or a key from a<br>
      map.<br>
      The smallest element of the set, or the smallest key<br>
      of a map.<br>
      Equality<br>
      The collection libraries have a uniform approach to equality and hashing.<br>
      The idea is, first, to divide collections into sets, maps, and sequences.
      Collec-<br>
      tions in different categories are always unequal. For instance, Set(1, 2,
      3)<br>
      is unequal to List(1, 2, 3) even though they contain the same elements.<br>
      On the other hand, within the same category, collections are equal if and<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      585Section 24.14<br>
      Chapter 24 · The Scala Collections API<br>
      586<br>
      head tail apply update prepend append insert<br>
      C<br>
      C<br>
      eC<br>
      C<br>
      aC<br>
      C<br>
      C C<br>
      C<br>
      eC<br>
      C<br>
      aC<br>
      C<br>
      L L<br>
      L<br>
      eC<br>
      L<br>
      L<br>
      C<br>
      C L<br>
      L<br>
      eC<br>
      L<br>
      L<br>
      -<br>
      L C<br>
      C<br>
      eC<br>
      C<br>
      L<br>
      -<br>
      L L<br>
      L<br>
      eC<br>
      L<br>
      C<br>
      -<br>
      L -<br>
      -<br>
      -<br>
      -<br>
      -<br>
      -<br>
      -<br>
      C<br>
      C<br>
      C<br>
      C<br>
      C<br>
      C<br>
      C<br>
      C<br>
      C L<br>
      L<br>
      L<br>
      L<br>
      L<br>
      L<br>
      L<br>
      L<br>
      L C<br>
      L<br>
      C<br>
      L<br>
      L<br>
      C<br>
      L<br>
      C<br>
      C C<br>
      L<br>
      C<br>
      L<br>
      L<br>
      C<br>
      L<br>
      C<br>
      C L<br>
      C<br>
      L<br>
      C<br>
      C<br>
      -<br>
      C<br>
      aC<br>
      - aC<br>
      C<br>
      aC<br>
      C<br>
      C<br>
      -<br>
      L<br>
      L<br>
      - L<br>
      L<br>
      L<br>
      L<br>
      L<br>
      -<br>
      L<br>
      L<br>
      -<br>
      immutable<br>
      List<br>
      Stream<br>
      Vector<br>
      Stack<br>
      Queue<br>
      Range<br>
      String<br>
      mutable<br>
      ArrayBuffer<br>
      ListBuffer<br>
      StringBuilder<br>
      MutableList<br>
      Queue<br>
      ArraySeq<br>
      Stack<br>
      ArrayStack<br>
      Array<br>
      Table 24.10 · Performance characteristics of sequence types<br>
      lookup add remove min<br>
      eC<br>
      Log<br>
      C<br>
      L eC<br>
      Log<br>
      L<br>
      L eC<br>
      Log<br>
      L<br>
      L L<br>
      Log<br>
      eC a<br>
      L<br>
      eC<br>
      eC<br>
      C eC<br>
      eC<br>
      aC eC<br>
      eC<br>
      C L<br>
      L<br>
      eC a<br>
      immutable<br>
      HashSet/HashMap<br>
      TreeSet/TreeMap<br>
      BitSet<br>
      ListMap<br>
      mutable<br>
      HashSet/HashMap<br>
      WeakHashMap<br>
      BitSet<br>
      Table 24.11 · Performance characteristics of set and map types<br>
      a Assuming<br>
      bits are densely packed.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      24.15<br>
      Chapter 24 · The Scala Collections API<br>
      only if they have the same elements (for sequences: the same elements in<br>
      the same order). For example, List(1, 2, 3) == Vector(1, 2, 3) , and<br>
      HashSet(1, 2) == TreeSet(2, 1) .<br>
      It does not matter for the equality check whether a collection is mutable<br>
      or immutable. For a mutable collection, equality simply depends on the<br>
      current elements at the time the equality test is performed. This means
      that a<br>
      mutable collection might be equal to different collections at different
      times,<br>
      depending what elements are added or removed. This is a potential trap
      when<br>
      using a mutable collection as a key in a hash map. For example:<br>
      scala&gt; import collection.mutable.{HashMap, ArrayBuffer}<br>
      import collection.mutable.{HashMap, ArrayBuffer}<br>
      scala&gt; val buf = ArrayBuffer(1, 2, 3)<br>
      buf: scala.collection.mutable.ArrayBuffer[Int] =<br>
      ArrayBuffer(1, 2, 3)<br>
      scala&gt; val map = HashMap(buf -&gt; 3)<br>
      map: scala.collection.mutable.HashMap[scala.collection.<br>
      mutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))<br>
      scala&gt; map(buf)<br>
      res13: Int = 3<br>
      scala&gt; buf(0) += 1<br>
      scala&gt; map(buf)<br>
      java.util.NoSuchElementException: key not found:<br>
      ArrayBuffer(2, 2, 3)<br>
      In this example, the selection in the last line will most likely fail
      because the<br>
      hash code of the array xs has changed in the second-to-last line.
      Therefore,<br>
      the hash-code-based lookup will look at a different place than the one in<br>
      which xs was stored.<br>
      24.15<br>
      Views<br>
      Collections have quite a few methods that construct new collections. Some<br>
      examples are map , filter , and ++ . We call such methods transformers be-<br>
      cause they take at least one collection as their receiver object and
      produce<br>
      another collection in their result.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      587Section 24.15<br>
      Chapter 24 · The Scala Collections API<br>
      Transformers can be implemented in two principal ways: strict and non-<br>
      strict (or lazy). A strict transformer constructs a new collection with
      all of its<br>
      elements. A non-strict, or lazy, transformer constructs only a proxy for
      the<br>
      result collection, and its elements are constructed on demand.<br>
      As an example of a non-strict transformer, consider the following imple-<br>
      mentation of a lazy map operation:<br>
      def lazyMap[T, U](coll: Iterable[T], f: T =&gt; U) =<br>
      new Iterable[U] {<br>
      def iterator = coll.iterator map f<br>
      }<br>
      Note that lazyMap constructs a new Iterable without stepping through all<br>
      elements of the given collection coll . The given function f is instead
      ap-<br>
      plied to the elements of the new collection’s iterator as they are
      demanded.<br>
      Scala collections are by default strict in all their transformers, except<br>
      for Stream , which implements all its transformer methods lazily. However,<br>
      there is a systematic way to turn every collection into a lazy one and
      vice<br>
      versa, which is based on collection views. A view is a special kind of
      col-<br>
      lection that represents some base collection, but implements all of its
      trans-<br>
      formers lazily.<br>
      To go from a collection to its view, you can use the view method on the<br>
      collection. If xs is some collection, then xs.view is the same collection,
      but<br>
      with all transformers implemented lazily. To get back from a view to a
      strict<br>
      collection, you can use the force method.<br>
      As an example, say you have a vector of Int s over which you want to<br>
      map two functions in succession:<br>
      scala&gt; val v = Vector(1 to 10: _*)<br>
      v: scala.collection.immutable.Vector[Int] =<br>
      Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)<br>
      scala&gt; v map (_ + 1) map (_ * 2)<br>
      res5: scala.collection.immutable.Vector[Int] =<br>
      Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)<br>
      In the last statement, the expression v map (_ + 1) constructs a new
      vector<br>
      that is then transformed into a third vector by the second call to map (_
      * 2) .<br>
      In many situations, constructing the intermediate result from the first
      call<br>
      to map is a bit wasteful. In the pseudo example, it would be faster to do
      a<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      588Section 24.15<br>
      Chapter 24 · The Scala Collections API<br>
      single map with the composition of the two functions (_ + 1) and (_ * 2) .<br>
      If you have the two functions available in the same place you can do this<br>
      by hand. But quite often, successive transformations of a data structure
      are<br>
      done in different program modules. Fusing those transformations would then<br>
      undermine modularity. A more general way to avoid the intermediate results<br>
      is by turning the vector first into a view, applying all transformations
      to the<br>
      view, and finally forcing the view to a vector:<br>
      scala&gt; (v.view map (_ + 1) map (_ * 2)).force<br>
      res12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)<br>
      We’ll do this sequence of operations again, one by one:<br>
      scala&gt; val vv = v.view<br>
      vv: scala.collection.SeqView[Int,Vector[Int]] =<br>
      SeqView(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)<br>
      The application v.view gives you a SeqView , i.e., a lazily evaluated Seq
      .<br>
      The type SeqView has two type parameters. The first, Int , shows the type<br>
      of the view’s elements. The second, Vector[Int] , shows you the type con-<br>
      structor you get back when forcing the view .<br>
      Applying the first map to the view gives you:<br>
      scala&gt; vv map (_ + 1)<br>
      res13: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...)<br>
      The result of the map is a value that prints SeqViewM(...) . This is in
      essence<br>
      a wrapper that records the fact that a map with function (_ + 1) needs to
      be<br>
      applied on the vector v . It does not apply that map until the view is
      force d,<br>
      however. The “ M ” after SeqView is an indication that the view
      encapsulates a<br>
      map operation. Other letters indicate other delayed operations. For
      instance<br>
      “ S ” indicates a delayed slice operation, and “ R ” indicates a reverse .
      We’ll<br>
      now apply the second map to the last result.<br>
      scala&gt; res13 map (_ * 2)<br>
      res14: scala.collection.SeqView[Int,Seq[_]] = SeqViewMM(...)<br>
      You now get a SeqView that contains two map operations, so it prints with
      a<br>
      double “ M ”: SeqViewMM(...) . Finally, forcing the last result gives:<br>
      scala&gt; res14.force<br>
      res15: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      589Section 24.15<br>
      Chapter 24 · The Scala Collections API<br>
      Both stored functions get applied as part of the execution of the force
      opera-<br>
      tion and a new vector is constructed. That way, no intermediate data
      structure<br>
      is needed.<br>
      One detail to note is that the static type of the final result is a Seq ,
      not a<br>
      Vector . Tracing the types back we see that as soon as the first delayed
      map<br>
      was applied, the result had static type SeqViewM[Int, Seq[_]] . That is,
      the<br>
      “knowledge” that the view was applied to the specific sequence type Vector<br>
      got lost. The implementation of a view for any particular class requires
      quite<br>
      a bit of code, so the Scala collection libraries provide views mostly only
      for<br>
      general collection types, not for specific implementations. 6<br>
      There are two reasons why you might want to consider using views. The<br>
      first is performance. You have seen that by switching a collection to a
      view<br>
      the construction of intermediate results can be avoided. These savings can<br>
      be quite important. As another example, consider the problem of finding<br>
      the first palindrome in a list of words. A palindrome is a word that reads<br>
      backwards the same as forwards. Here are the necessary definitions:<br>
      def isPalindrome(x: String) = x == x.reverse<br>
      def findPalindrome(s: Seq[String]) = s find isPalindrome<br>
      Now, assume you have a very long sequence words and you want to find a<br>
      palindrome in the first million words of that sequence. Can you re-use the<br>
      definition of findPalindrome ? Of course, you could write:<br>
      findPalindrome(words take 1000000)<br>
      This nicely separates the two aspects of taking the first million words of<br>
      a sequence and finding a palindrome in it. But the downside is that it al-<br>
      ways constructs an intermediary sequence consisting of one million words,<br>
      even if the first word of that sequence is already a palindrome. So poten-<br>
      tially, 999,999 words are copied into the intermediary result without
      being<br>
      inspected at all afterwards. Many programmers would give up here and write<br>
      their own specialized version of finding palindromes in some given prefix
      of<br>
      an argument sequence. But with views, you don’t have to. Simply write:<br>
      findPalindrome(words.view take 1000000)<br>
      6 An exception to this is arrays: applying delayed operations on arrays
      will again give<br>
      results with static type Array .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      590Section 24.15<br>
      Chapter 24 · The Scala Collections API<br>
      This has the same nice separation of concerns, but instead of a sequence
      of a<br>
      million elements it will only construct a single lightweight view object.
      This<br>
      way, you do not need to choose between performance and modularity.<br>
      The second use case applies to views over mutable sequences. Many<br>
      transformer functions on such views provide a window into the original se-<br>
      quence that can then be used to update selectively some elements of that<br>
      sequence. To see this in an example, suppose you have an array arr :<br>
      scala&gt; val arr = (0 to 9).toArray<br>
      arr: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)<br>
      You can create a subwindow into that array by creating a slice of a view
      of<br>
      the array:<br>
      scala&gt; val subarr = arr.view.slice(3, 6)<br>
      subarr: scala.collection.mutable.IndexedSeqView[<br>
      Int,Array[Int]] = IndexedSeqViewS(...)<br>
      This gives a view, subarr , which refers to the elements at positions 3
      through<br>
      5 of the array arr . The view does not copy these elements, it just
      provides<br>
      a reference to them. Now, assume you have a method that modifies some<br>
      elements of a sequence. For instance, the following negate method would<br>
      negate all elements of the sequence of integers it’s given:<br>
      scala&gt; def negate(xs: collection.mutable.Seq[Int]) =<br>
      for (i &lt;- 0 until xs.length) xs(i) = -xs(i)<br>
      negate: (xs: scala.collection.mutable.Seq[Int])Unit<br>
      Assume now you want to negate elements at positions three through five of<br>
      the array arr . Can you use negate for this? Using a view, this is simple:<br>
      scala&gt; negate(subarr)<br>
      scala&gt; arr<br>
      res4: Array[Int] = Array(0, 1, 2, -3, -4, -5, 6, 7, 8, 9)<br>
      What happened here is that negate changed all elements of subarr , which<br>
      were a slice of the elements of arr . Again, you see that views help in
      keeping<br>
      things modular. The code above nicely separated the question of what index<br>
      range to apply a method to from the question what method to apply.<br>
      After having seen all these nifty uses of views you might wonder why<br>
      have strict collections at all? One reason is that performance comparisons
      do<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      591Section 24.15<br>
      Chapter 24 · The Scala Collections API<br>
      not always favor lazy over strict collections. For smaller collection
      sizes the<br>
      added overhead of forming and applying closures in views is often greater<br>
      than the gain from avoiding the intermediary data structures. A possibly<br>
      more important reason is that evaluation in views can be very confusing if<br>
      the delayed operations have side effects.<br>
      Here’s an example that bit a few users of versions of Scala before 2.8. In<br>
      these versions the Range type was lazy, so it behaved in effect like a
      view.<br>
      People were trying to create a number of actors 7 like this:<br>
      val actors = for (i &lt;- 1 to 10) yield actor { ... }<br>
      They were surprised that none of the actors were executing afterwards,
      even<br>
      though the actor method should create and start an actor from the code<br>
      that’s enclosed in the braces following it. To explain why nothing
      happened,<br>
      remember that the for expression above is equivalent to an application of<br>
      the map method:<br>
      val actors = (1 to 10) map (i =&gt; actor { ... })<br>
      Since previously the range produced by (1 to 10) behaved like a view, the<br>
      result of the map was again a view. That is, no element was computed, and,<br>
      consequently, no actor was created! Actors would have been created by<br>
      forcing the range of the whole expression, but it’s far from obvious that
      this<br>
      is what was required to make the actors do their work.<br>
      To avoid surprises like this, the Scala 2.8 collections library has more<br>
      regular rules. All collections except streams and views are strict. The
      only<br>
      way to go from a strict to a lazy collection is via the view method. The
      only<br>
      way to go back is via force . So the actors definition above would behave<br>
      as expected in Scala 2.8 in that it would create and start ten actors. To
      get<br>
      back the surprising previous behavior, you’d have to add an explicit view<br>
      method call:<br>
      val actors = for (i &lt;- (1 to 10).view) yield actor { ... }<br>
      In summary, views are a powerful tool to reconcile concerns of efficiency<br>
      with concerns of modularity. But in order not to be entangled in aspects
      of<br>
      delayed evaluation, you should restrict views to two scenarios. Either you<br>
      apply views in purely functional code where collection transformations do<br>
      7 An<br>
      actor is a thread that can communicate with message passing; see Chapter
      32.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      592Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      not have side effects. Or you apply them over mutable collections where
      all<br>
      modifications are done explicitly. What’s best avoided is a mixture of
      views<br>
      and operations that create new collections while also having side effects.<br>
      24.16<br>
      Iterators<br>
      An iterator is not a collection, but rather a way to access the elements
      of<br>
      a collection one by one. The two basic operations on an iterator it are<br>
      next and hasNext . A call to it.next() will return the next element of<br>
      the iterator and advance the state of the iterator. Calling next again on
      the<br>
      same iterator will then yield the element one beyond the one returned pre-<br>
      viously. If there are no more elements to return, a call to next will
      throw a<br>
      NoSuchElementException . You can find out whether there are more ele-<br>
      ments to return using Iterator ’s hasNext method.<br>
      The most straightforward way to “step through” all the elements returned<br>
      by an iterator is to use a while loop:<br>
      while (it.hasNext)<br>
      println(it.next())<br>
      Iterators in Scala also provide analogues of most of the methods that you
      find<br>
      in the Traversable , Iterable , and Seq traits. For instance, they provide
      a<br>
      foreach method that executes a given procedure on each element returned<br>
      by an iterator. Using foreach , the loop above could be abbreviated to:<br>
      it foreach println<br>
      As always, for expressions can be used as an alternate syntax for
      expressions<br>
      involving foreach , map , filter , and flatMap , so yet another way to
      print<br>
      all elements returned by an iterator would be:<br>
      for (elem &lt;- it) println(elem)<br>
      There’s an important difference between the foreach method on iterators<br>
      and the same method on traversable collections: When called on an itera-<br>
      tor, foreach will leave the iterator at its end when it is done. So
      calling<br>
      next again on the same iterator will fail with a NoSuchElementException .<br>
      By contrast, when called on a collection, foreach leaves the number of el-<br>
      ements in the collection unchanged (unless the passed function adds or re-<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      593Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      moves elements, but this is discouraged, because it can easily lead to
      surpris-<br>
      ing results).<br>
      The other operations that Iterator has in common with Traversable<br>
      have the same property of leaving the iterator at its end when done. For<br>
      instance, iterators provide a map method, which returns a new iterator:<br>
      scala&gt; val it = Iterator("a", "number", "of", "words")<br>
      it: Iterator[java.lang.String] = non-empty iterator<br>
      scala&gt; it.map(_.length)<br>
      res1: Iterator[Int] = non-empty iterator<br>
      scala&gt; res1 foreach println<br>
      1<br>
      6<br>
      2<br>
      5<br>
      scala&gt; it.next()<br>
      java.util.NoSuchElementException: next on empty iterator<br>
      As you can see, after the call to map , the it iterator has advanced to
      its end.<br>
      Another example is the dropWhile method, which can be used to find<br>
      the first element of an iterator that has a certain property. For
      instance, to find<br>
      the first word in the iterator shown previously that has at least two
      characters,<br>
      you could write:<br>
      scala&gt; val it = Iterator("a", "number", "of", "words")<br>
      it: Iterator[java.lang.String] = non-empty iterator<br>
      scala&gt; it dropWhile (_.length &lt; 2)<br>
      res4: Iterator[java.lang.String] = non-empty iterator<br>
      scala&gt; it.next()<br>
      res5: java.lang.String = number<br>
      Note again that it has changed by the call to dropWhile : it now points to<br>
      the second word “number” in the list. In fact, it and the result res4
      returned<br>
      by dropWhile will return exactly the same sequence of elements.<br>
      There is only one standard operation, duplicate , which allows you to<br>
      re-use the same iterator:<br>
      val (it1, it2) = it.duplicate<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      594Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      The call to duplicate gives you two iterators, which each return exactly
      the<br>
      same elements as the iterator it . The two iterators work independently;<br>
      advancing one does not affect the other. By contrast the original
      iterator, it ,<br>
      is advanced to its end by duplicate and is thus rendered unusable.<br>
      In summary, iterators behave like collections if you never access an it-<br>
      erator again after invoking a method on it. The Scala collection libraries<br>
      make this explicit with an abstraction called TraversableOnce , which is a<br>
      common supertrait of Traversable and Iterator . As the name implies,<br>
      TraversableOnce objects can be traversed using foreach , but the state of<br>
      that object after the traversal is not specified. If the TraversableOnce
      ob-<br>
      ject is in fact an Iterator , it will be at its end after the traversal,
      but if<br>
      it is a Traversable , it will still exist as before. A common use case of<br>
      TraversableOnce is as an argument type for methods that can take either<br>
      an iterator or traversable as argument. An example is the appending method<br>
      ++ in trait Traversable . It takes a TraversableOnce parameter, so you can<br>
      append elements coming from either an iterator or a traversable
      collection.<br>
      All operations on iterators are summarized in Table 24.12:<br>
      Table 24.12 · Operations in trait Iterator<br>
      What it is<br>
      What it does<br>
      Abstract methods:<br>
      it.next() Returns the next element in the iterator and<br>
      advances past it .<br>
      it.hasNext Returns true if it can return another element.<br>
      Variations:<br>
      it.buffered A buffered iterator returning all elements of it .<br>
      it grouped size An iterator that yields the elements returned by<br>
      it in fixed-sized sequence “chunks.”<br>
      xs sliding size An iterator that yields the elements returned by<br>
      it in sequences representing a sliding fixed-sized<br>
      window.<br>
      Copying:<br>
      it copyToBuffer buf Copies all elements returned by it to buffer buf .<br>
      it copyToArray(arr, s, l) Copies at most l elements returned by it to
      array<br>
      arr starting at index s . The last two arguments<br>
      are optional.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      595Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.12 · continued<br>
      Duplication:<br>
      it.duplicate<br>
      A pair of iterators that each independently return<br>
      all elements of it .<br>
      Additions:<br>
      it ++ jt<br>
      An iterator returning all elements returned by<br>
      iterator it , followed by all elements returned by<br>
      iterator jt .<br>
      it padTo (len, x) The iterator that returns all elements of it<br>
      followed by copies of x until length len elements<br>
      are returned overall.<br>
      it map f The iterator obtained from applying the function<br>
      f to every element returned from it .<br>
      it flatMap f The iterator obtained from applying the<br>
      iterator-valued function f to every element in it<br>
      and appending the results.<br>
      it collect f The iterator obtained from applying the partial<br>
      function f to every element in it for which it is<br>
      defined and collecting the results.<br>
      Maps:<br>
      Conversions:<br>
      it.toArray<br>
      it.toList<br>
      Collects the elements returned by it in an array.<br>
      Collects the elements returned by it in a list.<br>
      it.toIterable Collects the elements returned by it in an<br>
      iterable.<br>
      it.toSeq Collects the elements returned by it in a<br>
      sequence.<br>
      it.toIndexedSeq Collects the elements returned by it in an<br>
      indexed sequence.<br>
      it.toStream<br>
      Collects the elements returned by it in a stream.<br>
      it.toSet Collects the elements returned by it in a set.<br>
      it.toMap Collects the key/value pairs returned by it in a<br>
      map.<br>
      it.isEmpty Tests whether the iterator is empty (opposite of<br>
      hasNext ).<br>
      Size info:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      596Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.12 · continued<br>
      it.nonEmpty<br>
      it.size<br>
      it.length<br>
      it.hasDefiniteSize<br>
      Tests whether the collection contains elements<br>
      (alias of hasNext ).<br>
      The number of elements returned by it . Note: it<br>
      will be at its end after this operation!<br>
      Same as it.size .<br>
      Returns true if it is known to return finitely<br>
      many elements (by default the same as isEmpty ).<br>
      Element retrieval index search:<br>
      it find p An option containing the first element returned by<br>
      it that satisfies p , or None if no element qualifies.<br>
      Note: The iterator advances to just after the<br>
      element, or, if none is found, to the end.<br>
      it indexOf x The index of the first element returned by it that<br>
      equals x . Note: The iterator advances past the<br>
      position of this element.<br>
      it indexWhere p The index of the first element returned by it that<br>
      satisfies p . Note: The iterator advances past the<br>
      position of this element.<br>
      Subiterators:<br>
      it take n An iterator returning of the first n elements of it .<br>
      Note: it will advance to the position after the<br>
      n ’th element, or to its end, if it contains less than<br>
      n elements.<br>
      it drop n The iterator that starts with the (n + 1) ’th element<br>
      of it . Note: it will advance to the same position.<br>
      it slice (m, n) The iterator that returns a slice of the elements<br>
      returned from it , starting with the m ’th element<br>
      and ending before the n ’th element.<br>
      it takeWhile p An iterator returning elements from it as long as<br>
      condition p is true.<br>
      it dropWhile p An iterator skipping elements from it as long as<br>
      condition p is true, and returning the remainder.<br>
      it filter p An iterator returning all elements from it that<br>
      satisfy the condition p .<br>
      it withFilter p Same as it filter p . Needed so that iterators<br>
      can be used in for expressions.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      597Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.12 · continued<br>
      it filterNot p<br>
      An iterator returning all elements from it that do<br>
      not satisfy the condition p .<br>
      Subdivisions:<br>
      it partition p<br>
      Splits it into a pair of two iterators; one<br>
      returning all elements from it that satisfy the<br>
      predicate p , the other returning all elements from<br>
      it that do not.<br>
      Element conditions:<br>
      it forall p A boolean indicating whether the predicate p<br>
      holds for all elements returned by it .<br>
      it exists p A boolean indicating whether the predicate p<br>
      holds for some element in it .<br>
      it count p The number of elements in it that satisfy the<br>
      predicate p .<br>
      Folds:<br>
      (z /: it)(op) Applies binary operation op between successive<br>
      elements returned by it , going left to right,<br>
      starting with z .<br>
      (it :\ z)(op) Applies binary operation op between successive<br>
      elements returned by it , going right to left,<br>
      starting with z .<br>
      it.foldLeft(z)(op) Same as (z /: it)(op) .<br>
      it.foldRight(z)(op) Same as (it :\ z)(op) .<br>
      it reduceLeft op Applies binary operation op between successive<br>
      elements returned by non-empty iterator it ,<br>
      going left to right.<br>
      it reduceRight op Applies binary operation op between successive<br>
      elements returned by non-empty iterator it ,<br>
      going right to left.<br>
      Specific folds:<br>
      it.sum<br>
      it.product<br>
      it.min<br>
      The sum of the numeric element values returned<br>
      by iterator it .<br>
      The product of the numeric element values<br>
      returned by iterator it .<br>
      The minimum of the ordered element values<br>
      returned by iterator it .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      598Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.12 · continued<br>
      it.max<br>
      The maximum of the ordered element values<br>
      returned by iterator it .<br>
      Zippers:<br>
      it zip jt An iterator of pairs of corresponding elements<br>
      returned from iterators it and jt .<br>
      it zipAll (jt, x, y) An iterator of pairs of corresponding elements<br>
      returned from iterators it and jt , where the<br>
      shorter iterator is extended to match the longer<br>
      one by appending elements x or y .<br>
      it.zipWithIndex<br>
      An iterator of pairs of elements returned from it<br>
      with their indicies.<br>
      Update:<br>
      it patch (i, jt, r)<br>
      The iterator resulting from it by replacing r<br>
      elements starting with i by the patch iterator jt .<br>
      Comparison:<br>
      it sameElements jt<br>
      A test whether iterators it and jt return the same<br>
      elements in the same order. Note: At least one of<br>
      it and jt will be at its end after this operation.<br>
      Strings:<br>
      it addString (b, start,<br>
      sep, end) Adds a string to StringBuilder b that shows all<br>
      elements returned by it between separators sep<br>
      enclosed in strings start and end . start , sep ,<br>
      and end are all optional.<br>
      it mkString (start,<br>
      sep, end) Converts the collection to a string that shows all<br>
      elements returned by it between separators sep<br>
      enclosed in strings start and end . start , sep ,<br>
      and end are all optional.<br>
      Buffered iterators<br>
      Sometimes you want an iterator that can “look ahead” so that you can in-<br>
      spect the next element to be returned without advancing past that element.<br>
      Consider, for instance, the task to skip leading empty strings from an
      iterator<br>
      that returns a sequence of strings. You might be tempted to write
      something<br>
      like the following method:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      599Section 24.16<br>
      Chapter 24 · The Scala Collections API<br>
      // This won’t work<br>
      def skipEmptyWordsNOT(it: Iterator[String]) {<br>
      while (it.next().isEmpty) {}<br>
      }<br>
      But looking at this code more closely, it’s clear that this is wrong: the
      code<br>
      will indeed skip leading empty strings, but it will also advance it past
      the<br>
      first non-empty string!<br>
      The solution to this problem is to use a buffered iterator, an instance of<br>
      trait BufferedIterator . BufferedIterator is a subtrait of Iterator ,<br>
      which provides one extra method, head . Calling head on a buffered
      iterator<br>
      will return its first element, but will not advance the iterator. Using a
      buffered<br>
      iterator, skipping empty words can be written like this:<br>
      def skipEmptyWords(it: BufferedIterator[String]) =<br>
      while (it.head.isEmpty) { it.next() }<br>
      Every iterator can be converted to a buffered iterator by calling its
      buffered<br>
      method. Here’s an example:<br>
      scala&gt; val it = Iterator(1, 2, 3, 4)<br>
      it: Iterator[Int] = non-empty iterator<br>
      scala&gt; val bit = it.buffered<br>
      bit: java.lang.Object with scala.collection.<br>
      BufferedIterator[Int] = non-empty iterator<br>
      scala&gt; bit.head<br>
      res10: Int = 1<br>
      scala&gt; bit.next()<br>
      res11: Int = 1<br>
      scala&gt; bit.next()<br>
      res11: Int = 2<br>
      Note that calling head on the buffered iterator, bit , did not advance it.<br>
      Therefore, the subsequent call, bit.next() , returned again the same value<br>
      as bit.head .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      600Section 24.17<br>
      24.17<br>
      Chapter 24 · The Scala Collections API<br>
      Creating collections from scratch<br>
      You have already seen syntax like List(1, 2, 3) , which creates a list of<br>
      three integers, and Map('A' -&gt; 1, 'C' -&gt; 2) , which creates a map
      with two<br>
      bindings. This is actually a universal feature of Scala collections. You
      can<br>
      take any collection name and follow it by a list of elements in
      parentheses.<br>
      The result will be a new collection with the given elements. Here are some<br>
      more examples:<br>
      Traversable() // An empty traversable object<br>
      List() // The empty list<br>
      List(1.0, 2.0) // A list with elements 1.0, 2.0<br>
      Vector(1.0, 2.0) // A vector with elements 1.0, 2.0<br>
      Iterator(1, 2, 3) // An iterator returning three integers.<br>
      Set(dog, cat, bird) // A set of three animals<br>
      HashSet(dog, cat, bird) // A hash set of the same animals<br>
      Map('a' -&gt; 7, 'b' -&gt; 0) // A map from characters to integers<br>
      “Under the covers” each of the above lines is a call to the apply method
      of<br>
      some object. For instance, the third line above expands to:<br>
      List.apply(1.0, 2.0)<br>
      So this is a call to the apply method of the companion object of the List<br>
      class. That method takes an arbitrary number of arguments and constructs a<br>
      list from them. Every collection class in the Scala library has a
      companion<br>
      object with such an apply method. It does not matter whether the
      collection<br>
      class represents a concrete implementation, like List , Stream , or Vector
      ,<br>
      or whether it is an trait such as Seq , Set , or Traversable . In the
      latter case,<br>
      calling apply will produce some default implementation of the trait. Here
      are<br>
      some examples:<br>
      scala&gt; List(1, 2, 3)<br>
      res17: List[Int] = List(1, 2, 3)<br>
      scala&gt; Traversable(1, 2, 3)<br>
      res18: Traversable[Int] = List(1, 2, 3)<br>
      scala&gt; mutable.Traversable(1, 2, 3)<br>
      res19: scala.collection.mutable.Traversable[Int] =<br>
      ArrayBuffer(1, 2, 3)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      601Section 24.17<br>
      Chapter 24 · The Scala Collections API<br>
      Besides apply , every collection companion object also defines a member<br>
      empty , which returns an empty collection. So instead of List() you could<br>
      write List.empty , instead of Map() , Map.empty , and so on.<br>
      Descendants of Seq traits also provide other factory operations in their<br>
      companion objects. These are summarized in Table 24.13. In short, there’s:<br>
      concat , which concatenates an arbitrary number of traversables to-<br>
      gether,<br>
      fill and tabulate , which generate single or multi-dimensional se-<br>
      quences of given dimensions initialized by some expression or tabu-<br>
      lating function,<br>
      range , which generates integer sequences with some constant step<br>
      length, and<br>
      iterate , which generates the sequence resulting from repeated appli-<br>
      cation of a function to a start element.<br>
      Table 24.13 · Factory methods for sequences<br>
      What it is<br>
      S.empty<br>
      S(x, y, z)<br>
      S.concat(xs, ys, zs)<br>
      S.fill(n)(e)<br>
      What it does<br>
      The empty sequence<br>
      A sequence consisting of elements x , y , and z<br>
      The sequence obtained by concatenating the<br>
      elements of xs , ys , and zs<br>
      A sequence of length n where each element is<br>
      computed by expression e<br>
      S.fill(m, n)(e) A sequence of sequences of dimension m × n<br>
      where each element is computed by expression e<br>
      (exists also in higher dimensions)<br>
      S.tabulate(n)(f) A sequence of length n where the element at each<br>
      index i is computed by f( i )<br>
      S.tabulate(m, n)(f) A sequence of sequences of dimension m × n<br>
      where the element at each index (i, j) is computed<br>
      by f( i , j ) (exists also in higher dimensions)<br>
      S.range(start, end) The sequence of integers start . . . end - 1<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      602Section 24.18<br>
      Chapter 24 · The Scala Collections API<br>
      Table 24.13 · continued<br>
      S.range(start, end, step) The sequence of integers starting with start and<br>
      progressing by step increments up to, and<br>
      excluding, the end value<br>
      S.iterate(x, n)(f) The sequence of length n with elements x , f(x) ,<br>
      f(f(x)) , . . .<br>
      24.18<br>
      Conversions between Java and Scala collections<br>
      Like Scala, Java has a rich collections library. There are many
      similarities<br>
      between the two. For instance, both libraries know iterators, iterables,
      sets,<br>
      maps, and sequences. But there are also important differences. In
      particular,<br>
      the Scala libraries put much more emphasis on immutable collections, and<br>
      provide many more operations that transform a collection into a new one.<br>
      Sometimes you might need to convert from one collection framework<br>
      to the other. For instance, you might want to access to an existing Java<br>
      collection, as if it were a Scala collection. Or you might want to pass
      one<br>
      of Scala’s collections to a Java method that expects the Java counterpart.
      It<br>
      is quite easy to do this, because Scala offers implicit conversions
      between<br>
      all the major collection types in the JavaConversions object. In
      particular,<br>
      you will find bidirectional conversions between the following types:<br>
      Iterator<br>
      Iterator<br>
      Iterable<br>
      Iterable<br>
      mutable.Buffer<br>
      mutable.Set<br>
      mutable.Map<br>
      ⇔<br>
      ⇔<br>
      ⇔<br>
      ⇔<br>
      ⇔<br>
      ⇔<br>
      ⇔<br>
      java.util.Iterator<br>
      java.util.Enumeration<br>
      java.lang.Iterable<br>
      java.util.Collection<br>
      java.util.List<br>
      java.util.Set<br>
      java.util.Map<br>
      To enable these conversions, simply import like this:<br>
      scala&gt; import collection.JavaConversions._<br>
      import collection.JavaConversions._<br>
      You have now automatic conversions between Scala collections and their<br>
      corresponding Java collections.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      603Section 24.18<br>
      Chapter 24 · The Scala Collections API<br>
      scala&gt; import collection.mutable._<br>
      import collection.mutable._<br>
      scala&gt; val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3)<br>
      jul: java.util.List[Int] = [1, 2, 3]<br>
      scala&gt; val buf: Seq[Int] = jul<br>
      buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)<br>
      scala&gt; val m: java.util.Map[String, Int] =<br>
      HashMap("abc" -&gt; 1, "hello" -&gt; 2)<br>
      m: java.util.Map[String,Int] = {hello=2, abc=1}<br>
      Internally, these conversion work by setting up a “wrapper” object that
      for-<br>
      wards all operations to the underlying collection object. So collections
      are<br>
      never copied when converting between Java and Scala. An interesting prop-<br>
      erty is that if you do a round-trip conversion from, say, a Java type to
      its<br>
      corresponding Scala type, and back to the same Java type, you end up with<br>
      the identical collection object you started with.<br>
      Some other common Scala collections exist that can also be converted<br>
      to Java types, but for which no corresponding conversion exists in the
      other<br>
      direction. These are:<br>
      Seq<br>
      mutable.Seq<br>
      Set<br>
      Map<br>
      ⇒<br>
      ⇒<br>
      ⇒<br>
      ⇒<br>
      java.util.List<br>
      java.util.List<br>
      java.util.Set<br>
      java.util.Map<br>
      Because Java does not distinguish between mutable and immutable collec-<br>
      tions in their type, a conversion from, say, collection.immutable.List<br>
      will yield a java.util.List , on which all attempted mutation operations<br>
      will throw an UnsupportedOperationException . Here’s an example:<br>
      scala&gt; val jul: java.util.List[Int] = List(1, 2, 3)<br>
      jul: java.util.List[Int] = [1, 2, 3]<br>
      scala&gt; jul.add(7)<br>
      java.lang.UnsupportedOperationException<br>
      at java.util.AbstractList.add(AbstractList.java:131)<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      604Section 24.19<br>
      Chapter 24 · The Scala Collections API<br>
      24.19<br>
      Migrating from Scala 2.7<br>
      If you have existing applications written in Scala 2.7, porting them to
      use<br>
      the new collections should be almost automatic. There are only a couple of<br>
      possible issues to take care of.<br>
      Generally, the old functionality of Scala 2.7 collections has been left<br>
      in place. Some features have been deprecated, which means they will re-<br>
      moved in some future release. You will get a deprecation warning when<br>
      you compile code that makes use of these features in Scala 2.8. In a few<br>
      places deprecation was unfeasible, because the operation in question was
      re-<br>
      tained in 2.8, but changed in meaning or performance characteristics.
      These<br>
      cases will be flagged with migration warnings when compiled under 2.8. To<br>
      get full deprecation and migration warnings with suggestions how to change<br>
      your code, pass the -deprecation and -Xmigration flags to scalac . 8 You<br>
      can also pass the same options to the scala interpreter to get the
      warnings<br>
      in an interactive session. Example:<br>
      &gt;scala -deprecation -Xmigration<br>
      Welcome to Scala version 2.8.1.<br>
      Type in expressions to have them evaluated.<br>
      Type :help for more information.<br>
      scala&gt; val xs = List((1, 2), (3, 4))<br>
      xs: List[(Int, Int)] = List((1,2), (3,4))<br>
      scala&gt; List.unzip(xs)<br>
      &lt;console&gt;:7: warning: method unzip in object List is<br>
      deprecated: use xs.unzip instead of List.unzip(xs)<br>
      List.unzip(xs)<br>
      ˆ<br>
      res0: (List[Int], List[Int]) = (List(1, 3),List(2, 4))<br>
      scala&gt; xs.unzip<br>
      res1: (List[Int], List[Int]) = (List(1, 3),List(2, 4))<br>
      scala&gt; val m = xs.toMap<br>
      m: scala.collection.immutable.Map[Int,Int] = Map((1,2), (3,4))<br>
      scala&gt; m.keys<br>
      &lt;console&gt;:8: warning: method keys in trait MapLike has<br>
      8 Note<br>
      that -Xmigration is an extended option, so it starts with an X .<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      605Section 24.20<br>
      Chapter 24 · The Scala Collections API<br>
      changed semantics: As of 2.8, keys returns Iterable[A]<br>
      rather than Iterator[A].<br>
      m.keys<br>
      ˆ<br>
      res2: Iterable[Int] = Set(1, 3)<br>
      Two parts of the old libraries were replaced wholesale. For these depre-<br>
      cation warnings were not feasible.<br>
      1. The previous scala.collection.jcl package is gone. This pack-<br>
      age tried to mimic some of the Java collection library design in Scala,<br>
      but in doing so broke many symmetries. Most people who wanted<br>
      Java collections bypassed jcl and used java.util directly. Scala 2.8<br>
      offers automatic conversion mechanisms between both collection li-<br>
      braries in the JavaConversions object, described in Section 24.18,<br>
      which replaces the jcl package.<br>
      2. Projections have been generalized and cleaned up and are now avail-<br>
      able as views . It seems that projections were used rarely, so not much<br>
      code should be affected by this change.<br>
      So, if your code uses either jcl or projections there might be some minor<br>
      rewriting to do.<br>
      24.20<br>
      Conclusion<br>
      You’ve now seen how to use Scala’s collection in great detail. Scala’s
      collec-<br>
      tions take the approach of giving you powerful building blocks rather than
      a<br>
      number of ad hoc utility methods. Putting together two or three such
      building<br>
      blocks allows you to express an enormous number of useful computations.<br>
      This style of library is especially effective due to Scala having a light
      syntax<br>
      for function literals, and due to it providing many collection types that
      are<br>
      persistent and immutable.<br>
      This chapter has shown collections from the point of view of a program-<br>
      mer using the collection library. The next chapter will show you how the<br>
      collections are built and how you can add your own collection types.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      606Chapter 25<br>
      The Architecture of Scala Collections<br>
      This chapter describes the architecture of the Scala collections framework<br>
      in detail. Compared to what you learned in Chapter 24 you will find out<br>
      more about the internal workings of the framework. You will also learn<br>
      how this architecture helps you define your own collections in a few lines
      of<br>
      code, while reusing the overwhelming part of collection functionality from<br>
      the framework.<br>
      Chapter 24 enumerated a large number of collection operations, which<br>
      exist uniformly on many different collection implementations. Implementing<br>
      every collection operation anew for every collection type would lead to an<br>
      enormous amount of code, most of which would be copied from somewhere<br>
      else. Such code duplication could lead to inconsistencies over time, when
      an<br>
      operation is added or modified in one part of the collection library but
      not in<br>
      others. The principal design objective of the new collections framework
      was<br>
      to avoid any duplication, defining every operation in as few places as
      possi-<br>
      ble. 1 The design approach was to implement most operations in collection<br>
      “templates” that can be flexibly inherited from individual base classes
      and<br>
      implementations. This chapter explains these templates and other classes<br>
      and traits that constitute the “building blocks” of the framework, as well
      as<br>
      the construction principles they support.<br>
      1 Ideally,<br>
      everything should be defined in one place only, but there are a few
      exceptions<br>
      where things needed to be redefined.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · IndexSection
      25.1<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      package scala.collection.generic<br>
      class Builder[-Elem, +To] {<br>
      def +=(elem: Elem): this.type<br>
      def result(): To<br>
      def clear()<br>
      def mapResult(f: To =&gt; NewTo): Builder[Elem, NewTo] = ...<br>
      }<br>
      Listing 25.1 · An outline of the Builder class.<br>
      25.1<br>
      Builders<br>
      Almost all collection operations are implemented in terms of traversals
      and<br>
      builders. Traversals are handled by Traversable ’s foreach method, and<br>
      building new collections is handled by instances of class Builder . List-<br>
      ing 25.1 presents a slightly abbreviated outline of this class.<br>
      You can add an element x to a builder b with b += x . There’s also syntax<br>
      to add more than one element at once, for instance b += (x, y) , and b ++=
      xs<br>
      work as for buffers (in fact, buffers are an enriched version of
      builders). The<br>
      result() method returns a collection from a builder. The state of the
      builder<br>
      is undefined after taking its result, but it can be reset into a new empty
      state<br>
      using clear() . Builders are generic in both the element type, Elem , and
      in<br>
      the type, To , of collections they return.<br>
      Often, a builder can refer to some other builder for assembling the el-<br>
      ements of a collection, but then would like to transform the result of the<br>
      other builder, for example to give it a different type. This task is
      simplified<br>
      by method mapResult in class Builder . Suppose for instance you have an<br>
      array buffer buf . Array buffers are builders for themselves, so taking
      the<br>
      result() of an array buffer will return the same buffer. If you want to
      use<br>
      this buffer to produce a builder that builds arrays, you can use mapResult<br>
      like this:<br>
      scala&gt; val buf = new ArrayBuffer[Int]<br>
      buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()<br>
      scala&gt; val bldr = buf mapResult (_.toArray)<br>
      bldr: scala.collection.mutable.Builder[Int,Array[Int]]<br>
      = ArrayBuffer()<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      608Section 25.2<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      package scala.collection<br>
      class TraversableLike[+Elem, +Repr] {<br>
      def newBuilder: Builder[Elem, Repr] // deferred<br>
      def foreach[U](f: Elem =&gt; U)<br>
      // deferred<br>
      ...<br>
      def filter(p: Elem =&gt; Boolean): Repr = {<br>
      val b = newBuilder<br>
      foreach { elem =&gt; if (p(elem)) b += elem }<br>
      b.result<br>
      }<br>
      }<br>
      Listing 25.2 · Implementation of filter in TraversableLike .<br>
      The result value, bldr , is a builder that uses the array buffer, buf , to
      col-<br>
      lect elements. When a result is demanded from bldr , the result of buf is<br>
      computed, which yields the array buffer buf itself. This array buffer is
      then<br>
      mapped with _.toArray to an array. So the end result is that bldr is a<br>
      builder for arrays.<br>
      25.2<br>
      Factoring out common operations<br>
      The main design objectives of the collection library redesign were to
      have, at<br>
      the same time, natural types and maximal sharing of implementation code.
      In<br>
      particular, Scala’s collections follow the “same-result-type” principle:
      wher-<br>
      ever possible, a transformation method on a collection will yield a
      collection<br>
      of the same type. For instance, the filter operation should yield, on
      every<br>
      collection type, an instance of the same collection type. Applying filter<br>
      on a List should give a List ; applying it on a Map should give a Map ,
      and<br>
      so on. In the rest of this section, you will find out how this is
      achieved.<br>
      The fast track<br>
      The material in this section is a bit more dense than usual and might<br>
      require some time to absorb. If you want to move ahead quickly, you could<br>
      skip the remainder of this section and move on to Section 25.3 on<br>
      page 614 where you will learn with concrete examples how to integrate<br>
      your own collection classes in the framework.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      609Section 25.2<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      The Scala collection library avoids code duplication and achieves the<br>
      “same-result-type” principle by using generic builders and traversals over<br>
      collections in so-called implementation traits. These traits are named
      with<br>
      a Like suffix; for instance, IndexedSeqLike is the implementation trait
      for<br>
      IndexedSeq , and similarly, TraversableLike is the implementation trait<br>
      for Traversable . Collection classes such as Traversable or IndexedSeq<br>
      inherit all their concrete method implementations from these traits.
      Imple-<br>
      mentation traits have two type parameters instead of one for normal
      collec-<br>
      tions. They parameterize not only over the collection’s element type, but<br>
      also over the collection’s representation type, i.e., the type of the
      underlying<br>
      collection, such as Seq[I] or List[T] . For instance, here is the header
      of<br>
      trait TraversableLike :<br>
      trait TraversableLike[+Elem, +Repr] { ... }<br>
      The type parameter, Elem , stands for the element type of the traversable<br>
      whereas the type parameter Repr stands for its representation. There are<br>
      no constraints on Repr . In particular Repr might be instantiated to a
      type<br>
      that is itself not a subtype of Traversable . That way, classes outside
      the<br>
      collections hierarchy such as String and Array can still make use of all<br>
      operations defined in a collection implementation trait.<br>
      Taking filter as an example, this operation is defined once for all col-<br>
      lection classes in the trait TraversableLike . An outline of the relevant<br>
      code is shown in Listing 25.2. The trait declares two abstract methods,<br>
      newBuilder and foreach , which are implemented in concrete collection<br>
      classes. The filter operation is implemented in the same way for all col-<br>
      lections using these methods. It first constructs a new builder for the
      repre-<br>
      sentation type Repr , using newBuilder . It then traverses all elements of
      the<br>
      current collection, using foreach . If an element x satisfies the given
      predi-<br>
      cate p (i.e., p(x) is true ), it is added with the builder. Finally, the
      elements<br>
      collected in the builder are returned as an instance of the Repr
      collection<br>
      type by calling the builder’s result method.<br>
      A bit more complicated is the map operation on collections. For instance,<br>
      if f is a function from String to Int , and xs is a List[String] , then<br>
      xs map f should give a List[Int] . Likewise, if ys is an Array[String] ,<br>
      then ys map f should give a Array[Int] . The problem is how to achieve
      that<br>
      without duplicating the definition of the map method in lists and arrays.
      The<br>
      newBuilder / foreach framework shown in Listing 25.2 is not sufficient for<br>
      this because it only allows creation of new instances of the same
      collection<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      610Section 25.2<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      type whereas map needs an instance of the same collection type
      constructor,<br>
      but possibly with a different element type.<br>
      What’s more, even the result type constructor of a function like map<br>
      might depend in non-trivial ways on the other argument types. Here is an<br>
      example:<br>
      scala&gt; import collection.immutable.BitSet<br>
      import collection.immutable.BitSet<br>
      scala&gt; val bits = BitSet(1, 2, 3)<br>
      bits: scala.collection.immutable.BitSet = BitSet(1, 2, 3)<br>
      scala&gt; bits map (_ * 2)<br>
      res13: scala.collection.immutable.BitSet = BitSet(2, 4, 6)<br>
      scala&gt; bits map (_.toFloat)<br>
      res14: scala.collection.immutable.Set[Float]<br>
      = Set(1.0, 2.0, 3.0)<br>
      If you map the doubling function _ * 2 over a bit set you obtain another
      bit<br>
      set. However, if you map the function (_.toFloat) over the same bit set,<br>
      the result is a general Set[Float] . Of course, it can’t be a bit set
      because<br>
      bit sets contain Int s, not Float s.<br>
      Note that map ’s result type depends on the type of function that’s passed<br>
      to it. If the result type of that function argument is again an Int , the
      result of<br>
      map is a BitSet , but if the result type of the function argument is
      something<br>
      else, the result of map is just a Set . You’ll find out soon how this
      type-<br>
      flexibility is achieved in Scala.<br>
      The problem with BitSet is not an isolated case. Here are two more<br>
      interactions with the interpreter that both map a function over a map:<br>
      scala&gt; Map("a" -&gt; 1, "b" -&gt; 2) map { case (x, y) =&gt; (y, x) }<br>
      res3: scala.collection.immutable.Map[Int,java.lang.String]<br>
      = Map(1 -&gt; a, 2 -&gt; b)<br>
      scala&gt; Map("a" -&gt; 1, "b" -&gt; 2) map { case (x, y) =&gt; y }<br>
      res4: scala.collection.immutable.Iterable[Int]<br>
      = List(1, 2)<br>
      The first function swaps two arguments of a key/value pair. The result of<br>
      mapping this function is again a map, but now going in the other
      direction.<br>
      In fact, the first expression yields the inverse of the original map,
      provided<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      611Section 25.2<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      it is invertible. The second function, however, maps the key/value pair to<br>
      an integer, namely its value component. In that case, we cannot form a Map<br>
      from the results, but we still can form an Iterable , a supertrait of Map
      .<br>
      You might ask, why not restrict map so that it can always return the same<br>
      kind of collection? For instance, on bit sets map could accept only Int
      -to-<br>
      Int functions and on maps it could only accept pair-to-pair functions. Not<br>
      only are such restrictions undesirable from an object-oriented modeling
      point<br>
      of view, they are illegal because they would violate the Liskov
      substitution<br>
      principle: A Map is an Iterable . So every operation that’s legal on an<br>
      Iterable must also be legal on a Map .<br>
      Scala solves this problem instead with overloading: not the simple form<br>
      of overloading inherited by Java (that would not be flexible enough), but
      the<br>
      more systematic form of overloading that’s provided by implicit
      parameters.<br>
      def map[B, That](p: Elem =&gt; B)<br>
      (implicit bf: CanBuildFrom[B, That, This]): That = {<br>
      val b = bf(this)<br>
      for (x &lt;- this) b += f(x)<br>
      b.result<br>
      }<br>
      Listing 25.3 · Implementation of map in TraversableLike .<br>
      Listing 25.3 shows trait TraversableLike ’s implementation of map . It’s<br>
      quite similar to the implementation of filter shown in Listing 25.2. The<br>
      principal difference is that where filter used the newBuilder method,<br>
      which is abstract in class TraversableLike , map uses a builder factory<br>
      that’s passed as an additional implicit parameter of type CanBuildFrom .<br>
      package scala.collection.generic<br>
      trait CanBuildFrom[-From, -Elem, +To] {<br>
      // Creates a new builder<br>
      def apply(from: From): Builder[Elem, To]<br>
      }<br>
      Listing 25.4 · The CanBuildFrom trait.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      612Section 25.2<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      Listing 25.4 shows the definition of the trait CanBuildFrom , which rep-<br>
      resents builder factories. It has three type parameters: Elem indicates
      the<br>
      element type of the collection to be built, To indicates the type of
      collec-<br>
      tion to build, and From indicates the type for which this builder factory<br>
      applies. By defining the right implicit definitions of builder factories,
      you<br>
      can tailor the right typing behavior as needed. Take class BitSet as an<br>
      example. Its companion object would contain a builder factory of type<br>
      CanBuildFrom[BitSet, Int, BitSet] . This means that when operating<br>
      on a BitSet you can construct another BitSet provided the type of the col-<br>
      lection to build is Int . If this is not the case, you can always fall
      back to a<br>
      different implicit builder factory, this time implemented in mutable.Set
      ’s<br>
      companion object. The type of this more general builder factory, where A
      is<br>
      a generic type parameter, is:<br>
      CanBuildFrom[Set[_], A, Set[A]]<br>
      This means that when operating on an arbitrary Set (expressed by the exis-<br>
      tential type Set[_] ) you can build a Set again, no matter what the
      element<br>
      type A is. Given these two implicit instances of CanBuildFrom , you can
      then<br>
      rely on Scala’s rules for implicit resolution to pick the one that’s
      appropriate<br>
      and maximally specific.<br>
      So implicit resolution provides the correct static types for tricky
      collec-<br>
      tion operations such as map . But what about the dynamic types?
      Specifically,<br>
      say you have a list value that has Iterable as its static type, and you
      map<br>
      some function over that value:<br>
      scala&gt; val xs: Iterable[Int] = List(1, 2, 3)<br>
      xs: Iterable[Int] = List(1, 2, 3)<br>
      scala&gt; val ys = xs map (x =&gt; x * x)<br>
      ys: Iterable[Int] = List(1, 4, 9)<br>
      The static type of ys above is Iterable , as expected. But its dynamic
      type<br>
      is (and should be) still List ! This behavior is achieved by one more in-<br>
      direction. The apply method in CanBuildFrom is passed the source col-<br>
      lection as argument. Most builder factories for generic traversables (in
      fact<br>
      all except builder factories for leaf classes) forward the call to a
      method<br>
      genericBuilder of a collection. The genericBuilder method in turn<br>
      calls the builder that belongs to the collection in which it is defined.
      So<br>
      Scala uses static implicit resolution to resolve constraints on the types
      of<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      613Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      map , and virtual dispatch to pick the best dynamic type that corresponds
      to<br>
      these constraints.<br>
      abstract class Base<br>
      case object A extends Base<br>
      case object T extends Base<br>
      case object G extends Base<br>
      case object U extends Base<br>
      object Base {<br>
      val fromInt: Int =&gt; Base = Array(A, T, G, U)<br>
      val toInt: Base =&gt; Int = Map(A -&gt; 0, T -&gt; 1, G -&gt; 2, U -&gt;
      3)<br>
      }<br>
      Listing 25.5 · RNA Bases.<br>
      25.3<br>
      Integrating new collections<br>
      What needs to be done if you want to integrate a new collection class, so
      that<br>
      it can profit from all predefined operations at the right types? In this
      section<br>
      you’ll be walked through two examples that do this.<br>
      Integrating sequences<br>
      Say you want to create a new sequence type for RNA strands, which are<br>
      sequences of bases A (adenine), T (thymine), G (guanine), and U (uracil).<br>
      The definitions for bases are easily set up as shown in Listing 25.5.<br>
      Every base is defined as a case object that inherits from a common ab-<br>
      stract class Base . The Base class has a companion object that defines two<br>
      functions that map between bases and the integers 0 to 3. You can see in
      the<br>
      examples two different ways to use collections to implement these
      functions.<br>
      The toInt function is implemented as a Map from Base values to integers.<br>
      The reverse function, fromInt , is implemented as an array. This makes use<br>
      of the fact that both maps and arrays are functions because they inherit
      from<br>
      the Function1 trait.<br>
      The next task is to define a class for strands of RNA. Conceptually, a<br>
      strand of RNA is simply a Seq[Base] . However, RNA strands can get quite<br>
      long, so it makes sense to invest some work in a compact representation.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      614Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      import collection.IndexedSeqLike<br>
      import collection.mutable.{Builder, ArrayBuffer}<br>
      import collection.generic.CanBuildFrom<br>
      final class RNA1 private (val groups: Array[Int],<br>
      val length: Int) extends IndexedSeq[Base] {<br>
      import RNA1._<br>
      def apply(idx: Int): Base = {<br>
      if (idx &lt; 0 || length &lt;= idx)<br>
      throw new IndexOutOfBoundsException<br>
      Base.fromInt(groups(idx / N) &gt;&gt; (idx % N * S) &amp; M)<br>
      }<br>
      }<br>
      object RNA1 {<br>
      // Number of bits necessary to represent group<br>
      private val S = 2<br>
      // Number of groups that fit in an Int<br>
      private val N = 32 / S<br>
      // Bitmask to isolate a group<br>
      private val M = (1 &lt;&lt; S) - 1<br>
      def fromSeq(buf: Seq[Base]): RNA1 = {<br>
      val groups = new Array[Int]((buf.length + N - 1) / N)<br>
      for (i &lt;- 0 until buf.length)<br>
      groups(i / N) |= Base.toInt(buf(i)) &lt;&lt; (i % N * S)<br>
      new RNA1(groups, buf.length)<br>
      }<br>
      def apply(bases: Base*) = fromSeq(bases)<br>
      }<br>
      Listing 25.6 · RNA strands class, first version.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      615Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      Because there are only four bases, a base can be identified with two bits,
      and<br>
      you can therefore store sixteen bases as two-bit values in an integer. The<br>
      idea, then, is to construct a specialized subclass of Seq[Base] , which
      uses<br>
      this packed representation.<br>
      Listing 25.6 presents the first version of this class. It will be refined
      later.<br>
      The class RNA1 has a constructor that takes an array of Int s as its first
      argu-<br>
      ment. This array contains the packed RNA data, with sixteen bases in each<br>
      element, except for the last array element, which might be partially
      filled.<br>
      The second argument, length , specifies the total number of bases on the<br>
      array (and in the sequence). Class RNA1 extends IndexedSeq[Base] . Trait<br>
      IndexedSeq , which comes from package scala.collection.immutable ,<br>
      defines two abstract methods, length and apply . These need to be imple-<br>
      mented in concrete subclasses. Class RNA1 implements length automati-<br>
      cally by defining a parametric field (described in Section 10.6) of the
      same<br>
      name. It implements the indexing method apply with the code given in List-<br>
      ing 25.6. Essentially, apply first extracts an integer value from the
      groups<br>
      array, then extracts the correct two-bit number from that integer using
      right<br>
      shift ( &gt;&gt; ) and mask ( &amp; ). The private constants S , N , and M
      come from the RNA1<br>
      companion object. S specifies the size of each packet (i.e. two); N
      specifies<br>
      the number of two-bit packets per integer; and M is a bit mask that
      isolates<br>
      the lowest S bits in a word.<br>
      Note that the constructor of class RNA1 is private . This means that<br>
      clients cannot create RNA1 sequences by calling new , which makes sense,<br>
      because it hides the representation of RNA1 sequences in terms of packed<br>
      arrays from the user. If clients cannot see what the representation
      details of<br>
      RNA sequences are, it becomes possible to change these representation
      details<br>
      at any point in the future without affecting client code. In other words,
      this<br>
      design achieves a good decoupling of the interface of RNA sequences and<br>
      its implementation. However, if constructing an RNA sequence with new is<br>
      impossible, there must be some other way to create new RNA sequences, else<br>
      the whole class would be rather useless. In fact there are two
      alternatives for<br>
      RNA sequence creation, both provided by the RNA1 companion object. The<br>
      first way is method fromSeq , which converts a given sequence of bases
      (i.e.,<br>
      a value of type Seq[Base] ) into an instance of class RNA1 . The fromSeq<br>
      method does this by packing all the bases contained in its argument
      sequence<br>
      into an array, then calling RNA1 ’s private constructor with that array
      and the<br>
      length of the original sequence as arguments. This makes use of the fact
      that<br>
      a private constructor of a class is visible in the class’s companion
      object.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      616Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      The second way to create an RNA1 value is provided by the apply method<br>
      in the RNA1 object. It takes a variable number of Base arguments and
      simply<br>
      forwards them as a sequence to fromSeq . Here are the two creation schemes<br>
      in action:<br>
      scala&gt; val xs = List(A, G, T, A)<br>
      xs: List[Product with Base] = List(A, G, T, A)<br>
      scala&gt; RNA1.fromSeq(xs)<br>
      res1: RNA1 = RNA1(A, G, T, A)<br>
      scala&gt; val rna1 = RNA1(A, U, G, G, T)<br>
      rna1: RNA1 = RNA1(A, U, G, G, T)<br>
      Adapting the result type of RNA methods<br>
      Here are some more interactions with the RNA1 abstraction:<br>
      scala&gt; rna1.length<br>
      res2: Int = 5<br>
      scala&gt; rna1.last<br>
      res3: Base = T<br>
      scala&gt; rna1.take(3)<br>
      res4: IndexedSeq[Base] = Vector(A, U, G)<br>
      The first two results are as expected, but the last result of taking the
      first<br>
      three elements of rna1 might not be. In fact, you see a IndexedSeq[Base]<br>
      as static result type and a Vector as the dynamic type of the result
      value.<br>
      You might have expected to see an RNA1 value instead. But this is not pos-<br>
      sible because all that was done in Listing 25.6 was making RNA1 extend<br>
      IndexedSeq . Class IndexedSeq , on the other hand, has a take method that<br>
      returns an IndexedSeq , and that’s implemented in terms of IndexedSeq ’s<br>
      default implementation, Vector . So that’s what you were seeing on the
      last<br>
      line of the previous interaction.<br>
      Now that you understand why things are the way they are, the next ques-<br>
      tion should be what needs to be done to change them? One way to do this<br>
      would be to override the take method in class RNA1 , maybe like this:<br>
      def take(count: Int): RNA1 = RNA1.fromSeq(super.take(count))<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      617Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      final class RNA2 private (<br>
      val groups: Array[Int],<br>
      val length: Int<br>
      ) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {<br>
      import RNA2._<br>
      override def newBuilder: Builder[Base, RNA2] =<br>
      new ArrayBuffer[Base] mapResult fromSeq<br>
      def apply(idx: Int): Base = // as before<br>
      }<br>
      Listing 25.7 · RNA strands class, second version.<br>
      This would do the job for take . But what about drop , or filter , or init
      ?<br>
      In fact there are over fifty methods on sequences that return again a se-<br>
      quence. For consistency, all of these would have to be overridden. This<br>
      looks less and less like an attractive option. Fortunately, there is a
      much eas-<br>
      ier way to achieve the same effect. The RNA class needs to inherit not
      only<br>
      from IndexedSeq , but also from its implementation trait IndexedSeqLike .<br>
      This is shown in Listing 25.7. The new implementation differs from the<br>
      previous one in only two aspects. First, class RNA2 now also extends from<br>
      IndexedSeqLike[Base, RNA2] . The IndexedSeqLike trait implements all<br>
      concrete methods of IndexedSeq in an extensible way. For instance, the re-<br>
      turn type of methods like take , drop , filter , or init is the second
      type<br>
      parameter passed to class IndexedSeqLike , i.e., RNA2 in Listing 25.7.<br>
      To be able to do this, IndexedSeqLike bases itself on the newBuilder<br>
      abstraction, which creates a builder of the right kind. Subclasses of
      trait<br>
      IndexedSeqLike have to override newBuilder to return collections of their<br>
      own kind. In class RNA2 , the newBuilder method returns a builder of type<br>
      Builder[Base, RNA2] .<br>
      To construct this builder, it first creates an ArrayBuffer , which itself<br>
      is a Builder[Base, ArrayBuffer] . It then transforms the ArrayBuffer<br>
      builder by calling its mapResult method to an RNA2 builder. The mapResult<br>
      method expects a transformation function from ArrayBuffer to RNA2 as its<br>
      parameter. The function given is simply RNA2.fromSeq , which converts an<br>
      arbitrary base sequence to an RNA2 value (recall that an array buffer is a
      kind<br>
      of sequence, so RNA2.fromSeq can be applied to it).<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      618Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      If you had left out the newBuilder definition, you would have gotten an<br>
      error message like the following:<br>
      RNA2.scala:5:<br>
      error:<br>
      overriding method newBuilder in trait<br>
      TraversableLike of type =&gt; scala.collection.mutable.Builder[Base,RNA2];<br>
      method newBuilder in trait GenericTraversableTemplate of type<br>
      =&gt; scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has<br>
      incompatible type<br>
      class RNA2 private (val groups:<br>
      Array[Int], val length:<br>
      Int)<br>
      ˆ<br>
      one error found<br>
      The error message is quite long and complicated, which reflects the
      intricate<br>
      way the collection libraries are put together. It’s best to ignore the
      infor-<br>
      mation about where the methods come from, because in this case it detracts<br>
      more than it helps. What remains is that a method newBuilder with result<br>
      type Builder[Base, RNA2] needed to be defined, but a method newBuilder<br>
      with result type Builder[Base,IndexedSeq[Base]] was found. The lat-<br>
      ter does not override the former. The first method, whose result type is<br>
      Builder[Base, RNA2] , is an abstract method that got instantiated at this<br>
      type in Listing 25.7 by passing the RNA2 type parameter to IndexedSeqLike
      .<br>
      The second method, of result type Builder[Base,IndexedSeq[Base]] , is<br>
      what’s provided by the inherited IndexedSeq class. In other words, the
      RNA2<br>
      class is invalid without a definition of newBuilder with the first result
      type.<br>
      With the refined implementation of the RNA class in Listing 25.7, meth-<br>
      ods like take , drop , or filter work now as expected:<br>
      scala&gt; val rna2 = RNA2(A, U, G, G, T)<br>
      rna2: RNA2 = RNA2(A, U, G, G, T)<br>
      scala&gt; rna2 take 3<br>
      res5: RNA2 = RNA2(A, U, G)<br>
      scala&gt; rna2 filter (U !=)<br>
      res6: RNA2 = RNA2(A, G, G, T)<br>
      Dealing with map and friends<br>
      However, there is another class of methods in collections that are not
      dealt<br>
      with yet. These methods do not always return the collection type exactly.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      619Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      They might return the same kind of collection, but with a different
      element<br>
      type. The classical example of this is the map method. If s is a Seq[Int]
      ,<br>
      and f is a function from Int to String , then s.map(f) would return a<br>
      Seq[String] . So the element type changes between the receiver and the<br>
      result, but the kind of collection stays the same.<br>
      There are a number of other methods that behave like map . For some<br>
      of them you would expect this (e.g., flatMap , collect ), but for others
      you<br>
      might not. For instance, the append method, ++ , also might return a
      result<br>
      of different type as its arguments—appending a list of String to a list of<br>
      Int would give a list of Any . How should these methods be adapted to RNA<br>
      strands? Ideally we’d expect that mapping bases to bases over an RNA
      strand<br>
      would yield again an RNA strand:<br>
      scala&gt; val rna = RNA(A, U, G, G, T)<br>
      rna: RNA = RNA(A, U, G, G, T)<br>
      scala&gt; rna map { case A =&gt; T case b =&gt; b }<br>
      res7: RNA = RNA(T, U, G, G, T)<br>
      Likewise, appending two RNA strands with ++ should yield again another<br>
      RNA strand:<br>
      scala&gt; rna ++ rna<br>
      res8: RNA = RNA(A, U, G, G, T, A, U, G, G, T)<br>
      On the other hand, mapping bases to some other type over an RNA strand<br>
      cannot yield another RNA strand because the new elements have the wrong<br>
      type. It has to yield a sequence instead. In the same vein appending
      elements<br>
      that are not of type Base to an RNA strand can yield a general sequence,
      but<br>
      it cannot yield another RNA strand.<br>
      scala&gt; rna map Base.toInt<br>
      res2: IndexedSeq[Int] = Vector(0, 3, 2, 2, 1)<br>
      scala&gt; rna ++ List("missing", "data")<br>
      res3: IndexedSeq[java.lang.Object] =<br>
      Vector(A, U, G, G, T, missing, data)<br>
      This is what you’d expect in the ideal case. But this is not what the RNA2
      class<br>
      as given in Listing 25.7 provides. In fact, if you ran the first two
      examples<br>
      above with instances of this class you would obtain:<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      620Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      scala&gt; val rna2 = RNA2(A, U, G, G, T)<br>
      rna2: RNA2 = RNA2(A, U, G, G, T)<br>
      scala&gt; rna2 map { case A =&gt; T case b =&gt; b }<br>
      res0: IndexedSeq[Base] = Vector(T, U, G, G, T)<br>
      scala&gt; rna2 ++ rna2<br>
      res1: IndexedSeq[Base] = Vector(A, U, G, G, T, A, U, G, G, T)<br>
      So the result of map and ++ is never an RNA strand, even if the element<br>
      type of the generated collection is a Base . To see how to do better, it<br>
      pays to have a close look at the signature of the map method (or of ++ ,<br>
      which has a similar signature). The map method is originally defined in
      class<br>
      scala.collection.TraversableLike with the following signature:<br>
      def map[B, That](f: A =&gt; B)<br>
      (implicit cbf: CanBuildFrom[Repr, B, That]): That<br>
      Here A is the type of elements of the collection, and Repr is the type of
      the<br>
      collection itself, that is, the second type parameter that gets passed to
      im-<br>
      plementation classes such as TraversableLike and IndexedSeqLike . The<br>
      map method takes two more type parameters, B and That . The B parameter<br>
      stands for the result type of the mapping function, which is also the
      element<br>
      type of the new collection. The That appears as the result type of map ,
      so it<br>
      represents the type of the new collection that gets created.<br>
      How is the That type determined? In fact it is linked to the other types
      by<br>
      an implicit parameter cbf , of type CanBuildFrom[Repr, B, That] . These<br>
      CanBuildFrom implicits are defined by the individual collection classes.
      In<br>
      essence, an implicit value of type CanBuildFrom[From, Elem, To] says:<br>
      “Here is a way, given a collection of type From , to build with elements
      of<br>
      type Elem a collection of type To .”<br>
      Now the behavior of map and ++ on RNA2 sequences becomes clearer.<br>
      There is no CanBuildFrom instance that creates RNA2 sequences, so the next<br>
      best available CanBuildFrom was found in the companion object of the in-<br>
      herited trait IndexedSeq . That implicit creates IndexedSeq s, and that’s<br>
      what you saw when applying map to rna2 .<br>
      To address this shortcoming, you need to define an implicit instance of<br>
      CanBuildFrom in the companion object of the RNA class. That instance<br>
      should have type CanBuildFrom[RNA, Base, RNA] . Hence, this instance<br>
      states that, given an RNA strand and a new element type Base , you can<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      621Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      final class RNA private (val groups: Array[Int], val length: Int)<br>
      extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {<br>
      import RNA._<br>
      // Mandatory re-implementation of ‘newBuilder‘ in ‘IndexedSeq‘<br>
      override protected[this] def newBuilder: Builder[Base, RNA] =<br>
      RNA.newBuilder<br>
      // Mandatory implementation of ‘apply‘ in ‘IndexedSeq‘<br>
      def apply(idx: Int): Base = {<br>
      if (idx &lt; 0 || length &lt;= idx)<br>
      throw new IndexOutOfBoundsException<br>
      Base.fromInt(groups(idx / N) &gt;&gt; (idx % N * S) &amp; M)<br>
      }<br>
      // Optional re-implementation of foreach,<br>
      // to make it more efficient.<br>
      override def foreach[U](f: Base =&gt; U): Unit = {<br>
      var i = 0<br>
      var b = 0<br>
      while (i &lt; length) {<br>
      b = if (i % N == 0) groups(i / N) else b &gt;&gt;&gt; S<br>
      f(Base.fromInt(b &amp; M))<br>
      i += 1<br>
      }<br>
      }<br>
      }<br>
      Listing 25.8 · RNA strands class, final version.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      622Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      object RNA {<br>
      private val S = 2<br>
      // number of bits in group<br>
      private val M = (1 &lt;&lt; S) - 1 // bitmask to isolate a group<br>
      private val N = 32 / S<br>
      // number of groups in an Int<br>
      def fromSeq(buf: Seq[Base]): RNA = {<br>
      val groups = new Array[Int]((buf.length + N - 1) / N)<br>
      for (i &lt;- 0 until buf.length)<br>
      groups(i / N) |= Base.toInt(buf(i)) &lt;&lt; (i % N * S)<br>
      new RNA(groups, buf.length)<br>
      }<br>
      def apply(bases: Base*) = fromSeq(bases)<br>
      def newBuilder: Builder[Base, RNA] =<br>
      new ArrayBuffer mapResult fromSeq<br>
      implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =<br>
      new CanBuildFrom[RNA, Base, RNA] {<br>
      def apply(): Builder[Base, RNA] = newBuilder<br>
      def apply(from: RNA): Builder[Base, RNA] = newBuilder<br>
      }<br>
      }<br>
      Listing 25.9 · RNA companion object—final version.<br>
      build another collection which is again an RNA strand. Listing 25.8 and<br>
      Listing 25.9 show the details. Compared to class RNA2 there are two im-<br>
      portant differences. First, the newBuilder implementation has moved from<br>
      the RNA class to its companion object. The newBuilder method in class<br>
      RNA simply forwards to this definition. Second, there is now an implicit<br>
      CanBuildFrom value in object RNA . To create such an object you need to<br>
      define two apply methods in the CanBuildFrom trait. Both create a new<br>
      builder for an RNA collection, but they differ in their argument list. The<br>
      apply() method simply creates a new builder of the right type. By con-<br>
      trast, the apply(from) method takes the original collection as argument.<br>
      This can be useful to adapt the dynamic type of builder’s return type to
      be<br>
      the same as the dynamic type of the receiver. In the case of RNA this does
      not<br>
      come into play because RNA is a final class, so any receiver of static
      type RNA<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      623Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      also has RNA as its dynamic type. That’s why apply(from) also simply calls<br>
      newBuilder , ignoring its argument.<br>
      That is it. The RNA class in Listing 25.8 implements all collection meth-<br>
      ods at their natural types. Its implementation requires a little bit of
      protocol.<br>
      In essence, you need to know where to put the newBuilder factories and the<br>
      canBuildFrom implicits. On the plus side, with relatively little code you
      get<br>
      a large number of methods automatically defined. Also, if you don’t intend<br>
      to do bulk operations like take , drop , map , or ++ on your collection
      you can<br>
      choose to not go the extra length and stop at the implementation shown in<br>
      Listing 25.6.<br>
      The discussion so far centered on the minimal amount of definitions<br>
      needed to define new sequences with methods that obey certain types. But
      in<br>
      practice you might also want to add new functionality to your sequences or<br>
      to override existing methods for better efficiency. An example of this is
      the<br>
      overridden foreach method in class RNA . foreach is an important method<br>
      in its own right because it implements loops over collections.
      Furthermore,<br>
      many other collection methods are implemented in terms of foreach . So it<br>
      makes sense to invest some effort optimizing the method’s implementation.<br>
      The standard implementation of foreach in IndexedSeq will simply select<br>
      every i ’th element of the collection using apply , where i ranges from 0
      to<br>
      the collection’s length minus one. So this standard implementation selects<br>
      an array element and unpacks a base from it once for every element in an<br>
      RNA strand. The overriding foreach in class RNA is smarter than that. For<br>
      every selected array element it immediately applies the given function to
      all<br>
      bases contained in it. So the effort for array selection and bit unpacking
      is<br>
      much reduced.<br>
      Integrating new sets and maps<br>
      As a second example you’ll learn how to integrate a new kind of map into<br>
      the collection framework. The idea is to implement a mutable map with<br>
      String as the type of keys by a “Patricia trie”. 2 The term Patricia is in
      fact<br>
      an abbreviation for “Practical Algorithm to Retrieve Information Coded in<br>
      Alphanumeric.” The idea is to store a set or a map as a tree where
      subsequent<br>
      character in a search key determines uniquely a descendant tree. For
      instance<br>
      a Patricia trie storing the three strings " abc ", " abd ", " al ", " all
      ", " xy " would<br>
      2 Morrison,<br>
      “PATRICIA—Practical Algorithm To Retrieve Information Coded in Al-<br>
      phanumeric” [Mor68]<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      624Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      a<br>
      y<br>
      l<br>
      b<br>
      c<br>
      x<br>
      d<br>
      l<br>
      Figure 25.1 · An example Patricia trie.<br>
      look like the tree given in Figure 25.1. To find the node corresponding to
      the<br>
      string "abc" in this trie, simply follow the subtree labeled " a ",
      proceed from<br>
      there to the subtree labeled " b ", to finally reach its subtree labeled "
      c ". If the<br>
      Patricia trie is used as a map, the value that’s associated with a key is
      stored<br>
      in the nodes that can be reached by the key. If it is a set, you simply
      store a<br>
      marker saying that the node is present in the set.<br>
      Patricia tries support very efficient lookups and updates. Another nice<br>
      feature is that they support selecting a subcollection by giving a prefix.
      For<br>
      instance, in the tree in Figure 25.1 you can obtain the sub-collection of
      all<br>
      keys that start with an " a " simply by following the " a " link from the
      root of<br>
      the tree.<br>
      Based on these ideas we will now walk you through the implementation<br>
      of a map that’s implemented as a Patricia trie. We call the map a
      PrefixMap ,<br>
      which means that it provides a method withPrefix that selects a submap of<br>
      all keys starting with a given prefix. We’ll first define a prefix map
      with the<br>
      keys shown in Figure 25.1:<br>
      scala&gt; val m = PrefixMap("abc" -&gt; 0, "abd" -&gt; 1, "al" -&gt; 2,<br>
      "all" -&gt; 3, "xy" -&gt; 4)<br>
      m: PrefixMap[Int] = Map((abc,0), (abd,1), (al,2), (all,3),<br>
      (xy,4))<br>
      Then calling withPrefix on m will yield another prefix map:<br>
      scala&gt; m withPrefix "a"<br>
      res14: PrefixMap[Int] = Map((bc,0), (bd,1), (l,2), (ll,3))<br>
      Listing 25.10 shows the definition of PrefixMap . This class is
      parameterized<br>
      with the type of associated values T , and extends mutable.Map[String, T]<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      625Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      import collection._<br>
      class PrefixMap[T]<br>
      extends mutable.Map[String, T]<br>
      with mutable.MapLike[String, T, PrefixMap[T]] {<br>
      var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty<br>
      var value: Option[T] = None<br>
      def get(s: String): Option[T] =<br>
      if (s.isEmpty) value<br>
      else suffixes get (s(0)) flatMap (_.get(s substring 1))<br>
      def withPrefix(s: String): PrefixMap[T] =<br>
      if (s.isEmpty) this<br>
      else {<br>
      val leading = s(0)<br>
      suffixes get leading match {<br>
      case None =&gt;<br>
      suffixes = suffixes + (leading -&gt; empty)<br>
      case _ =&gt;<br>
      }<br>
      suffixes(leading) withPrefix (s substring 1)<br>
      }<br>
      override def update(s: String, elem: T) =<br>
      withPrefix(s).value = Some(elem)<br>
      override def remove(s: String): Option[T] =<br>
      if (s.isEmpty) { val prev = value; value = None; prev }<br>
      else suffixes get (s(0)) flatMap (_.remove(s substring 1))<br>
      def iterator: Iterator[(String, T)] =<br>
      (for (v &lt;- value.iterator) yield ("", v)) ++<br>
      (for ((chr, m) &lt;- suffixes.iterator;<br>
      (s, v) &lt;- m.iterator) yield (chr +: s, v))<br>
      def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }<br>
      def -= (s: String): this.type<br>
      = { remove(s); this }<br>
      override def empty = new PrefixMap[T]<br>
      }<br>
      Listing 25.10 · An implementation of prefix maps with Patricia tries.<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      626Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      and mutable.MapLike[String, T, PrefixMap[T]] . You have seen this<br>
      pattern already for sequences in the RNA strand example; then as now
      inher-<br>
      iting an implementation class such as MapLike serves to get the right
      result<br>
      type for transformations such as filter .<br>
      A prefix map node has two mutable fields: suffixes and value . The<br>
      value field contains an optional value that’s associated with the node. It
      is<br>
      initialized to None . The suffixes field contains a map from characters to<br>
      PrefixMap values. It is initialized to the empty map.<br>
      You might ask why did we pick an immutable map as the implementation<br>
      type for suffixes ? Would not a mutable map have been more standard,<br>
      since PrefixMap as a whole is also mutable? The answer is that immutable<br>
      maps that contain only a few elements are very efficient in both space and<br>
      execution time. For instance, maps that contain fewer than 5 elements are<br>
      represented as a single object. By contrast, as described in Section 17.2,<br>
      the standard mutable map is a HashMap , which typically occupies around 80<br>
      bytes, even if it is empty. So if small collections are common, it’s
      better to<br>
      pick immutable over mutable. In the case of Patricia tries, we’d expect
      that<br>
      most nodes except the ones at the very top of the tree would contain only
      a<br>
      few successors. So storing these successors in an immutable map is likely
      to<br>
      be more efficient.<br>
      Now have a look at the first method that needs to be implemented for<br>
      a map: get . The algorithm is as follows: To get the value associated with<br>
      the empty string in a prefix map, simply select the optional value stored
      in<br>
      the root of the tree. Otherwise, if the key string is not empty, try to
      select<br>
      the submap corresponding to the first character of the string. If that
      yields<br>
      a map, follow up by looking up the remainder of the key string after its<br>
      first character in that map. If the selection fails, the key is not stored
      in the<br>
      map, so return with None . The combined selection over an option value is<br>
      elegantly expressed using flatMap . When applied to an optional value, ov
      ,<br>
      and a closure, f , which in turn returns an optional value, ov flatMap f
      will<br>
      succeed if both ov and f return a defined value. Otherwise ov flatMap f<br>
      will return None .<br>
      The next two methods to implement for a mutable map are += and -= . In<br>
      the implementation of Listing 25.10, these are defined in terms of two
      other<br>
      methods: update and remove .<br>
      The remove method is very similar to get , except that before return-<br>
      ing any associated value, the field containing that value is set to None .
      The<br>
      update method first calls withPrefix to navigate to the tree node that
      needs<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      627Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      to be updated, then sets the value field of that node to the given value.
      The<br>
      withPrefix method navigates through the tree, creating sub-maps as neces-<br>
      sary if some prefix of characters is not yet contained as a path in the
      tree.<br>
      The last abstract method to implement for a mutable map is iterator .<br>
      This method needs to produce an iterator that yields all key/value pairs
      stored<br>
      in the map. For any given prefix map this iterator is composed of the
      follow-<br>
      ing parts: First, if the map contains a defined value, Some(x) , in the
      value<br>
      field at its root, then ("", x) is the first element returned from the
      iterator.<br>
      Furthermore, the iterator needs to traverse the iterators of all submaps
      stored<br>
      in the suffixes field, but it needs to add a character in front of every
      key<br>
      string returned by those iterators. More precisely, if m is the submap
      reached<br>
      from the root through a character chr , and (s, v) is an element returned<br>
      from m.iterator , then the root’s iterator will return (chr +: s, v)
      instead.<br>
      This logic is implemented quite concisely as a concatenation of two for
      ex-<br>
      pressions in the implementation of the iterator method in Listing 25.10.<br>
      The first for expression iterates over value.iterator . This makes use of<br>
      the fact that Option values define an iterator method that returns either
      no<br>
      element, if the option value is None , or exactly one element x , if the
      option<br>
      value is Some(x) .<br>
      Note that there is no newBuilder method defined in PrefixMap . There<br>
      is no need to, because maps and sets come with default builders, which are<br>
      instances of class MapBuilder . For a mutable map the default builder
      starts<br>
      with an empty map and then adds successive elements using the map’s +=<br>
      method. Mutable sets behave the same. The default builders for immutable<br>
      maps and sets use the non-destructive element addition method + , instead
      of<br>
      method += .<br>
      However, in all these cases, to build the right kind of set or map, you
      need<br>
      to start with an empty set or map of this kind. This is provided by the
      empty<br>
      method, which is the last method defined in PrefixMap . In Listing 25.10,<br>
      this method simply returns a fresh PrefixMap .<br>
      We’ll now turn to the companion object PrefixMap , which is shown in<br>
      Listing 25.11. In fact it is not strictly necessary to define this
      companion<br>
      object, as class PrefixMap can stand well on its own. The main purpose of<br>
      object PrefixMap is to define some convenience factory methods. It also<br>
      defines a CanBuildFrom implicit to make typing work out better.<br>
      The two convenience methods are empty and apply . The same methods<br>
      are present for all other collections in Scala’s collection framework so
      it<br>
      makes sense to define them here, too. With the two methods, you can write<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      628Section 25.3<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      import scala.collection.mutable.{Builder, MapBuilder}<br>
      import scala.collection.generic.CanBuildFrom<br>
      object PrefixMap extends {<br>
      def empty[T] = new PrefixMap[T]<br>
      def apply[T](kvs: (String, T)*): PrefixMap[T] = {<br>
      val m: PrefixMap[T] = empty<br>
      for (kv &lt;- kvs) m += kv<br>
      m<br>
      }<br>
      def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =<br>
      new MapBuilder[String, T, PrefixMap[T]](empty)<br>
      implicit def canBuildFrom[T]<br>
      : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =<br>
      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {<br>
      def apply(from: PrefixMap[_]) = newBuilder[T]<br>
      def apply() = newBuilder[T]<br>
      }<br>
      }<br>
      Listing 25.11 · The companion object for prefix maps.<br>
      PrefixMap literals like you do for any other collection:<br>
      scala&gt; PrefixMap("hello" -&gt; 5, "hi" -&gt; 2)<br>
      res0: PrefixMap[Int] = Map((hello,5), (hi,2))<br>
      scala&gt; PrefixMap.empty[String]<br>
      res2: PrefixMap[String] = Map()<br>
      The other member in object PrefixMap is an implicit CanBuildFrom in-<br>
      stance. It has the same purpose as the CanBuildFrom definition in the last<br>
      section: to make methods like map return the best possible type. For
      instance,<br>
      consider map ping a function over the key/value pairs of a PrefixMap . As<br>
      long as that function produces pairs of strings and some second type, the<br>
      result collection will again be a PrefixMap . Here’s an example:<br>
      scala&gt; res0 map { case (k, v) =&gt; (k + "!", "x" * v) }<br>
      res8: PrefixMap[String] = Map((hello!,xxxxx), (hi!,xx))<br>
      Cover · Overview · Contents · Discuss · Suggest · Glossary · Index<br>
      629Section 25.4<br>
      Chapter 25 · The Architecture of Scala Collections<br>
      The given function argument takes the key/value bindings of the prefix map<br>
      res0 and produces pairs of strings. The result of the map is a PrefixMap ,<br>
      this time with value type String instead of Int . Without the canBuildFrom<br>
      implicit in PrefixMap the result would just have been a general mutable<br>
      map, not a prefix map.<br>
      Summary<br>
      To summarize, if you want to fully integrate a new collection class into
      the<br>
      framework you need to pay attention to the following points:<br>
      1. Decide whether the collection should be mutable or immutable.<br>
      2. Pick the right base traits for the collection.<br>
      3. Inherit from the right implementation trait to implement most collec-<br>
      tion operations.<br>
      4. If you want map and similar operations to return instances of your col-<br>
      lection type, provide an implicit CanBuildFrom in your class’s com-<br>
      panion object.<br>
      25.4<br>
      Conclusion<br>
      You have now seen how Scala’s collections are built and how you can build<br>
      new kinds of collections. Because of Scala’s rich support for abstraction,<br>
      each new collection type can have a large number of methods without having<br>
      to reimplement them all over again.</p>
  </body>
</html>
