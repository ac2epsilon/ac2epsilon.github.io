<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_javascript_promises_">JavaScript Promises: вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Jake Archibald
Human boy working on web standards at Google</p></div>
<div class="paragraph"><p>Розробники, підготуйтеся до ключового моменту в історії веб-розробки.</p></div>
<div class="paragraph"><p><em>Починається барабанний дріб</em></p></div>
<div class="ulist"><ul>
<li>
<p>
Обіцянки нарешті надійшли до JavaScript!
</p>
</li>
</ul></div>
<div class="paragraph"><p><em>Вибухають феєрверхи, зверху дощить блискучий папір, натовп стає несамовитим</em></p></div>
<div class="paragraph"><p>У цей момент ви потрапляєте в одну з таких категорій:</p></div>
<div class="ulist"><ul>
<li>
<p>
Люди підбадьорюють вас, але ви не впевнені, у чому вся суєта. Можливо, ви навіть не впевнені, що таке «обіцянка». Ви би знизали плечима, але вага блискучого паперу важить на ваших плечах. Якщо так, не хвилюйтеся з цього приводу, мені знадобилися віки, щоб розібратися, чому я повинен дбати про ці речі. Ви, мабуть, хочете почати на початку.
</p>
</li>
<li>
<p>
Ви рубаєте кулаком повітря! Настав ваш час, так? Ви раніше використовували ці Promise, але вас турбує факт, що всі реалізації мають трохи інший API. Який API для офіційної версії JavaScript? Ви, мабуть, хочете почати з термінології.
</p>
</li>
<li>
<p>
Ви про це вже знали і насміхаєтесь над тими, хто стрибає вгору і вниз, ніби це для них новина. Знайдіть хвилину, щоб поласувати своєю перевагою, а потім направляйтеся прямо до посилання API.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="____">Що це за метушня?</h3>
<div class="paragraph"><p>JavaScript є однопоточним, тобто два біти скрипту не можуть працювати одночасно; вони повинні виконуватись один за одним. У веб-переглядачах JavaScript поділяє потік із завантаженням інших речей, що відрізняються від браузера до браузера. Але зазвичай JavaScript знаходиться в тій самій черзі, що і малювання, оновлення стилів та обробка дій користувача (наприклад, виділення тексту та взаємодія з елементами управління формами). Активність в одній з цих речей затримує інші.</p></div>
<div class="paragraph"><p>Як притаманно людині, ви багатопоточні. Ви можете друкувати декількома пальцями, можете вести машину і підтримувати розмову одночасно. Єдина функція блокування, з якою ми вимушені мати справу, - це чхання, де всю поточну активність потрібно призупинити на час чихання. Це дуже дратує, особливо коли ви їдете та намагаєтесь вести розмову. Ви не хочете писати код, що чихає.</p></div>
<div class="paragraph"><p>Ви, ймовірно, використовували події та зворотні виклики, щоб уникнути цього. Ось події:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">img1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.img-1&#39;</span><span class="p">);</span>

<span class="nx">img1</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// завантажено зображення</span>
<span class="p">});</span>

<span class="nx">img1</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ачч, все зламано</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Це зовсім не чхає. Ми отримуємо зображення, додаємо пару слухачів, потім JavaScript може припинити виконання, поки не викликається один із цих слухачів.</p></div>
<div class="paragraph"><p>На жаль, у наведеному вище прикладі можливо, що події відбувалися ще до того, як ми почали їх слухати, тому нам потрібно обійти це, використовуючи властивість зображень <code>"complete"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">img1</span> <span class="k">=</span> <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">img</span><span class="o">-</span><span class="mi">1</span><span class="err">&#39;</span><span class="o">);</span>

<span class="n">function</span> <span class="n">loaded</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// завантажено зображення</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">img1</span><span class="o">.</span><span class="n">complete</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">loaded</span><span class="o">();</span>
<span class="o">}</span>
<span class="k">else</span> <span class="o">{</span>
  <span class="n">img1</span><span class="o">.</span><span class="n">addEventListener</span><span class="o">(</span><span class=" -Symbol">&#39;load</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">loaded</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">img1</span><span class="o">.</span><span class="n">addEventListener</span><span class="o">(</span><span class=" -Symbol">&#39;error</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// ачч, все зламано</span>
<span class="o">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не відловлює зображення, які мали помилку, перш ніж ми отримали можливість їх слухати; на жаль, DOM не дає нам способу це зробити. Крім того, це завантаження одного зображення. Речі стають ще складнішими, якщо ми хочемо знати, коли завантажився набір зображень.</p></div>
</div>
<div class="sect2">
<h3 id="______">Події - це не завжди найкращий спосіб</h3>
<div class="paragraph"><p>Events are great for things that can happen multiple times on the same object—keyup, touchstart etc. With those events you don&#8217;t really care about what happened before you attached the listener. But when it comes to async success/failure, ideally you want something like this:
Події чудово підходять для речей, які можуть відбуватися багаторазово на одному об’єкті - клавіатурі, сенсорній панелі і т.п. З тими подіями вам не дуже важливо, що сталося до того, як ви приєднали слухача. Але якщо мова йде про асинхронні успіх/невдачу, в ідеалі вам потрібно щось подібне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">img1</span><span class="o">.</span><span class="n">callThisIfLoadedOrWhenLoaded</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// завантажене</span>
<span class="o">}).</span><span class="n">orIfFailedCallThis</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// не вдалося</span>
<span class="o">});</span>

<span class="c1">// та потім...</span>
<span class="n">whenAllTheseHaveLoaded</span><span class="o">([</span><span class="kt">img1</span>, <span class="kt">img2</span><span class="o">]).</span><span class="n">callThis</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// всі завантажені</span>
<span class="o">}).</span><span class="n">orIfSomeFailedCallThis</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// одна або декілька помилок</span>
<span class="o">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те, що роблять обіцянки, але з кращим назвами. Якщо в елементах HTML зображень був би метод <code>"ready"</code>, який повернув обіцянку, ми могли б зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">img1</span><span class="o">.</span><span class="n">ready</span><span class="o">().</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// завантажене</span>
<span class="o">},</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// не вдалося</span>
<span class="o">});</span>

<span class="c1">// та потім...</span>
<span class="nc">Promise</span><span class="o">.</span><span class="n">all</span><span class="o">([</span><span class="kt">img1.ready</span><span class="o">()</span>, <span class="kt">img2.ready</span><span class="o">()]).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// всі завантажені</span>
<span class="o">},</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// одна або декілька помилок</span>
<span class="o">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, обіцянки схожі на слухачів подій, за винятком:</p></div>
<div class="ulist"><ul>
<li>
<p>
Обіцянка може вдатися або провалитися лише один раз. Вона не може досягти успіху чи невдачі двічі, а також не може перейти від успіху до невдачі чи навпаки.
</p>
</li>
<li>
<p>
Якщо обіцянка вдалася або не вдалася, і ви пізніше додасте зворотний виклик успіху/невдачі, буде викликано правильний зворотний виклик, навіть якщо подія відбулася раніше.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Це надзвичайно корисно для асинхронних успіху/невдачі, оскільки вас менше цікавить точний час, коли щось стало доступним, і більше зацікавлені в реакції на результат.</p></div>
</div>
<div class="sect2">
<h3 id="__">Термінологія обіцянок</h3>
<div class="paragraph"><p>Домен Денікола вибірково прочитав першу чернетку цієї статті і оцінив мене на "двійку" з термінології. Він помістив мене під варту, змусив 100 разів копіювати <em>States and Fates</em> і написав занепокоєний лист моїм батькам. Незважаючи на це, у мене все ще багато мішанини в термінології, але ось основи:</p></div>
<div class="paragraph"><p>Обіцянка може бути:</p></div>
<div class="ulist"><ul>
<li>
<p>
виконана - дія, що стосується обіцянки, вдалася
</p>
</li>
<li>
<p>
відхилена - дії, пов'язані з обіцянкою, не вдалися
</p>
</li>
<li>
<p>
підвішена - ще не виконана або відхилена
</p>
</li>
<li>
<p>
визначена - виконана або відхилена
</p>
</li>
</ul></div>
<div class="paragraph"><p>Специфікація також використовує термін <em>thenable</em> для опису об'єкта, який є подібним до обіцянок, оскільки він має метод <code>then</code>. Цей термін нагадує мені про екс-менеджера з футболу Англії Террі Венаблеса, тому я буду використовувати його якомога менше.</p></div>
</div>
<div class="sect2">
<h3 id="_____javascript">Обіцянки з'являються у JavaScript!</h3>
<div class="paragraph"><p>Обіцяння вже деякий час існують у формі бібліотек, таких як:</p></div>
<div class="ulist"><ul>
<li>
<p>
Q
</p>
</li>
<li>
<p>
when
</p>
</li>
<li>
<p>
WinJS
</p>
</li>
<li>
<p>
RSVP.js
</p>
</li>
</ul></div>
<div class="paragraph"><p>Вищезазначені та обіцянки JavaScript поділяють загальну, стандартизовану поведінку під назвою <code>Promises/A+</code>. Якщо ви користувач <code>jQuery</code>, у них є щось подібне під назвою <code>Deferred</code>. Однак <code>Deferred</code> не сумісні з <code>Promise/A+</code>, що робить їх трохи відмінними та менш корисними, тому будьте обережні. <code>jQuery</code> також має тип <code>Promise</code>, але це лише підмножина <code>Deferred</code>, і має ті самі проблеми.</p></div>
<div class="paragraph"><p>Хоча впровадження обіцянок дотримується стандартизованої поведінки, їх загальний API відрізняється. Обіцяння JavaScript схожі в API для RSVP.js. Ось як ви створюєте обіцянку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">promise</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">resolve</span><span class="o">,</span> <span class="n">reject</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// робити щось, можливо, async, потім…</span>

  <span class="k">if</span> <span class="o">(</span><span class="cm">/* все вийшло успішно */</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="s">&quot;Все робить!&quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="n">reject</span><span class="o">(</span><span class="nc">Error</span><span class="o">(</span><span class="s">&quot;Воно поламалось&quot;</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Конструктор обіцянок приймає один аргумент, зворотний виклик з двома параметрами, <code>resolve</code> та <code>reject</code>. Зробіть щось із зворотного виклику, можливо, асинхроннно, потім викликаємо <code>resolve</code>, якщо все спрацювало, інакше викликається <code>reject</code>.</p></div>
<div class="paragraph"><p>Як <code>throw</code> в звичайному старому JavaScript, відхиляти з об'єктом <code>Error</code> прийнято, але не потрібно. Перевага об'єктів <code>Error</code> полягає в тому, що вони захоплюють слід стека, роблячи інструменти налагодження більш корисними.</p></div>
<div class="paragraph"><p>Ось як ви використовуєте цю обіцянку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">promise</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">result</span><span class="o">);</span> <span class="c1">// &quot;Все робить!&quot;</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">err</span><span class="o">);</span> <span class="c1">// Error: &quot;Воно поламалось&quot;</span>
<span class="o">});</span>
</pre></div></div></div>
<div class="paragraph"><p><code>then()</code> бере два аргументи, зворотний виклик для успішної справи та інший для випадку відмови. Обидва є необов’язковими, тому ви можете додати зворотний виклик лише у випадку успіху чи відмови.</p></div>
<div class="paragraph"><p>Обіцянки JavaScript почалися в DOM як <code>Future</code>, перейменовані на <code>Promise</code> і нарешті перейшли в JavaScript. Наявність їх у JavaScript, а не в DOM - це чудово, оскільки вони будуть доступні в контекстах JS, що не є браузером, таких як Node.js (чи вони використовуватимуть їх у своїх основних API-інтерфейсах - це інше питання).</p></div>
<div class="paragraph"><p>Хоча вони є функцією JavaScript, DOM не боїться ними користуватися. Насправді всі нові API DOM з асинхронними методами успіху/відмови будуть використовувати обіцянки. Це відбувається вже з управлінням квотами, подіями завантаження шрифтів, ServiceWorker, веб-MIDI, потоками Streams тощо.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Підтримка веб-переглядачів та поліфілл</h3>
<div class="paragraph"><p>Сьогодні вже є реалізація обіцянок у браузерах.</p></div>
<div class="paragraph"><p>Що стосується Chrome 32, Opera 19, Firefox 29, Safari 8 та Microsoft Edge, обіцянки включені за замовчуванням.</p></div>
<div class="paragraph"><p>Щоб довести браузери, яким не вистачає повної реалізації обіцянок, до відповідності специфікації, або додати обіцянки до інших браузерів та Node.js, використовуйте поліфілл (2k gzipped).</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Сумісність з іншими бібліотеками</h3>
<div class="paragraph"><p>API обіцянок JavaScript буде ставитись до будь-чого з методом <code>then()</code> як до обіцянки (або <em>thenable</em> мовою обіцяльників). Тому якщо ви використовуєте бібліотеку, яка повертає обіцянку Q, це добре, це буде добре грати з новим JavaScript обіцянки.</p></div>
<div class="paragraph"><p>Хоча, як я вже згадував, <code>Deferred</code> з jQuery дещо&#8230; безпораді. На щастя, ви можете привести їх в стандартні обіцянки, що варто зробити якнайшвидше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jsPromise</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">(</span><span class="n">$</span><span class="o">.</span><span class="n">ajax</span><span class="o">(</span><span class="err">&#39;</span><span class="o">/</span><span class="n">whatever</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>$.ajax</code> з jQuery повертає <code>Deferred</code>. Оскільки у нього є метод <code>then()</code>, <code>Promise.resolve()</code> може перетворити його в обіцянку JavaScript. Однак іноді <code>Deferred</code> передають кілька аргументів своїм зворотним викликам, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jqDeferred</span> <span class="k">=</span> <span class="n">$</span><span class="o">.</span><span class="n">ajax</span><span class="o">(</span><span class="err">&#39;</span><span class="o">/</span><span class="n">whatever</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">);</span>

<span class="n">jqDeferred</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">statusText</span><span class="o">,</span> <span class="n">xhrObj</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">xhrObj</span><span class="o">,</span> <span class="n">textStatus</span><span class="o">,</span> <span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як обіцянка JS буде ігнорувати всі, крім першого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">jsPromise</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">xhrObj</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>На щастя, це зазвичай те, чого ви хочете, або принаймні надає вам доступ до того, що ви хочете. Також майте на увазі, що jQuery не дотримується умов передачі об'єктів <code>Error</code> у відхилення.</p></div>
</div>
<div class="sect2">
<h3 id="_____3">Складний код асинхронізації спростився</h3>
<div class="paragraph"><p>Гаразд, давайте закодируємо деякі речі. Скажімо, ми хочемо:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Запустити спінер, щоб вказати на хід завантаження
</p>
</li>
<li>
<p>
Отримати JSON для оповідання, яке дає нам назву, та URL кожної глави
</p>
</li>
<li>
<p>
Додати заголовок на сторінку
</p>
</li>
<li>
<p>
Підтягувати кожну главу
</p>
</li>
<li>
<p>
Додати оповідання на сторінку
</p>
</li>
<li>
<p>
Зупинити спінер
</p>
<div class="olist lowerroman"><ol class="lowerroman">
<li>
<p>
але також повідомити користувачеві, якщо щось пішло не так по дорозі. Ми також хочемо зупинити спінер на цьому етапі також, інакше він буде продовжувати крутитися, запаморочитися і врізатися в якийсь інший інтерфейс користувача.
</p>
</li>
</ol></div>
</li>
</ol></div>
<div class="paragraph"><p>Звичайно, ви б не використовували JavaScript, щоб доставити оповідання, в вигляді HTML це робитиме швидше. Але ця схема є досить поширеною при роботі з API: Кілька підтягувань даних, а потім дещо зробіти, коли все буде зроблено.</p></div>
<div class="paragraph"><p>Для початку давайте розберемося з отриманням даних з мережі:</p></div>
</div>
<div class="sect2">
<h3 id="__xmlhttprequest">Обіцяннки XMLHttpRequest</h3>
<div class="paragraph"><p>Старі API будуть оновлені, щоб використовувати обіцянки, якщо це можливо в зворотно сумісний спосіб. <code>XMLHttpRequest</code> є головним кандидатом, але поки давайте напишемо просту функцію, щоб зробити запит <code>GET</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">get</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Повернути нову обіцянку.</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">resolve</span><span class="o">,</span> <span class="n">reject</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Зробіть звичайні речі XHR</span>
    <span class="k">var</span> <span class="n">req</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="o">();</span>
    <span class="n">req</span><span class="o">.</span><span class="n">open</span><span class="o">(</span><span class=" -Symbol">&#39;GET</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>

    <span class="n">req</span><span class="o">.</span><span class="n">onload</span> <span class="k">=</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// Це визивається по 404 тощо</span>
      <span class="c1">// тому перевірити стан</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Розв’яжіть обіцянку текстом відповіді</span>
        <span class="n">resolve</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="n">response</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// В іншому випадку відхиліть з текстом статусу</span>
        <span class="c1">// що, сподіваємось, буде значущою помилкою</span>
        <span class="n">reject</span><span class="o">(</span><span class="nc">Error</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="n">statusText</span><span class="o">));</span>
      <span class="o">}</span>
    <span class="o">};</span>

    <span class="c1">// Обробка мережевих помилок</span>
    <span class="n">req</span><span class="o">.</span><span class="n">onerror</span> <span class="k">=</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">reject</span><span class="o">(</span><span class="nc">Error</span><span class="o">(</span><span class="s">&quot;Network Error&quot;</span><span class="o">));</span>
    <span class="o">};</span>

    <span class="c1">// Зробити запит</span>
    <span class="n">req</span><span class="o">.</span><span class="n">send</span><span class="o">();</span>
  <span class="o">});</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер скористаємося цим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Success!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;Failed!&quot;</span><span class="o">,</span> <span class="n">error</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми можемо робити запити HTTP, не вводячи <code>XMLHttpRequest</code> вручну, що чудово, тому що чим менше мені доведеться бачити надихаючий верблюжий реєстр <code>XMLHttpRequest</code>, тим щасливішим буде моє життя.</p></div>
</div>
<div class="sect2">
<h3 id="_">Зціплення</h3>
<div class="paragraph"><p><code>then()</code> не є кінцем історії, ви можете зв'язати ланцюги <code>then</code> разом, щоб перетворити значення або виконувати додаткові дії асинхронізації одна за одною.</p></div>
<div class="sect3">
<h4 id="___2">Перетворення значень</h4>
<div class="paragraph"><p>Ви можете перетворити значення, просто повернувши нове значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">promise</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">resolve</span><span class="o">,</span> <span class="n">reject</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">resolve</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">});</span>

<span class="n">promise</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="k">val</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="k">val</span><span class="o">);</span> <span class="c1">// 1</span>
  <span class="k">return</span> <span class="k">val</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="k">val</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="k">val</span><span class="o">);</span> <span class="c1">// 3</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>В якості практичного прикладу повернемося до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Success!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Відповідь - JSON, але зараз ми отримуємо це як звичайний текст. Ми могли б змінити нашу функцію <code>get</code>, щоб використовувати тип відповіді JSON, але ми також могли вирішити її в області обіцянок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Yey JSON!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>JSON.parse()</code> приймає один аргумент і повертає перетворене значення, ми можемо зробити скорочення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Yey JSON!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Насправді ми могли б зробити функцію <code>getJSON()</code> дуже легко:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">url</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>getJSON()</code> все ще повертає обіцянку, яка отримує URL, а потім розбирає відповідь як JSON.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___">Черги асинхронних дій</h3>
<div class="paragraph"><p>Ви також можете зв'язати ланцюги для виконання послідовних асинхронних дій.</p></div>
<div class="paragraph"><p>Коли ви повертаєте щось із зворотного виклика <code>then()</code>, це трохи магія. Якщо ви повернете значення, наступне <code>then()</code> викликається з цим значенням. Однак якщо ви повернете щось подібне до обіцянки, наступне <code>then()</code> чекає на ній, і його викликають лише тоді, коли ця обіцянка набере чинності (успішно/неуспішно). Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">[</span><span class="err">0</span><span class="o">]);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Got chapter 1!&quot;</span><span class="o">,</span> <span class="n">chapter1</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми робимо <code>async</code> запит до <code>story.json</code>, який дає нам набір URL-адрес для запиту, тоді ми запитуємо першу з них. Ось коли обіцянки дійсно починають видрізнятись від простих моделей зворотного виклику.</p></div>
<div class="paragraph"><p>Ви навіть можете зробити метод швидкого доступу, щоб отримати всі глави:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">storyPromise</span><span class="o">;</span>

<span class="n">function</span> <span class="n">getChapter</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">storyPromise</span> <span class="k">=</span> <span class="n">storyPromise</span> <span class="o">||</span> <span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">);</span>

  <span class="k">return</span> <span class="n">storyPromise</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">[</span><span class="kt">i</span><span class="o">]);</span>
  <span class="o">})</span>
<span class="o">}</span>

<span class="c1">// і використовувати його просто:</span>
<span class="n">getChapter</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">chapter</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">getChapter</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">chapter</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не завантажуємо <code>story.json</code> до виклику <code>getChapter</code>, але наступного разу, коли викликається <code>getChapter</code>, ми повторно використовуємо обіцянку оповідання, тому <code>story.json</code> отримується лише один раз. Yay Promises!</p></div>
</div>
<div class="sect2">
<h3 id="___3">Обробка помилок</h3>
<div class="paragraph"><p>Як ми бачили раніше, <code>then()</code> бере два аргументи: один для <code>success</code>, один на <code>failure</code> (або виконати і відкинути, мовою обіцянки):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Success!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Failed!&quot;</span><span class="o">,</span> <span class="n">error</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете використовувати <code>catch()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Success!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Failed!&quot;</span><span class="o">,</span> <span class="n">error</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>У <code>catch()</code> немає нічого особливого, це лише цукор для <code>then(undefined, func)</code>, але він легше читається. Зауважимо, що два наведені вище приклади коду не поводяться однаково, останній еквівалентний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Success!&quot;</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">undefined</span><span class="o">,</span> <span class="n">function</span><span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Failed!&quot;</span><span class="o">,</span> <span class="n">error</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Різниця тонка, але надзвичайно корисна. Відхилення обіцянок пропускають вперед до наступного <code>then()</code> з викликом відхилення (або <code>catch()</code>, оскільки це рівнозначно). В <code>then(func1, func2)</code> будуть визиватись <code>func1</code> або <code>func2</code>, ніколи не обидва. Але з <code>then(func1).catch(func2)</code> будуть викликані обидва, якщо <code>func1</code> відмовить, оскільки вони є окремими кроками в ланцюзі. Візьміть наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">asyncThing1</span><span class="o">().</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">asyncThing2</span><span class="o">();</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">asyncThing3</span><span class="o">();</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">asyncRecovery1</span><span class="o">();</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">asyncThing4</span><span class="o">();</span>
<span class="o">},</span> <span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">asyncRecovery2</span><span class="o">();</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;Don&#39;t worry about it&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;All done!&quot;</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Потік вище дуже схожий на звичайний JavaScript <code>try/catch</code>: помилки, які трапляються в межах <code>try</code>, негайно переходять до блоку <code>catch()</code>. Ось наведене вище як блок-схема (тому що я люблю блок-схеми):</p></div>
<div class="paragraph"><p>Дотримуйтесь синіх ліній для обіцянок, які виконуються, або червоних для тих, що відхилені.</p></div>
</div>
<div class="sect2">
<h3 id="____javascript">Винятки та обіцянки JavaScript</h3>
<div class="paragraph"><p>Відхилення трапляються, коли обіцянку явно відхилено, але також неявно, якщо помилка передається у зворотному виклику конструктора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jsonPromise</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">resolve</span><span class="o">,</span> <span class="n">reject</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// JSON.parse видає помилку, якщо ви подаєте</span>
  <span class="c1">// недійсний JSON, тому це неявно відхиляє:</span>
  <span class="n">resolve</span><span class="o">(</span><span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="s">&quot;This ain&#39;t JSON&quot;</span><span class="o">));</span>
<span class="o">});</span>

<span class="n">jsonPromise</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Цього ніколи не буває:</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;It worked!&quot;</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Натомість це відбувається:</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;It failed!&quot;</span><span class="o">,</span> <span class="n">err</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що корисно виконувати всі роботи, пов'язані з обіцянками, всередині зворотного виклику конструктора обіцянок, тому помилки автоматично потрапляють і стають відхиленнями.</p></div>
<div class="paragraph"><p>Те саме стосується помилок, закинутих у зворотні виклики <code>then()</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">get</span><span class="o">(</span><span class="sc">&#39;/&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// Це ніколи не відбувається, &#39;/&#39; - це HTML-сторінка, а не JSON</span>
  <span class="c1">// це закидає JSON.parse</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;It worked!&quot;</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Натомість відбувається  це:</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;It failed!&quot;</span><span class="o">,</span> <span class="n">err</span><span class="o">);</span>
<span class="o">})</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____4">Обробка помилок на практиці</h3>
<div class="paragraph"><p>За допомогою нашої розповіді та розділів ми можемо використовувати <code>catch</code> для відображення помилки для користувача:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">[</span><span class="err">0</span><span class="o">]);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter1</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Failed to show chapter&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо витягнути <code>story.chapterUrls[0]</code> не вдасться (наприклад, <code>http 500</code> або користувач в автономному режимі), він буде пропускати всі наступні зворотні виклики успіху, що включає в себе той, який є в <code>getJSON()</code>, який намагається проаналізувати відповідь як JSON, а також пропустить зворотний виклик, який додає <code>chapter1.html</code> на сторінку. Замість цього він переходить на зворотний виклик <code>catch</code>. Як результат, на сторінку буде додане <code>"Failed to show chapter"</code>, якщо будь-яка з попередніх дій не вдалася.</p></div>
<div class="paragraph"><p>Як і при <code>try/catch</code> JavaScript, помилка перехоплюється, і подальший код продовжується, тому спінер завжди прихований, як ми і хочемо. Вищенаведене стає неблокуючою версією асинхронізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">story</span> <span class="k">=</span> <span class="n">getJSONSync</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">);</span>
  <span class="k">var</span> <span class="n">chapter1</span> <span class="k">=</span> <span class="n">getJSONSync</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">[</span><span class="err">0</span><span class="o">]);</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter1</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Failed to show chapter&quot;</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зробити <code>catch()</code> просто для ведення журналу, не відновлюючись від помилки. Для цього просто повторіть помилку. Це можна зробити за допомогою нашого методу <code>getJSON()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">url</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="nc">JSON</span><span class="o">.</span><span class="n">parse</span><span class="o">).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="s">&quot;getJSON failed for&quot;</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="n">err</span><span class="o">);</span>
    <span class="k">throw</span> <span class="n">err</span><span class="o">;</span>
  <span class="o">});</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Отже, нам вдалося отримати одну главу, але ми хочемо їх усіх. Давайте це зробимо.</p></div>
</div>
<div class="sect2">
<h3 id="_______2">Паралелізм та послідовність: найкраще з обох</h3>
<div class="paragraph"><p>Думати асинхронно непросто. Якщо ви намагаєтеся зійти з позначки, спробуйте написати код так, ніби він був синхронним. В цьому випадку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">story</span> <span class="k">=</span> <span class="n">getJSONSync</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">);</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

  <span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">forEach</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">chapter</span> <span class="k">=</span> <span class="n">getJSONSync</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">);</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
  <span class="o">});</span>

  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span>
</pre></div></div></div>
<div class="sect3">
<h4 id="___4">Спробуємо це</h4>
<div class="paragraph"><p>Це працює (див.код)! Але це синхронне і блокує браузер під час завантаження. Щоб зробити цю роботу асинхронною, ми використовуємо <code>then()</code> для того, щоб все відбувалося одне за одним.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

  <span class="c1">// TODO: для кожної URL-адреси в story.chapterUrls, fetch &amp; amp; показ</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// І ми все зробили!</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Ловіть будь-яку помилку, яка сталася по дорозі</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// Завжди ховайте спінер</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Але як ми можемо переглядати URL-адреси глав та отримувати їх у порядку? Це не працює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">forEach</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Підтягнути розділ</span>
  <span class="n">getJSON</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// і додайте його на сторінку</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
  <span class="o">});</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p><code>forEach</code> не обізнаний з асинхроністю, тому наші глави відображатимуться в будь-якому порядку, в якому вони  вони завантажуються, в основному так як написано Pulp Fiction. Це не Pulp Fiction, тож давайте це полагодимо.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___5">Створення послідовності</h3>
<div class="paragraph"><p>We want to turn our chapterUrls array into a sequence of promises. We can do that using then():
Ми хочемо перетворити наш масив <code>ChapterUrls</code> у послідовність обіцянок. Це можна зробити, використовуючи <code>then()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Почніть з обіцянки, яка завжди вирішується</span>
<span class="k">var</span> <span class="n">sequence</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">();</span>

<span class="c1">// Переглянемо URL-адреси нашого розділу</span>
<span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">forEach</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Додайте ці дії до кінця послідовності</span>
  <span class="n">sequence</span> <span class="k">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">);</span>
  <span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
  <span class="o">});</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Це перший раз, коли ми бачили <code>Promise.resolve()</code>, який створює обіцянку, яка вирішує будь-яке значення, яке ви надаєте. Якщо ви передасте йому екземпляр <code>Promise</code>, він просто поверне його (зверніть увагу: це зміна в специфікації, якої деякі реалізації ще не дотримуються). Якщо ви передаєте йому щось подібне до обіцянок (має метод <code>then()</code>), воно створює чистий <code>Promise</code>, який виконує/відкидає так само. Якщо ви передасте будь-яке інше значення, наприклад, <code>Promise.resolve ("Привіт")</code>, воно створює обіцянку, яка відповідає цьому значенню. Якщо ви визиваєте це без значення, як в коді вище, воно задовільняється <code>"undefined"</code>.</p></div>
<div class="paragraph"><p>Існує також <code>Promise.reject(val)</code>, який створює обіцянку, яка відхиляє значення, яке ви надаєте (або <code>"undefined"</code>).</p></div>
<div class="paragraph"><p>Ми можемо виправити наведений вище код за допомогою <code>array.reduce</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Перегляньте URL-адреси нашого розділу</span>
<span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">sequence</span><span class="o">,</span> <span class="n">chapterUrl</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Додайте ці дії до кінця послідовності</span>
  <span class="k">return</span> <span class="n">sequence</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">);</span>
  <span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
  <span class="o">});</span>
<span class="o">},</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робиться так само, як і в попередньому прикладі, але не потрібна окрема <code>sequence</code>. Наш зворотний виклик викликається для кожного елемента в масиві. <code>sequence</code> - спочатку <code>Promise.resolve()</code>, але для решти викликів <code>sequence</code> - це те, що ми повернули з попереднього виклика. <code>array.reduce</code> дійсно корисний для зведення масиву до єдиного значення, що в цьому випадку є обіцянкою.</p></div>
<div class="paragraph"><p>Давайте складемо все це разом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

  <span class="k">return</span> <span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">sequence</span><span class="o">,</span> <span class="n">chapterUrl</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Once the last chapter&#39;s promise is done…</span>
    <span class="k">return</span> <span class="n">sequence</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// …fetch the next chapter</span>
      <span class="k">return</span> <span class="n">getJSON</span><span class="o">(</span><span class="n">chapterUrl</span><span class="o">);</span>
    <span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// and add it to the page</span>
      <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
    <span class="o">});</span>
  <span class="o">},</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">());</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// And we&#39;re all done!</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Catch any error that happened along the way</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// Always hide the spinner</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>І ось у нас вона (див.код), повністю асинхронна версія версії синхронізації. Але ми можемо зробити краще. Наразі наша сторінка завантажується так:</p></div>
<div class="paragraph"><p>Браузери досить добре завантажують кілька речей одночасно, тому ми втрачаємо продуктивність, завантажуючи глави одна за одною. Що ми хочемо зробити, це завантажити їх одночасно, а потім обробити їх, коли всі вони прибули. На щастя, для цього є API:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Promise</span><span class="o">.</span><span class="n">all</span><span class="o">(</span><span class="n">arrayOfPromises</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">arrayOfResults</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//...</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Promise.all</code> приймає масив обіцянок і створює обіцянку, яка виконується, коли всі вони успішно виконані. Ви отримуєте масив результатів (незалежно від виконаних обіцянок) у тому ж порядку, що і обіцянки, які ви виконали.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

  <span class="c1">// Візьміть масив обіцянок і зачекайте їх усіх</span>
  <span class="k">return</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">all</span><span class="o">(</span>
    <span class="c1">// Мапа нашого масиву URL-адрес глав</span>
    <span class="c1">// на масив обіцянок глави json</span>
    <span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">getJSON</span><span class="o">)</span>
  <span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapters</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Тепер ми маємо розділи jsons по порядку! Проведіть цикл ...</span>
  <span class="n">chapters</span><span class="o">.</span><span class="n">forEach</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// і додати на сторінку</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
  <span class="o">});</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// зловити будь-яку помилку, що сталася до цього часу</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Залежно від з'єднання, це може бути на секунду швидше, ніж завантаження по одному (див.код), і це менше коду, ніж наша перша спроба. Глави можуть завантажуватися в будь-якому порядку, але вони відображаються на екрані в потрібному порядку.</p></div>
<div class="paragraph"><p>Однак ми можемо вдосконалити сприйняті результати. Коли прийде перша глава, ми повинні додати її на сторінку. Це дозволяє користувачеві почати читати до того, як залишилися інші глави. Коли прийде третій розділ, ми не додамо його до сторінки, оскільки користувач може не зрозуміти, що глава 2 відсутня. Коли прийде друга глава, ми можемо додати глави другу і три і т.д. і т.д.</p></div>
<div class="paragraph"><p>Для цього ми отримуємо JSON одночасно для всіх наших розділів, а потім створюємо послідовність, щоб додати їх до документа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">story</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

<span class="c1">// Мапа нашого масиву URL-адрес глав</span>
<span class="c1">// на масив обіцянок глав json.</span>
<span class="c1">// Це гарантує, що всі вони завантажуються паралельно.</span>
  <span class="k">return</span> <span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">getJSON</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">sequence</span><span class="o">,</span> <span class="n">chapterPromise</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Використовуйте reduce для ланцюга обіцянок разом,</span>
      <span class="c1">// додавання вмісту до сторінки для кожної глави</span>
      <span class="k">return</span> <span class="n">sequence</span><span class="o">.</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Зачекайте, поки все в послідовності,</span>
        <span class="c1">// тоді зачекайте, поки ця глава надійде.</span>
        <span class="k">return</span> <span class="n">chapterPromise</span><span class="o">;</span>
      <span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">chapter</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
      <span class="o">});</span>
    <span class="o">},</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">());</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
<span class="o">}).</span><span class="k">catch</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// зловити будь-яку помилку, яка сталася по дорозі</span>
  <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}).</span><span class="n">then</span><span class="o">(</span><span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>І ми їдемо (див.код), найкраще з обох! Щоб доставити весь вміст, потрібна однакова кількість часу, але користувач швидше отримує перший шматочок вмісту.</p></div>
<div class="paragraph"><p>У цьому тривіальному прикладі всі глави надходять приблизно в один і той же час, але користь відображення однієї за одною буде збільшена з більшими, більшими главами.</p></div>
<div class="paragraph"><p>Зробити вищезазначене за допомогою зворотних викликів або подій у стилі Node.js - це приблизно вдвічі більше коду, але що ще важливіше не так просто прослідкувати. Однак, це не є кінцем історії для обіцянок, коли в поєднанні з іншими функціями ES6 вони стають ще простішими.</p></div>
</div>
<div class="sect2">
<h3 id="______2">Бонусний раунд: обіцянки та генератори</h3>
<div class="paragraph"><p>Цей наступний біт включає цілу купу нових функцій ES6, але це не те, що вам потрібно зрозуміти, щоб використовувати обіцянки у своєму коді сьогодні. Ставтесь до цього як до трейлеру фільму щодо деяких майбутніх функцій блокбастера.</p></div>
<div class="paragraph"><p>ES6 також дає нам генератори, які дозволяють функціям виходити в певній точці, наприклад "повернутися", але пізніше відновити з тієї ж точки і стану, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="o">*</span><span class="n">addGenerator</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="k">yield</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Notice the star before the function name, this makes it a generator. The yield keyword is our return/resume point. We can use it like this:
Помітьте зірку перед назвою функції, це зробить її генератором. Ключове слово <code>yield</code> - це наша точка повернення / відновлення. Ми можемо використовувати його так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">adder</span> <span class="k">=</span> <span class="n">addGenerator</span><span class="o">();</span>
<span class="n">adder</span><span class="o">.</span><span class="n">next</span><span class="o">().</span><span class="n">value</span><span class="o">;</span> <span class="c1">// 0</span>
<span class="n">adder</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">value</span><span class="o">;</span> <span class="c1">// 5</span>
<span class="n">adder</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">value</span><span class="o">;</span> <span class="c1">// 10</span>
<span class="n">adder</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">value</span><span class="o">;</span> <span class="c1">// 15</span>
<span class="n">adder</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="mi">50</span><span class="o">).</span><span class="n">value</span><span class="o">;</span> <span class="c1">// 65</span>
</pre></div></div></div>
<div class="paragraph"><p>But what does this mean for promises? Well, you can use this return/resume behaviour to write async code that looks like (and is as easy to follow as) synchronous code. Don&#8217;t worry too much about understanding it line-for-line, but here&#8217;s a helper function that lets us use yield to wait for promises to settle:
Але що це означає для обіцянок? Ну, ви можете використовувати цю функцію повернення / відновлення для написання асинхронного коду, який виглядає як синхронний (і його так само просто слідувати). Не надто переживайте про розуміння кожного рядка, але ось функція помічника, яка дозволяє нам використовувати врожай, щоб чекати, коли обіцянки вирішаться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">spawn</span><span class="o">(</span><span class="n">generatorFunc</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">function</span> <span class="n">continuer</span><span class="o">(</span><span class="n">verb</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">result</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">result</span> <span class="k">=</span> <span class="n">generator</span><span class="o">[</span><span class="kt">verb</span><span class="o">](</span><span class="n">arg</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">reject</span><span class="o">(</span><span class="n">err</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="n">done</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">Promise</span><span class="o">.</span><span class="n">resolve</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="o">).</span><span class="n">then</span><span class="o">(</span><span class="n">onFulfilled</span><span class="o">,</span> <span class="n">onRejected</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">var</span> <span class="n">generator</span> <span class="k">=</span> <span class="n">generatorFunc</span><span class="o">();</span>
  <span class="k">var</span> <span class="n">onFulfilled</span> <span class="k">=</span> <span class="n">continuer</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">continuer</span><span class="o">,</span> <span class="s">&quot;next&quot;</span><span class="o">);</span>
  <span class="k">var</span> <span class="n">onRejected</span> <span class="k">=</span> <span class="n">continuer</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">continuer</span><span class="o">,</span> <span class="s">&quot;throw&quot;</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">onFulfilled</span><span class="o">();</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="olist lowerroman"><ol class="lowerroman">
<li>
<p>
який я досить сильно підсилив версією дослівного <code>fromQ</code>, але пристосований для обіцянок JavaScript. З цим ми можемо взяти наш останній приклад найкращого випадку, змішати його з вантажем нового добра ES6 і перетворити його на:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">spawn</span><span class="o">(</span><span class="n">function</span> <span class="o">*()</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// &#39;yield&#39; ефективно робить асинхронічне очікування,</span>
    <span class="c1">// повертаючи  результат обіцянки</span>
    <span class="n">let</span> <span class="n">story</span> <span class="k">=</span> <span class="k">yield</span> <span class="n">getJSON</span><span class="o">(</span><span class=" -Symbol">&#39;story</span><span class="o">.</span><span class="n">json</span><span class="err">&#39;</span><span class="o">);</span>
    <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">story</span><span class="o">.</span><span class="n">heading</span><span class="o">);</span>

    <span class="c1">// Мапа нашого масиву URL-адрес глави</span>
    <span class="c1">// на масив обіцянок глав json.</span>
    <span class="c1">// Це гарантує, що всі вони завантажуються паралельно.</span>
    <span class="n">let</span> <span class="n">chapterPromises</span> <span class="k">=</span> <span class="n">story</span><span class="o">.</span><span class="n">chapterUrls</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">getJSON</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">let</span> <span class="n">chapterPromise</span> <span class="n">of</span> <span class="n">chapterPromises</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Дочекайтеся готовності кожної глави, а потім додайте її на сторінку</span>
      <span class="n">let</span> <span class="n">chapter</span> <span class="k">=</span> <span class="k">yield</span> <span class="n">chapterPromise</span><span class="o">;</span>
      <span class="n">addHtmlToPage</span><span class="o">(</span><span class="n">chapter</span><span class="o">.</span><span class="n">html</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;All done&quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">catch</span> <span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// try/catch просто працює, сюди кидаються відхилені обіцянки</span>
    <span class="n">addTextToPage</span><span class="o">(</span><span class="s">&quot;Argh, broken: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="o">(</span><span class="err">&#39;</span><span class="o">.</span><span class="n">spinner</span><span class="err">&#39;</span><span class="o">).</span><span class="n">style</span><span class="o">.</span><span class="n">display</span> <span class="k">=</span> <span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">;</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Це працює точно так само, як і раніше, але так набагато простіше читати. Це працює в Chrome і Opera сьогодні (див. Код) і працює в Microsoft Edge, перейшовши до пункту <code>aabout:flags</code> та увімкнувши налаштування <code>Enable experimental JavaScript features</code>. Це буде включено за замовчуванням у наступній версії.</p></div>
<div class="paragraph"><p>Це об'єднує багато нового ES6: обіцянки, генератори, <code>let</code>, <code>for-of</code>. Коли ми даємо обіцянку, помічник <code>spawn</code> чекає, коли обіцянка вирішиться, і поверне остаточне значення. Якщо обіцянка відхиляється, <code>spawn</code> призводить до того, що наше твердження <code>yield</code> кидає виняток, який ми можемо зловити за допомогою звичайного JavaScript <code>try/catch</code>. Дивовижно просте асинхронне кодування!</p></div>
<div class="paragraph"><p>Ця модель є настільки корисною, вона надходить до ES7 у вигляді функції <code>async</code>. Це майже так само, як вище, але немає необхідності в методі <code>spawn</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___promise_api">Посилання на Promise API</h3>
<div class="paragraph"><p>Усі методи працюють у Chrome, Opera, Firefox, Microsoft Edge та Safari, якщо не зазначено інше. Поліфайл надає нижче для всіх браузерів.</p></div>
<div class="paragraph"><p><code>Promise.resolve(promise);</code>     Повертає обіцянку (лише у випадку, якщо <code>promise.constructor == Promise</code>)
<code>Promise.resolve(thenable);</code> Робить нову обіцянку від thenable. <code>Thenable</code> є подібне до обіцянок, наскільки воно має метод <code>then()</code>.
<code>Promise.resolve(obj);</code> Створює обіцянку, яка виконує obj. у цій ситуації.
<code>Promise.reject(obj);</code> Створює обіцянку, яка відхиляє obj. Для послідовності та налагодження (наприклад, сліди стека), obj повинен бути екземпляром помилки.
<code>Promise.all(array);</code>   Створює обіцянку, яка виконується, коли кожен елемент масиву виконується, і відхиляє, якщо (і коли) будь-який елемент відхиляє. Кожен елемент масиву передається <code>Promise.resolve</code>, тому масив може бути сумішшю об'єктів, що нагадують обіцянки та інших об'єктів. Значення виконання - це масив (по порядку) значень виконання. Значення відхилення - це перше значення відхилення.
<code>Promise.race(array);</code> Створює обіцянку, яка виконується, як тільки будь-який елемент виконується, або відхиляє, як тільки будь-який елемент відхиляє, що б не трапилося спочатку. Примітка: я не переконаний у корисності <code>Promise.race</code>; Я вважаю за краще протилежний <code>Promise.all</code>, який відхиляє лише, якщо всі елементи відхиляються.</p></div>
<div class="paragraph"><p>Конструктор</p></div>
<div class="paragraph"><p><code>new Promise(function(resolve, reject) {});</code></p></div>
<div class="paragraph"><p><code>resolve(thenable)</code>
Ваша обіцянка буде виконана/відхилена з результатом thenable</p></div>
<div class="paragraph"><p><code>resolve(obj)</code>
Ваша обіцянка виконується з obj</p></div>
<div class="paragraph"><p><code>reject(obj)</code>
Ваша обіцянка відхиляється з <code>obj</code>. Для послідовності та налагодження (наприклад, сліди стека), <code>obj</code> повинен бути екземпляром помилки. Будь-які помилки, викинуті у зворотний виклик конструктора, будуть неявно передані для <code>reject()</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Методи екземпляра</h3>
<div class="paragraph"><p><code>promise.then(onFulfilled, onRejected)</code> <code>onFulfilled</code> викликається, коли / якщо обіцянка вирішується. <code>onRejected</code> викликається, коли/якщо обіцянка відхиляється. Обидва є необов'язковими, якщо будь-який/обидва опущені, наступний <code>onFulfilled/onRejected</code> у ланцюзі викликається. Обидва зворотні виклики мають один параметр, значення виконання або причину відхилення. <code>then()</code> повертає нову обіцянку, еквівалентну значенню, яке ви повертаєте з програми <code>onFulfilled/onRejected</code> після проходження через <code>Promise.resolve</code>. Якщо в зворотному виклику видано помилку, повернута обіцянка відхиляється з цією помилкою.</p></div>
<div class="paragraph"><p><code>promis.catch (onRejected)</code> Цукор для <code>promise.then(undefined, onRejected)</code></p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-01-29 03:41:33 EET
</div>
</div>
</body>
</html>
