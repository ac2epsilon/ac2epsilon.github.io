:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== JavaScript: Що слід уникати

Ми подивимось на нецільове використання циклу `for… in`, оператора `==`, об'єкта `arguments` та `this`

Як і будь-яка інша мова програмування, у JavaScript є власний перелік найкращих практик для полегшення читання та обслуговування програм. У JavaScript багато складних деталей, тому є багато речей, яких слід уникати.

Ми можемо дотримуватися деяких найкращих практик, щоб зробити наш код JavaScript легким для читання.

У цій статті ми розглянемо більше конструкцій, яких нам слід уникати, включаючи нецільове використання циклу `for ... in`, оператору `==`, об'єкта `arguments` і `this`.

=== Неправильне використання циклу For…in

Цикл `for ... in` не повинен використовуватися для ітерації по масивах та об’єктах, схожі на масив. Наприклад, якщо у нас є:

[source,js]
----
const arr = ['a', 'b', 'c', 'd', 'e'];
for (let i in arr) {
  console.log(i)
}
----

Ми отримаємо:

----
0
1
2
3
4
----

Однак це неправильне використання `for...in` у циклі, оскільки він повинен переглядати перелічені властивості об'єкта та його прототипу, а не перебирати індекси масиву.

Порядок перерахування не гарантований, тому ми не можемо перебирати масив у порядку, що погано.

Цикл `for...in` також проходить через успадковані властивості, які перелічуються, що є ще однією проблемою.

Наприклад, якщо у нас є:

[source,js]
----
let obj = Object.create({
  foo: 1
})
obj.bar = 2;
for (let prop in obj) {
  console.log(prop);
}
----


Потім ми створюємо об’єкт-прототип з властивістю `foo`. Цикл `for ... in` прокручуватиме як перелічені властивості прототипу `obj`, так і `obj`.

Щоб не переглядати властивості його прототипу, ми можемо замість цього використовувати `Object.keys`:

[source,js]
----
for (let prop of Object.keys(obj)) {
  console.log(prop);
}
----

Ми можемо перебирати пару ключових значень `obj` без прототипу, якщо використовувати `Object.entries`:

[source,js]
----
for (let entry of Object.entries(obj)) {
  console.log(entry);
}
----

Для циклічного перегляду масивів та об’єктів, схожих на масив, замість цього слід використовувати цикл `for ... of`:

[source,js]
----
const arr = ['a', 'b', 'c', 'd', 'e'];
for (let a of arr) {
  console.log(a)
}
----

Тоді ми отримуємо записи масиву.

=== Візня з this

`this` об'єкт завжди є проблемою в JavaScript. Це відбувається тому, що він змінюється залежно від сфери застосування.

На щастя, в ES6 у нас є функції стрілок, які не змінюють значення `this` значення, якщо ми посилаємось на нього всередині. Це також означає, що ми не можемо змінити значення `this` через `call`, `bind` чи `apply`.

Наприклад, наступний код буде реєструвати об’єкт вікна:

Значення `this` не змінюється, навіть якщо ми намагаємось змінити його через `bind`.

Також у ES6 є синтаксис класу для створення `constructor` функцій, тому зрозуміло, що `this` повинно бути всередині класу, доки ми використовуємо методи класу та функції стрілок.

Методи класу матимуть клас, як значення `this`, а функції зі стрілками всередині класу матимуть для `this` однакове значення.

=== Оператор ==

Оператор `==` здійснює автоматичне перетворення типів перед порівнянням операндів на рівність. Це створює проблеми з різними типами даних, які вважаються однаковими.

Наприклад, `null == undefined` повертає `true`, чого ми, мабуть, не хочемо.

`null == undefined` повертає `true`, оскільки вони обоє хибні.

Щоб уникнути подібних питань, замість цього слід використовувати оператор `===`, що дозволить уникнути порівнянь таких типів операндів, що повертаються як істинні. Це тому, що `===` перевіряє тип кожного операнда на додаток до вмісту операнду.

=== Об'єкт arguments

Завдяки введенню `rest` оператора ми можемо остаточно уникнути використання об'єкта `arguments` для отримання аргументів, переданих у функцію.

Об'єкт `arguments` не слід використовувати з кількох причин. Одна полягає в тому, що це об’єкт, схожий на масив, який означає, що в ньому є такі властивості, як `length`, і його можна прокрутити за допомогою циклу `for`, але методи масиву, такі як `map` та `forEach`, не включаються до нього.

Також ми можемо отримати доступ до його записів за допомогою його індексу, який обманює, оскільки це насправді не масив.

Використання `arguments` також запобігає оптимізації коду за допомогою браузерних двигунів, а це означає, що продуктивність повільніше. Також об’єкт `arguments` недоступний у функціях стрілок.

Тому для доступу до додаткових аргументів, що перевищують перелічені параметри, замість цього слід використовувати `rest` оператор.

Наприклад, замість написання:

[source,js]
----
const add = function(){
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }
  return sum;
}
console.log(add(1, 2, 3, 4, 5));
----

Ми можемо написати:

[source,js]
----
const add = (...args) => args.reduce((a, b) => a + b, 0);
console.log(add(1, 2, 3, 4, 5));
----

Зауважте, що використовувати `rest` оператора набагато коротше, це `...args` частина підпису функції. `args` - це вже масив, тому у нас є всі доступні методи масиву.

=== Висновок

У сучасному JavaScript ми можемо відмовитись від безлічі старих конструкцій, щоб полегшити читання та підтримку нашого коду.

Ми можемо використовувати оператор `rest` замість об’єкта аргументів. Це тому, що оператор `rest` надає нам масив аргументів замість об’єкта, подібного до масиву.

Крім того, ми повинні уникати оператора `==` для порівняння рівності, оскільки він робить автоматичне перетворення типів перед порівнянням, яке ми можемо не хотіти.

Ми також повинні уникати возитися з `this`, використовуючи функції стрілок та синтаксис класу для функцій конструктора. Ці дві конструкції роблять значення цього набагато зрозумілішим. Ми використовуємо методи класів для класів і функції стрілок для функцій, які не є методом класу.

Нарешті, цикл `for ... in` не повинен використовуватися для циклічного перегляду масивів та об’єктів, схожих на масив, оскільки не гарантується порядок перерахунку в порядку, що призводить до несподіваних результатів.