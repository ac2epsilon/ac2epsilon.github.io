<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html
  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
    <meta name="generator" content="AsciiDoc 8.6.10" />
    <title>SVG.js</title>
    <style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
    <script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
  </head>
  <body class="book">
    <div id="header">
      <h1>SVG.js</h1>
    </div>
    <div id="content">
      <div id="preamble">
        <div class="sectionbody">
          <div class="paragraph">
            <p>Легковажна бібліотека для маніпуляції та анімації SVG.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___svg_js">Чому обирають SVG.js?</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js не має залежностей, та націлена бути малою як це можливо,
              при цьому провадячи повне покриття специфікації SVG. Якщо ви ще не
              переконані, ось декілька фактів.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="__">Вона тонка.</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js є легковажною. Цифри не брешуть, так що тут надається
              порівняння конкурентів. Майте на увазі, що це робить ту саму річ,
              але майже половиною довжини кода!</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___2">Вона швидка.</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js швидка. Очевидно, не така швидка, як ванільний js, але в
              багато разів швидше, ніж конкуренти.</p>
          </div>
          <div class="paragraph">
            <p>Індекс:</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  <code>rects</code>: генерує 10000 прямокутників
                </p>
              </li>
              <li>
                <p>
                  <code>fill</code>: генерує 10000 заповнених кольором
                  прямокутників
                </p>
              </li>
              <li>
                <p>
                  <code>gradient</code>: генерує 10000 прямокутників з
                  градієнтом кольору
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>Меньше - краще. Протестовано на Intel Core m5 @ 1.2GHz.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="____">Просто читається, незахаращений синтаксис.</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Створення та маніпуляція SVG з використанням самого JavaScript
              досить балакуче. Наприклад, просте створення рожевого квадрата
              потребує досить багато коду:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="c1">// Звичайний js</span>
<span class="kd">var</span> <span class="nx">ns</span> <span class="o">=</span> <span
class="s1">'http://www.w3.org/2000/svg'</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span
class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span
class="p">(</span><span class="s1">'drawing'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">svg</span> <span class="o">=</span> <span
class="nb">document</span><span class="p">.</span><span class="nx">createElementNS</span><span
class="p">(</span><span class="nx">ns</span><span class="p">,</span> <span class="s1">'svg'</span><span
class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">setAttributeNS</span><span
class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'width'</span><span
class="p">,</span> <span class="s1">'100%'</span><span class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">setAttributeNS</span><span
class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'height'</span><span
class="p">,</span> <span class="s1">'100%'</span><span class="p">)</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">appendChild</span><span
class="p">(</span><span class="nx">svg</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nb">document</span><span class="p">.</span><span class="nx">createElementNS</span><span
class="p">(</span><span class="nx">ns</span><span class="p">,</span> <span class="s1">'rect'</span><span
class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span
class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'width'</span><span
class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span
class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'height'</span><span
class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span
class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'fill'</span><span
class="p">,</span> <span class="s1">'#f06'</span><span class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">appendChild</span><span
class="p">(</span><span class="nx">rect</span><span class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>SVG.js провадить синтаксис, що одночасно стислий та його легко
              читати. Цей код робить те саме, що і js приклад вище:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="c1">// SVG.js</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span
class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">)</span>
  <span class="p">,</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">'#f06'</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Це тільки два рядка коду, замість десяти! Та при цьому значно
              менше повторів.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___">Шаленійте з анімацією</h2>
        <div class="sectionbody">
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span
class="o">=</span> <span class="nb">document</span><span class="p">.</span><span
class="nx">querySelector</span><span class="p">(</span><span class="s1">'input[type=text]'</span><span
class="p">)</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span
class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">).</span><span class="nx">viewbox</span><span class="p">(</span><span
class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span
class="mi">300</span><span class="p">,</span> <span class="mi">140</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span
class="nx">draw</span><span class="p">.</span><span class="nx">text</span><span
class="p">(</span><span class="kd">function</span><span class="p">(</span><span
class="nx">add</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span> <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span
class="p">)</span>
<span class="p">})</span>

<span class="nx">text</span>
        <span class="p">.</span><span class="nx">path</span><span class="p">(</span><span
class="s1">'M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80'</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">animate</span><span class="p">(</span><span
class="mi">1000</span><span class="p">,</span> <span class="s1">'&lt;&gt;'</span><span
class="p">)</span>
        <span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span
class="s1">'M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80'</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">loop</span><span class="p">(</span><span
class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span
class="p">)</span>

<span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span
class="p">(</span><span class="s1">'keyup'</span><span class="p">,</span> <span
class="nx">updateText</span><span class="p">(</span><span class="nx">text</span><span
class="p">))</span>

<span class="kd">function</span> <span class="nx">updateText</span><span class="p">(</span><span
class="nx">textPath</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span
class="p">{</span>
                <span class="nx">textPath</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span
class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___8230">Та більше…</h2>
        <div class="sectionbody">
          <div class="ulist">
            <ul>
              <li>
                <p>
                  анімація за розміром, позицією, трансформацією, колором, …
                </p>
              </li>
              <li>
                <p>
                  безболісне розширення, дякуючи модулярній структурі
                </p>
              </li>
              <li>
                <p>
                  доступність різноманітні корисні плагіни
                </p>
              </li>
              <li>
                <p>
                  уніфікований api між типами фігур щодо пересування, розміру,
                  центрування, …
                </p>
              </li>
              <li>
                <p>
                  прив'язка подій до елементів
                </p>
              </li>
              <li>
                <p>
                  повна підтримка для масок прозорості та шляхів відсічення
                </p>
              </li>
              <li>
                <p>
                  текстові шляхи, навіть анімовані
                </p>
              </li>
              <li>
                <p>
                  групи елементів
                </p>
              </li>
              <li>
                <p>
                  динамічні градієнти та шаблони
                </p>
              </li>
              <li>
                <p>
                  повністю документовано (ви дивитесь на це :)
                </p>
              </li>
            </ul>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_">Ліцензія</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js ліцензований за умовами MIT License.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___3">Журнал змін</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Цікавитесь, що змінилось в останньому релізі? Подивіться журнал
              змін.</p>
          </div>
        </div>
      </div>
      <h1 id="__2">Починаємо</h1>
      <div class="sect1">
        <h2 id="__3">Підготовка</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js вважає, що ви маєте HTML елемент з атрибутом <code>id</code>,
              створений та готовий служити як огортка. Щось таке:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>SVG.js<span
class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span
class="o">=</span><span class="s">"drawing"</span><span class="p">&gt;&lt;/</span><span
class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="__svg_">Створення SVG документу</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Далі використовуйте функцію SVG() для створення SVG документу в
              оточуючому елементі:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span
class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">).</span><span class="nx">size</span><span class="p">(</span><span class="mi">300</span><span
class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">)</span>
  <span class="p">.</span><span class="nx">attr</span><span class="p">({</span> <span
class="nx">fill</span><span class="o">:</span> <span class="s1">'#f06'</span> <span
class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Перший аргумент може бути або <code>id</code> елемента, або сам
              обраний елемент. Це буде генерувати такий вихід:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span
class="na">id</span><span class="o">=</span><span class="s">"drawing"</span><span
class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">svg</span> <span class="na">xmlns</span><span
class="o">=</span><span class="s">"http://www.w3.org/2000/svg"</span> <span class="na">version</span><span
class="o">=</span><span class="s">"1.1"</span> <span class="na">xmlns:xlink</span><span
class="o">=</span><span class="s">"http://www.w3.org/1999/xlink"</span> <span class="na">width</span><span
class="o">=</span><span class="s">"300"</span> <span class="na">height</span><span
class="o">=</span><span class="s">"300"</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">width</span><span
class="o">=</span><span class="s">"100"</span> <span class="na">height</span><span
class="o">=</span><span class="s">"100"</span> <span class="na">fill</span><span
class="o">=</span><span class="s">"#f06"</span><span class="p">&gt;&lt;/</span><span
class="nt">rect</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>По замовчанню малюнок svg слідує розмірам свого батька, в цьому
              випадку <code>#drawing</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span
class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">).</span><span class="nx">size</span><span class="p">(</span><span class="s1">'100%'</span><span
class="p">,</span> <span class="s1">'100%'</span><span class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___svg">Перевірка підтримки SVG</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>По замовчанню SVG.js вважає, що браузер клієнта підтримує SVG. Ви
              можете перевірити підтримку таким чином:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="k">if</span> <span class="p">(</span><span
class="nx">SVG</span><span class="p">.</span><span class="nx">supported</span><span
class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span
class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">)</span>
  <span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s1">'SVG not supported'</span><span
class="p">)</span>
<span class="p">}</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="___dom">Очікування завантаження DOM</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Це може для багатьох виглядати очевидним, але це все ще варте
              нагадування. Якщо ви включаєте ваші js файли в заголовку вашого
              документу, переконайтесь, що діждетесь завантаження DOM:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="nx">SVG</span><span class="p">.</span><span
class="nx">on</span><span class="p">(</span><span class="nb">document</span><span
class="p">,</span> <span class="s1">'DOMContentLoaded'</span><span class="p">,</span> <span
class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span
class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">)</span>
<span class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Це не проблема, якщо ви вставляєте ваш js знизу.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="__svg">Чистий SVG</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>SVG.js також робить за межами HTML DOM, наприклад, в документі
              SVG:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="cp">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span>
<span class="nt">&lt;svg</span> <span class="na">id=</span><span class="s">"drawing"</span> <span
class="na">xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span> <span
class="na">xmlns:xlink=</span><span class="s">"http://www.w3.org/1999/xlink"</span> <span
class="na">version=</span><span class="s">"1.1"</span> <span class="nt">&gt;</span>
  <span class="nt">&lt;script</span> <span class="na">type=</span><span class="s">"text/javascript"</span> <span
class="na">xlink:href=</span><span class="s">"svg.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;script</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span
class="nt">&gt;</span>
    <span class="cp">&lt;![CDATA[</span>
<span class="cp">      var draw = SVG('drawing')</span>
<span class="cp">      draw.rect(100,100).animate().fill('#f03').move(100,100)</span>
<span class="cp">    ]]&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/svg&gt;</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="__4">Пісочниця</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Щоб дати вам поштовх, ось базове налаштування. Присутнє все для
              початку забавок.</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="c1">// ініціалізація SVG.js</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span
class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">)</span>

<span class="c1">// темно рожевий квадрат</span>
<span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">).</span><span class="nx">move</span><span class="p">(</span><span class="mi">100</span><span
class="p">,</span> <span class="mi">50</span><span class="p">).</span><span class="nx">fill</span><span
class="p">(</span><span class="s1">'#f06'</span><span class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="__5">Батькі</h1>
      <div class="sect1">
        <h2 id="_svg_parent">SVG.Parent</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Клас <code>SVG.Parent</code> є базовою огорткою для всіх
              елементів, що можуть містити інші елементи. <code>SVG.Parent</code>
              наслідує напряму від найнижчого рівня класів SVG.js: <code>SVG.Element</code>.</p>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_container">SVG.Container</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p><code>SVG.Container</code> додає інший рівень до стеку
              батьківського наслідування. Якщо <code>SVG.Parent</code>
              приносить декілька низькорівневих методів, як <code>add()</code>,
              <code>remove()</code> та <code>has()</code>, щоб назвати
              декілька, <code>SVG.Container</code> може та повинен
              використовуватись, якщо ви бажаєте додати ваші власні методи.
              Таким чином, прототип <code>SVG.Parent</code> залишається чистим.
              Вам слідує завжди наслідувати від <code>SVG.Container</code>,
              коли реалізуєте ваші власні батьківські елементи.</p>
          </div>
          <div class="paragraph">
            <p>Стек батьківського наслідування таий: <code>SVG.Element</code>
              &gt; <code>SVG.Parent</code> &gt; <code>SVG.Container</code>.</p>
          </div>
        </div>
      </div>
      <h1 id="_svg_doc">SVG.Doc</h1>
      <div class="paragraph">
        <p>Функція-ініціалізатор SVG.js створює кореневий вузол в наданий
          елемент, та повертає примірник <code>SVG.Doc</code>.</p>
      </div>
      <div class="sect1">
        <h2 id="_svg">SVG()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>повертає <code>SVG.Doc</code>, що наслідує від <code>SVG.Container</code></p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span
class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">'drawing'</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="admonitionblock">
            <table>
              <tbody>
                <tr>
                  <td class="icon">
                    <img src="./images/icons/note.png" alt="Note" />
                  </td>
                  <td class="content">Перший раз, коли викликається <code>SVG()</code>,
                    буде створений другий, невидимий <code>&lt;svg&gt;</code>.
                    Це наш парсер, та він пояснений в FAQ.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_nested">SVG.Nested</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Вкладені документи SVG один в одного.</p>
          </div>
          <div class="sect2">
            <h3 id="_nested">nested()</h3>
            <div class="paragraph">
              <p>конструктор <code>SVG.Container</code>
                повертає <code>SVG.Nested</code>, що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>Вкладені SVG документи мають точно такі можливості, що і
                головний SVG документ вищого рівня:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">nested</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">nested</span><span
class="p">()</span>

<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nx">nested</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_g">SVG.G</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Групування елементів може буде корисне, якщо ви бажаєте
              трансформувати набір елементів, так, якби це був один елемент. Всі
              елементи в групі керують свою позицію відносно до групи, до якої
              вони належать.</p>
          </div>
          <div class="admonitionblock">
            <table>
              <tbody>
                <tr>
                  <td class="icon">
                    <img src="./images/icons/note.png" alt="Note" />
                  </td>
                  <td class="content">Групи не мають своєї власної геометрії,
                    вона наслідується від його вмісту. Таким чином групи не
                    зважають на атрибути <code>x</code>, <code>y</code>, <code>width</code>
                    та <code>height</code>. Якщо це те, що ви шукаєте,
                    використовуйте замість цього <code>nested()</code> svg.</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="sect2">
            <h3 id="_group">group()</h3>
            <div class="paragraph">
              <p>конструктор <code>SVG.Container</code>
                повертає <code>SVG.G</code>, що наслідує від <code>SVG.Container</code></p>
            </div>
            <div class="paragraph">
              <p>Група має всі ті самі методи елемента, що і кореневий документ
                SVG:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">group</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">group</span><span
class="p">()</span>
<span class="nx">group</span><span class="p">.</span><span class="nx">path</span><span
class="p">(</span><span class="s1">'M10,20L30,40'</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Існуючі елементи з документу SVG також може бути додані групи:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">group</span><span class="p">.</span><span
class="nx">add</span><span class="p">(</span><span class="nx">rect</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_symbol">SVG.Symbol</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор <code>SVG.Container</code>
              повертає <code>SVG.Symbol</code>, що наслідує від <code>SVG.Container</code></p>
          </div>
          <div class="paragraph">
            <p>Подібно до елементу групи, елемент символа є контейнерним
              елементом. Єдина різниця в тому, що символи не відображуються.
              Таким чином елемент символа є ідеальним в комбінації з елементом <code>use</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">symbol</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">symbol</span><span
class="p">()</span>
<span class="nx">symbol</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">'#f09'</span><span
class="p">)</span>

<span class="kd">var</span> <span class="nx">use</span>  <span class="o">=</span> <span
class="nx">draw</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span
class="nx">symbol</span><span class="p">).</span><span class="nx">move</span><span
class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_defs">SVG.Defs</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Елемент &lt;defs&gt; є контейнером для посиланих елементів.
              Нащадки вузла <code>&lt;defs&gt;</code> не відображуються
              напряму. Вузол <code>&lt;defs&gt;</code> живе в головному
              документі <code>&lt;svg&gt;</code>, та може бути досяжний за
              допомогою метода <code>defs()</code>.</p>
          </div>
          <div class="sect2">
            <h3 id="_defs">defs()</h3>
            <div class="paragraph">
              <p>конструктор <code>SVG.Container</code>
                повертає <code>SVG.Defs</code>, що наслідує від <code>SVG.Container</code></p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">defs</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">defs</span><span
class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p><code>defs</code> також доступний на любому іншому елементі
                через метод <code>doc()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">defs</span> <span
class="o">=</span> <span class="nx">rect</span><span class="p">.</span><span class="nx">doc</span><span
class="p">().</span><span class="nx">defs</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Вузол <code>defs</code> робить точно так само, як і групи.</p>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_svg_a">SVG.A</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Створює гіперпосилання, що буде активоване на всіх дитячих
              елементах.</p>
          </div>
          <div class="sect2">
            <h3 id="_link">link()</h3>
            <div class="paragraph">
              <p>конструктор <code>SVG.Container</code>
                повертає <code>SVG.A</code>, що наслідує від <code>SVG.Container</code></p>
            </div>
            <div class="paragraph">
              <p>Гіперпосилання або тег <code>&lt;a&gt;</code> створює
                контейнер, що дозволяє посилання на всіх його дітях:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">link</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">link</span><span
class="p">(</span><span class="s1">'http://svgdotjs.github.io/'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span
class="nx">link</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Url посилання може бути оновлене за допомогою метода <code>to()</code>
                method:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">link</span><span class="p">.</span><span
class="nx">to</span><span class="p">(</span><span class="s1">'http://apple.com'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Більше того, елемент <code>link</code> має метод <code>show()</code>
                для створення атрибута <code>xlink:show</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">link</span><span class="p">.</span><span
class="nx">show</span><span class="p">(</span><span class="s1">'replace'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Та метод <code>target()</code> для створення атрибута <code>target</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">link</span><span class="p">.</span><span
class="nx">target</span><span class="p">(</span><span class="s1">'_blank'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Елементи можуть бути пов'язані в інший спосіб за допомогою
                метода <code>linkTo()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">rect</span><span class="p">.</span><span
class="nx">linkTo</span><span class="p">(</span><span class="s1">'http://svgdotjs.github.io/'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Альтернативно, замість URL може бути переданий блок, для
                додаткових опцій елемента посилання:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">rect</span><span class="p">.</span><span
class="nx">linkTo</span><span class="p">(</span><span class="kd">function</span><span
class="p">(</span><span class="nx">link</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">link</span><span class="p">.</span><span class="nx">to</span><span
class="p">(</span><span class="s1">'http://svgdotjs.github.io/'</span><span class="p">).</span><span
class="nx">target</span><span class="p">(</span><span class="s1">'_blank'</span><span
class="p">)</span>
<span class="p">})</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="__6">Елементи</h1>
      <div class="paragraph">
        <p><code>SVG.Element</code> є базовим прототипом, що огортає всі
          елементи (або вузли, коли це важливо) в SVG.js. Додатковий рівень
          уточнення доданий з допомогою <code>SVG.Shape</code>. Кожний елемент,
          що може приймати атрибути <code>fill</code> та/або <code>stroke</code>.
          Бажано розширювати елементи ваши ми власними методами на <code>SVG.Shape</code>,
          скоріше ніж на <code>SVG.Element</code>.</p>
      </div>
      <h1 id="_svg_rect">SVG.Rect</h1>
      <div class="sect2">
        <h3 id="_rect">rect()</h3>
        <div class="paragraph">
          <p>конструктор на SVG.Container
            повертає SVG.Rect що наслідує від <code>SVG.Shape</code></p>
        </div>
        <div class="paragraph">
          <p>Прямокутники мають два аргументи, свою ширину та висоту:</p>
        </div>
        <div class="listingblock">
          <div class="content">
            <div class="highlight">
              <pre><span></span><span class="kd">var</span> <span class="nx">rect</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span
class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span
class="p">)</span>
</pre></div>
          </div>
        </div>
      </div>
      <div class="sect2">
        <h3 id="_rect_radius">rect.radius()</h3>
        <div class="paragraph">
          <p>повертає себе, анімується</p>
        </div>
        <div class="paragraph">
          <p>Прямокутники можуть мати скруглені кути:</p>
        </div>
        <div class="listingblock">
          <div class="content">
            <div class="highlight">
              <pre><span></span><span class="nx">rect</span><span class="p">.</span><span
class="nx">radius</span><span class="p">(</span><span class="mi">10</span><span
class="p">)</span>
</pre></div>
          </div>
        </div>
        <div class="paragraph">
          <p>Це буде встановлювати атрибути <code>rx</code> та <code>ry</code>
            в <code>10</code>. Щоб встановити <code>rx</code> та <code>ry</code>
            індивідуально:</p>
        </div>
        <div class="listingblock">
          <div class="content">
            <div class="highlight">
              <pre><span></span><span class="nx">rect</span><span class="p">.</span><span
class="nx">radius</span><span class="p">(</span><span class="mi">10</span><span
class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
          </div>
        </div>
      </div>
      <h1 id="_svg_circle">SVG.Circle</h1>
      <div class="sect1">
        <h2 id="_circle">circle()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на SVG.Container
              повертає SVG.Circle що наслідує від SVG.Shape</p>
          </div>
          <div class="paragraph">
            <p>Єдиний аргумент, потрібний для кола, є його диаметр:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">circle</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">circle</span><span
class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_circle_radius">circle.radius()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>повертає себе, анімується</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="nx">circle</span><span class="p">.</span><span
class="nx">radius</span><span class="p">(</span><span class="mi">75</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_ellipse">SVG.Ellipse</h1>
      <div class="sect1">
        <h2 id="_ellipse">ellipse()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на SVG.Container
              повертає SVG.Circle що наслідує від SVG.Shape</p>
          </div>
          <div class="paragraph">
            <p>Еліпси мають два аргументи, їх ширину та висоту:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">ellipse</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">ellipse</span><span
class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sect1">
        <h2 id="_ellipse_radius">ellipse.radius()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>повертає себе, анімується</p>
          </div>
          <div class="paragraph">
            <p>Еліпси також можуть перевизначатись по радіусу:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="nx">ellipse</span><span class="p">.</span><span
class="nx">radius</span><span class="p">(</span><span class="mi">75</span><span
class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_line">SVG.Line</h1>
      <div class="sect1">
        <h2 id="_line">line()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на SVG.Container
              повертає SVG.Line що наслідує від SVG.Shape</p>
          </div>
          <div class="paragraph">
            <p>Створює лінію від точки A до точки B:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">line</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">line</span><span
class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span
class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span
class="p">).</span><span class="nx">stroke</span><span class="p">({</span> <span
class="nx">width</span><span class="o">:</span> <span class="mi">1</span> <span
class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Створення елементу лінії може бути зроблене в чотори способи.
              Дивіться метод <code>plot()</code> щоб побачити всі можливості.</p>
          </div>
          <div class="sect2">
            <h3 id="_line_array">line.array()</h3>
            <div class="paragraph">
              <p>повертає <code>SVG.PointArray</code></p>
            </div>
            <div class="paragraph">
              <p>Посилання на примірник <code>SVG.PointArray</code>. Цей метод
                скоріше призначений для внутрішнього використання:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">array</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Додаткова інформація: <code>SVG.PointArray</code>.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_line_plot">line.plot()</h3>
            <div class="paragraph">
              <p>повертає себе, анімується</p>
            </div>
            <div class="paragraph">
              <p>Оновлення лінії методом <code>plot()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">line</span><span class="p">.</span><span
class="nx">plot</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span
class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span
class="mi">150</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Альтернативно приймає рядок з точками:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">line</span><span class="p">.</span><span
class="nx">plot</span><span class="p">(</span><span class="s1">'0,0 100,150'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Або масив масивів для точок:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">line</span><span class="p">.</span><span
class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span
class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span
class="p">,</span> <span class="mi">150</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Або примірник <code>SVG.PointArray</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">array</span> <span
class="o">=</span> <span class="k">new</span> <span class="nx">SVG</span><span class="p">.</span><span
class="nx">PointArray</span><span class="p">([[</span><span class="mi">0</span><span
class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span
class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]])</span>
<span class="nx">line</span><span class="p">.</span><span class="nx">plot</span><span
class="p">(</span><span class="nx">array</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Метод <code>plot()</code> може бути анімований:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">line</span><span class="p">.</span><span
class="nx">animate</span><span class="p">(</span><span class="mi">3000</span><span
class="p">).</span><span class="nx">plot</span><span class="p">([[</span><span class="mi">200</span><span
class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="p">[</span><span
class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_polyline">SVG.Polyline</h1>
      <div class="sect1">
        <h2 id="_polyline">polyline()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на SVG.Container
              повертає SVG.Polyine що наслідує від SVG.Shape</p>
          </div>
          <div class="paragraph">
            <p>Елемент полілінії визначає набір прямих сегментів ліній. Типово
              елементи поліліній визначають відкриті фігури:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">polyline</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polyline</span><span
class="p">(</span><span class="s1">'0,0 100,50 50,100'</span><span class="p">).</span><span
class="nx">fill</span><span class="p">(</span><span class="s1">'none'</span><span
class="p">).</span><span class="nx">stroke</span><span class="p">({</span> <span
class="nx">width</span><span class="o">:</span> <span class="mi">1</span> <span
class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Полілайн рядкі складаються зі списку точок, розділених комами або
              проміжками. Так що <code>x,y x,y x,y</code> так само як <code>x
                y x y x y</code> або навіть <code>x,y,x,y,x,y</code> буде
              робити.</p>
          </div>
          <div class="paragraph">
            <p>Як альтернатива також буде робити масив точок:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">polyline</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polyline</span><span
class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span
class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span
class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">50</span><span
class="p">,</span><span class="mi">100</span><span class="p">]])</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Або навіть плаский масив точок, що навіть краще:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">polyline</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polyline</span><span
class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span
class="p">,</span> <span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span
class="p">,</span> <span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span
class="p">])</span>
</pre></div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_polyline_array">polyline.array()</h3>
            <div class="paragraph">
              <p>повертає SVG.PointArray</p>
            </div>
            <div class="paragraph">
              <p>Посилання на промірник <code>SVG.PointArray</code>. Цей метод
                скоріше призначений для внутрішнього використання:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">array</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Додаткова інформація: <code>SVG.PointArray</code>.</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">clear</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Коли дані про точки розібрані результат кешується. Цей метод
                очищує кеш.</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">clear</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_polyline_plot">polyline.plot()</h3>
            <div class="paragraph">
              <p>Повертає себе, анімується</p>
            </div>
            <div class="paragraph">
              <p>Полілінії можуть бути оновлені з використанням метода <code>plot()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span
class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span
class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span
class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span
class="p">[</span><span class="mi">150</span><span class="p">,</span><span class="mi">50</span><span
class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span><span
class="mi">50</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Метод plot() також може бути анімований:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polyline</span><span class="p">.</span><span
class="nx">animate</span><span class="p">(</span><span class="mi">3000</span><span
class="p">).</span><span class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span
class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span
class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> <span
class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span
class="p">],</span> <span class="p">[</span><span class="mi">150</span><span class="p">,</span><span
class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span
class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span
class="mi">250</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span
class="p">[</span><span class="mi">300</span><span class="p">,</span><span class="mi">50</span><span
class="p">],</span> <span class="p">[</span><span class="mi">350</span><span class="p">,</span><span
class="mi">50</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_polygon">SVG.Polygon</h1>
      <div class="sect1">
        <h2 id="_polygon">polygon()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на <code>SVG.Container</code>
              повертає <code>SVG.Polygon</code> що наслідує від <code>SVG.Shape</code></p>
          </div>
          <div class="paragraph">
            <p>Елемент полігона, на відміну від елемента полілінії, визначає
              замкнену фігуру, що складається з множини поєднаних прямих
              сегментів ліній:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">polygon</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polygon</span><span
class="p">(</span><span class="s1">'0,0 100,50 50,100'</span><span class="p">).</span><span
class="nx">fill</span><span class="p">(</span><span class="s1">'none'</span><span
class="p">).</span><span class="nx">stroke</span><span class="p">({</span> <span
class="nx">width</span><span class="o">:</span> <span class="mi">1</span> <span
class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Рядки або масиви полігонів точна такі ж, як і рядки поліліній.
              Немає потреби замикати фігуру, бо перша і остання точка будуть
              поєднані автоматично.</p>
          </div>
          <div class="sect2">
            <h3 id="_polygon_array">polygon.array()</h3>
            <div class="paragraph">
              <p>повертає <em>SVG.PointArray</em></p>
            </div>
            <div class="paragraph">
              <p>Посилання на примірник <code>SVG.PointArray</code>. Цей метод
                скоріше призначений для внутрішнього використання:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polygon</span><span class="p">.</span><span
class="nx">array</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Додаткова інформація: <code>SVG.PointArray</code>.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_polygon_clear">polygon.clear()</h3>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Коли надані дані точок розібрані, результат кешується. Цей
                метод очищує кеш.</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polygon</span><span class="p">.</span><span
class="nx">clear</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_polygon_plot">polygon.plot()</h3>
            <div class="paragraph">
              <p>Повертає себе, анімується</p>
            </div>
            <div class="paragraph">
              <p>Як і полілінії, полігони можуть бути оновлені методом <code>plot()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polygon</span><span class="p">.</span><span
class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span
class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span
class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span
class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span
class="p">[</span><span class="mi">150</span><span class="p">,</span><span class="mi">50</span><span
class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span><span
class="mi">50</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Метод <code>plot()</code> також може бути анімований:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">polygon</span><span class="p">.</span><span
class="nx">animate</span><span class="p">(</span><span class="mi">3000</span><span
class="p">).</span><span class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span
class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span
class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> <span
class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span
class="p">],</span> <span class="p">[</span><span class="mi">150</span><span class="p">,</span><span
class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span
class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span
class="mi">250</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span
class="p">[</span><span class="mi">300</span><span class="p">,</span><span class="mi">50</span><span
class="p">],</span> <span class="p">[</span><span class="mi">350</span><span class="p">,</span><span
class="mi">50</span><span class="p">]])</span>
</pre></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_path">SVG.Path</h1>
      <div class="sect1">
        <h2 id="_path">path()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на <code>SVG.Container</code>
              повертає <code>SVG.Path</code> що наслідує від <code>SVG.Shape</code></p>
          </div>
          <div class="paragraph">
            <p>Рядок шляху подібний до рядка полігону, але значно більш складний
              щоб підтримувати криві:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="nx">draw</span><span class="p">.</span><span
class="nx">path</span><span class="p">(</span><span class="s1">'M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z'</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Для додаткової інформації по рядкам даних шляхів будь ласка
              посилайтесь до SVG документації.</p>
          </div>
          <div class="sect2">
            <h3 id="_path_array">path.array()</h3>
            <div class="paragraph">
              <p>повертає <code>SVG.PathArray</code></p>
            </div>
            <div class="paragraph">
              <p>Посилається на примірник <code>SVG.PathArray</code>. Цей метод
                скоріше призначений для внутрішнього використання:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">path</span><span class="p">.</span><span
class="nx">array</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Додаткова інформація: <code>SVG.PathArray</code>.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_path_clear">path.clear()</h3>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Коли надані дані шляху розібрані, результат кешується. Цей
                метод очищує кеш.</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">path</span><span class="p">.</span><span
class="nx">clear</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_path_length">path.length()</h3>
            <div class="paragraph">
              <p>Повертає число</p>
            </div>
            <div class="paragraph">
              <p>Повертає загальну довжину елемента:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">length</span> <span
class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span
class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_path_pointat">path.pointAt()</h3>
            <div class="paragraph">
              <p>повертає <code>SVGPoint</code></p>
            </div>
            <div class="paragraph">
              <p>Видає точку на шляху на певній довжині:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">point</span> <span
class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">pointAt</span><span
class="p">(</span><span class="mi">105</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Зауваження: <code>pointAt()</code> повертає природну <code>SVGPoint</code>,
                та не <code>SVG.Point</code>.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_path_plot">path.plot()</h3>
            <div class="paragraph">
              <p>Повертає себе, анімується</p>
            </div>
            <div class="paragraph">
              <p>Шляхи можуть бути оновлені з використанням метода <code>plot()</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">path</span><span class="p">.</span><span
class="nx">plot</span><span class="p">(</span><span class="s1">'M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80'</span><span
class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Метод <code>plot()</code> також може бути анімований:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">path</span><span class="p">.</span><span
class="nx">animate</span><span class="p">(</span><span class="mi">2000</span><span
class="p">).</span><span class="nx">plot</span><span class="p">(</span><span class="s1">'M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80'</span><span
class="p">).</span><span class="nx">loop</span><span class="p">(</span><span class="kc">true</span><span
class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Є тільки базова підтримка для анімованих шляхів, додана до
                SVG.js, що означає, що тільки шляхи з тими самими командами
                (M,C,S etc.) можуть бути анімовані.</p>
            </div>
            <div class="paragraph">
              <p>Якщо вам треба анімувати шляхи, що не поділяють ті самі команди
                в тому ж порядку, вам треба використовувати <code>svg.pathmorphing.js</code></p>
            </div>
          </div>
        </div>
      </div>
      <h1 id="_svg_text">SVG.Text</h1>
      <div class="sect1">
        <h2 id="_text">text()</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>конструктор на <code>SVG.Container</code>
              повертає <code>SVG.Text</code> що наслідує від <code>SVG.Shape</code></p>
          </div>
          <div class="paragraph">
            <p>На відміну від <code>html</code>, текст <code>svg</code> значно
              складніше приборками. Немає способу створити перетікаючий текст,
              так що нові рядки траба вставляти вручну. В SVG.js є два способи
              створити текстові елементи.</p>
          </div>
          <div class="paragraph">
            <p>Перший та простіший метод є запровадити рядок тексту, розділений
              новими рядками:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">text</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">text</span><span
class="p">(</span><span class="s2">"Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor."</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Це буде автоматично створювати блоку тексту та вставляти нові
              рядкі де потрібно.</p>
          </div>
          <div class="paragraph">
            <p>Другий метод буде давати вам більше контролю, але потребує трохи
              більше коду:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">text</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">text</span><span
class="p">(</span><span class="kd">function</span><span class="p">(</span><span
class="nx">add</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'Lorem ipsum dolor sit amet '</span><span class="p">).</span><span
class="nx">newLine</span><span class="p">()</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'consectetur'</span><span class="p">).</span><span
class="nx">fill</span><span class="p">(</span><span class="s1">'#f06'</span><span
class="p">)</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'Cras sodales imperdiet auctor.'</span><span
class="p">).</span><span class="nx">newLine</span><span class="p">().</span><span
class="nx">dx</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'Nunc ultrices lectus at erat'</span><span class="p">).</span><span
class="nx">newLine</span><span class="p">()</span>
  <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'dictum pharetra elementum ante'</span><span
class="p">).</span><span class="nx">newLine</span><span class="p">()</span>
<span class="p">})</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Якщо ви бажаєте піти іншим шляхом, та взагалі не бажаєте додавати
              <code>tspans</code>, тільки один радок тексту, ви можете
              використовувати замість цього метод <code>plain()</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <div class="highlight">
                <pre><span></span><span class="kd">var</span> <span class="nx">text</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">plain</span><span
class="p">(</span><span class="s1">'Lorem ipsum dolor sit amet consectetur.'</span><span
class="p">)</span>
</pre></div>
            </div>
          </div>
          <div class="paragraph">
            <p>Це скорочення до метода <code>plain</code> на примірнику <code>SVG.Text</code>,
              що взагалі не малює нові рядкі.</p>
          </div>
          <div class="sect2">
            <h3 id="_text_build">text.build()</h3>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Метод <code>build()</code> може бути використаний для
                включення / виключення режиму побудови. Коли цей метод
                вимкнений,методи <code>plain()</code> та <code>tspan()</code>
                будуть спочатку викликати метод <code>clear()</code> перед
                додаванням нового вмісту. Так що коли побудова вімкнена, <code>plain()</code>
                та <code>tspan()</code> будуть додавати вміст до існуючого
                вмісту. Коли передається блок до методу <code>text()</code>,
                режим побудови перемикається автоматично перед та після виклику
                блока. Але в деяких випадках може бути корисним бути в змозі
                перемикатись вручну:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="kd">var</span> <span class="nx">text</span> <span
class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">text</span><span
class="p">(</span><span class="s1">'This is just the start, '</span><span class="p">)</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">build</span><span
class="p">(</span><span class="kc">true</span><span class="p">)</span>  <span class="c1">// enables build mode</span>
<span class="kd">var</span> <span class="nx">tspan</span> <span class="o">=</span> <span
class="nx">text</span><span class="p">.</span><span class="nx">tspan</span><span
class="p">(</span><span class="s1">'something pink in the middle '</span><span class="p">).</span><span
class="nx">fill</span><span class="p">(</span><span class="s1">'#00ff97'</span><span
class="p">)</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">plain</span><span
class="p">(</span><span class="s1">'and again boring at the end.'</span><span class="p">)</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">build</span><span
class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// disables build mode</span>
<span class="nx">tspan</span><span class="p">.</span><span class="nx">animate</span><span
class="p">(</span><span class="s1">'2s'</span><span class="p">).</span><span class="nx">fill</span><span
class="p">(</span><span class="s1">'#f06'</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_clear">text.clear()</h3>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Очищує весь вміст викликаного текстового елементу:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">text</span><span class="p">.</span><span
class="nx">clear</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_length">text.length()</h3>
            <div class="paragraph">
              <p>Повертає число</p>
            </div>
            <div class="paragraph">
              <p>Повертає загальну обчислену довжину тексту всіх <code>tspans</code>
                разом:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">text</span><span class="p">.</span><span
class="nx">length</span><span class="p">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_font__">text.font() як сеттер</h3>
            <div class="paragraph">
              <p>Повертає себе</p>
            </div>
            <div class="paragraph">
              <p>Зручний метод для додавання властивостей шрифта:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">text</span><span class="p">.</span><span
class="nx">font</span><span class="p">({</span>
  <span class="nx">family</span><span class="o">:</span>   <span class="s1">'Helvetica'</span>
<span class="p">,</span> <span class="nx">size</span><span class="o">:</span>     <span
class="mi">144</span>
<span class="p">,</span> <span class="nx">anchor</span><span class="o">:</span>   <span
class="s1">'middle'</span>
<span class="p">,</span> <span class="nx">leading</span><span class="o">:</span>  <span
class="s1">'1.5em'</span>
<span class="p">})</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Метод <code>font()</code> також приймає пари ключ/значення:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="nx">text</span><span class="p">.</span><span
class="nx">font</span><span class="p">(</span><span class="s1">'family'</span><span
class="p">,</span> <span class="s1">'Menlo'</span><span class="p">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Доступні властивості:</p>
            </div>
            <div class="paragraph">
              <p><strong>leading</strong> (робить те саме, що і виклик <code>leading()</code>
                як сеттер)</p>
            </div>
            <div class="paragraph">
              <p><strong>anchor</strong> (буде встановлювати атрибут <em>text-anchor</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>family</strong> (буде встановлювати атрибут <em>font-family</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>size</strong> (буде встановлювати атрибут <em>font-size</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>stretch</strong> (буде встановлювати атрибут <em>font-stretch</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>style</strong> (буде встановлювати атрибут <em>font-style</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>variant</strong> (буде встановлювати атрибут <em>font-variant</em>)</p>
            </div>
            <div class="paragraph">
              <p><strong>weight</strong> (буде встановлювати атрибут <em>font-weight</em>)</p>
            </div>
            <div class="paragraph">
              <p>Люба інша властивість буде застосована як є. Так що, наприклад,
                властивість <code>letter-spacing</code> буде застосована так,
                якби вона була надана до метода <code>attr()</code>. Більшість
                про властивостей шрифтів читайте деінде.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_font___2">text.font() як геттер</h3>
            <div class="paragraph">
              <p>Як ви можете очікувати, метод <code>font()</code> також діє як
                геттер:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="k">var</span> <span class="n">leading</span> <span
class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">font</span><span
class="o">(</span><span class=" -Symbol">'leading</span><span class="err">'</span><span
class="o">)</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_leading__">text.leading() як сеттер</h3>
            <div class="paragraph">
              <p>Повертає себе, анімується</p>
            </div>
            <div class="paragraph">
              <p>На відміну від html, де інтерлін'яж визначений висотою рядка, в
                svg рядки не визначені в природний спосіб. Рядки визначені як
                вузли <code>&lt;tspan&gt;</code> з атрибутом <code>dy</code>,
                що визначає висоту рядка, та значення <code>x</code>, що скидає
                рядок в позицію <code>x</code> батьківського елементу. Але ви
                також можете мати багато вузлів в одному рядку, що визначають
                різні <code>y</code>, <code>dy</code>, <code>x</code> або
                навіть <code>dx</code> значення. Це дає багато свободи, але
                також і багато відповідальності. Ми маємо визначити, коли
                визначений новий рядок, де він починається, який його сзув, та
                яка його висота. Метод <code>leading()</code> в SVG.js
                намагається полегшити біль, надаючи вам поведінку, що більш
                близька до html. В комбінації ї рядками з переносами це робить
                так само, як html:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="k">var</span> <span class="n">text</span> <span
class="k">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">text</span><span
class="o">(</span><span class="s">"Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor."</span><span
class="o">)</span>
<span class="n">text</span><span class="o">.</span><span class="n">leading</span><span
class="o">(</span><span class="mf">1.3</span><span class="o">)</span>
</pre></div>
              </div>
            </div>
            <div class="paragraph">
              <p>Це буде малювати текстовий елемент з елементом <code>tspan</code>
                для кожного рядка, зі значенням <code>dy</code> в 130% від
                розміру шрифта.</p>
            </div>
            <div class="paragraph">
              <p>Зауважте, що метод <code>leading()</code> вважає, що кожний <code>tspan</code>
                першого рівня в текстовому вузлі представляє новий рядок.
                Використання <code>leading()</code> на текстових елементах, що
                містить багато <code>tspan</code> на одному рядку (тобто без
                огорнання <code>tspan</code> новими рядками) буде малювати
                східці. Так що радимо використовувати цей метод уважно, бажано
                тільки коли в текстовий елемент закидається текст з новими
                рядками, або викликається метод <code>newLine()</code> на
                кожному <code>tspan</code> першого рівня, доданому в блоці, що
                передається як аргумент до текстового елементу.</p>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_leading___2">text.leading() як геттер</h3>
            <div class="paragraph">
              <p>Повертає значення</p>
            </div>
            <div class="paragraph">
              <p>Поветрає поточне значенння <code>leading</code>:</p>
            </div>
            <div class="listingblock">
              <div class="content">
                <div class="highlight">
                  <pre><span></span><span class="k">var</span> <span class="n">leading</span> <span
class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">leading</span><span
class="o">()</span>
</pre></div>
              </div>
            </div>
          </div>
          <div class="sect2">
            <h3 id="_text_lines">text.lines()</h3>
            <div class="paragraph">
              <p>повертає SVG.Set</p>
            </div>
            <div class="paragraph">
              <p>На всі <code>tspan</code> першого рівня можна посилатись за
                допомогою метода <code>lines()</code>:</p>
            </div>
            <div class="paragraph">
              <p>text.lines()
                This will return an instance of SVG.Set including all tspan
                elements.</p>
            </div>
            <div class="paragraph">
              <p>text.plain()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>If the content of the element doesn’t need any styling or
                multiple lines, it might be sufficient to just add some plain
                text:</p>
            </div>
            <div class="paragraph">
              <p>text.plain(<em>I do not have any expectations.</em>)
                text.rebuild()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>This is an internal callback that probably never needs to be
                called manually. Basically it rebuilds the text element
                whenerver font-size and x attributes or the leading() of the
                text element are modified. This method also acts a setter to
                enable or disable rebuilding:</p>
            </div>
            <div class="paragraph">
              <p>text.rebuild(false) //→ disables rebuilding
                text.rebuild(true) //→ enables rebuilding and instantaneously
                rebuilds the text element
                text.text() as setter
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Changing text afterwards is also possible with the text()
                method:</p>
            </div>
            <div class="paragraph">
              <p>text.text(<em>Brilliant!</em>)
                text.text() as getter
                returns string</p>
            </div>
            <div class="paragraph">
              <p>To get the raw text content:</p>
            </div>
            <div class="paragraph">
              <p>text.text()
                text.tspan()
                повертає SVG.Tspan</p>
            </div>
            <div class="paragraph">
              <p>Just adding one tspan is also possible:</p>
            </div>
            <div class="paragraph">
              <p>text.tspan(' on a train…<em>).fill(</em>#f06')</p>
            </div>
            <div class="paragraph">
              <p>SVG.TextPath
                path()
                конструктор на SVG.Text
                повертає SVG.TextPath що наслідує від SVG.Text</p>
            </div>
            <div class="paragraph">
              <p>A nice feature in svg is the ability to run text along a path:</p>
            </div>
            <div class="paragraph">
              <p>var text = draw.text(function(add) { add.tspan(<em>We go ')
                  add.tspan('up</em>).fill(<em>#f09</em>).dy(-40) add.tspan(<em>,
                  then we go down, then up again</em>).dy(40)
                })</p>
            </div>
            <div class="paragraph">
              <p>var path = <em>M 100 200 C 200 100 300 0 400 100 C 500 200 600
                  300 700 200 C 800 100 900 100 900 100</em></p>
            </div>
            <div class="paragraph">
              <p>text.path(path).font({ size: 42.5, family: <em>Verdana</em> })
                When calling the path() method on a text element, the text
                element is mutated into an intermediate between a text and a
                path element. From that point on the text element will also
                feature a plot() method to update the path:</p>
            </div>
            <div class="paragraph">
              <p>text.plot(<em>M 300 500 C 200 100 300 0 400 100 C 500 200 600
                  300 700 200 C 800 100 900 100 900 100</em>)
                Attributes specific to the &lt;textPath&gt; element can be
                applied to the textPath instance itself:</p>
            </div>
            <div class="paragraph">
              <p>text.textPath().attr(<em>startOffset</em>, <em>50%</em>)
                And they can be animated as well of course:</p>
            </div>
            <div class="paragraph">
              <p>text.textPath().animate(3000).attr(<em>startOffset</em>, <em>80%</em>)
                Note: If a startOffset other than a percentage is given, then
                the value represents a distance along the path measured in the
                current user coordinate system.</p>
            </div>
            <div class="paragraph">
              <p>textPath.array()
                повертає SVG.PathArray</p>
            </div>
            <div class="paragraph">
              <p>Get the path array of the underlying path:</p>
            </div>
            <div class="paragraph">
              <p>var array = text.textPath().array()
                textPath.plot()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Change the path on the textpath element:</p>
            </div>
            <div class="paragraph">
              <p>text.textPath().plot(<em>M 300 500 C 200 100 300 0 400 100 C
                  500 200 600 300 700 200</em>)
                textPath.textPath()
                повертає SVG.TextPath</p>
            </div>
            <div class="paragraph">
              <p>Referencing the textPath node directly:</p>
            </div>
            <div class="paragraph">
              <p>var textPath = text.textPath()
                textPath.track()
                повертає SVG.Path</p>
            </div>
            <div class="paragraph">
              <p>Referencing the linked path element directly:</p>
            </div>
            <div class="paragraph">
              <p>var path = text.track()</p>
            </div>
            <div class="paragraph">
              <p>Note: SVG.TextPath inherits from SVG.Text, so all those methods
                are inherited as well.</p>
            </div>
            <div class="paragraph">
              <p>Events for SVG.Text
                The text element has one event. It is fired every time the
                rebuild() method is called:</p>
            </div>
            <div class="paragraph">
              <p>text.on(<em>rebuild</em>, function() { // whatever you need to
                do after rebuilding
                })</p>
            </div>
            <div class="paragraph">
              <p>SVG.Tspan
                tspan()
                конструктор на SVG.Text
                повертає SVG.Tspan що наслідує від SVG.Shape</p>
            </div>
            <div class="paragraph">
              <p>The tspan elements are only available inside text elements or
                inside other tspan elements.</p>
            </div>
            <div class="paragraph">
              <p>text.tspan(<em>spannened</em>)
                tspan.clear()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Clear all the contents of the called tspan element:</p>
            </div>
            <div class="paragraph">
              <p>tspan.clear()
                tspan.dx()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Define the dynamic x value of the element, much like a html
                element with position:relative and left defined:</p>
            </div>
            <div class="paragraph">
              <p>tspan.dx(30)
                tspan.dy()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Define the dynamic y value of the element, much like a html
                element with position:relative and top defined:</p>
            </div>
            <div class="paragraph">
              <p>tspan.dy(30)
                tspan.plain()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Just adds some plain text:</p>
            </div>
            <div class="paragraph">
              <p>tspan.plain(<em>I do not have any expectations.</em>)
                tspan.length()
                returns number</p>
            </div>
            <div class="paragraph">
              <p>Gets the total computed text length:</p>
            </div>
            <div class="paragraph">
              <p>tspan.length()
                tspan.newLine()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>The newLine() is a convenience method for adding a new line
                with a dy attribute using the current "leading":</p>
            </div>
            <div class="paragraph">
              <p>var text = draw.text(function(add) { add.tspan(<em>Lorem ipsum
                  dolor sit amet ').newLine() add.tspan('consectetur</em>).fill(<em>#f06</em>)
                add.tspan(<em>.</em>) add.tspan(<em>Cras sodales imperdiet
                  auctor.</em>).newLine().dx(20) add.tspan(<em>Nunc ultrices
                  lectus at erat</em>).newLine() add.tspan(<em>dictum pharetra
                  elementum ante</em>).newLine()
                })
                tspan.text()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Update the content of the tspan. This can be done by either
                passing a string:</p>
            </div>
            <div class="paragraph">
              <p>tspan.text(<em>Just a string.</em>)
                Which will basicly call the plain() method:</p>
            </div>
            <div class="paragraph">
              <p>Or by passing a block to add more specific content inside the
                called tspan:</p>
            </div>
            <div class="paragraph">
              <p>tspan.text(function(add) { add.plain(<em>Just plain text.</em>)
                add.tspan(<em>Fancy text wrapped in a tspan.</em>).fill(<em>#f06</em>)
                add.tspan(function(addMore) { addMore.tspan(<em>And you can doo
                  deeper and deeper…</em>) })
                })
                tspan.tspan()
                повертає SVG.Tspan</p>
            </div>
            <div class="paragraph">
              <p>Add a nested tspan:</p>
            </div>
            <div class="paragraph">
              <p>tspan.tspan(<em>I am a child of my parent</em>).fill(<em>#f06</em>)</p>
            </div>
            <div class="paragraph">
              <p>SVG.Image
                image()
                конструктор на SVG.Container
                повертає SVG.Image що наслідує від SVG.Shape</p>
            </div>
            <div class="paragraph">
              <p>Creating images is as you might expect:</p>
            </div>
            <div class="paragraph">
              <p>var image = draw.image(<em>/path/to/image.jpg</em>)
                If you know the size of the image, those parameters can be
                passed as the second and third arguments:</p>
            </div>
            <div class="paragraph">
              <p>var image = draw.image(<em>/path/to/image.jpg</em>, 200, 300)</p>
            </div>
            <div class="paragraph">
              <p>image.load()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Loading another image can be done with the load() method:</p>
            </div>
            <div class="paragraph">
              <p>image.load(<em>/path/to/another/image.jpg</em>)
                image.loaded()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>If you don’t know the size of the image, obviously you will
                have to wait for the image to be loaded:</p>
            </div>
            <div class="paragraph">
              <p>var image = draw.image(<em>/path/to/image.jpg</em>).loaded(function(loader)
                { this.size(loader.width, loader.height)
                })
                The returned loader object as first the argument of the loaded
                method contains four values:</p>
            </div>
            <div class="paragraph">
              <p>width
                height
                ratio (width / height)
                url</p>
            </div>
            <div class="paragraph">
              <p>SVG.Gradient
                gradient()
                конструктор на SVG.Container
                повертає SVG.Gradient що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>There are linear and radial gradients. The linear gradient can
                be created like this:</p>
            </div>
            <div class="paragraph">
              <p>var gradient = draw.gradient(<em>linear</em>, function(stop) {
                stop.at(0, <em>#333</em>) stop.at(1, <em>#fff</em>)
                })
                Finally, to use the gradient on an element:</p>
            </div>
            <div class="paragraph">
              <p>rect.attr({ fill: gradient })
                Or:</p>
            </div>
            <div class="paragraph">
              <p>rect.fill(gradient)
                By passing the gradient instance as the fill on any element, the
                fill() method will be called on the gradient instance.</p>
            </div>
            <div class="paragraph">
              <p>MDN has a great example page on how SVG Gradients work.</p>
            </div>
            <div class="paragraph">
              <p>gradient.at()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>The offset and color parameters are required for stops, opacity
                is optional. The offset is a float between 0 and 1, or a
                percentage value (e.g. 33%).</p>
            </div>
            <div class="paragraph">
              <p>stop.at(0, <em>#333</em>)
                or</p>
            </div>
            <div class="paragraph">
              <p>stop.at({ offset: 0, color: <em>#333</em>, opacity: 1 })
                gradient.fill()
                returns string</p>
            </div>
            <div class="paragraph">
              <p>gradient.fill() //→ returns <em>url(#SvgjsGradient1234)</em>
                gradient.from()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>To define the direction you can set from x, y and to x, y:</p>
            </div>
            <div class="paragraph">
              <p>gradient.from(0, 0).to(0, 1)
                The from and to values are also expressed in percent.</p>
            </div>
            <div class="paragraph">
              <p>gradient.get()
                повертає SVG.Stop</p>
            </div>
            <div class="paragraph">
              <p>The get() method makes it even easier to get a stop from an
                existing gradient:</p>
            </div>
            <div class="paragraph">
              <p>var gradient = draw.gradient(<em>radial</em>, function(stop) {
                stop.at({ offset: 0, color: <em>#000</em>, opacity: 1 }) // →
                first stop.at({ offset: 0.5, color: <em>#f03</em>, opacity: 1
                }) // → second stop.at({ offset: 1, color: <em>#066</em>,
                opacity: 1 }) // → third
                })</p>
            </div>
            <div class="paragraph">
              <p>var s1 = gradient.get(0) // → returns "first" stop
                gradient.radius()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Radial gradients have a radius() method to define the outermost
                radius to where the inner color should develop:</p>
            </div>
            <div class="paragraph">
              <p>var gradient = draw.gradient(<em>radial</em>, function(stop) {
                stop.at(0, <em>#333</em>) stop.at(1, <em>#fff</em>)
                })</p>
            </div>
            <div class="paragraph">
              <p>gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)
                gradient.to()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>To define the direction you can set from x, y and to x, y:</p>
            </div>
            <div class="paragraph">
              <p>gradient.from(0, 0).to(0, 1)
                The from and to values are also expressed in percent.</p>
            </div>
            <div class="paragraph">
              <p>gradient.update()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>A gradient can also be updated afterwards:</p>
            </div>
            <div class="paragraph">
              <p>gradient.update(function(stop) { stop.at(0.1, <em>#333</em>,
                0.2) stop.at(0.9, <em>#f03</em>, 1)
                })
                And even a single stop can be updated:</p>
            </div>
            <div class="paragraph">
              <p>var s1, s2, s3</p>
            </div>
            <div class="paragraph">
              <p>draw.gradient(<em>radial</em>, function(stop) { s1 = stop.at(0,
                <em>#000</em>) s2 = stop.at(0.5, <em>#f03</em>) s3 = stop.at(1,
                <em>#066</em>)
                })</p>
            </div>
            <div class="paragraph">
              <p>s1.update(0.1, <em>#0f0</em>, 1)</p>
            </div>
            <div class="paragraph">
              <p>SVG.Stop
                at()
                конструктор на SVG.Gradient
                повертає SVG.Stop що наслідує від SVG.Element</p>
            </div>
            <div class="paragraph">
              <p>The stop elements are only available inside gradient elements.</p>
            </div>
            <div class="paragraph">
              <p>var stop = gradient.at(0.5, <em>#f03</em>)
                or</p>
            </div>
            <div class="paragraph">
              <p>var stop = gradient.at({ offset: 0.5, color: <em>#f06</em>,
                opacity: 1 })
                stop.update()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Takes the same parameters as the constructor.</p>
            </div>
            <div class="paragraph">
              <p>stop.update(0, <em>#333</em>)
                or</p>
            </div>
            <div class="paragraph">
              <p>stop.update({ offset: 0, color: <em>#333</em>, opacity: 1 })</p>
            </div>
            <div class="paragraph">
              <p>SVG.Pattern
                pattern()
                конструктор на SVG.Container
                повертає SVG.Pattern що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>Creating a pattern is very similar to creating gradients:</p>
            </div>
            <div class="paragraph">
              <p>var pattern = draw.pattern(20, 20, function(add) {
                add.rect(20,20).fill(<em>#f06</em>) add.rect(10,10)
                add.rect(10,10).move(10,10)
                })
                This creates a checkered pattern of 20 x 20 pixels. You can add
                any available element to your pattern.</p>
            </div>
            <div class="paragraph">
              <p>Finally, to use the pattern on an element:</p>
            </div>
            <div class="paragraph">
              <p>rect.attr({ fill: pattern })
                Or:</p>
            </div>
            <div class="paragraph">
              <p>rect.fill(pattern)
                By passing the pattern instance as the fill on any element, the
                fill() method will be called on the pattern instance.</p>
            </div>
            <div class="paragraph">
              <p>pattern.fill()
                returns string</p>
            </div>
            <div class="paragraph">
              <p>pattern.fill() //→ returns <em>url(#SvgjsPattern1234)</em>
                pattern.update()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>A pattern can also be updated afterwards:</p>
            </div>
            <div class="paragraph">
              <p>pattern.update(function(add) { add.circle(15).center(10,10)
                })</p>
            </div>
            <div class="paragraph">
              <p>SVG.Mask
                mask()
                конструктор на SVG.Container
                повертає SVG.Mask що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill(<em>#fff</em>)</p>
            </div>
            <div class="paragraph">
              <p>var mask = draw.mask().add(ellipse)</p>
            </div>
            <div class="paragraph">
              <p>rect.maskWith(mask)
                But you can also use multiple elements:</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: <em>#fff</em>
                })
                var text = draw.text(<em>SVG.JS</em>).move(10, 10).font({ size:
                36 }).fill({ color: <em>#fff</em> })</p>
            </div>
            <div class="paragraph">
              <p>var mask = draw.mask().add(text).add(ellipse)</p>
            </div>
            <div class="paragraph">
              <p>rect.maskWith(mask)</p>
            </div>
            <div class="paragraph">
              <p>maskWith()
                конструктор на SVG.Element
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>The easiest way to mask is to use a single element:</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: <em>#fff</em>
                })</p>
            </div>
            <div class="paragraph">
              <p>rect.maskWith(ellipse)
                If you want the masked object to be rendered at 100% you need to
                set the fill color of the masking object to white. But you might
                also want to use a gradient:</p>
            </div>
            <div class="paragraph">
              <p>var gradient = draw.gradient(<em>linear</em>, function(stop) {
                stop.at({ offset: 0, color: <em>#000</em> }) stop.at({ offset:
                1, color: <em>#fff</em> })
                })</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color:
                gradient })</p>
            </div>
            <div class="paragraph">
              <p>rect.maskWith(ellipse)
                mask.unmask()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Unmasking the elements can be done with the unmask() method:</p>
            </div>
            <div class="paragraph">
              <p>rect.unmask()
                The unmask() method returns the masking element.</p>
            </div>
            <div class="paragraph">
              <p>mask.remove()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Removing the mask altogether will also unmask() all masked
                elements as well:</p>
            </div>
            <div class="paragraph">
              <p>mask.remove()
                masker
                повертає SVG.Mask</p>
            </div>
            <div class="paragraph">
              <p>For your convenience, the masking element is also referenced in
                the masked element. This can be useful in case you want to
                change the mask:</p>
            </div>
            <div class="paragraph">
              <p>rect.masker.fill(<em>#fff</em>)</p>
            </div>
            <div class="paragraph">
              <p>SVG.ClipPath
                Clipping elements works exactly the same as masking elements.
                The only difference is that clipped elements will adopt the
                geometry of the clipping element. Therefore events are only
                triggered when entering the clipping element whereas with masks
                the masked element triggers the event. Another difference is
                that masks can define opacity with their fill colour and
                clipPaths can’t.</p>
            </div>
            <div class="paragraph">
              <p>clip()
                конструктор на SVG.Container
                повертає SVG.ClipPath що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>Clip with multiple elements:</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10)
                var text = draw.text(<em>SVG.JS</em>).move(10, 10).font({ size:
                36 })</p>
            </div>
            <div class="paragraph">
              <p>var clip = draw.clip().add(text).add(ellipse)</p>
            </div>
            <div class="paragraph">
              <p>rect.clipWith(clip)</p>
            </div>
            <div class="paragraph">
              <p>clipWith()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>var ellipse = draw.ellipse(80, 40).move(10, 10)</p>
            </div>
            <div class="paragraph">
              <p>rect.clipWith(ellipse)
                clipPath.unclip()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Unclipping the elements can be done with the unclip() method:</p>
            </div>
            <div class="paragraph">
              <p>rect.unclip()
                clipPath.remove()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Removing the clip alltogether will also unclip() all clipped
                elements as well:</p>
            </div>
            <div class="paragraph">
              <p>clip.remove()
                clipper
                повертає SVG.ClipPath</p>
            </div>
            <div class="paragraph">
              <p>For your convenience, the clipping element is also referenced
                in the clipped element. This can be useful in case you want to
                change the clipPath:</p>
            </div>
            <div class="paragraph">
              <p>rect.clipper.move(10, 10)</p>
            </div>
            <div class="paragraph">
              <p>SVG.Use
                use()
                конструктор на SVG.Container
                повертає SVG.Use що наслідує від SVG.Shape</p>
            </div>
            <div class="paragraph">
              <p>The use element simply emulates another existing element. Any
                changes on the master element will be reflected on all the use
                instances. The usage of use() is very straightforward:</p>
            </div>
            <div class="paragraph">
              <p>var rect = draw.rect(100, 100).fill(<em>#f09</em>)
                var use = draw.use(rect).move(200, 200)
                In the case of the example above two rects will appear on the
                svg drawing, the original and the use instance. In some cases,
                you might want to hide the original element. The best way to do
                this is to create the original element in the defs node:</p>
            </div>
            <div class="paragraph">
              <p>var rect = draw.defs().rect(100, 100).fill(<em>#f09</em>)
                var use = draw.use(rect).move(200, 200)
                In this way, the rect element acts as a library element. You can
                edit it, but it won’t be rendered.</p>
            </div>
            <div class="paragraph">
              <p>Another way is to point an external SVG file, just specified
                the element id and path to file.</p>
            </div>
            <div class="paragraph">
              <p>var use = draw.use(<em>elementId</em>, <em>path/to/file.svg</em>)
                This way is useful when you have complex images already created.
                Note that, for external images (outside your domain) it may be
                necessary to load the file with XHR.</p>
            </div>
            <div class="paragraph">
              <p>SVG.Marker
                marker()
                конструктор на SVG.Container
                повертає SVG.Marker що наслідує від SVG.Container</p>
            </div>
            <div class="paragraph">
              <p>Markers can be added to every individual point of a line,
                polyline, polygon and path. There are three types of markers:
                start, mid and end. Where start represents the first point, end
                the last and mid every point in between.</p>
            </div>
            <div class="paragraph">
              <p>var path = draw.path(<em>M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0
                  100 100</em>)</p>
            </div>
            <div class="paragraph">
              <p>path.fill(<em>none</em>).move(20, 20).stroke({ width: 1, color:
                <em>#ccc</em> })</p>
            </div>
            <div class="paragraph">
              <p>path.marker(<em>start</em>, 10, 10, function(add) {
                add.circle(10).fill(<em>#f06</em>)
                })
                path.marker(<em>mid</em>, 10, 10, function(add) { add.rect(5,
                10).cx(5).fill(<em>#ccc</em>)
                })
                path.marker(<em>end</em>, 20, 20, function(add) {
                add.circle(6).center(4, 5) add.circle(6).center(4, 15)
                add.circle(6).center(12, 10)</p>
            </div>
            <div class="literalblock">
              <div class="content">
                <pre><code>  this.fill('#0f9')
})
The marker() method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times, so it will create a marker in the defs but not show it yet:</code></pre>
              </div>
            </div>
            <div class="paragraph">
              <p>var marker = draw.marker(10, 10, function(add) { add.rect(10,
                10)
                })
                Secondly a marker can be created and applied directly on its
                target element:</p>
            </div>
            <div class="paragraph">
              <p>path.marker(<em>start</em>, 10, 10, function(add) {
                add.circle(10).fill(<em>#f06</em>)
                })
                This will create a marker in the defs and apply it directly.
                Note that the first argument defines the position of the marker
                and that there are four arguments as opposed to three with the
                first example.</p>
            </div>
            <div class="paragraph">
              <p>Lastly, if a marker is created for reuse on a container
                element, it can be applied directly to the target element:</p>
            </div>
            <div class="paragraph">
              <p>path.marker(<em>mid</em>, marker)
                Finally, to get a marker instance from the target element
                reference:</p>
            </div>
            <div class="paragraph">
              <p>path.reference(<em>marker-end</em>)</p>
            </div>
            <div class="paragraph">
              <p>marker.height()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Defines the markerHeight attribute:</p>
            </div>
            <div class="paragraph">
              <p>marker.height(10)
                marker.ref()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>By default, the refX and refY attributes of a marker are set to
                respectively half the width nd height values. To define the refX
                and refY of a marker differently:</p>
            </div>
            <div class="paragraph">
              <p>marker.ref(2, 7)
                marker.size()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Defines the markerWidth and markerHeight attributes:</p>
            </div>
            <div class="paragraph">
              <p>marker.size(10, 10)
                marker.update()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>Updating the contents of a marker will clear() the existing
                content and add the content defined in the block passed as the
                first argument:</p>
            </div>
            <div class="paragraph">
              <p>marker.update(function(add) { add.circle(10)
                })
                marker.width()
                returns itself
                animate yes</p>
            </div>
            <div class="paragraph">
              <p>Defines the markerWidth attribute:</p>
            </div>
            <div class="paragraph">
              <p>marker.width(10)</p>
            </div>
            <div class="paragraph">
              <p>SVG.Bare
                For all SVG elements that are not described by SVG.js, the
                SVG.Bare class comes in handy. This class inherits directly from
                SVG.Element and makes it possible to add custom methods in a
                separate namespace without polluting the main SVG.Element
                namespace. Consider it your personal playground.</p>
            </div>
            <div class="paragraph">
              <p>element()
                повертає SVG.Bare що наслідує від SVG.Element</p>
            </div>
            <div class="paragraph">
              <p>The SVG.Bare class can be instantiated with the element()
                method on any parent element:</p>
            </div>
            <div class="paragraph">
              <p>var element = draw.element(<em>title</em>)
                The string value passed as the first argument is the node name
                that should be generated.</p>
            </div>
            <div class="paragraph">
              <p>Additionally, any existing class name can be passed as the
                second argument to define from which class the element should
                inherit:</p>
            </div>
            <div class="paragraph">
              <p>var element = draw.element(<em>symbol</em>, SVG.Parent)
                This gives you as the user a lot of power. But remember, with
                great power comes great responsibility.</p>
            </div>
            <div class="paragraph">
              <p>element.words()
                returns itself</p>
            </div>
            <div class="paragraph">
              <p>The SVG.Bare instance carries an additional method to add plain
                text:</p>
            </div>
            <div class="paragraph">
              <p>var element = draw.element(<em>title</em>).words(<em>This is a
                  title.</em>)</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="footnotes">
      <hr /></div>
    <div id="footer">
      <div id="footer-text">
        Last updated 2019-05-02 09:55:50 EEST
      </div>
    </div>
  </body>
</html>
