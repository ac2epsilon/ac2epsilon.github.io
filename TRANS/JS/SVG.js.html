<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>SVG.js</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>SVG.js</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Легковажна бібліотека для маніпуляції та анімації SVG.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___svg_js">Чому обирають SVG.js?</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js не має залежностей, та націлена бути малою як це можливо, при цьому провадячи повне покриття специфікації SVG. Якщо ви ще не переконані, ось декілька фактів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__">Вона тонка.</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js є легковажною. Цифри не брешуть, так що тут надається порівняння конкурентів. Майте на увазі, що це робить ту саму річ, але майже половиною довжини кода!</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Вона швидка.</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js швидка. Очевидно, не така швидка, як ванільний js, але в багато разів швидше, ніж конкуренти.</p></div>
<div class="paragraph"><p>Індекс:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>rects</code>: генерує 10000 прямокутників
</p>
</li>
<li>
<p>
<code>fill</code>: генерує 10000 заповнених кольором прямокутників
</p>
</li>
<li>
<p>
<code>gradient</code>: генерує 10000 прямокутників з градієнтом кольору
</p>
</li>
</ul></div>
<div class="paragraph"><p>Меньше - краще. Протестовано на Intel Core m5 @ 1.2GHz.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____">Просто читається, незахаращений синтаксис.</h2>
<div class="sectionbody">
<div class="paragraph"><p>Створення та маніпуляція SVG з використанням самого JavaScript досить балакуче. Наприклад, просте створення рожевого квадрата потребує досить багато коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Звичайний js</span>
<span class="kd">var</span> <span class="nx">ns</span> <span class="o">=</span> <span class="s1">&#39;http://www.w3.org/2000/svg&#39;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">svg</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElementNS</span><span class="p">(</span><span class="nx">ns</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="s1">&#39;100%&#39;</span><span class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;100%&#39;</span><span class="p">)</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">svg</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElementNS</span><span class="p">(</span><span class="nx">ns</span><span class="p">,</span> <span class="s1">&#39;rect&#39;</span><span class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nx">rect</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;#f06&#39;</span><span class="p">)</span>
<span class="nx">svg</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">rect</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>SVG.js провадить синтаксис, що одночасно стислий та його легко читати. Цей код робить те саме, що  і js приклад вище:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// SVG.js</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;#f06&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це тільки два рядка коду, замість десяти! Та при цьому значно менше повторів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___">Шаленійте з анімацією</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;input[type=text]&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">).</span><span class="nx">viewbox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">140</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">add</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">add</span><span class="p">.</span><span class="nx">tspan</span><span class="p">(</span> <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="p">)</span>
<span class="p">})</span>

<span class="nx">text</span>
        <span class="p">.</span><span class="nx">path</span><span class="p">(</span><span class="s1">&#39;M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">animate</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="s1">&#39;M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">loop</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

<span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;keyup&#39;</span><span class="p">,</span> <span class="nx">updateText</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>

<span class="kd">function</span> <span class="nx">updateText</span><span class="p">(</span><span class="nx">textPath</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">textPath</span><span class="p">.</span><span class="nx">tspan</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___8230">Та більше&#8230;</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
анімація за розміром, позицією, трансформацією, колором, &#8230;
</p>
</li>
<li>
<p>
безболісне розширення, дякуючи модулярній структурі
</p>
</li>
<li>
<p>
доступність різноманітні корисні плагіни
</p>
</li>
<li>
<p>
уніфікований api між типами фігур щодо пересування, розміру, центрування, &#8230;
</p>
</li>
<li>
<p>
прив'язка подій до елементів
</p>
</li>
<li>
<p>
повна підтримка для масок прозорості та шляхів відсічення
</p>
</li>
<li>
<p>
текстові шляхи, навіть анімовані
</p>
</li>
<li>
<p>
групи елементів
</p>
</li>
<li>
<p>
динамічні градієнти та шаблони
</p>
</li>
<li>
<p>
повністю документовано (ви дивитесь на це :)
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Ліцензія</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js ліцензований за умовами MIT License.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___3">Журнал змін</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цікавитесь, що змінилось в останньому релізі? Подивіться журнал змін.</p></div>
</div>
</div>
<h1 id="__2">Починаємо</h1>
<div class="sect1">
<h2 id="__3">Підготовка</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js вважає, що ви маєте HTML елемент з атрибутом <code>id</code>, створений та готовий служити як огортка. Щось таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>SVG.js<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;drawing&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__svg_">Створення SVG документу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Далі використовуйте функцію SVG() для створення SVG документу в оточуючому елементі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">).</span><span class="nx">size</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">attr</span><span class="p">({</span> <span class="nx">fill</span><span class="o">:</span> <span class="s1">&#39;#f06&#39;</span> <span class="p">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший аргумент може бути або <code>id</code> елемента, або сам обраний елемент. Це буде генерувати такий вихід:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;drawing&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">svg</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="na">version</span><span class="o">=</span><span class="s">&quot;1.1&quot;</span> <span class="na">xmlns:xlink</span><span class="o">=</span><span class="s">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="na">width</span><span class="o">=</span><span class="s">&quot;300&quot;</span> <span class="na">height</span><span class="o">=</span><span class="s">&quot;300&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">width</span><span class="o">=</span><span class="s">&quot;100&quot;</span> <span class="na">height</span><span class="o">=</span><span class="s">&quot;100&quot;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&quot;#f06&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">rect</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>По замовчанню малюнок svg слідує розмірам свого батька, в цьому випадку <code>#drawing</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">).</span><span class="nx">size</span><span class="p">(</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span> <span class="s1">&#39;100%&#39;</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___svg">Перевірка підтримки SVG</h2>
<div class="sectionbody">
<div class="paragraph"><p>По замовчанню SVG.js вважає, що браузер клієнта підтримує SVG. Ви можете перевірити підтримку таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">SVG</span><span class="p">.</span><span class="nx">supported</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;SVG not supported&#39;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___dom">Очікування завантаження DOM</h2>
<div class="sectionbody">
<div class="paragraph"><p>Це може для багатьох виглядати очевидним, але це все ще варте нагадування. Якщо ви включаєте ваші js файли в заголовку вашого документу, переконайтесь, що діждетесь завантаження DOM:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">SVG</span><span class="o">.</span><span class="n">on</span><span class="o">(</span><span class="n">document</span><span class="o">,</span> <span class=" -Symbol">&#39;DOMContentLoaded</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">function</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">draw</span> <span class="k">=</span> <span class="nc">SVG</span><span class="o">(</span><span class=" -Symbol">&#39;drawing</span><span class="err">&#39;</span><span class="o">)</span>
<span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не проблема, якщо ви вставляєте ваш js знизу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__svg">Чистий SVG</h2>
<div class="sectionbody">
<div class="paragraph"><p>SVG.js також робить за межами HTML DOM, наприклад, в документі SVG:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span>
<span class="nt">&lt;svg</span> <span class="na">id=</span><span class="s">&quot;drawing&quot;</span> <span class="na">xmlns=</span><span class="s">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="na">xmlns:xlink=</span><span class="s">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="na">version=</span><span class="s">&quot;1.1&quot;</span> <span class="nt">&gt;</span>
  <span class="nt">&lt;script</span> <span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">xlink:href=</span><span class="s">&quot;svg.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;script</span> <span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span>
    <span class="cp">&lt;![CDATA[</span>
<span class="cp">      var draw = SVG(&#39;drawing&#39;)</span>
<span class="cp">      draw.rect(100,100).animate().fill(&#39;#f03&#39;).move(100,100)</span>
<span class="cp">    ]]&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/svg&gt;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__4">Пісочниця</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб дати вам поштовх, ось базове налаштування. Присутнє все для початку забавок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ініціалізація SVG.js</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">)</span>

<span class="c1">// темно рожевий квадрат</span>
<span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">).</span><span class="nx">move</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;#f06&#39;</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<h1 id="__5">Батькі</h1>
<div class="sect1">
<h2 id="_svg_parent">SVG.Parent</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас <code>SVG.Parent</code> є базовою огорткою для всіх елементів, що можуть містити інші елементи. <code>SVG.Parent</code> наслідує напряму від найнижчого рівня класів SVG.js: <code>SVG.Element</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_container">SVG.Container</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>SVG.Container</code> додає інший рівень до стеку батьківського наслідування. Якщо <code>SVG.Parent</code> приносить декілька низькорівневих методів, як <code>add()</code>, <code>remove()</code> та <code>has()</code>, щоб назвати декілька, <code>SVG.Container</code> може та повинен використовуватись, якщо ви бажаєте додати ваші власні методи. Таким чином, прототип <code>SVG.Parent</code> залишається чистим. Вам слідує завжди наслідувати від <code>SVG.Container</code>, коли реалізуєте ваші власні батьківські елементи.</p></div>
<div class="paragraph"><p>Стек батьківського наслідування таий: <code>SVG.Element</code> &gt; <code>SVG.Parent</code> &gt; <code>SVG.Container</code>.</p></div>
</div>
</div>
<h1 id="_svg_doc">SVG.Doc</h1>
<div class="paragraph"><p>Функція-ініціалізатор SVG.js створює кореневий вузол в наданий елемент, та повертає примірник <code>SVG.Doc</code>.</p></div>
<div class="sect1">
<h2 id="_svg">SVG()</h2>
<div class="sectionbody">
<div class="paragraph"><p>повертає <code>SVG.Doc</code>, що наслідує від <code>SVG.Container</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">SVG</span><span class="p">(</span><span class="s1">&#39;drawing&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Перший раз, коли викликається <code>SVG()</code>, буде створений другий, невидимий <code>&lt;svg&gt;</code>. Це наш парсер, та він пояснений в FAQ.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_nested">SVG.Nested</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вкладені документи SVG один в одного.</p></div>
<div class="sect2">
<h3 id="_nested">nested()</h3>
<div class="paragraph"><p>конструктор <code>SVG.Container</code>
повертає <code>SVG.Nested</code>, що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>Вкладені SVG документи мають точно такі можливості, що і головний SVG документ вищого рівня:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">nested</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">nested</span><span class="p">()</span>

<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">nested</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_g">SVG.G</h2>
<div class="sectionbody">
<div class="paragraph"><p>Групування елементів може буде корисне, якщо ви бажаєте трансформувати набір елементів, так, якби це був один елемент. Всі елементи в групі керують свою позицію відносно до групи, до якої вони належать.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Групи не мають своєї власної геометрії, вона наслідується від його вмісту. Таким чином групи не зважають на атрибути <code>x</code>, <code>y</code>, <code>width</code> та <code>height</code>. Якщо це те, що ви шукаєте, використовуйте замість цього <code>nested()</code> svg.</td>
</tr></table>
</div>
<div class="sect2">
<h3 id="_group">group()</h3>
<div class="paragraph"><p>конструктор <code>SVG.Container</code>
повертає <code>SVG.G</code>, що наслідує від <code>SVG.Container</code></p></div>
<div class="paragraph"><p>Група має всі ті самі методи елемента, що і кореневий документ SVG:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">group</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">group</span><span class="p">()</span>
<span class="nx">group</span><span class="p">.</span><span class="nx">path</span><span class="p">(</span><span class="s1">&#39;M10,20L30,40&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Існуючі елементи з документу SVG також може бути додані групи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">group</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">rect</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_symbol">SVG.Symbol</h2>
<div class="sectionbody">
<div class="paragraph"><p>конструктор <code>SVG.Container</code>
повертає <code>SVG.Symbol</code>, що наслідує від <code>SVG.Container</code></p></div>
<div class="paragraph"><p>Подібно до елементу групи, елемент символа є контейнерним елементом. Єдина різниця в тому, що символи не відображуються. Таким чином елемент символа є ідеальним в комбінації з елементом <code>use</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">symbol</span><span class="p">()</span>
<span class="nx">symbol</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;#f09&#39;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">use</span>  <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">symbol</span><span class="p">).</span><span class="nx">move</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_defs">SVG.Defs</h2>
<div class="sectionbody">
<div class="paragraph"><p>Елемент &lt;defs&gt; є контейнером для посиланих елементів. Нащадки вузла <code>&lt;defs&gt;</code> не відображуються напряму. Вузол <code>&lt;defs&gt;</code> живе в головному документі <code>&lt;svg&gt;</code>, та може бути досяжний за допомогою метода <code>defs()</code>.</p></div>
<div class="sect2">
<h3 id="_defs">defs()</h3>
<div class="paragraph"><p>конструктор <code>SVG.Container</code>
повертає <code>SVG.Defs</code>, що наслідує від <code>SVG.Container</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">defs</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">defs</span><span class="p">()</span>
</pre></div></div></div>
<div class="paragraph"><p><code>defs</code> також доступний на любому іншому елементі через метод <code>doc()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">defs</span> <span class="o">=</span> <span class="nx">rect</span><span class="p">.</span><span class="nx">doc</span><span class="p">().</span><span class="nx">defs</span><span class="p">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Вузол <code>defs</code> робить точно так само, як і групи.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_svg_a">SVG.A</h2>
<div class="sectionbody">
<div class="paragraph"><p>Створює гіперпосилання, що буде активоване на всіх дитячих елементах.</p></div>
<div class="sect2">
<h3 id="_link">link()</h3>
<div class="paragraph"><p>конструктор <code>SVG.Container</code>
повертає <code>SVG.A</code>, що наслідує від <code>SVG.Container</code></p></div>
<div class="paragraph"><p>Гіперпосилання або тег <code>&lt;a&gt;</code> створює контейнер, що дозволяє посилання на всіх його дітях:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">link</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">link</span><span class="p">(</span><span class="s1">&#39;http://svgdotjs.github.io/&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">link</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Url посилання може бути оновлене за допомогою метода <code>to()</code> method:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">link</span><span class="p">.</span><span class="nx">to</span><span class="p">(</span><span class="s1">&#39;http://apple.com&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більше того, елемент <code>link</code> має метод <code>show()</code> для створення атрибута <code>xlink:show</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">link</span><span class="p">.</span><span class="nx">show</span><span class="p">(</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та метод <code>target()</code> для створення атрибута <code>target</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">link</span><span class="p">.</span><span class="nx">target</span><span class="p">(</span><span class="s1">&#39;_blank&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Елементи можуть бути пов'язані в інший спосіб за допомогою метода <code>linkTo()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">rect</span><span class="p">.</span><span class="nx">linkTo</span><span class="p">(</span><span class="s1">&#39;http://svgdotjs.github.io/&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, замість URL може бути переданий блок, для додаткових опцій елемента посилання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">rect</span><span class="p">.</span><span class="nx">linkTo</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">link</span><span class="p">.</span><span class="nx">to</span><span class="p">(</span><span class="s1">&#39;http://svgdotjs.github.io/&#39;</span><span class="p">).</span><span class="nx">target</span><span class="p">(</span><span class="s1">&#39;_blank&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div></div></div>
</div>
</div>
</div>
<h1 id="__6">Елементи</h1>
<div class="paragraph"><p><code>SVG.Element</code> є базовим прототипом, що огортає всі елементи (або вузли, коли це важливо) в SVG.js. Додатковий рівень уточнення доданий з допомогою <code>SVG.Shape</code>. Кожний елемент, що може приймати атрибути <code>fill</code> та/або <code>stroke</code>. Бажано розширювати елементи ваши ми власними методами на <code>SVG.Shape</code>, скоріше ніж на <code>SVG.Element</code>.</p></div>
<h1 id="_svg_rect">SVG.Rect</h1>
<div class="sect2">
<h3 id="_rect">rect()</h3>
<div class="paragraph"><p>конструктор на SVG.Container
повертає SVG.Rect що наслідує від <code>SVG.Shape</code></p></div>
<div class="paragraph"><p>Прямокутники мають два аргументи, свою ширину та висоту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_rect_radius">rect.radius()</h3>
<div class="paragraph"><p>повертає себе, анімується</p></div>
<div class="paragraph"><p>Прямокутники можуть мати скруглені кути:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">rect</span><span class="p">.</span><span class="nx">radius</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде встановлювати атрибути <code>rx</code> та <code>ry</code> в <code>10</code>. Щоб встановити <code>rx</code> та <code>ry</code> індивідуально:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">rect</span><span class="p">.</span><span class="nx">radius</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</pre></div></div></div>
</div>
<h1 id="_svg_circle">SVG.Circle</h1>
<div class="sect1">
<h2 id="_circle">circle()</h2>
<div class="sectionbody">
<div class="paragraph"><p>конструктор на SVG.Container
повертає SVG.Circle що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Єдиний аргумент, потрібний для кола, є його диаметр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">circle</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_circle_radius">circle.radius()</h2>
<div class="sectionbody">
<div class="paragraph"><p>повертає себе, анімується</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">circle</span><span class="p">.</span><span class="nx">radius</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<h1 id="_svg_ellipse">SVG.Ellipse</h1>
<div class="sect1">
<h2 id="_ellipse">ellipse()</h2>
<div class="sectionbody">
<div class="paragraph"><p>конструктор на SVG.Container
повертає SVG.Circle що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Еліпси мають два аргументи, їх ширину та висоту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">ellipse</span> <span class="k">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_ellipse_radius">ellipse.radius()</h2>
<div class="sectionbody">
<div class="paragraph"><p>повертає себе, анімується</p></div>
<div class="paragraph"><p>Еліпси також можуть перевизначатись по радіусу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">ellipse</span><span class="p">.</span><span class="nx">radius</span><span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
<h1 id="_svg_line">SVG.Line</h1>
<div class="sect1">
<h2 id="_line">line()</h2>
<div class="sectionbody">
<div class="paragraph"><p>конструктор на SVG.Container
повертає SVG.Line що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Створює лінію від точки A до точки B:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">line</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">).</span><span class="nx">stroke</span><span class="p">({</span> <span class="nx">width</span><span class="o">:</span> <span class="mi">1</span> <span class="p">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення елементу лінії може бути зроблене в чотори способи. Дивіться метод <code>plot()</code> щоб побачити всі можливості.</p></div>
<div class="sect2">
<h3 id="_line_array">line.array()</h3>
<div class="paragraph"><p>повертає <code>SVG.PointArray</code></p></div>
<div class="paragraph"><p>Посилання на примірник <code>SVG.PointArray</code>. Цей метод скоріше призначений для внутрішнього використання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">polyline</span><span class="p">.</span><span class="nx">array</span><span class="p">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Додаткова інформація: <code>SVG.PointArray</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_line_plot">line.plot()</h3>
<div class="paragraph"><p>повертає себе, анімується</p></div>
<div class="paragraph"><p>Оновлення лінії методом <code>plot()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">line</span><span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно приймає рядок з точками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">line</span><span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="s1">&#39;0,0 100,150&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або масив масивів для точок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">line</span><span class="p">.</span><span class="nx">plot</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]])</span>
</pre></div></div></div>
<div class="paragraph"><p>Або примірник <code>SVG.PointArray</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SVG</span><span class="p">.</span><span class="nx">PointArray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]])</span>
<span class="nx">line</span><span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>plot()</code> може бути анімований:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">line</span><span class="o">.</span><span class="n">animate</span><span class="o">(</span><span class="mi">3000</span><span class="o">).</span><span class="n">plot</span><span class="o">([[</span><span class="err">200</span>, <span class="err">200</span><span class="o">]</span>, <span class="o">[</span><span class="err">100</span>, <span class="err">150</span><span class="o">]])</span>
</pre></div></div></div>
</div>
</div>
</div>
<h1 id="_svg_polyline">SVG.Polyline</h1>
<div class="sect1">
<h2 id="_polyline">polyline()</h2>
<div class="sectionbody">
<div class="paragraph"><p>конструктор на SVG.Container
повертає SVG.Polyine що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Елемент полілінії визначає набір прямих сегментів ліній. Типово елементи поліліній визначають відкриті фігури:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">polyline</span> <span class="k">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">polyline</span><span class="o">(</span><span class="err">&#39;</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span> <span class="mi">100</span><span class="o">,</span><span class="mi">50</span> <span class="mi">50</span><span class="o">,</span><span class="mi">100</span><span class="err">&#39;</span><span class="o">).</span><span class="n">fill</span><span class="o">(</span><span class=" -Symbol">&#39;none</span><span class="err">&#39;</span><span class="o">).</span><span class="n">stroke</span><span class="o">({</span> <span class="n">width</span><span class="k">:</span> <span class="err">1</span> <span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Полілайн рядкі складаються зі списку точок, розділених комами або проміжками. Так що <code>x,y x,y x,y</code> так само як <code>x y x y x y</code> або навіть <code>x,y,x,y,x,y</code> буде робити.</p></div>
<div class="paragraph"><p>Як альтернатива також буде робити масив точок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">polyline</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polyline</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">]])</span>
</pre></div></div></div>
<div class="paragraph"><p>Або навіть плаский масив точок, що навіть краще:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">polyline</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">polyline</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_polyline_array">polyline.array()</h3>
<div class="paragraph"><p>повертає SVG.PointArray</p></div>
<div class="paragraph"><p>References the SVG.PointArray instance. This method is rather intended for internal use:</p></div>
<div class="paragraph"><p>polyline.array()
More info: SVG.PointArray.</p></div>
<div class="paragraph"><p>polyline.clear()
returns itself</p></div>
<div class="paragraph"><p>When the given point data is parsed, the result is cached. This method clears the cache.</p></div>
<div class="paragraph"><p>polyline.clear()
polyline.plot()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Polylines can be updated using the plot() method:</p></div>
<div class="paragraph"><p>polyline.plot(<a id="0"></a>)
The plot() method can also be animated:</p></div>
<div class="paragraph"><p>polyline.animate(3000).plot(<a id="0"></a>)</p></div>
<div class="paragraph"><p>SVG.Polygon
polygon()
конструктор на SVG.Container
повертає SVG.Polygon що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>The polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments:</p></div>
<div class="paragraph"><p>var polygon = draw.polygon(<em>0,0 100,50 50,100</em>).fill(<em>none</em>).stroke({ width: 1 })
Polygon strings or arrays are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically.</p></div>
<div class="paragraph"><p>polygon.array()
повертає SVG.PointArray</p></div>
<div class="paragraph"><p>References the SVG.PointArray instance. This method is rather intended for internal use:</p></div>
<div class="paragraph"><p>polygon.array()
More info: SVG.PointArray.</p></div>
<div class="paragraph"><p>polygon.clear()
returns itself</p></div>
<div class="paragraph"><p>When the given point data is parsed, the result is cached. This method clears the cache.</p></div>
<div class="paragraph"><p>polygon.clear()
polygon.plot()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Like polylines, polygons can be updated using the plot() method:</p></div>
<div class="paragraph"><p>polygon.plot(<a id="0"></a>)
The plot() method can also be animated:</p></div>
<div class="paragraph"><p>polygon.animate(3000).plot(<a id="0"></a>)</p></div>
<div class="paragraph"><p>SVG.Path
path()
конструктор на SVG.Container
повертає SVG.Path що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>The path string is similar to the polygon string but much more complex in order to support curves:</p></div>
<div class="paragraph"><p>draw.path(<em>M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z</em>)</p></div>
<div class="paragraph"><p>For more details on path data strings, please refer to the SVG documentation on path data.</p></div>
<div class="paragraph"><p>path.array()
повертає SVG.PathArray</p></div>
<div class="paragraph"><p>References the SVG.PathArray instance. This method is rather intended for internal use:</p></div>
<div class="paragraph"><p>path.array()
More info: SVG.PathArray.</p></div>
<div class="paragraph"><p>path.clear()
returns itself</p></div>
<div class="paragraph"><p>When the given path data is parsed, the result is cached. This method clears the cache.</p></div>
<div class="paragraph"><p>path.clear()
path.length()
returns number</p></div>
<div class="paragraph"><p>Get the total length of a path element:</p></div>
<div class="paragraph"><p>var length = path.length()
path.pointAt()
повертає SVGPoint</p></div>
<div class="paragraph"><p>Get point on a path at given length:</p></div>
<div class="paragraph"><p>var point = path.pointAt(105)
Note: pointAt() returns a native SVGPoint and not a SVG.Point.</p></div>
<div class="paragraph"><p>path.plot()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Paths can be updated using the plot() method:</p></div>
<div class="paragraph"><p>path.plot(<em>M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80</em>)
The plot() method can also be animated:</p></div>
<div class="paragraph"><p>path.animate(2000).plot(<em>M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80</em>).loop(true, true)
There is only basic support for animating paths baked into SVG.js, which means that only paths with the same commands (M,C,S etc.) are animateable.</p></div>
<div class="paragraph"><p>If you need to animate paths that do not share the same commands in order, you can use svg.pathmorphing.js</p></div>
<div class="paragraph"><p>SVG.Text
text()
конструктор на SVG.Container
повертає SVG.Text що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Unlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements.</p></div>
<div class="paragraph"><p>The first and easiest method is to provide a string of text, split by newlines:</p></div>
<div class="paragraph"><p>var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
This will automatically create a block of text and insert newlines where necessary.</p></div>
<div class="paragraph"><p>The second method will give you much more control but requires a bit more code:</p></div>
<div class="paragraph"><p>var text = draw.text(function(add) {
  add.tspan(<em>Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur</em>).fill(<em>#f06</em>)
  add.tspan(<em>.</em>)
  add.tspan(<em>Cras sodales imperdiet auctor.</em>).newLine().dx(20)
  add.tspan(<em>Nunc ultrices lectus at erat</em>).newLine()
  add.tspan(<em>dictum pharetra elementum ante</em>).newLine()
})
If you want to go the other way and don&#8217;t want to add tspans at all, just one line of text, you can use the plain() method instead:</p></div>
<div class="paragraph"><p>var text = draw.plain(<em>Lorem ipsum dolor sit amet consectetur.</em>)
This is a shortcut to the plain method on the SVG.Text instance which doesn&#8217;t render newlines at all.</p></div>
<div class="paragraph"><p>text.build()
returns itself</p></div>
<div class="paragraph"><p>The build() can be used to enable / disable build mode. With build mode disabled, the plain() and tspan() methods will first call the clear() method before adding the new content. So when build mode is enabled, plain() and tspan() will append the new content to the existing content. When passing a block to the text() method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually:</p></div>
<div class="paragraph"><p>var text = draw.text('This is just the start, ')</p></div>
<div class="paragraph"><p>text.build(true)  // enables build mode</p></div>
<div class="paragraph"><p>var tspan = text.tspan(<em>something pink in the middle ').fill(</em>#00ff97')
text.plain(<em>and again boring at the end.</em>)</p></div>
<div class="paragraph"><p>text.build(false) // disables build mode</p></div>
<div class="paragraph"><p>tspan.animate(<em>2s</em>).fill(<em>#f06</em>)
text.clear()
returns itself</p></div>
<div class="paragraph"><p>Clear all the contents of the called text element:</p></div>
<div class="paragraph"><p>text.clear()
text.length()
returns number</p></div>
<div class="paragraph"><p>Gets the total computed text length of all tspans together:</p></div>
<div class="paragraph"><p>text.length()
text.font() as setter
returns itself</p></div>
<div class="paragraph"><p>A convenience method to add font-related properties:</p></div>
<div class="paragraph"><p>text.font({
  family:   <em>Helvetica</em>
, size:     144
, anchor:   <em>middle</em>
, leading:  <em>1.5em</em>
})
Not unlike the attr() method, the font() method also accepts a key/value pair:</p></div>
<div class="paragraph"><p>text.font(<em>family</em>, <em>Menlo</em>)
Available properties are:</p></div>
<div class="paragraph"><p>leading (will do the same as calling the leading() method as setter)
anchor (will set the text-anchor attribute)
family (will set the font-family attribute)
size (will set the font-size attribute)
stretch (will set the font-stretch attribute)
style (will set the font-style attribute)
variant (will set the font-variant attribute)
weight (will set the font-weight attribute)
Any other property will be applied as given. So, for example, the letter-spacing property will just be applied as it would be given to the attr() method. More on font-related properties here.</p></div>
<div class="paragraph"><p>text.font() as getter
As you might expect, the font() method also acts as a getter:</p></div>
<div class="paragraph"><p>var leading = text.font(<em>leading</em>)
text.leading() as setter
returns itself
animate yes</p></div>
<div class="paragraph"><p>As opposed to html, where leading is defined by line-height, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by &lt;tspan&gt; nodes with a dy attribute defining the line height and an x value resetting the line to the x position of the parent text element. But you can also have many nodes in one line defining a different y, dy, x or even dx value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it&#8217;s height is. The leading() method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html:</p></div>
<div class="paragraph"><p>var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
text.leading(1.3)
This will render a text element with a tspan element for each line, with a dy value of 130% of the font size.</p></div>
<div class="paragraph"><p>Note that the leading() method assumes that every first level tspan in a text node represents a new line. Using leading() on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the newLine() method on every first level tspan added in the block passed as an argument to the text element.</p></div>
<div class="paragraph"><p>text.leading() as getter
returns value</p></div>
<div class="paragraph"><p>Get the current leading value:</p></div>
<div class="paragraph"><p>var leading = text.leading()
text.lines()
повертає SVG.Set</p></div>
<div class="paragraph"><p>All first level tspans can be referenced with the lines() method:</p></div>
<div class="paragraph"><p>text.lines()
This will return an instance of SVG.Set including all tspan elements.</p></div>
<div class="paragraph"><p>text.plain()
returns itself</p></div>
<div class="paragraph"><p>If the content of the element doesn&#8217;t need any styling or multiple lines, it might be sufficient to just add some plain text:</p></div>
<div class="paragraph"><p>text.plain(<em>I do not have any expectations.</em>)
text.rebuild()
returns itself</p></div>
<div class="paragraph"><p>This is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver font-size and x attributes or the leading() of the text element are modified. This method also acts a setter to enable or disable rebuilding:</p></div>
<div class="paragraph"><p>text.rebuild(false) //&#8594; disables rebuilding
text.rebuild(true)  //&#8594; enables rebuilding and instantaneously rebuilds the text element
text.text() as setter
returns itself</p></div>
<div class="paragraph"><p>Changing text afterwards is also possible with the text() method:</p></div>
<div class="paragraph"><p>text.text(<em>Brilliant!</em>)
text.text() as getter
returns string</p></div>
<div class="paragraph"><p>To get the raw text content:</p></div>
<div class="paragraph"><p>text.text()
text.tspan()
повертає SVG.Tspan</p></div>
<div class="paragraph"><p>Just adding one tspan is also possible:</p></div>
<div class="paragraph"><p>text.tspan(' on a train&#8230;<em>).fill(</em>#f06')</p></div>
<div class="paragraph"><p>SVG.TextPath
path()
конструктор на SVG.Text
повертає SVG.TextPath що наслідує від SVG.Text</p></div>
<div class="paragraph"><p>A nice feature in svg is the ability to run text along a path:</p></div>
<div class="paragraph"><p>var text = draw.text(function(add) {
  add.tspan(<em>We go ')
  add.tspan('up</em>).fill(<em>#f09</em>).dy(-40)
  add.tspan(<em>, then we go down, then up again</em>).dy(40)
})</p></div>
<div class="paragraph"><p>var path = <em>M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100</em></p></div>
<div class="paragraph"><p>text.path(path).font({ size: 42.5, family: <em>Verdana</em> })
When calling the path() method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a plot() method to update the path:</p></div>
<div class="paragraph"><p>text.plot(<em>M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100</em>)
Attributes specific to the &lt;textPath&gt; element can be applied to the textPath instance itself:</p></div>
<div class="paragraph"><p>text.textPath().attr(<em>startOffset</em>, <em>50%</em>)
And they can be animated as well of course:</p></div>
<div class="paragraph"><p>text.textPath().animate(3000).attr(<em>startOffset</em>, <em>80%</em>)
Note: If a startOffset other than a percentage is given, then the value represents a distance along the path measured in the current user coordinate system.</p></div>
<div class="paragraph"><p>textPath.array()
повертає SVG.PathArray</p></div>
<div class="paragraph"><p>Get the path array of the underlying path:</p></div>
<div class="paragraph"><p>var array = text.textPath().array()
textPath.plot()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Change the path on the textpath element:</p></div>
<div class="paragraph"><p>text.textPath().plot(<em>M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200</em>)
textPath.textPath()
повертає SVG.TextPath</p></div>
<div class="paragraph"><p>Referencing the textPath node directly:</p></div>
<div class="paragraph"><p>var textPath = text.textPath()
textPath.track()
повертає SVG.Path</p></div>
<div class="paragraph"><p>Referencing the linked path element directly:</p></div>
<div class="paragraph"><p>var path = text.track()</p></div>
<div class="paragraph"><p>Note: SVG.TextPath inherits from SVG.Text, so all those methods are inherited as well.</p></div>
<div class="paragraph"><p>Events for SVG.Text
The text element has one event. It is fired every time the rebuild() method is called:</p></div>
<div class="paragraph"><p>text.on(<em>rebuild</em>, function() {
  // whatever you need to do after rebuilding
})</p></div>
<div class="paragraph"><p>SVG.Tspan
tspan()
конструктор на SVG.Text
повертає SVG.Tspan що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>The tspan elements are only available inside text elements or inside other tspan elements.</p></div>
<div class="paragraph"><p>text.tspan(<em>spannened</em>)
tspan.clear()
returns itself</p></div>
<div class="paragraph"><p>Clear all the contents of the called tspan element:</p></div>
<div class="paragraph"><p>tspan.clear()
tspan.dx()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Define the dynamic x value of the element, much like a html element with position:relative and left defined:</p></div>
<div class="paragraph"><p>tspan.dx(30)
tspan.dy()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Define the dynamic y value of the element, much like a html element with position:relative and top defined:</p></div>
<div class="paragraph"><p>tspan.dy(30)
tspan.plain()
returns itself</p></div>
<div class="paragraph"><p>Just adds some plain text:</p></div>
<div class="paragraph"><p>tspan.plain(<em>I do not have any expectations.</em>)
tspan.length()
returns number</p></div>
<div class="paragraph"><p>Gets the total computed text length:</p></div>
<div class="paragraph"><p>tspan.length()
tspan.newLine()
returns itself</p></div>
<div class="paragraph"><p>The newLine() is a convenience method for adding a new line with a dy attribute using the current "leading":</p></div>
<div class="paragraph"><p>var text = draw.text(function(add) {
  add.tspan(<em>Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur</em>).fill(<em>#f06</em>)
  add.tspan(<em>.</em>)
  add.tspan(<em>Cras sodales imperdiet auctor.</em>).newLine().dx(20)
  add.tspan(<em>Nunc ultrices lectus at erat</em>).newLine()
  add.tspan(<em>dictum pharetra elementum ante</em>).newLine()
})
tspan.text()
returns itself</p></div>
<div class="paragraph"><p>Update the content of the tspan. This can be done by either passing a string:</p></div>
<div class="paragraph"><p>tspan.text(<em>Just a string.</em>)
Which will basicly call the plain() method:</p></div>
<div class="paragraph"><p>Or by passing a block to add more specific content inside the called tspan:</p></div>
<div class="paragraph"><p>tspan.text(function(add) {
  add.plain(<em>Just plain text.</em>)
  add.tspan(<em>Fancy text wrapped in a tspan.</em>).fill(<em>#f06</em>)
  add.tspan(function(addMore) {
    addMore.tspan(<em>And you can doo deeper and deeper&#8230;</em>)
  })
})
tspan.tspan()
повертає SVG.Tspan</p></div>
<div class="paragraph"><p>Add a nested tspan:</p></div>
<div class="paragraph"><p>tspan.tspan(<em>I am a child of my parent</em>).fill(<em>#f06</em>)</p></div>
<div class="paragraph"><p>SVG.Image
image()
конструктор на SVG.Container
повертає SVG.Image що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>Creating images is as you might expect:</p></div>
<div class="paragraph"><p>var image = draw.image(<em>/path/to/image.jpg</em>)
If you know the size of the image, those parameters can be passed as the second and third arguments:</p></div>
<div class="paragraph"><p>var image = draw.image(<em>/path/to/image.jpg</em>, 200, 300)</p></div>
<div class="paragraph"><p>image.load()
returns itself</p></div>
<div class="paragraph"><p>Loading another image can be done with the load() method:</p></div>
<div class="paragraph"><p>image.load(<em>/path/to/another/image.jpg</em>)
image.loaded()
returns itself</p></div>
<div class="paragraph"><p>If you don&#8217;t know the size of the image, obviously you will have to wait for the image to be loaded:</p></div>
<div class="paragraph"><p>var image = draw.image(<em>/path/to/image.jpg</em>).loaded(function(loader) {
  this.size(loader.width, loader.height)
})
The returned loader object as first the argument of the loaded method contains four values:</p></div>
<div class="paragraph"><p>width
height
ratio (width / height)
url</p></div>
<div class="paragraph"><p>SVG.Gradient
gradient()
конструктор на SVG.Container
повертає SVG.Gradient що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>There are linear and radial gradients. The linear gradient can be created like this:</p></div>
<div class="paragraph"><p>var gradient = draw.gradient(<em>linear</em>, function(stop) {
  stop.at(0, <em>#333</em>)
  stop.at(1, <em>#fff</em>)
})
Finally, to use the gradient on an element:</p></div>
<div class="paragraph"><p>rect.attr({ fill: gradient })
Or:</p></div>
<div class="paragraph"><p>rect.fill(gradient)
By passing the gradient instance as the fill on any element, the fill() method will be called on the gradient instance.</p></div>
<div class="paragraph"><p>MDN has a great example page on how SVG Gradients work.</p></div>
<div class="paragraph"><p>gradient.at()
returns itself</p></div>
<div class="paragraph"><p>The offset and color parameters are required for stops, opacity is optional. The offset is a float between 0 and 1, or a percentage value (e.g. 33%).</p></div>
<div class="paragraph"><p>stop.at(0, <em>#333</em>)
or</p></div>
<div class="paragraph"><p>stop.at({ offset: 0, color: <em>#333</em>, opacity: 1 })
gradient.fill()
returns string</p></div>
<div class="paragraph"><p>gradient.fill() //&#8594; returns <em>url(#SvgjsGradient1234)</em>
gradient.from()
returns itself
animate yes</p></div>
<div class="paragraph"><p>To define the direction you can set from x, y and to x, y:</p></div>
<div class="paragraph"><p>gradient.from(0, 0).to(0, 1)
The from and to values are also expressed in percent.</p></div>
<div class="paragraph"><p>gradient.get()
повертає SVG.Stop</p></div>
<div class="paragraph"><p>The get() method makes it even easier to get a stop from an existing gradient:</p></div>
<div class="paragraph"><p>var gradient = draw.gradient(<em>radial</em>, function(stop) {
  stop.at({ offset: 0, color: <em>#000</em>, opacity: 1 })   // &#8594; first
  stop.at({ offset: 0.5, color: <em>#f03</em>, opacity: 1 }) // &#8594; second
  stop.at({ offset: 1, color: <em>#066</em>, opacity: 1 })   // &#8594; third
})</p></div>
<div class="paragraph"><p>var s1 = gradient.get(0) // &#8594; returns "first" stop
gradient.radius()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Radial gradients have a radius() method to define the outermost radius to where the inner color should develop:</p></div>
<div class="paragraph"><p>var gradient = draw.gradient(<em>radial</em>, function(stop) {
  stop.at(0, <em>#333</em>)
  stop.at(1, <em>#fff</em>)
})</p></div>
<div class="paragraph"><p>gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)
gradient.to()
returns itself
animate yes</p></div>
<div class="paragraph"><p>To define the direction you can set from x, y and to x, y:</p></div>
<div class="paragraph"><p>gradient.from(0, 0).to(0, 1)
The from and to values are also expressed in percent.</p></div>
<div class="paragraph"><p>gradient.update()
returns itself</p></div>
<div class="paragraph"><p>A gradient can also be updated afterwards:</p></div>
<div class="paragraph"><p>gradient.update(function(stop) {
  stop.at(0.1, <em>#333</em>, 0.2)
  stop.at(0.9, <em>#f03</em>, 1)
})
And even a single stop can be updated:</p></div>
<div class="paragraph"><p>var s1, s2, s3</p></div>
<div class="paragraph"><p>draw.gradient(<em>radial</em>, function(stop) {
  s1 = stop.at(0, <em>#000</em>)
  s2 = stop.at(0.5, <em>#f03</em>)
  s3 = stop.at(1, <em>#066</em>)
})</p></div>
<div class="paragraph"><p>s1.update(0.1, <em>#0f0</em>, 1)</p></div>
<div class="paragraph"><p>SVG.Stop
at()
конструктор на SVG.Gradient
повертає SVG.Stop що наслідує від SVG.Element</p></div>
<div class="paragraph"><p>The stop elements are only available inside gradient elements.</p></div>
<div class="paragraph"><p>var stop = gradient.at(0.5, <em>#f03</em>)
or</p></div>
<div class="paragraph"><p>var stop = gradient.at({ offset: 0.5, color: <em>#f06</em>, opacity: 1 })
stop.update()
returns itself</p></div>
<div class="paragraph"><p>Takes the same parameters as the constructor.</p></div>
<div class="paragraph"><p>stop.update(0, <em>#333</em>)
or</p></div>
<div class="paragraph"><p>stop.update({ offset: 0, color: <em>#333</em>, opacity: 1 })</p></div>
<div class="paragraph"><p>SVG.Pattern
pattern()
конструктор на SVG.Container
повертає SVG.Pattern що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>Creating a pattern is very similar to creating gradients:</p></div>
<div class="paragraph"><p>var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill(<em>#f06</em>)
  add.rect(10,10)
  add.rect(10,10).move(10,10)
})
This creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern.</p></div>
<div class="paragraph"><p>Finally, to use the pattern on an element:</p></div>
<div class="paragraph"><p>rect.attr({ fill: pattern })
Or:</p></div>
<div class="paragraph"><p>rect.fill(pattern)
By passing the pattern instance as the fill on any element, the fill() method will be called on the pattern instance.</p></div>
<div class="paragraph"><p>pattern.fill()
returns string</p></div>
<div class="paragraph"><p>pattern.fill() //&#8594; returns <em>url(#SvgjsPattern1234)</em>
pattern.update()
returns itself</p></div>
<div class="paragraph"><p>A pattern can also be updated afterwards:</p></div>
<div class="paragraph"><p>pattern.update(function(add) {
  add.circle(15).center(10,10)
})</p></div>
<div class="paragraph"><p>SVG.Mask
mask()
конструктор на SVG.Container
повертає SVG.Mask що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill(<em>#fff</em>)</p></div>
<div class="paragraph"><p>var mask = draw.mask().add(ellipse)</p></div>
<div class="paragraph"><p>rect.maskWith(mask)
But you can also use multiple elements:</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: <em>#fff</em> })
var text = draw.text(<em>SVG.JS</em>).move(10, 10).font({ size: 36 }).fill({ color: <em>#fff</em> })</p></div>
<div class="paragraph"><p>var mask = draw.mask().add(text).add(ellipse)</p></div>
<div class="paragraph"><p>rect.maskWith(mask)</p></div>
<div class="paragraph"><p>maskWith()
конструктор на SVG.Element
returns itself</p></div>
<div class="paragraph"><p>The easiest way to mask is to use a single element:</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: <em>#fff</em> })</p></div>
<div class="paragraph"><p>rect.maskWith(ellipse)
If you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient:</p></div>
<div class="paragraph"><p>var gradient = draw.gradient(<em>linear</em>, function(stop) {
  stop.at({ offset: 0, color: <em>#000</em> })
  stop.at({ offset: 1, color: <em>#fff</em> })
})</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })</p></div>
<div class="paragraph"><p>rect.maskWith(ellipse)
mask.unmask()
returns itself</p></div>
<div class="paragraph"><p>Unmasking the elements can be done with the unmask() method:</p></div>
<div class="paragraph"><p>rect.unmask()
The unmask() method returns the masking element.</p></div>
<div class="paragraph"><p>mask.remove()
returns itself</p></div>
<div class="paragraph"><p>Removing the mask altogether will also unmask() all masked elements as well:</p></div>
<div class="paragraph"><p>mask.remove()
masker
повертає SVG.Mask</p></div>
<div class="paragraph"><p>For your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask:</p></div>
<div class="paragraph"><p>rect.masker.fill(<em>#fff</em>)</p></div>
<div class="paragraph"><p>SVG.ClipPath
Clipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill colour and clipPaths can&#8217;t.</p></div>
<div class="paragraph"><p>clip()
конструктор на SVG.Container
повертає SVG.ClipPath що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>Clip with multiple elements:</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10)
var text = draw.text(<em>SVG.JS</em>).move(10, 10).font({ size: 36 })</p></div>
<div class="paragraph"><p>var clip = draw.clip().add(text).add(ellipse)</p></div>
<div class="paragraph"><p>rect.clipWith(clip)</p></div>
<div class="paragraph"><p>clipWith()
returns itself</p></div>
<div class="paragraph"><p>var ellipse = draw.ellipse(80, 40).move(10, 10)</p></div>
<div class="paragraph"><p>rect.clipWith(ellipse)
clipPath.unclip()
returns itself</p></div>
<div class="paragraph"><p>Unclipping the elements can be done with the unclip() method:</p></div>
<div class="paragraph"><p>rect.unclip()
clipPath.remove()
returns itself</p></div>
<div class="paragraph"><p>Removing the clip alltogether will also unclip() all clipped elements as well:</p></div>
<div class="paragraph"><p>clip.remove()
clipper
повертає SVG.ClipPath</p></div>
<div class="paragraph"><p>For your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath:</p></div>
<div class="paragraph"><p>rect.clipper.move(10, 10)</p></div>
<div class="paragraph"><p>SVG.Use
use()
конструктор на SVG.Container
повертає SVG.Use що наслідує від SVG.Shape</p></div>
<div class="paragraph"><p>The use element simply emulates another existing element. Any changes on the master element will be reflected on all the use instances. The usage of use() is very straightforward:</p></div>
<div class="paragraph"><p>var rect = draw.rect(100, 100).fill(<em>#f09</em>)
var use  = draw.use(rect).move(200, 200)
In the case of the example above two rects will appear on the svg drawing, the original and the use instance. In some cases, you might want to hide the original element. The best way to do this is to create the original element in the defs node:</p></div>
<div class="paragraph"><p>var rect = draw.defs().rect(100, 100).fill(<em>#f09</em>)
var use  = draw.use(rect).move(200, 200)
In this way, the rect element acts as a library element. You can edit it, but it won&#8217;t be rendered.</p></div>
<div class="paragraph"><p>Another way is to point an external SVG file, just specified the element id and path to file.</p></div>
<div class="paragraph"><p>var use  = draw.use(<em>elementId</em>, <em>path/to/file.svg</em>)
This way is useful when you have complex images already created.
Note that, for external images (outside your domain) it may be necessary to load the file with XHR.</p></div>
<div class="paragraph"><p>SVG.Marker
marker()
конструктор на SVG.Container
повертає SVG.Marker що наслідує від SVG.Container</p></div>
<div class="paragraph"><p>Markers can be added to every individual point of a line, polyline, polygon and path. There are three types of markers: start, mid and end. Where start represents the first point, end the last and mid every point in between.</p></div>
<div class="paragraph"><p>var path = draw.path(<em>M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100</em>)</p></div>
<div class="paragraph"><p>path.fill(<em>none</em>).move(20, 20).stroke({ width: 1, color: <em>#ccc</em> })</p></div>
<div class="paragraph"><p>path.marker(<em>start</em>, 10, 10, function(add) {
  add.circle(10).fill(<em>#f06</em>)
})
path.marker(<em>mid</em>, 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill(<em>#ccc</em>)
})
path.marker(<em>end</em>, 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  this.fill('#0f9')
})
The marker() method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times, so it will create a marker in the defs but not show it yet:</code></pre>
</div></div>
<div class="paragraph"><p>var marker = draw.marker(10, 10, function(add) {
  add.rect(10, 10)
})
Secondly a marker can be created and applied directly on its target element:</p></div>
<div class="paragraph"><p>path.marker(<em>start</em>, 10, 10, function(add) {
  add.circle(10).fill(<em>#f06</em>)
})
This will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example.</p></div>
<div class="paragraph"><p>Lastly, if a marker is created for reuse on a container element, it can be applied directly to the target element:</p></div>
<div class="paragraph"><p>path.marker(<em>mid</em>, marker)
Finally, to get a marker instance from the target element reference:</p></div>
<div class="paragraph"><p>path.reference(<em>marker-end</em>)</p></div>
<div class="paragraph"><p>marker.height()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Defines the markerHeight attribute:</p></div>
<div class="paragraph"><p>marker.height(10)
marker.ref()
returns itself</p></div>
<div class="paragraph"><p>By default, the refX and refY attributes of a marker are set to respectively half the width nd height values. To define the refX and refY of a marker differently:</p></div>
<div class="paragraph"><p>marker.ref(2, 7)
marker.size()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Defines the markerWidth and markerHeight attributes:</p></div>
<div class="paragraph"><p>marker.size(10, 10)
marker.update()
returns itself</p></div>
<div class="paragraph"><p>Updating the contents of a marker will clear() the existing content and add the content defined in the block passed as the first argument:</p></div>
<div class="paragraph"><p>marker.update(function(add) {
  add.circle(10)
})
marker.width()
returns itself
animate yes</p></div>
<div class="paragraph"><p>Defines the markerWidth attribute:</p></div>
<div class="paragraph"><p>marker.width(10)</p></div>
<div class="paragraph"><p>SVG.Bare
For all SVG elements that are not described by SVG.js, the SVG.Bare class comes in handy. This class inherits directly from SVG.Element and makes it possible to add custom methods in a separate namespace without polluting the main SVG.Element namespace. Consider it your personal playground.</p></div>
<div class="paragraph"><p>element()
повертає SVG.Bare що наслідує від SVG.Element</p></div>
<div class="paragraph"><p>The SVG.Bare class can be instantiated with the element() method on any parent element:</p></div>
<div class="paragraph"><p>var element = draw.element(<em>title</em>)
The string value passed as the first argument is the node name that should be generated.</p></div>
<div class="paragraph"><p>Additionally, any existing class name can be passed as the second argument to define from which class the element should inherit:</p></div>
<div class="paragraph"><p>var element = draw.element(<em>symbol</em>, SVG.Parent)
This gives you as the user a lot of power. But remember, with great power comes great responsibility.</p></div>
<div class="paragraph"><p>element.words()
returns itself</p></div>
<div class="paragraph"><p>The SVG.Bare instance carries an additional method to add plain text:</p></div>
<div class="paragraph"><p>var element = draw.element(<em>title</em>).words(<em>This is a title.</em>)</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-29 09:58:08 EEST
</div>
</div>
</body>
</html>
