:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

SVG.js
======

Легковажна бібліотека для маніпуляції та анімації SVG.

Чому обирають SVG.js?
---------------------
SVG.js не має залежностей, та націлена бути малою як це можливо, при цьому провадячи повне покриття специфікації SVG. Якщо ви ще не переконані, ось декілька фактів.

Вона тонка.
-----------
SVG.js є легковажною. Цифри не брешуть, так що тут надається порівняння конкурентів. Майте на увазі, що це робить ту саму річ, але майже половиною довжини кода!

Вона швидка.
------------
SVG.js швидка. Очевидно, не така швидка, як ванільний js, але в багато разів швидше, ніж конкуренти.

Індекс:

* `rects`: генерує 10000 прямокутників

* `fill`: генерує 10000 заповнених кольором прямокутників

* `gradient`: генерує 10000 прямокутників з градієнтом кольору

Меньше - краще. Протестовано на Intel Core m5 @ 1.2GHz.

Просто читається, незахаращений синтаксис.
------------------------------------------
Створення та маніпуляція SVG з використанням самого JavaScript досить балакуче. Наприклад, просте створення рожевого квадрата потребує досить багато коду:

[source,js]
----
// Звичайний js
var ns = 'http://www.w3.org/2000/svg'
var div = document.getElementById('drawing') 
var svg = document.createElementNS(ns, 'svg')
svg.setAttributeNS(null, 'width', '100%')
svg.setAttributeNS(null, 'height', '100%')
div.appendChild(svg)
var rect = document.createElementNS(ns, 'rect')
rect.setAttributeNS(null, 'width', 100)
rect.setAttributeNS(null, 'height', 100)
rect.setAttributeNS(null, 'fill', '#f06')
svg.appendChild(rect)
----
SVG.js провадить синтаксис, що одночасно стислий та його легко читати. Цей код робить те саме, що  і js приклад вище:
[source,js]
----
// SVG.js
var draw = SVG('drawing')
  , rect = draw.rect(100, 100).fill('#f06')
----
Це тільки два рядка коду, замість десяти! Та при цьому значно менше повторів.

Шаленійте з анімацією
---------------------
[source,js]
----
var input = document.querySelector('input[type=text]')
var draw = SVG('drawing').viewbox(0, 0, 300, 140)
var text = draw.text(function(add) {
	add.tspan( input.value )
})

text
	.path('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
	.animate(1000, '<>')
	.plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80')
	.loop(true, true)

input.addEventListener('keyup', updateText(text))

function updateText(textPath) {
	return function() {
		textPath.tspan(this.value)
	}				
}
----

Та більше...
------------
* анімація за розміром, позицією, трансформацією, колором, ...

* безболісне розширення, дякуючи модулярній структурі

* доступність різноманітні корисні плагіни

* уніфікований api між типами фігур щодо пересування, розміру, центрування, ...

* прив'язка подій до елементів

* повна підтримка для масок прозорості та шляхів відсічення

* текстові шляхи, навіть анімовані

* групи елементів

* динамічні градієнти та шаблони

* повністю документовано (ви дивитесь на це :)

Ліцензія
--------
SVG.js ліцензований за умовами MIT License.

Журнал змін
-----------
Цікавитесь, що змінилось в останньому релізі? Подивіться журнал змін.

Починаємо
=========
Підготовка
----------
SVG.js вважає, що ви маєте HTML елемент з атрибутом `id`, створений та готовий служити як огортка. Щось таке:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>SVG.js</title>
</head>
<body>
  <div id="drawing"></div>
</body>
</html>
----
Створення SVG документу
-----------------------
Далі використовуйте функцію SVG() для створення SVG документу в оточуючому елементі:
[source,js]
----
var draw = SVG('drawing').size(300, 300)
var rect = draw.rect(100, 100)
  .attr({ fill: '#f06' })
----
Перший аргумент може бути або `id` елемента, або сам обраний елемент. Це буде генерувати такий вихід:
[source,html]
----
<div id="drawing">
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="300">
    <rect width="100" height="100" fill="#f06"></rect>
  </svg>
</div>
----
По замовчанню малюнок svg слідує розмірам свого батька, в цьому випадку `#drawing`:
[source,js]
----
var draw = SVG('drawing').size('100%', '100%')
----
Перевірка підтримки SVG
-----------------------
По замовчанню SVG.js вважає, що браузер клієнта підтримує SVG. Ви можете перевірити підтримку таким чином:
[source,js]
----
if (SVG.supported) {
  var draw = SVG('drawing')
  var rect = draw.rect(100, 100)
} else {
  alert('SVG not supported')
}
----
Очікування завантаження DOM
---------------------------
Це може для багатьох виглядати очевидним, але це все ще варте нагадування. Якщо ви включаєте ваші js файли в заголовку вашого документу, переконайтесь, що діждетесь завантаження DOM:
[source,scala]
----
SVG.on(document, 'DOMContentLoaded', function() {
  var draw = SVG('drawing')
})
----
Це не проблема, якщо ви вставляєте ваш js знизу.

Чистий SVG
----------
SVG.js також робить за межами HTML DOM, наприклад, в документі SVG:
[source,xml]
----
<?xml version="1.0" encoding="utf-8" ?>
<svg id="drawing" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" >
  <script type="text/javascript" xlink:href="svg.min.js"></script>
  <script type="text/javascript">
    <![CDATA[
      var draw = SVG('drawing')
      draw.rect(100,100).animate().fill('#f03').move(100,100)
    ]]>
  </script>
</svg>
----
Пісочниця
---------
Щоб дати вам поштовх, ось базове налаштування. Присутнє все для початку забавок.
[source,js]
----
// ініціалізація SVG.js
var draw = SVG('drawing')

// темно рожевий квадрат
draw.rect(100, 100).move(100, 50).fill('#f06')
----

Батькі
======
SVG.Parent
----------
Клас `SVG.Parent` є базовою огорткою для всіх елементів, що можуть містити інші елементи. `SVG.Parent` наслідує напряму від найнижчого рівня класів SVG.js: `SVG.Element`.

SVG.Container
-------------
`SVG.Container` додає інший рівень до стеку батьківського наслідування. Якщо `SVG.Parent` приносить декілька низькорівневих методів, як `add()`, `remove()` та `has()`, щоб назвати декілька, `SVG.Container` може та повинен використовуватись, якщо ви бажаєте додати ваші власні методи. Таким чином, прототип `SVG.Parent` залишається чистим. Вам слідує завжди наслідувати від `SVG.Container`, коли реалізуєте ваші власні батьківські елементи.

Стек батьківського наслідування таий: `SVG.Element` > `SVG.Parent` > `SVG.Container`.

SVG.Doc
=======
Функція-ініціалізатор SVG.js створює кореневий вузол в наданий елемент, та повертає примірник `SVG.Doc`.

SVG()
-----
повертає `SVG.Doc`, що наслідує від `SVG.Container`
[source,js]
----
var draw = SVG('drawing')
----
NOTE: Перший раз, коли викликається `SVG()`, буде створений другий, невидимий `<svg>`. Це наш парсер, та він пояснений в FAQ.

SVG.Nested
----------
Вкладені документи SVG один в одного.

nested()
~~~~~~~~
конструктор `SVG.Container`
повертає `SVG.Nested`, що наслідує від SVG.Container

Вкладені SVG документи мають точно такі можливості, що і головний SVG документ вищого рівня:
[source,js]
----
var nested = draw.nested()

var rect = nested.rect(200, 200)
----

SVG.G
-----
Групування елементів може буде корисне, якщо ви бажаєте трансформувати набір елементів, так, якби це був один елемент. Всі елементи в групі керують свою позицію відносно до групи, до якої вони належать.

NOTE: Групи не мають своєї власної геометрії, вона наслідується від його вмісту. Таким чином групи не зважають на атрибути `x`, `y`, `width` та `height`. Якщо це те, що ви шукаєте, використовуйте замість цього `nested()` svg.

group()
~~~~~~~
конструктор `SVG.Container`
повертає `SVG.G`, що наслідує від `SVG.Container`

Група має всі ті самі методи елемента, що і кореневий документ SVG:
[source,js]
----
var group = draw.group()
group.path('M10,20L30,40')
----
Існуючі елементи з документу SVG також може бути додані групи:
[source,js]
----
group.add(rect)
----

SVG.Symbol
----------
конструктор `SVG.Container`
повертає `SVG.Symbol`, що наслідує від `SVG.Container`

Подібно до елементу групи, елемент символа є контейнерним елементом. Єдина різниця в тому, що символи не відображуються. Таким чином елемент символа є ідеальним в комбінації з елементом `use`:
[source,js]
----
var symbol = draw.symbol()
symbol.rect(100, 100).fill('#f09')

var use  = draw.use(symbol).move(200, 200)
----

SVG.Defs
--------
Елемент <defs> є контейнером для посиланих елементів. Нащадки вузла `<defs>` не відображуються напряму. Вузол `<defs>` живе в головному документі `<svg>`, та може бути досяжний за допомогою метода `defs()`.

defs()
~~~~~~
конструктор `SVG.Container`
повертає `SVG.Defs`, що наслідує від `SVG.Container`
[source,js]
----
var defs = draw.defs()
----
`defs` також доступний на любому іншому елементі через метод `doc()`:
[source,js]
----
var defs = rect.doc().defs()
----
Вузол `defs` робить точно так само, як і групи.

SVG.A
-----
Створює гіперпосилання, що буде активоване на всіх дитячих елементах.

link()
~~~~~~
конструктор `SVG.Container`
повертає `SVG.A`, що наслідує від `SVG.Container`

Гіперпосилання або тег `<a>` створює контейнер, що дозволяє посилання на всіх його дітях:
[source,js]
----
var link = draw.link('http://svgdotjs.github.io/')
var rect = link.rect(100, 100)
----
Url посилання може бути оновлене за допомогою метода `to()` method:
[source,js]
----
link.to('http://apple.com')
----
Більше того, елемент `link` має метод `show()` для створення атрибута `xlink:show`:
[source,js]
----
link.show('replace')
----
Та метод `target()` для створення атрибута `target`:
[source,js]
----
link.target('_blank')
----
Елементи можуть бути пов'язані в інший спосіб за допомогою метода `linkTo()`:
[source,js]
----
rect.linkTo('http://svgdotjs.github.io/')
----
Альтернативно, замість URL може бути переданий блок, для додаткових опцій елемента посилання:
[source,js]
----
rect.linkTo(function(link) {
  link.to('http://svgdotjs.github.io/').target('_blank')
})
----

Елементи
========

`SVG.Element` є базовим прототипом, що огортає всі елементи (або вузли, коли це важливо) в SVG.js. Додатковий рівень уточнення доданий з допомогою `SVG.Shape`. Кожний елемент, що може приймати атрибути `fill` та/або `stroke`. Бажано розширювати елементи ваши ми власними методами на `SVG.Shape`, скоріше ніж на `SVG.Element`.

SVG.Rect
========

rect()
~~~~~~
конструктор на SVG.Container
повертає SVG.Rect що наслідує від `SVG.Shape`

Прямокутники мають два аргументи, свою ширину та висоту:

[source,js]
----
var rect = draw.rect(100, 100)
----

rect.radius()
~~~~~~~~~~~~~
повертає себе, анімується

Прямокутники можуть мати скруглені кути:

[source,js]
----
rect.radius(10)
----
Це буде встановлювати атрибути `rx` та `ry` в `10`. Щоб встановити `rx` та `ry` індивідуально:
[source,js]
----
rect.radius(10, 20)
----

SVG.Circle
==========

circle()
--------
конструктор на SVG.Container
повертає SVG.Circle що наслідує від SVG.Shape

Єдиний аргумент, потрібний для кола, є його диаметр:
[source,js]
----
var circle = draw.circle(100)
----

circle.radius()
---------------
повертає себе, анімується

[source,js]
----
circle.radius(75)
----

SVG.Ellipse
===========

ellipse()
---------
конструктор на SVG.Container
повертає SVG.Circle що наслідує від SVG.Shape

Еліпси мають два аргументи, їх ширину та висоту:
[source,scala]
----
var ellipse = draw.ellipse(200, 100)
----

ellipse.radius()
----------------
повертає себе, анімується

Еліпси також можуть перевизначатись по радіусу:

[source,js]
----
ellipse.radius(75, 50)
----

SVG.Line
========

line()
------
конструктор на SVG.Container
повертає SVG.Line що наслідує від SVG.Shape

Створює лінію від точки A до точки B:

[source,js]
----
var line = draw.line(0, 0, 100, 150).stroke({ width: 1 })
----
Створення елементу лінії може бути зроблене в чотори способи. Дивіться метод `plot()` щоб побачити всі можливості.

line.array()
~~~~~~~~~~~~
повертає `SVG.PointArray`

Посилання на примірник `SVG.PointArray`. Цей метод скоріше призначений для внутрішнього використання:
[source,js]
----
polyline.array()
----
Додаткова інформація: `SVG.PointArray`.

line.plot()
~~~~~~~~~~~
повертає себе, анімується

Оновлення лінії методом `plot()`:
[source,js]
----
line.plot(50, 30, 100, 150)
----
Альтернативно приймає рядок з точками:
[source,js]
----
line.plot('0,0 100,150')
----
Або масив масивів для точок:
[source,js]
----
line.plot([[0, 0], [100, 150]])
----
Або примірник `SVG.PointArray`:
[source,js]
----
var array = new SVG.PointArray([[0, 0], [100, 150]])
line.plot(array)
----
Метод `plot()` може бути анімований:
[source,scala]
----
line.animate(3000).plot([[200, 200], [100, 150]])
----

SVG.Polyline
============

polyline()
----------
конструктор на SVG.Container
повертає SVG.Polyine що наслідує від SVG.Shape

Елемент полілінії визначає набір прямих сегментів ліній. Типово елементи поліліній визначають відкриті фігури:
[source,scala]
----
var polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
----
Полілайн рядкі складаються зі списку точок, розділених комами або проміжками. Так що `x,y x,y x,y` так само як `x y x y x y` або навіть `x,y,x,y,x,y` буде робити.

Як альтернатива також буде робити масив точок:
[source,js]
----
var polyline = draw.polyline([[0,0], [100,50], [50,100]])
----
Або навіть плаский масив точок, що навіть краще:
[source,js]
----
var polyline = draw.polyline([0,0, 100,50, 50,100])
----

polyline.array()
~~~~~~~~~~~~~~~~
повертає SVG.PointArray

References the SVG.PointArray instance. This method is rather intended for internal use:

polyline.array()
More info: SVG.PointArray.

polyline.clear()
returns itself

When the given point data is parsed, the result is cached. This method clears the cache.

polyline.clear()
polyline.plot()
returns itself
animate yes

Polylines can be updated using the plot() method:

polyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
The plot() method can also be animated:

polyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])


SVG.Polygon
polygon()
конструктор на SVG.Container
повертає SVG.Polygon що наслідує від SVG.Shape

The polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments:

var polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
Polygon strings or arrays are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically.


polygon.array()
повертає SVG.PointArray

References the SVG.PointArray instance. This method is rather intended for internal use:

polygon.array()
More info: SVG.PointArray.

polygon.clear()
returns itself

When the given point data is parsed, the result is cached. This method clears the cache.

polygon.clear()
polygon.plot()
returns itself
animate yes

Like polylines, polygons can be updated using the plot() method:

polygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
The plot() method can also be animated:

polygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])


SVG.Path
path()
конструктор на SVG.Container
повертає SVG.Path що наслідує від SVG.Shape

The path string is similar to the polygon string but much more complex in order to support curves:

draw.path('M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z')

For more details on path data strings, please refer to the SVG documentation on path data.

path.array()
повертає SVG.PathArray

References the SVG.PathArray instance. This method is rather intended for internal use:

path.array()
More info: SVG.PathArray.

path.clear()
returns itself

When the given path data is parsed, the result is cached. This method clears the cache.

path.clear()
path.length()
returns number

Get the total length of a path element:

var length = path.length()
path.pointAt()
повертає SVGPoint

Get point on a path at given length:

var point = path.pointAt(105)
Note: pointAt() returns a native SVGPoint and not a SVG.Point.

path.plot()
returns itself
animate yes

Paths can be updated using the plot() method:

path.plot('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
The plot() method can also be animated:

path.animate(2000).plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80').loop(true, true)
There is only basic support for animating paths baked into SVG.js, which means that only paths with the same commands (M,C,S etc.) are animateable.

If you need to animate paths that do not share the same commands in order, you can use svg.pathmorphing.js



SVG.Text
text()
конструктор на SVG.Container
повертає SVG.Text що наслідує від SVG.Shape

Unlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements.

The first and easiest method is to provide a string of text, split by newlines:

var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
This will automatically create a block of text and insert newlines where necessary.

The second method will give you much more control but requires a bit more code:

var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
If you want to go the other way and don't want to add tspans at all, just one line of text, you can use the plain() method instead:

var text = draw.plain('Lorem ipsum dolor sit amet consectetur.')
This is a shortcut to the plain method on the SVG.Text instance which doesn't render newlines at all.


text.build()
returns itself

The build() can be used to enable / disable build mode. With build mode disabled, the plain() and tspan() methods will first call the clear() method before adding the new content. So when build mode is enabled, plain() and tspan() will append the new content to the existing content. When passing a block to the text() method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually:

var text = draw.text('This is just the start, ')

text.build(true)  // enables build mode

var tspan = text.tspan('something pink in the middle ').fill('#00ff97')
text.plain('and again boring at the end.')

text.build(false) // disables build mode

tspan.animate('2s').fill('#f06')
text.clear()
returns itself

Clear all the contents of the called text element:

text.clear()
text.length()
returns number

Gets the total computed text length of all tspans together:

text.length()
text.font() as setter
returns itself

A convenience method to add font-related properties:

text.font({
  family:   'Helvetica'
, size:     144
, anchor:   'middle'
, leading:  '1.5em'
})
Not unlike the attr() method, the font() method also accepts a key/value pair:

text.font('family', 'Menlo')
Available properties are:

leading (will do the same as calling the leading() method as setter)
anchor (will set the text-anchor attribute)
family (will set the font-family attribute)
size (will set the font-size attribute)
stretch (will set the font-stretch attribute)
style (will set the font-style attribute)
variant (will set the font-variant attribute)
weight (will set the font-weight attribute)
Any other property will be applied as given. So, for example, the letter-spacing property will just be applied as it would be given to the attr() method. More on font-related properties here.

text.font() as getter
As you might expect, the font() method also acts as a getter:

var leading = text.font('leading')
text.leading() as setter
returns itself
animate yes

As opposed to html, where leading is defined by line-height, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by <tspan> nodes with a dy attribute defining the line height and an x value resetting the line to the x position of the parent text element. But you can also have many nodes in one line defining a different y, dy, x or even dx value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it's height is. The leading() method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html:

var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
text.leading(1.3)
This will render a text element with a tspan element for each line, with a dy value of 130% of the font size.

Note that the leading() method assumes that every first level tspan in a text node represents a new line. Using leading() on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the newLine() method on every first level tspan added in the block passed as an argument to the text element.

text.leading() as getter
returns value

Get the current leading value:

var leading = text.leading()
text.lines()
повертає SVG.Set

All first level tspans can be referenced with the lines() method:

text.lines()
This will return an instance of SVG.Set including all tspan elements.

text.plain()
returns itself

If the content of the element doesn't need any styling or multiple lines, it might be sufficient to just add some plain text:

text.plain('I do not have any expectations.')
text.rebuild()
returns itself

This is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver font-size and x attributes or the leading() of the text element are modified. This method also acts a setter to enable or disable rebuilding:

text.rebuild(false) //-> disables rebuilding
text.rebuild(true)  //-> enables rebuilding and instantaneously rebuilds the text element
text.text() as setter
returns itself

Changing text afterwards is also possible with the text() method:

text.text('Brilliant!')
text.text() as getter
returns string

To get the raw text content:

text.text()
text.tspan()
повертає SVG.Tspan

Just adding one tspan is also possible:

text.tspan(' on a train...').fill('#f06')


SVG.TextPath
path()
конструктор на SVG.Text
повертає SVG.TextPath що наслідує від SVG.Text

A nice feature in svg is the ability to run text along a path:

var text = draw.text(function(add) {
  add.tspan('We go ')
  add.tspan('up').fill('#f09').dy(-40)
  add.tspan(', then we go down, then up again').dy(40)
})

var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'

text.path(path).font({ size: 42.5, family: 'Verdana' })
When calling the path() method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a plot() method to update the path:

text.plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')
Attributes specific to the <textPath> element can be applied to the textPath instance itself:

text.textPath().attr('startOffset', '50%')
And they can be animated as well of course:

text.textPath().animate(3000).attr('startOffset', '80%')
Note: If a startOffset other than a percentage is given, then the value represents a distance along the path measured in the current user coordinate system.


textPath.array()
повертає SVG.PathArray

Get the path array of the underlying path:

var array = text.textPath().array()
textPath.plot()
returns itself
animate yes

Change the path on the textpath element:

text.textPath().plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200')
textPath.textPath()
повертає SVG.TextPath

Referencing the textPath node directly:

var textPath = text.textPath()
textPath.track()
повертає SVG.Path

Referencing the linked path element directly:

var path = text.track()


Note: SVG.TextPath inherits from SVG.Text, so all those methods are inherited as well.

Events for SVG.Text
The text element has one event. It is fired every time the rebuild() method is called:

text.on('rebuild', function() {
  // whatever you need to do after rebuilding
})


SVG.Tspan
tspan()
конструктор на SVG.Text
повертає SVG.Tspan що наслідує від SVG.Shape

The tspan elements are only available inside text elements or inside other tspan elements.

text.tspan('spannened')
tspan.clear()
returns itself

Clear all the contents of the called tspan element:

tspan.clear()
tspan.dx()
returns itself
animate yes

Define the dynamic x value of the element, much like a html element with position:relative and left defined:

tspan.dx(30)
tspan.dy()
returns itself
animate yes

Define the dynamic y value of the element, much like a html element with position:relative and top defined:

tspan.dy(30)
tspan.plain()
returns itself

Just adds some plain text:

tspan.plain('I do not have any expectations.')
tspan.length()
returns number

Gets the total computed text length:

tspan.length()
tspan.newLine()
returns itself

The newLine() is a convenience method for adding a new line with a dy attribute using the current "leading":

var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
tspan.text()
returns itself

Update the content of the tspan. This can be done by either passing a string:

tspan.text('Just a string.')
Which will basicly call the plain() method:

Or by passing a block to add more specific content inside the called tspan:

tspan.text(function(add) {
  add.plain('Just plain text.')
  add.tspan('Fancy text wrapped in a tspan.').fill('#f06')
  add.tspan(function(addMore) {
    addMore.tspan('And you can doo deeper and deeper...')
  })
})
tspan.tspan()
повертає SVG.Tspan

Add a nested tspan:

tspan.tspan('I am a child of my parent').fill('#f06')


SVG.Image
image()
конструктор на SVG.Container
повертає SVG.Image що наслідує від SVG.Shape

Creating images is as you might expect:

var image = draw.image('/path/to/image.jpg')
If you know the size of the image, those parameters can be passed as the second and third arguments:

var image = draw.image('/path/to/image.jpg', 200, 300)

image.load()
returns itself

Loading another image can be done with the load() method:

image.load('/path/to/another/image.jpg')
image.loaded()
returns itself

If you don't know the size of the image, obviously you will have to wait for the image to be loaded:

var image = draw.image('/path/to/image.jpg').loaded(function(loader) {
  this.size(loader.width, loader.height)
})
The returned loader object as first the argument of the loaded method contains four values:

width
height
ratio (width / height)
url


SVG.Gradient
gradient()
конструктор на SVG.Container
повертає SVG.Gradient що наслідує від SVG.Container

There are linear and radial gradients. The linear gradient can be created like this:

var gradient = draw.gradient('linear', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})
Finally, to use the gradient on an element:

rect.attr({ fill: gradient })
Or:

rect.fill(gradient)
By passing the gradient instance as the fill on any element, the fill() method will be called on the gradient instance.


MDN has a great example page on how SVG Gradients work.

gradient.at()
returns itself

The offset and color parameters are required for stops, opacity is optional. The offset is a float between 0 and 1, or a percentage value (e.g. 33%).

stop.at(0, '#333')
or

stop.at({ offset: 0, color: '#333', opacity: 1 })
gradient.fill()
returns string

gradient.fill() //-> returns 'url(#SvgjsGradient1234)'
gradient.from()
returns itself
animate yes

To define the direction you can set from x, y and to x, y:

gradient.from(0, 0).to(0, 1)
The from and to values are also expressed in percent.

gradient.get()
повертає SVG.Stop

The get() method makes it even easier to get a stop from an existing gradient:

var gradient = draw.gradient('radial', function(stop) {
  stop.at({ offset: 0, color: '#000', opacity: 1 })   // -> first
  stop.at({ offset: 0.5, color: '#f03', opacity: 1 }) // -> second
  stop.at({ offset: 1, color: '#066', opacity: 1 })   // -> third
})

var s1 = gradient.get(0) // -> returns "first" stop
gradient.radius()
returns itself
animate yes

Radial gradients have a radius() method to define the outermost radius to where the inner color should develop:

var gradient = draw.gradient('radial', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})

gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)
gradient.to()
returns itself
animate yes

To define the direction you can set from x, y and to x, y:

gradient.from(0, 0).to(0, 1)
The from and to values are also expressed in percent.

gradient.update()
returns itself

A gradient can also be updated afterwards:

gradient.update(function(stop) {
  stop.at(0.1, '#333', 0.2)
  stop.at(0.9, '#f03', 1)
})
And even a single stop can be updated:

var s1, s2, s3

draw.gradient('radial', function(stop) {
  s1 = stop.at(0, '#000')
  s2 = stop.at(0.5, '#f03')
  s3 = stop.at(1, '#066')
})

s1.update(0.1, '#0f0', 1)


SVG.Stop
at()
конструктор на SVG.Gradient
повертає SVG.Stop що наслідує від SVG.Element

The stop elements are only available inside gradient elements.

var stop = gradient.at(0.5, '#f03')
or

var stop = gradient.at({ offset: 0.5, color: '#f06', opacity: 1 })
stop.update()
returns itself

Takes the same parameters as the constructor.

stop.update(0, '#333')
or

stop.update({ offset: 0, color: '#333', opacity: 1 })


SVG.Pattern
pattern()
конструктор на SVG.Container
повертає SVG.Pattern що наслідує від SVG.Container

Creating a pattern is very similar to creating gradients:

var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill('#f06')
  add.rect(10,10)
  add.rect(10,10).move(10,10)
})
This creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern.

Finally, to use the pattern on an element:

rect.attr({ fill: pattern })
Or:

rect.fill(pattern)
By passing the pattern instance as the fill on any element, the fill() method will be called on the pattern instance.


pattern.fill()
returns string

pattern.fill() //-> returns 'url(#SvgjsPattern1234)'
pattern.update()
returns itself

A pattern can also be updated afterwards:

pattern.update(function(add) {
  add.circle(15).center(10,10)
})


SVG.Mask
mask()
конструктор на SVG.Container
повертає SVG.Mask що наслідує від SVG.Container

var ellipse = draw.ellipse(80, 40).move(10, 10).fill('#fff')

var mask = draw.mask().add(ellipse)

rect.maskWith(mask)
But you can also use multiple elements:

var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })

var mask = draw.mask().add(text).add(ellipse)

rect.maskWith(mask)

maskWith()
конструктор на SVG.Element
returns itself

The easiest way to mask is to use a single element:

var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })

rect.maskWith(ellipse)
If you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient:

var gradient = draw.gradient('linear', function(stop) {
  stop.at({ offset: 0, color: '#000' })
  stop.at({ offset: 1, color: '#fff' })
})

var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })

rect.maskWith(ellipse)
mask.unmask()
returns itself

Unmasking the elements can be done with the unmask() method:

rect.unmask()
The unmask() method returns the masking element.

mask.remove()
returns itself

Removing the mask altogether will also unmask() all masked elements as well:

mask.remove()
masker
повертає SVG.Mask

For your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask:

rect.masker.fill('#fff')


SVG.ClipPath
Clipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill colour and clipPaths can't.

clip()
конструктор на SVG.Container
повертає SVG.ClipPath що наслідує від SVG.Container

Clip with multiple elements:

var ellipse = draw.ellipse(80, 40).move(10, 10)
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })

var clip = draw.clip().add(text).add(ellipse)

rect.clipWith(clip)

clipWith()
returns itself

var ellipse = draw.ellipse(80, 40).move(10, 10)

rect.clipWith(ellipse)
clipPath.unclip()
returns itself

Unclipping the elements can be done with the unclip() method:

rect.unclip()
clipPath.remove()
returns itself

Removing the clip alltogether will also unclip() all clipped elements as well:

clip.remove()
clipper
повертає SVG.ClipPath

For your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath:

rect.clipper.move(10, 10)


SVG.Use
use()
конструктор на SVG.Container
повертає SVG.Use що наслідує від SVG.Shape

The use element simply emulates another existing element. Any changes on the master element will be reflected on all the use instances. The usage of use() is very straightforward:

var rect = draw.rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
In the case of the example above two rects will appear on the svg drawing, the original and the use instance. In some cases, you might want to hide the original element. The best way to do this is to create the original element in the defs node:

var rect = draw.defs().rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
In this way, the rect element acts as a library element. You can edit it, but it won't be rendered.

Another way is to point an external SVG file, just specified the element id and path to file.

var use  = draw.use('elementId', 'path/to/file.svg')
This way is useful when you have complex images already created.
Note that, for external images (outside your domain) it may be necessary to load the file with XHR.



SVG.Marker
marker()
конструктор на SVG.Container
повертає SVG.Marker що наслідує від SVG.Container

Markers can be added to every individual point of a line, polyline, polygon and path. There are three types of markers: start, mid and end. Where start represents the first point, end the last and mid every point in between.

var path = draw.path('M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100')

path.fill('none').move(20, 20).stroke({ width: 1, color: '#ccc' })

path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
path.marker('mid', 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill('#ccc')
})
path.marker('end', 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)

  this.fill('#0f9')
})
The marker() method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times, so it will create a marker in the defs but not show it yet:

var marker = draw.marker(10, 10, function(add) {
  add.rect(10, 10)
})
Secondly a marker can be created and applied directly on its target element:

path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
This will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example.

Lastly, if a marker is created for reuse on a container element, it can be applied directly to the target element:

path.marker('mid', marker)
Finally, to get a marker instance from the target element reference:

path.reference('marker-end')

marker.height()
returns itself
animate yes

Defines the markerHeight attribute:

marker.height(10)
marker.ref()
returns itself

By default, the refX and refY attributes of a marker are set to respectively half the width nd height values. To define the refX and refY of a marker differently:

marker.ref(2, 7)
marker.size()
returns itself
animate yes

Defines the markerWidth and markerHeight attributes:

marker.size(10, 10)
marker.update()
returns itself

Updating the contents of a marker will clear() the existing content and add the content defined in the block passed as the first argument:

marker.update(function(add) {
  add.circle(10)
})
marker.width()
returns itself
animate yes

Defines the markerWidth attribute:

marker.width(10)


SVG.Bare
For all SVG elements that are not described by SVG.js, the SVG.Bare class comes in handy. This class inherits directly from SVG.Element and makes it possible to add custom methods in a separate namespace without polluting the main SVG.Element namespace. Consider it your personal playground.

element()
повертає SVG.Bare що наслідує від SVG.Element

The SVG.Bare class can be instantiated with the element() method on any parent element:

var element = draw.element('title')
The string value passed as the first argument is the node name that should be generated.

Additionally, any existing class name can be passed as the second argument to define from which class the element should inherit:

var element = draw.element('symbol', SVG.Parent)
This gives you as the user a lot of power. But remember, with great power comes great responsibility.

element.words()
returns itself

The SVG.Bare instance carries an additional method to add plain text:

var element = draw.element('title').words('This is a title.')
//-> <title>This is a title.</title>