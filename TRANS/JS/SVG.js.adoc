:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

SVG.js
======

Легковажна бібліотека для маніпуляції та анімації SVG.

Чому обирають SVG.js?
---------------------
SVG.js не має залежностей, та націлена бути малою як це можливо, при цьому провадячи повне покриття специфікації SVG. Якщо ви ще не переконані, ось декілька фактів.

Вона тонка.
-----------
SVG.js є легковажною. Цифри не брешуть, так що тут надається порівняння конкурентів. Майте на увазі, що це робить ту саму річ, але майже половиною довжини кода!

Вона швидка.
------------
SVG.js швидка. Очевидно, не така швидка, як ванільний js, але в багато разів швидше, ніж конкуренти.

Індекс:

* `rects`: генерує 10000 прямокутників

* `fill`: генерує 10000 заповнених кольором прямокутників

* `gradient`: генерує 10000 прямокутників з градієнтом кольору

Меньше - краще. Протестовано на Intel Core m5 @ 1.2GHz.

Просто читається, незахаращений синтаксис.
------------------------------------------
Створення та маніпуляція SVG з використанням самого JavaScript досить балакуче. Наприклад, просте створення рожевого квадрата потребує досить багато коду:

[source,js]
----
// Звичайний js
var ns = 'http://www.w3.org/2000/svg'
var div = document.getElementById('drawing') 
var svg = document.createElementNS(ns, 'svg')
svg.setAttributeNS(null, 'width', '100%')
svg.setAttributeNS(null, 'height', '100%')
div.appendChild(svg)
var rect = document.createElementNS(ns, 'rect')
rect.setAttributeNS(null, 'width', 100)
rect.setAttributeNS(null, 'height', 100)
rect.setAttributeNS(null, 'fill', '#f06')
svg.appendChild(rect)
----
SVG.js провадить синтаксис, що одночасно стислий та його легко читати. Цей код робить те саме, що  і js приклад вище:
[source,js]
----
// SVG.js
var draw = SVG('drawing')
  , rect = draw.rect(100, 100).fill('#f06')
----
Це тільки два рядка коду, замість десяти! Та при цьому значно менше повторів.

Шаленійте з анімацією
---------------------
[source,js]
----
var input = document.querySelector('input[type=text]')
var draw = SVG('drawing').viewbox(0, 0, 300, 140)
var text = draw.text(function(add) {
	add.tspan( input.value )
})

text
	.path('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
	.animate(1000, '<>')
	.plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80')
	.loop(true, true)

input.addEventListener('keyup', updateText(text))

function updateText(textPath) {
	return function() {
		textPath.tspan(this.value)
	}				
}
----

Та більше...
------------
* анімація за розміром, позицією, трансформацією, колором, ...

* безболісне розширення, дякуючи модулярній структурі

* доступність різноманітні корисні плагіни

* уніфікований api між типами фігур щодо пересування, розміру, центрування, ...

* прив'язка подій до елементів

* повна підтримка для масок прозорості та шляхів відсічення

* текстові шляхи, навіть анімовані

* групи елементів

* динамічні градієнти та шаблони

* повністю документовано (ви дивитесь на це :)

Ліцензія
--------
SVG.js ліцензований за умовами MIT License.

Журнал змін
-----------
Цікавитесь, що змінилось в останньому релізі? Подивіться журнал змін.

Починаємо
=========
Підготовка
----------
SVG.js вважає, що ви маєте HTML елемент з атрибутом `id`, створений та готовий служити як огортка. Щось таке:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>SVG.js</title>
</head>
<body>
  <div id="drawing"></div>
</body>
</html>
----
Створення SVG документу
-----------------------
Далі використовуйте функцію SVG() для створення SVG документу в оточуючому елементі:
[source,js]
----
var draw = SVG('drawing').size(300, 300)
var rect = draw.rect(100, 100)
  .attr({ fill: '#f06' })
----
Перший аргумент може бути або `id` елемента, або сам обраний елемент. Це буде генерувати такий вихід:
[source,html]
----
<div id="drawing">
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="300">
    <rect width="100" height="100" fill="#f06"></rect>
  </svg>
</div>
----
По замовчанню малюнок svg слідує розмірам свого батька, в цьому випадку `#drawing`:
[source,js]
----
var draw = SVG('drawing').size('100%', '100%')
----
Перевірка підтримки SVG
-----------------------
По замовчанню SVG.js вважає, що браузер клієнта підтримує SVG. Ви можете перевірити підтримку таким чином:
[source,js]
----
if (SVG.supported) {
  var draw = SVG('drawing')
  var rect = draw.rect(100, 100)
} else {
  alert('SVG not supported')
}
----
Очікування завантаження DOM
---------------------------
Це може для багатьох виглядати очевидним, але це все ще варте нагадування. Якщо ви включаєте ваші js файли в заголовку вашого документу, переконайтесь, що діждетесь завантаження DOM:
[source,scala]
----
SVG.on(document, 'DOMContentLoaded', function() {
  var draw = SVG('drawing')
})
----
Це не проблема, якщо ви вставляєте ваш js знизу.

Чистий SVG
----------
SVG.js також робить за межами HTML DOM, наприклад, в документі SVG:
[source,xml]
----
<?xml version="1.0" encoding="utf-8" ?>
<svg id="drawing" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" >
  <script type="text/javascript" xlink:href="svg.min.js"></script>
  <script type="text/javascript">
    <![CDATA[
      var draw = SVG('drawing')
      draw.rect(100,100).animate().fill('#f03').move(100,100)
    ]]>
  </script>
</svg>
----
Пісочниця
---------
Щоб дати вам поштовх, ось базове налаштування. Присутнє все для початку забавок.
[source,js]
----
// ініціалізація SVG.js
var draw = SVG('drawing')

// темно рожевий квадрат
draw.rect(100, 100).move(100, 50).fill('#f06')
----

Батькі
======
SVG.Parent
----------
Клас `SVG.Parent` є базовою огорткою для всіх елементів, що можуть містити інші елементи. `SVG.Parent` наслідує напряму від найнижчого рівня класів SVG.js: `SVG.Element`.

SVG.Container
-------------
`SVG.Container` додає інший рівень до стеку батьківського наслідування. Якщо `SVG.Parent` приносить декілька низькорівневих методів, як `add()`, `remove()` та `has()`, щоб назвати декілька, `SVG.Container` може та повинен використовуватись, якщо ви бажаєте додати ваші власні методи. Таким чином, прототип `SVG.Parent` залишається чистим. Вам слідує завжди наслідувати від `SVG.Container`, коли реалізуєте ваші власні батьківські елементи.

Стек батьківського наслідування таий: `SVG.Element` > `SVG.Parent` > `SVG.Container`.

SVG.Doc
=======
Функція-ініціалізатор SVG.js створює кореневий вузол в наданий елемент, та повертає примірник `SVG.Doc`.

SVG()
-----
повертає `SVG.Doc`, що наслідує від `SVG.Container`
[source,js]
----
var draw = SVG('drawing')
----
NOTE: Перший раз, коли викликається `SVG()`, буде створений другий, невидимий `<svg>`. Це наш парсер, та він пояснений в FAQ.

SVG.Nested
----------
Вкладені документи SVG один в одного.

nested()
~~~~~~~~
конструктор `SVG.Container`
повертає `SVG.Nested`, що наслідує від SVG.Container

Вкладені SVG документи мають точно такі можливості, що і головний SVG документ вищого рівня:
[source,js]
----
var nested = draw.nested()

var rect = nested.rect(200, 200)
----

SVG.G
-----
Групування елементів може буде корисне, якщо ви бажаєте трансформувати набір елементів, так, якби це був один елемент. Всі елементи в групі керують свою позицію відносно до групи, до якої вони належать.

NOTE: Групи не мають своєї власної геометрії, вона наслідується від його вмісту. Таким чином групи не зважають на атрибути `x`, `y`, `width` та `height`. Якщо це те, що ви шукаєте, використовуйте замість цього `nested()` svg.

group()
~~~~~~~
конструктор `SVG.Container`
повертає `SVG.G`, що наслідує від `SVG.Container`

Група має всі ті самі методи елемента, що і кореневий документ SVG:
[source,js]
----
var group = draw.group()
group.path('M10,20L30,40')
----
Існуючі елементи з документу SVG також може бути додані групи:
[source,js]
----
group.add(rect)
----

SVG.Symbol
----------
конструктор `SVG.Container`
повертає `SVG.Symbol`, що наслідує від `SVG.Container`

Подібно до елементу групи, елемент символа є контейнерним елементом. Єдина різниця в тому, що символи не відображуються. Таким чином елемент символа є ідеальним в комбінації з елементом `use`:
[source,js]
----
var symbol = draw.symbol()
symbol.rect(100, 100).fill('#f09')

var use  = draw.use(symbol).move(200, 200)
----

SVG.Defs
--------
Елемент <defs> є контейнером для посиланих елементів. Нащадки вузла `<defs>` не відображуються напряму. Вузол `<defs>` живе в головному документі `<svg>`, та може бути досяжний за допомогою метода `defs()`.

defs()
~~~~~~
конструктор `SVG.Container`
повертає `SVG.Defs`, що наслідує від `SVG.Container`
[source,js]
----
var defs = draw.defs()
----
`defs` також доступний на любому іншому елементі через метод `doc()`:
[source,js]
----
var defs = rect.doc().defs()
----
Вузол `defs` робить точно так само, як і групи.

SVG.A
-----
Створює гіперпосилання, що буде активоване на всіх дитячих елементах.

link()
~~~~~~
конструктор `SVG.Container`
повертає `SVG.A`, що наслідує від `SVG.Container`

Гіперпосилання або тег `<a>` створює контейнер, що дозволяє посилання на всіх його дітях:
[source,js]
----
var link = draw.link('http://svgdotjs.github.io/')
var rect = link.rect(100, 100)
----
Url посилання може бути оновлене за допомогою метода `to()` method:
[source,js]
----
link.to('http://apple.com')
----
Більше того, елемент `link` має метод `show()` для створення атрибута `xlink:show`:
[source,js]
----
link.show('replace')
----
Та метод `target()` для створення атрибута `target`:
[source,js]
----
link.target('_blank')
----
Елементи можуть бути пов'язані в інший спосіб за допомогою метода `linkTo()`:
[source,js]
----
rect.linkTo('http://svgdotjs.github.io/')
----
Альтернативно, замість URL може бути переданий блок, для додаткових опцій елемента посилання:
[source,js]
----
rect.linkTo(function(link) {
  link.to('http://svgdotjs.github.io/').target('_blank')
})
----

