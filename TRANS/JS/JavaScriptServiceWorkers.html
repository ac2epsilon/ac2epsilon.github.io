<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Сервісні працівники: вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers">Matt Gaunt</a> WebFundamentals</p></div>
<div class="paragraph"><p>Багатий досвід в режимі офлайн, періодичні фонові синхронізації, push-сповіщення - функціональність, яка зазвичай вимагає нативної програми, приходить у веб. Сервісні працівники забезпечують технічну основу, на яку покладаються всі ці функції.</p></div>
<div class="sect2">
<h3 id="____">Що таке сервісний працівник</h3>
<div class="paragraph"><p>Сервісний працівник - це сценарій, який ваш браузер виконує у фоновому режимі, окремо від веб-сторінки, відкриваючи двері для функцій, які не потребують веб-сторінки чи взаємодії з користувачем. Сьогодні вони вже включають такі функції, як push-сповіщення та фонова синхронізація. В майбутньому сервісні працівники можуть підтримувати інші речі, такі як періодична синхронізація чи географічне обмеження. Основна особливість, обговорювана в цьому підручнику, - це можливість перехоплення та обробки мережевих запитів, включаючи програмне керування кешем відповідей.</p></div>
<div class="paragraph"><p>Причина цього такого захоплюючого API полягає в тому, що він дозволяє підтримувати офлайн-досвід, надаючи розробникам повний контроль над цим досвідом.</p></div>
<div class="paragraph"><p>До виникнення сервісних працівників існував ще один API, який надав користувачам офлайн-досвід в Інтернеті під назвою AppCache. З API AppCache існує ряд проблем, яких мали уникнути сервісні працівники.</p></div>
<div class="paragraph"><p>Що слід зазначити про сервісного працівника:</p></div>
<div class="ulist"><ul>
<li>
<p>
Це JavaScript Worker, тому він не може отримати доступ до DOM безпосередньо. Натомість сервісний працівник може спілкуватися зі сторінками, якими він керує, відповідаючи на повідомлення, що надсилаються через інтерфейс <code>postMessage</code>, і ці сторінки можуть маніпулювати DOM за потреби.
</p>
</li>
<li>
<p>
Сервісний працівник - це програмований мережевий проксі, який дозволяє вам контролювати обробку мережевих запитів на вашій сторінці.
</p>
</li>
<li>
<p>
Він припиняється, коли не використовується, і перезапускається при наступномій необхідності, тому ви не можете розраховувати на глобальний стан в обробниках <code>onfetch</code> і <code>onmessage</code>. Якщо є інформація, яку потрібно зберігати та використовувати повторно при перезапуску, сервісні працівники мають доступ до API IndexedDB.
</p>
</li>
<li>
<p>
Сервісні працівники широко використовують обіцянки, тож якщо ви не розумієте обіцянок, тоді вам слід припинити читати це та ознайомитись із обіцянками.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_____2">Життєвий цикл сервісних працівників</h3>
<div class="paragraph"><p>У сервісного працівника життєвий цикл повністю відокремлений від вашої веб-сторінки.</p></div>
<div class="paragraph"><p>Щоб встановити сервісного працівника для вашого сайту, вам потрібно зареєструвати його, що ви робите в JavaScript на своїй сторінці. Реєстрація сервісного працівника призведе до того, що браузер запустить крок встановлення сервісного працівника у фоновому режимі.</p></div>
<div class="paragraph"><p>Зазвичай під час кроку встановлення вам потрібно виконати кешування деяких статичних об’єктів. Якщо всі файли успішно кешовано, сервісний працівник встановлюється. Якщо будь-який з файлів не завантажується і кешується, то етап встановлення не вдасться і сервіс-працівник не активується (тобто не буде встановлений). Якщо це трапиться, не хвилюйтесь, він спробує повторити наступного разу. Але це означає, що якщо робітник встановиться, ви знаєте, що у вас є ці статичні активи в кеші.</p></div>
<div class="paragraph"><p>Після встановлення буде слідувати крок активації, і це чудова можливість для обробки управління будь-якими старими кешами. Ми розглядаємо це в розділі оновлення службового працівника.</p></div>
<div class="paragraph"><p>Після кроку активації сервісний працівник контролюватиме всі сторінки, які потрапляють в його поле зору, хоча сторінка, яка зареєструвала службового службовця вперше, не буде контролюватися, поки не буде завантажена знову. Після того, як сервісний працівник отриимує контроль, він опиниться в одному з двох станів: або сервісний працівник припиняється для збереження пам’яті, або він буде обробляти події отримання та повідомлення, які виникають, коли з вашої сторінки виробляється мережевий запит чи повідомлення.</p></div>
<div class="paragraph"><p>Нижче представлена ​​надмірно спрощена версія життєвого циклу сервісного працівника при його першому встановленні.</p></div>
<div class="imageblock">
<div class="content">
<img src="sw-lifecycle.png" alt="service worker lifecycle" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_">Передумови</h3>
<div class="sect3">
<h4 id="__">Підтримка браузера</h4>
<div class="paragraph"><p>Browser options are growing. Service workers are supported by Chrome, Firefox and Opera. Microsoft Edge is now showing public support. Even Safari has dropped hints of future development. You can follow the progress of all the browsers at Jake Archibald&#8217;s is Serviceworker ready site.
Вибір браузерів зростає. Сервісні працівники підтримують Chrome, Firefox та Opera. Microsoft Edge тепер демонструє відкриту підтримку. Навіть Safari кинув натяки на майбутню розробку. Ви можете слідкувати за ходом роботи всіх браузерів на веб-сайті готовності до Serviceworker, який веде Jake Archibald.</p></div>
</div>
<div class="sect3">
<h4 id="___https">Вам потрібен HTTPS</h4>
<div class="paragraph"><p>Під час розробки ви зможете використовувати сервісного працівника через localhost, але для розгортання його на сайті вам потрібно буде встановити HTTPS на вашому сервері.</p></div>
<div class="paragraph"><p>За допомогою сервісного працівника ви можете перехопити з'єднання, виготовити та фільтрувати відповіді. Потужні речі. Хоча ми б використовували ці повноваження в благих намірах, людина-посередник можливо ні. Щоб уникнути цього, ви можете реєструвати лише службовців на сторінках, що надходять через HTTPS. Тому ми знаємо, що сервісний працівник, який отримує браузер, не підроблявся під час його подорожі по мережі.</p></div>
<div class="paragraph"><p>Сторінки GitHub обслуговуються через HTTPS, тому вони є прекрасним місцем для розміщення демонстраційних версій.</p></div>
<div class="paragraph"><p>Якщо ви хочете додати HTTPS до свого сервера, вам потрібно буде отримати сертифікат TLS та встановити його для свого сервера. Це залежить від налаштувань, тому перевірте документацію вашого сервера та переконайтеся, що використовуєте генератор конфігурацій Mozilla SSL.</p></div>
</div>
<div class="sect3">
<h4 id="____2">Зареєструйте сервісного працівника</h4>
<div class="paragraph"><p>Щоб встановити сервісного працівника, потрібно розпочати процес, зареєструвавши його на своїй сторінці. Це повідомляє веб-переглядачу, де живе файл JavaScript вашого службового працівника.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="s1">&#39;serviceWorker&#39;</span> <span class="k">in</span> <span class="nx">navigator</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">navigator</span><span class="p">.</span><span class="nx">serviceWorker</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">&#39;/sw.js&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">registration</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Реєстрація пройшла успішно</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ServiceWorker registration successful with scope: &#39;</span><span class="p">,</span> <span class="nx">registration</span><span class="p">.</span><span class="nx">scope</span><span class="p">);</span>
    <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// реєстрація не вдалася :(</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ServiceWorker registration failed: &#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код перевіряє, чи доступний API сервісного працівника, і якщо він є, сервісний працівник в /sw.js реєструється після завантаження сторінки.</p></div>
<div class="paragraph"><p>Ви можете викликати <code>register()</code> щоразу, коли сторінка завантажується без побоювання; браузер з’ясує, чи вже зареєстрований сервісний працівник чи ні, і обробляє це відповідно.</p></div>
<div class="paragraph"><p>Однією тонкістю методу <code>register()</code> є розташування файлу сервісного працівника. Ви помітите в цьому випадку, що файл сервісного працівника знаходиться в корені домену. Це означає, що сфера діяльності службовця буде весь origin. Іншими словами, цей сервісний працівник отримуватиме події для всього цього домену. Якщо ми зареєструємо файл сервісного працівника за адресою <code>/example/sw.js</code>, то службовий сервіс побачить лише події для сторінок, URL-адреси яких починаються з <code>/example/</code> (тобто <code>/example/page1/</code>, <code>/example/page2/</code>).</p></div>
<div class="paragraph"><p>Тепер ви можете переконатися, що сервісний працівник увімкнено, перейшовши до пункту <code>chrome://inspect/#service-workers</code> та переглянувши ваш сайт.</p></div>
<div class="paragraph"><p>Коли вперше реалізується сервісний працівник, ви також можете переглядати деталі свого сервісного працівника через
<code>chrome://serviceworker-internals</code>. Це може бути корисним, лише щоб дізнатися про життєвий цикл сервісних працівників, але не дивуйтеся, якщо згодом його повністю замінить <code>chrome://inspect/#service-workers</code>.</p></div>
<div class="paragraph"><p>Вам може бути корисно протестувати свого сервісного працівника у вікні анонімного перегляду Incognito, щоб ви могли закрити і знову відкрити, знаючи, що попередній сервісний працівник не вплине на нове вікно. Будь-які реєстрації та кеші, створені з вікна інкогніто, будуть очищені, коли це вікно буде закрите.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____3">Встановлення сервісного працівника</h3>
<div class="paragraph"><p>Після того, як контрольована сторінка розпочне процес реєстрації, перейдемо до точки зору сценарію службового працівника, який обробляє події <code>install</code>.</p></div>
<div class="paragraph"><p>Для найосновнішого прикладу потрібно визначити зворотний виклик події <code>install</code> та визначити, які файли потрібно кешувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;install&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Виконайте етапи встановлення</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині нашого зворотного виклику <code>install</code> нам потрібно зробити наступні кроки:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Відкрийте кеш.
</p>
</li>
<li>
<p>
Кешуйте наші файли.
</p>
</li>
<li>
<p>
Підтвердіть, кешовані всі необхідні активи чи ні.
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">CACHE_NAME</span> <span class="o">=</span> <span class="s1">&#39;my-site-cache-v1&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">urlsToCache</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s1">&#39;/&#39;</span><span class="p">,</span>
  <span class="s1">&#39;/styles/main.css&#39;</span><span class="p">,</span>
  <span class="s1">&#39;/script/main.js&#39;</span>
<span class="p">];</span>

<span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;install&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Виконайте етапи встановлення</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">waitUntil</span><span class="p">(</span>
    <span class="nx">caches</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">CACHE_NAME</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cache</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Opened cache&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">addAll</span><span class="p">(</span><span class="nx">urlsToCache</span><span class="p">);</span>
      <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ви бачите, що ми викликаємо <code>caches.open()</code> з нашим потрібним іменем кешу, після чого ми викликаємо <code>cache.addAll()</code> і передаємо в наш масив файлів. Це ланцюжок обіцянок (<code>caches.open()</code> та <code>cache.addAll()</code>). Метод <code>event.waitUntil()</code> приймає обіцянку і використовує її, щоб знати, як триває установка, і вдалася вона чи ні.</p></div>
<div class="paragraph"><p>Якщо всі файли успішно кешовано, сервісний працівник буде встановлений. Якщо будь-який з файлів не завантажується, то крок встановлення не вдасться. Це дозволяє розраховувати на наявність усіх визначених вами активів, але це означає, що вам потрібно бути обережними зі списком файлів, які ви вирішите кешувати на кроці встановлення. Визначення довгого списку файлів збільшить ймовірність того, що один файл може не вдатися кешувати, що призведе до того, що ваш сервісний працівник не буде встановлений.</p></div>
<div class="paragraph"><p>Це лише один приклад: ви можете виконувати інші завдання в події встановлення або взагалі уникати встановлення слухача події <code>install</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_____3">Кеш і повернення запитів</h3>
<div class="paragraph"><p>Тепер, коли ви встановили сервісного працівника, ви, ймовірно, хочете повернути одну із кешованих відповідей, правда?</p></div>
<div class="paragraph"><p>Після того, як сервісний працівник встановлений і користувач перейде на іншу сторінку або оновиться, сервісний працівник почне отримувати події для отримання даних, приклад яких наведено нижче.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;fetch&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span>
    <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Кеш-хіт - повертаємо відповідь</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">)</span>
  <span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми визначили нашу подію <code>fetch</code> і в рамках <code>event.respoWith()</code> ми передаємо обіцянку від <code>caches.match()</code>. Цей метод розглядає запит і знаходить будь-які кешовані результати з будь-якого кешу, створеного вашим службовим працівником.</p></div>
<div class="paragraph"><p>Якщо у нас є співпадаючі відповіді, ми повертаємо кешоване значення, інакше повертаємо результат виклику для <code>fetch</code>, який зробить мережевий запит і поверне дані, якщо щось можна буде отримати з мережі. Це простий приклад і використовує будь-які кешовані активи, які ми кешували під час кроку встановлення.</p></div>
<div class="paragraph"><p>If we want to cache new requests cumulatively, we can do so by handling the response of the fetch request and then adding it to the cache, like below.</p></div>
<div class="paragraph"><p>self.addEventListener(<em>fetch</em>, function(event) {
  event.respondWith(
    caches.match(event.request)
      .then(function(response) {
        // Cache hit - return response
        if (response) {
          return response;
        }</p></div>
<div class="literalblock">
<div class="content">
<pre><code>return fetch(event.request).then(
  function(response) {
    // Check if we received a valid response
    if(!response || response.status !== 200 || response.type !== 'basic') {
      return response;
    }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// IMPORTANT: Clone the response. A response is a stream
// and because we want the browser to consume the response
// as well as the cache consuming the response, we need
// to clone it so we have two streams.
var responseToCache = response.clone();</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>caches.open(CACHE_NAME)
  .then(function(cache) {
    cache.put(event.request, responseToCache);
  });</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>            return response;
          }
        );
      })
    );
});</code></pre>
</div></div>
<div class="paragraph"><p>What we are doing is this:</p></div>
<div class="paragraph"><p>Add a callback to .then() on the fetch request.
Once we get a response, we perform the following checks:
Ensure the response is valid.
Check the status is 200 on the response.
Make sure the response type is basic, which indicates that it&#8217;s a request from our origin. This means that requests to third party assets aren&#8217;t cached as well.
If we pass the checks, we clone the response. The reason for this is that because the response is a Stream, the body can only be consumed once. Since we want to return the response for the browser to use, as well as pass it to the cache to use, we need to clone it so we can send one to the browser and one to the cache.
Update a service worker
There will be a point in time where your service worker will need updating. When that time comes, you&#8217;ll need to follow these steps:</p></div>
<div class="paragraph"><p>Update your service worker JavaScript file. When the user navigates to your site, the browser tries to redownload the script file that defined the service worker in the background. If there is even a byte&#8217;s difference in the service worker file compared to what it currently has, it considers it new.
Your new service worker will be started and the install event will be fired.
At this point the old service worker is still controlling the current pages so the new service worker will enter a waiting state.
When the currently open pages of your site are closed, the old service worker will be killed and the new service worker will take control.
Once your new service worker takes control, its activate event will be fired.
One common task that will occur in the activate callback is cache management. The reason you&#8217;ll want to do this in the activate callback is because if you were to wipe out any old caches in the install step, any old service worker, which keeps control of all the current pages, will suddenly stop being able to serve files from that cache.</p></div>
<div class="paragraph"><p>Let&#8217;s say we have one cache called <em>my-site-cache-v1</em>, and we find that we want to split this out into one cache for pages and one cache for blog posts. This means in the install step we&#8217;d create two caches, <em>pages-cache-v1</em> and <em>blog-posts-cache-v1</em> and in the activate step we&#8217;d want to delete our older <em>my-site-cache-v1</em>.</p></div>
<div class="paragraph"><p>The following code would do this by looping through all of the caches in the service worker and deleting any caches that aren&#8217;t defined in the cache whitelist.</p></div>
<div class="paragraph"><p>self.addEventListener(<em>activate</em>, function(event) {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>var cacheWhitelist = ['pages-cache-v1', 'blog-posts-cache-v1'];</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});</code></pre>
</div></div>
<div class="paragraph"><p>Rough edges and gotchas
This stuff is really new. Here&#8217;s a collection of issues that get in the way. Hopefully this section can be deleted soon, but for now these are worth being mindful of.</p></div>
<div class="paragraph"><p>If installation fails, we&#8217;re not so good at telling you about it
If a worker registers, but then doesn&#8217;t appear in chrome://inspect/#service-workers or chrome://serviceworker-internals, it&#8217;s likely failed to install due to an error being thrown, or a rejected promise being passed to event.waitUntil().</p></div>
<div class="paragraph"><p>To work around this, go to chrome://serviceworker-internals and check "Open DevTools window and pause JavaScript execution on service worker startup for debugging", and put a debugger statement at the start of your install event. This, along with Pause on uncaught exceptions, should reveal the issue.</p></div>
<div class="paragraph"><p>The defaults of fetch()
No credentials by default
When you use fetch, by default, requests won&#8217;t contain credentials such as cookies. If you want credentials, instead call:</p></div>
<div class="paragraph"><p>fetch(url, {
  credentials: <em>include</em>
})</p></div>
<div class="paragraph"><p>This behaviour is on purpose, and is arguably better than XHR&#8217;s more complex default of sending credentials if the URL is same-origin, but omitting them otherwise. Fetch&#8217;s behaviour is more like other CORS requests, such as &lt;img crossorigin&gt;, which never sends cookies unless you opt-in with &lt;img crossorigin="use-credentials"&gt;.</p></div>
<div class="paragraph"><p>Non-CORS fail by default
By default, fetching a resource from a third party URL will fail if it doesn&#8217;t support CORS. You can add a no-CORS option to the Request to overcome this, although this will cause an <em>opaque</em> response, which means you won&#8217;t be able to tell if the response was successful or not.</p></div>
<div class="paragraph"><p>cache.addAll(urlsToPrefetch.map(function(urlToPrefetch) {
  return new Request(urlToPrefetch, { mode: <em>no-cors</em> });
})).then(function() {
  console.log(<em>All resources have been fetched and cached.</em>);
});</p></div>
<div class="paragraph"><p>Handling responsive images
The srcset attribute or the &lt;picture&gt; element will select the most appropriate image asset at run time and make a network request.</p></div>
<div class="paragraph"><p>For service worker, if you wanted to cache an image during the install step, you have a few options:</p></div>
<div class="paragraph"><p>Install all the images that the &lt;picture&gt; element and the srcset attribute will request.
Install a single low-res version of the image.
Install a single high-res version of the image.
Realistically you should be picking option 2 or 3 since downloading all of the images would be a waste of storage space.</p></div>
<div class="paragraph"><p>Let&#8217;s assume you go for the low res version at install time and you want to try and retrieve higher res images from the network when the page is loaded, but if the high res images fail, fallback to the low res version. This is fine and dandy to do but there is one problem.</p></div>
<div class="paragraph"><p>If we have the following two images:</p></div>
<div class="paragraph"><p>Screen Density  Width   Height
1x      400     400
2x      800     800
In a srcset image, we&#8217;d have some markup like this:</p></div>
<div class="paragraph"><p>&lt;img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" /&gt;</p></div>
<div class="paragraph"><p>If we are on a 2x display, then the browser will opt to download image-2x.png, if we are offline you could .catch() this request and return image-src.png instead if it&#8217;s cached, however the browser will expect an image that takes into account the extra pixels on a 2x screen, so the image will appear as 200x200 CSS pixels instead of 400x400 CSS pixels. The only way around this is to set a fixed height and width on the image.</p></div>
<div class="paragraph"><p>&lt;img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x"
 style="width:400px; height: 400px;" /&gt;</p></div>
<div class="paragraph"><p>For &lt;picture&gt; elements being used for art direction, this becomes considerably more difficult and will depend heavily on how your images are created and used, but you may be able to use a similar approach to srcset.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-02-11 00:50:02 EET
</div>
</div>
</body>
</html>
