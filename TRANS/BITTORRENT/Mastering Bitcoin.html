<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Mastering Bitcoin</title>
  </head>
  <body><sub> Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2017</sub><br>
    <h3>Andreas M. Antonopoulos&nbsp;Mastering Bitcoin 2nd Edition </h3>
    <h3>O`REILLY 2017 </h3>
    <h1>Опановуючи Bitcoin</h1>
    <h4>Програмування відкритого блокчейну</h4>
    <p>Долучіться до технологічної революції, що захоплює фінансовий світ як
      шторм. Опановуючі Bitcoin є вашим провідником по, здавалось би, складному
      світові біткоіну, провадячи потрібні вам знання щоб приймати участь в
      інтернеті грошей. Чи ви будуєте наступне вбивче застосування, інвестуєте в
      стартап, або просто цікавитесь цією технологією, це перероблене та
      розширене друге видання провадить основні деталі, з яких ви маєте
      починати.&nbsp;</p>
    <h3>Швидкий глосарій</h3>
    <p> <strong>адреса</strong> біткоін виглядає як <strong>1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV</strong>.
      Вона складається з рядка літер та чисел. Насправді це закодована версія <strong>base58check</strong>
      публічного ключа <strong>160-бітного хешу</strong>. Так само, як ви
      просите вислати поштову адресу на вашу адресу, ви можете запитати
      надіслати вам біткоіни на одну з ваших біткоін адрес.</p>
    <p> <strong>bip</strong>, Bitcoin Improvement Proposals. Набір пропозицій
      від членів спільноти, надісланих для покращення біткоіна. Наприклад,
      BIP-21 є пропозиція покращити схему біткоінівськіх ідентифікаторів
      ресурсів (URI).<br>
    </p>
    <p><strong>біткоін</strong> є назвою грошових одиниць (монет), так само як
      мережі та програмного забезпечення.<br>
    </p>
    <p><strong>блок</strong> - група транзакій, що помічені часовою відміткою,
      та відтиск від попереднього блоку. Заголовок блоку захешовано для
      отримання підтвердження виконаної роботи, що підтверджує транзакції.
      Валідні блоки додаються до блокчейну через мережевий консенсус.</p>
    <p><strong> блокчейн</strong> є списком валідних блоків, кожний пов'язаний
      зі своїм попередником, і далі так само, до первинного блоку. </p>
    <p> <strong>проблема візантійськіх генералів</strong>. Надійна комп'ютерна
      система має бути в змозі мати справу з одним або більше відмовами однієї
      або більше своїх компонент. Збійний компонент може виказувати тип
      поведінки, на яку зазвичай не звертають уваги — а саме, надсилати
      конфліктуючу інформацію до різних частей системи. Проблема при спілкуванні
      з такими збоями абстрактно виражена через проблему візантійськіх
      генералів..<br>
    </p>
    <p><strong>коінбейс</strong> - спеціальне поле, що використовується як єдине
      джерело для транзакцій коінбейс. Коінбейс дозволяє підтвердити отримання
      нагороди за підпис блоку, та провадить 100 байтів довільних даних. На слід
      плутати з коінбейс транзакціями. </p>
    <p> <strong>коінбейс транзакція</strong> - перша транзакція в блоку. Завджи
      створюється майнером, та включає єдиний коінбейс. Не плутати з самим
      коінбейс. <br>
    </p>
    <p><strong>холодне сховище</strong> посилається на зберігання біткоінів
      офлайн. Холодне сховище утворюється через створення та зберігання
      приватних ключів Bitcoin в безпечному оточенні офлайн. Холодне сховище
      важливе для будь-кого, що має накопичення біткоінів. Комп'ютери онлайн є
      вразливі для хакерів, та не мають використовуватись для зберігання
      важливої кількості біткоінів. <br>
    </p>
    <p><strong>кольорові монети</strong>. Відкритий код протоколу <strong>Bitcoin
        2.0</strong> дозволяє розробникам створювати цифрові активи зверху
      блокчейну, використовуючи його функціональність за межами грошового обігу.
      <br>
    </p>
    <p><strong>підтвердження</strong>. Коли транзакція включається в блок, вона
      має одне підтвердження. Коли майнається інший блок в тому ж блокчейні,
      транзакція матиме два підтвердження, і так далі. <strong>Шість</strong>
      підтверджень вважаються достатнім підтвердженням, що транзакція не може
      бути відмінена. </p>
    <p> <strong>консенсус</strong> - коли декілька вузлів, звичайно, більшість
      вузлів в мережі, всі мають ті самі блоки в своїх найкращих валідованих
      ланцюжках блокчейну. Не плутати з правилами консенсусу.</p>
    <p> <strong>правила консенсусу</strong> - правила перевірки блоків, якім
      слідують повні вузли, щоб залишатись в стані консенсусу з іншими вузлами.
      Не плутати з консенсусом. </p>
    <p><strong>складність</strong> - налаштування рівня мережі, що контролює,
      скільки обчислень потрібно для продукування підтвердження виконанної
      роботи. <br>
    </p>
    <p><strong>переорієнтування складності</strong> - переобчислення для всієї
      мережі складності, що трапляється кожні <strong> 2,016</strong> блоків,
      та приймає до уваги потужність хешування попередніх 2,016 блоків.</p>
    <p><strong>цільова складність</strong> - складність, з якою всі обчислення в
      мережі будуть знаходити блоки з апроксімацією кожні <strong>10 хвилин</strong>.<br>
    </p>
    <p><strong>подвійне витрачання</strong> є результатом успішного використання
      деяких грошей більше ніж один раз. Bitcoin захищений від подвійного
      витрачання через верифікацію транзакцій, доданих до блокчейну, щоб
      переконатись, що всі входи для транзакції наразі не були витрачені до
      цього. <br>
    </p>
    <p><strong>ECDSA</strong>, Elliptic Curve Digital Signature Algorithm є
      криптографічним алгоритмом, що використовує Bitcoin, щоб переконатись, що
      фонди можуть бути витрачені своїми справжніми власниками. <br>
    </p>
    <p><strong>додатковий довісок</strong>. По мірі зростання складності майнери
      часто проходять всі <strong>4 мільярди</strong> значень довіска, не
      знайшовши блок. Оскільки скрипт коінбейс може зберігати від <strong>2 до
        100 байтів</strong> даних, майнери починають використовувати цей
      додатковий простір як додатковий довісок, що дозволяє їм досліджувати
      значно більший диапазон значень заголовка блока, та знайти значення
      блока.&nbsp; </p>
    <p><b>(комісійні) збори</b>. Надсилач транзакції часто включає комісію для
      мережі за обробку запитаної транзакції. Більшість транзакцій потребують
      мінімальні комісійні в <strong>0.5 mBTC</strong>.<br>
    </p>
    <p><strong>відгалуження</strong>, також відоме як випадкове відгалуження,
      трапляється, коли два або більше блоків мають ту саму висоту блоку, даючи
      розгалуження блокчейну. типово трапляється, коли два або більше майнери
      знаходять блоки в той самий час. Також може трапитись як частина атаки. <br>
    </p>
    <p><strong>первинний блок</strong> - перший блок в блокчейні,
      використовується для ініціалізації крипто валюти.<br>
    </p>
    <p><strong>жорстке розгалуження</strong>, також відоме як зміна жорсткого
      розгалуження, є постійне розділення блокчейну, загалом трапляється, коли
      неоновлені вузли не можуть перевірити блоки, створені оновленими вузлами,
      що слідують новим правилам валідації. Не плутати з розгалуженням, м'яким
      розгалуженням, програмним розгалуженням та розгалуженням Git.<br>
    </p>
    <p><strong>апаратний гаманець</strong> є спеціальним типом гаманця біткоін,
      що зберігає приватні ключі користувача на безпечному апаратному пристрої.<br>
    </p>
    <p><strong>хеш</strong> - цифровий відтиск деякого бінарного значення.</p>
    <p><strong>хеш блокування</strong> є типом перешкод, що обмежує витрату
      входу, докі деяка вказана частина даних не буде публічно розкрита. Хеш
      блокування має корисну властивість, що коли одне з блокувань стає
      розкритим публічно, любі інші хеш блокування, захищені тим самим ключем,
      також можуть бути відкриті. Це робить можливим створити декілька виходів,
      зачинених тим самим хеш блокуванням, та які всі стає можливо витрачати
      одночасно.</p>
    <p><strong>протокол HD</strong>, Hierarchical Deterministic (HD), протокол
      для створення та передачі ключів (<strong>BIP32</strong>), що дозволяє
      створення&nbsp; дочірніх ключів від батьківськів в ієрархії.</p>
    <p><strong>гаманець HD</strong> використовує Hierarchical Deterministic
      (протокол HD) для створення ключів (BIP32).</p>
    <p> <strong>зерно HD гаманця</strong>, або кореневе зерно є потенційно
      short value used as a seed to generate<br>
      the master private key and master chain code for an HD wallet.<br>
    </p>
    <p><strong>HTLC</strong> Hashed TimeLock Contract, контракт з хешованим
      часовим замком, є класом платежів, що використовують хеш блокування та
      часові замки, що потребують, щоб отримувач платежу або підтвердив
      отримання платежу до визначенного терміну, через генерацію підтвердження
      платежу, або він втрачає здатність претендувати на платіж, повертаючи його
      платникові.<br>
    </p>
    <p><strong>KYC</strong> Know your customer, знай свого клієнта - процес в
      бізнесі, ідентифікуючий та верифікуючий його клієнтів. Термін також
      використовується на банківське регулювання, що регулює ці дії.<br>
    </p>
    <p><strong>LevelDB</strong> є відкритим сховищем ключ-значення на диску.
      LevelDB є легковажною бібліотекою єдиного призначення зберігання, що має
      прив'язки до багатьох платформ. <br>
    </p>
    <p><strong>Lightning Networks</strong> є запропонованою реалізацією Hashed
      Timelock Contracts (HTLC) з дво-спрямованими каналами платежів, що
      дозволяє безпечне переправлення платежів через різноманітні канали
      платежів сторона-до-сторони. Це дозволяє формування мережі, де кожна
      сторона в мережі може заплатити кожному іншому, навіть якщо вони напряму
      не мають відкритого каналу один до одного. <br>
    </p>
    <p><strong>Locktime</strong>, або більш технічно nLockTime, є частиною
      транзакції, що вказує на найменьший час, або найранішній блок, коли
      транзакція може бути додана до ланцюга блоків.<br>
    </p>
    <p><strong>mempool</strong>,&nbsp; блокчейн мемпул (пул в пам'яті) є
      колекцією з усіх даних транзакцій в блоці, що були перевірені вузлами
      біткоін, але все ще не підтверджені. <br>
    </p>
    <p><strong>мерклівській корінь</strong> - кореневий вузол мерклівського
      дерева, нащадок всіх хешованих пар в дереві. Заголовки блоків мають
      включати валідний мерклівський корінь, що походить з усіх транзакцій в
      блоці. <br>
    </p>
    <p><strong>мерклівське дерево</strong>, дерево, створене через хешування
      попарних даних (листів), що потім збираються попарно, та хешуючи
      результат, доки не залишиться єдиний хеш, мерклівській корінь. В Bitcoin
      листами майже завжди є транзакції з одного блоку.<br>
    </p>
    <p><strong>майнер</strong> - вузол мережі, що шукає валідний доказ
      проробленої роботи для нових блоків, через циклічне хешування. <br>
    </p>
    <p><strong>мультисигнатура</strong> - multisig, посилаєтсья на вимогу мати
      більше ніж один ключ для авторизації транзакції біткоін.<br>
    </p>
    <p><strong>мережа</strong>, поєднання сторона-до-сторони, що просуває
      транзакції та блоки до кожного вузла біткоін в мережі. <br>
    </p>
    <p><strong>довісок</strong> є полем в блоці біткоін, розміром 32-біти (4
      байти), чиє значення встановлюється так, щоб хеш блоку містив задану
      кількість першух нулів. Залишок полів не можуть були змінені, бо вони
      мають визначене значення.<br>
    </p>
    <p><strong>поза-ланцюгові транзакції</strong> - переміщення значень за
      межами блокчейну. Тоді як ланцюгові транзакції&nbsp; — на які звичайно
      посилаютсья як на прості транзакції — модифікують блокчейн, та залежать
      від блокчейну для визначення власної валідності, поза-ланцюгові транзакції
      покладаються на інші методи для запису та перевірки транзакції.<br>
    </p>
    <p><strong>коди операцій</strong>, opcode - коди мови Bitcoin Script, що
      засувають дані або виконують функції в скрипті pubkey або signature.<br>
    </p>
    <p><strong>протокол Open Assets</strong> є простий та потужний протокол,
      побудований на блокчейні біткоіна. Він дозволяє випуск та передачу
      створених користувачем активів. Протокол Open Assets є розвитком концепції
      кольорових монет.<br>
    </p>
    <p><strong>OP_RETURN</strong> - код операції, використаний в одному з
      виходів в транзакції OP_RETURN. Не треба плутати з транзакцією OP_RETURN.<br>
    </p>
    <p>транзакція OP_RETURN - тип транзакції, що передається та майниться по
      замовченню в Bitcoin Core 0.9.0 та пізніших, що додає довільні дані до
      доказового скрипта невитратного pubkey, що повні вузли не мають зберігати
      в своїй базі даних UTXO. Не плутати з кодом операції <br>
      OP_RETURN.<br>
    </p>
    <p><strong>очікуючий (підвислий) блок</strong> - блок, чий батьківській блок
      ще не був оброблений локальним вузлом, так що він наразі не може бути
      валідований. <br>
    </p>
    <p><strong>очікуючі (підвислі) транзакції</strong> - такі транзакції, що не
      можуть іти в пул через одну або більше вхідних транзакцій. <br>
    </p>
    <p><strong>вихід, вихід транзакції або TxOut</strong> є вихід в транзакції,
      що містить два поля: поле значення для нуля або більше сатоші, та скрипт
      pubkey, для встановлення, яким умовам треба задовільняти, щоб витратити ці
      сатоші. <br>
    </p>
    <p><strong>P2PKH</strong> - транзакції, що сплачуються на адресу біткоін, що
      містить P2PKH або скрипт Pay To PubKey Hash. Вихід, що заблоковано
      скриптом P2PKH, може бути розблокований(витрачений), через пред'явлення
      публічного ключа та цифрового підпису, створеного відповідним приватним
      ключем. <br>
    </p>
    <p><strong>P2SH або Pay-to-Script-Hash</strong> - потужний новий тип
      транзакцій, що значно спрощує використання складних скриптів транзакцій.
      За допомогою P2SH складний скрипт, що перелічує умови для витрати виходу
      (повторний сценарій) не представлений в блокуючому скрипті. Замість цього
      там є лише хеш цього скрипта. <br>
    </p>
    <p><strong>P2SH адреса</strong> є Base58Check кодуванням 20-байтного хешу
      скрипта. P2SH адреса використовує префікс “5”, що призводить до того, що
      Base58Check-кодована адреса починається з “3”. P2SH адреса приховує всю
      складність, так що людина, що робить платіж, не бачить скрипта. <br>
    </p>
    <p><strong>P2WPKH</strong> - сигнатура P2WPKH
      (Pay-to-Witness-Public-Key-Hash), містить ту саму інформацію, що і витрата
      P2PKH, але розташована в полі доказу, замість поля scriptSig. Також
      scriptPubKey є модифікований.<br>
    </p>
    <p><strong>P2WSH</strong>. Різниця між P2SH та P2WSH
      (Pay-to-Witness-Script-Hash) полягає в розміщенні криптографічного
      підтвердження, що змінене з поля scriptSig до поля свідоцтва, та
      scriptPubKey також модифікований.<br>
    </p>
    <p><strong>паперовий гаманець</strong>, в найбільш специфічному сенсі, є
      документом, що містить всі дані, потрібні для генерації любого числа
      приватних ключів Bitcoin, формуючи гаманець з ключами. Однак люди часто
      використовують цей термін, маючи на увазі любий спосіб зберігання
      біткоінів офлайн, як фізичний документ. Це друге визначення також включає
      паперові ключі, та погашувальні коди. <br>
    </p>
    <p><strong>канали платежів</strong> - канал мікроплатежів або канал платежів
      є прийомом, розробленим щоб дозволити користувачам робити багато
      транзакцій с біткоіном, без підтвердження всіх транзакцій в біткоін
      блокчейні. В типовому каналі платежів тільки дві транзакції додаються до
      блокчейна, але необмежене, або майже необмежене число платежів можуть бути
      зроблені між задіяними сторонами. <br>
    </p>
    <p><strong>майнинг в пулі</strong> - підхід до майнингу, коли багато
      генеруючих клієнтів докладаються до генерації блоку, та потім поділяють
      винагороду згідно вкладеній оброблюваній потужності. <br>
    </p>
    <p><strong>Proof-of-Stake</strong>, (PoS), доказ ставок, є методом, яким
      мережа крипто валюти з блокчейном досягає розподіленого консенсусу.
      Proof-of-Stake запитує користувачів доказати власність певної кількості
      валюти (їхню “ставку” в валюті).<br>
    </p>
    <p><strong>підтвердження виконанної роботи</strong>, Proof-of-Work - частина
      даних, що потребує виконання значних обчислень, щоб бути знайденою. В
      біткоіні, майнери мають знайти числове рішення алгоритма <strong>SHA256</strong>,
      що задовільняє мережевій цільовій складності.<br>
    </p>
    <p><strong>винагорода</strong> - сума, що вкладається в кожний новий блок,
      як винагорода від мережі майнеру, хто знайшов рішення підтвердження
      виконанної роботи. На сьогодні це<strong> 12.5 BTC</strong> за блок.<br>
    </p>
    <p><strong>RIPEMD-160</strong> є 160-бітною криптографічною хеш функцією.
      RIPEMD-160 є посиленою версією RIPEMD з 160-бітовим результатом хеша, та
      очікується, що буде безпечною протягом найближчих десяти років, або
      більше. <br>
    </p>
    <p><strong>сатоші</strong> є найменьшою одиницею обміну біткоінами, що може
      бути записана в блокчейні. Вона еквівалентна <strong>0.00000001</strong>
      біткоінам та названа на честь створювача Bitcoinа, Satoshi Nakamoto.<br>
    </p>
    <p><strong>Satoshi Nakamoto</strong> - ім'я, використане персоною або
      людьми, хто розробив Bitcoin та створив оригінальну референсну реалізацію,
      Bitcoin Core. Як частина реалізації, вони також розробили першу базу даних
      блокчейна. В процесі вони першими вирішили проблему подвійної витрати для
      цифрових грошей. Їх дійсні імена залишаються невідомими. <br>
    </p>
    <p><strong>скрипт</strong>. Bitcoin використовує скриптову систему для
      транзакцій. Система скриптів проста та скидаєтсья на Forth, базується на
      стеку, та обробляється зліва направо. Вона навмисно не Т'юрінг-повна, бо
      не має циклів. <br>
    </p>
    <p><strong>скрипт ScriptPubKey</strong> (також скрипт pubkey) - скрипт,
      включений в вихід, що встановлює умови, яким треба задовільняти, щоб
      витратити ці сатоші. Дані, потрібні щоб задовільнити умовам, мають бути
      запроваджені в скрипті. <br>
    </p>
    <p><strong>підпис ScriptSig</strong> (також скрипт сигнатури) - дані,
      згенеровані тим, хто витрачає, що майже завжди використовуються як змінні,
      щоб задовільнити скрипт <strong>pubkey</strong>.<br>
    </p>
    <p><strong>секретний ключ</strong> (він же приватний ключ) - секретне число,
      що відкриває біткоіни, надіслані на відповідну адресу. Секретний ключ
      виглядає таким чином: 5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh<br>
    </p>
    <p><strong>відокремлене свідоцтво</strong> є запропоноване оновлення до
      протоколу Bitcoin, що є технологічною іновацією, яка відокремлює дані
      підпису від транзакцій біткоін. Відокремлене свідоцтво є запропонованих
      м'яким відгалуженням; ця зміна технічно робить протокол Bitcoin більш
      обмежуючим. <br>
    </p>
    <p><strong>SHA</strong>, Secure Hash Algorithm, або безпечний хеш-алгоритм,
      є сімейство кріптографічних хеш функцій, опублікованих Національним
      інститутом стандартів та технології&nbsp; (NIST).<br>
    </p>
    <p><strong>SPV</strong>, simplified payment verification, або спрощена
      верифікація є метод для верифікації часткових транзакцій, що включені в
      блок, без завантаження самого блоку. Метод використовується в деяких
      легковажних клієнтах Bitcoin.<br>
    </p>
    <p><strong>м'яке розгалуження</strong>, або зміна м'якого розгалуження є
      тимчасовим розгалуженням в блокчейні, що загалом трапляється, коли майнери
      використовують неоновлені вузли, що не слідують новим правилам консенсусу,
      про який вони не знають. Не плутати з розгалуженням, жорстким
      розгалуженням, програмних розгалуженням та розгалуженням Git.<br>
    </p>
    <p><strong>стабільний блок</strong> - такий, що успішно змайнений, але не
      включений в поточний кращий ланцюжок блокчейн, вірогідно тому, що деякий
      інший блок з такою самою висотою розширив блок раніше. <br>
    </p>
    <p><strong>часове блокування</strong> є типом перешкод, що обмежує витрату
      біткоінів до вказаного часу в майбутньому, або до заданої висоти блоку.
      Часове блокування яскраво використовується в багатьох контрактах Bitcoin,
      включаючи платіжні канали та контракти з хешовим блокуванням.</p>
    <p><strong>транзакція</strong>, в простих термінах, є передача біткоінів з
      однієї адреси до іншої. Більш точно, транзакція є підписана структура
      даних, що виражає передачу значення. Транзакції передаються через мережу
      біткоін, збираються майнерами, та включаються в блоки, стаючи постійними в
      блокчейні. <br>
    </p>
    <p><strong>пул транзакцій</strong> - невпрорядкована колекція транзакцій, що
      не є в блоках основного блокчейну, але для яких ми маємо вхідні
      транзакції.<br>
    </p>
    <p><strong>повнота Т'юрінга</strong>. Мова називається повною за Т'юрингом,
      якщо вона може використати любу програму, що може виконати машина
      Т'юрінга, маючи досить чису та пам'яті.<br>
    </p>
    <p><strong>невикористані вихідні транзакції</strong>, unspent transaction
      output (UTXO) є вихідними транзакціями, що можуть бути витрачені в
      наступних вхідних транзакціях.<br>
    </p>
    <p><strong>гаманець</strong> є програмою, що зберігає всі біткоін адреси та
      секретні ключі. Використовується для надсилання, отримання та зберігання
      ваших біткоінів. <br>
    </p>
    <p><strong>Wallet Import Format</strong> (WIF) - формат обміну даними,
      розроблений щоб дозволити експорт та імпорт одного приватного ключа з
      флагом, що вказує, чи використовується стискання публічного ключа, або ні.<br>
    </p>
    <h2>Глава 1</h2>
    <h1> Вступ</h1>
    <h3> Що таке Bitcoin?</h3>
    <p> Bitcoin є набором концепцій та технологій, що формують основу цифрової
      грошової екосистеми. Грошові одиниці, що називаються біткоін (біткоінами)
      використовуються для зберігання та передачі вартості між приймаючими
      участь в мережі біткоін. Користувачі біткоін комунікують один з одним,
      використовуючи біткоін протокол, в основному через інтернет, хоча інші
      транспотртні мережі також можуть бути використані. Стек протоколу біткоін,
      доступний як програма з відкритим кодом, може виконуватись на великому
      диапазоні обчислювальних приладів, включаючи лептопи та смартфони, що
      робить технологію легко доступною.</p>
    <p>Користувачі можуть передавати біткоін через мережу, щоб робити все те
      саме, що може бути зроблене зі звичайними грошима, включаючи придбання та
      продаж товарів, надсилання грошей іншим людям або організаціям, або
      отримання кредиту. Біткоін може бути придбаний, проданий та обміняний на
      інші валюти на спеціалізованих обмінниках валют. Біткоін в деякому сенсі є
      ідеальною формою грошей для інтернета, бо він є швидкий, безпечний та
      необмежений кордонами. </p>
    <p>На відміну від традиційних валют, біткоін є повністю віртуальним. Немає
      фізичних монет, або навіть цифрових монет, як таких. Монети маються на
      увазі в транзакціях, що передають вартість від надсилача до отримувача.
      Користувачі біткоін володіють ключами, що дозволяють їм підтвердити
      власність на біткоіни в мережі біткоін. За допомогою ціх ключів вони
      можуть підписувати транзакції, щоб відімкнути (розблокувати) вартість, та
      витратити її, передавши новому власнику. Ключі часто зберігаютья в
      цифровому гаманці на комп'ютері або смартфоні кожного користувача.
      Володіння ключем, що може підписати транзакцію, є єдиною передумовою для
      витрачання біткоінів, передаючи контроль повністю в руки кожного
      користувача.&nbsp;</p>
    <p><br>
      Біткоін є розподіленою системою сторона-до-сторони. Як такого, немає
      “центрального” сервера або точки контролю. Біткоін створений через процес,
      що називається “майнингом”, що включає змагання за пошук рішень
      математичної проблеми, при цьому обробляючи транзакції біткоін. Любий, хто
      приймає участь в мережі біткоін, (тобто, кожний, хто використовує
      пристрій, що виконує повний стек протоколу біткоін), може оперувати як
      майнер, використовуючи свою ообчислювальну потужність для перевірки та
      запису транзакцій. Кожні 10 хвилин, в середньому, майнер біткоін є в змозі
      перевірити транзакції за останні 10 хвилин, та винагороджується повністю
      новими біткоінами. В своїй основі, біткоін майнинг децентралізує випуск
      грошей та функції клірингу (підтвердження та закріплення транзакцій)
      замість центрального батнку, та заміняє потребу в центральному банку. </p>
    <p> Біткоін протокол включає вбудовані алгоритми, що регулюють функцію
      майнингу по всій мережі. Складність завдання обробки, що мають виконати
      майнери, динамічно підлаштовується, так, щоб дехто отримував успіх кожні
      10 хвилин, безвідносно до того, як багато майнерів (та як багато
      обчислень) змагаються наразі в кожний момент.</p>
    <p>Протокол також переділяє навпіл рівень, з яким створюється біткоін, кожні
      4 роки, та обмежує загальне число біткоінів, що будуть створені до
      фіксованого загалу меньше 21 мільйонів монет. Результат цієї кількості
      біткоінів в обігу близько слідує добре передбачуваній кривій, що досягає
      21 мільйонів в 2140 році. Через зниження швидкості карбування біткоінів, в
      довгій перспективі, валюта біткоіну є дефляційною. Більше того, біткоін не
      може бути інфльований через “друк” нових грошей далі же межами очікуванної
      кількості випущенних монет.</p>
    <p> За лаштунками сцени біткоін також є назвою протоколу, мережі
      сторона-до-сторони, та інноваційного розподіленого обчислення. Валюта
      біткоіна насправді є тільки першим застосуванням цього винаходу. Біткоін
      представляє кульмінацію десятирічь дослідів в криптотграфії та
      розподілених системах, та включає чотири ключові інновації, складені разом
      в унікальний та потужній комбінації. Біткоін складається з:</p>
    <p> • Децентралізованої мережі сторона-до-сторони (протокол біткоін)</p>
    <p> • Публічний реєстр транзакцій (блокчейн)</p>
    <p> • Набір правил для незалежної валідації транзакцій та випуску грошей
      (правила консенсусу)</p>
    <p> • Механізм для досягнення децентралізованого консенсусу на валідному
      блокчейні (алгоритм доказу виконаної роботи)</p>
    <p> Як розробник, я дивлюсь на біткоін, як щось подібне на інтернету грошей,
      мережа, що просуває цінність та захищає власність на цифрові активи через
      розподілені обчислення. В біткоіні є значно більше, ніж впадає в око з
      першого погляду. В цій главі ми почнемо досліджувати деякі з головних
      концепцій та термінів, отримаємо необхідне програмне забезпечення, та
      використаємо біткоін для простих транзакцій. В наступних главах ми почнемо
      розгортати нашарування технологій, що роблять біткоін можливим, та
      дослідимо внутрішню роботу мережі та протоколу біткоін.</p>
    <h3>Цифрові гроші перед Bitcoin</h3>
    <p> Створення життєспроможньіх цифрових грошей тісно пов'язане з розробками
      в криптографії. Не стало сюрпризом, коли дехто розглядає фундаментальні
      виклики, використовуючи біти для представлення вартості, що можуть бути
      обміняні на товари та послуги. Три основні запитання постають для кожного,
      хто приймає цифрові гроші, і вони наступні:</p>
    <p> 1. Можу я довіряти тому, що ці гроші справжні та не є підробними?<br>
    </p>
    <p>2. Можу я довіряти тому, що цифрові гроші можуть бути витрачені один раз
      (відоме як проблема “подвійної витрати”)?<br>
    </p>
    <p>3. Чи можу я бути впевнений, що ніхто інший не зможе переконати, що гроші
      належать йому, та не мені?<br>
    </p>
    <p>Друкарі паперових грошей постійно ведуть боротьбу з проблемою підробок,
      через застосування все більш складні папір та технології друку. Фізичні
      гроші вирішують проблему подвійної витрати, бо той самий папір не може
      знаходитись в двох місцях одночасно. Зрозуміло, що звичайні гроші також
      часто зберігаютсья та передаються в вигляді транзакцій. В ціх випадках,
      підробка та проблема подвійної витрати обробляються через очищення всіх
      електронних транзакцій в центральних установах, що мають глобальний погляд
      на всі гроші в обігу. Для цифрових грошей, що не можуть отримати переваги
      від застосування езотеричних чорнил або голограмних стрічок, криптографія
      провадить основу для довіри легитимності претензій користувача щодо прав
      власності. Більш детально, криптографічні цифрові підписи дозщволяють
      користувачеві підписувати цифрові активи або транзакції, що провадить
      власність щодо цього активу. З відповідною архитектурою, цифрові підписи
      також можуть бути використані для вирішення проблеми подвійної витрати. </p>
    <p> Коли криптографія почала ставати більш широко доступною, та стала
      зрозумілою в кінці 1980-х, багато дослідників почали спроби
      використовувати криптографію для побудови цифрових валют. Ці ранішні
      проекти цифрових грошей випускали цифрові гроші, часто підтримані
      національними валютами, або дорогоцінними металами, такими як золото. <br>
    </p>
    <p>Хоча ці ранішні цифрові валюти прауювали, вони були централізовані, та,
      як результат, було простим для атаки з боку урядів та хакерів. Ранішні
      цифрові гроші використовували центральні клірингові установи для
      закріплення всіх транзакцій з регулярними інтервалами, так само, як
      традиційна банківська система. На жаль, в більшості випадків ці незрілі
      цифрові валюти ставали ціллю занепокоєних урядів, та з часом судилися аж
      до зникнення. Деякі схибили через феєричні падіння, коли батківська
      компанія раптово ліквідувалась. Щоб бути стійким до нападів антагоністів,
      чи то суперечки з урядами, або кримінальними елементами, була потрібна
      розподілена валюта, щоб уникнути єдиної точки атаки. Біткоін є саме такою
      системою, децентралізованою від народження, та вільна від жодної
      центральною цстанови, або точки контролю, що може бути атакована або
      пошкоджена.</p>
    <h3>Історія Bitcoin</h3>
    <p> Bitcoin був винайдений в 2008-му році, коли була опублікована стаття
      “Bitcoin: A Peer-to-Peer Electronic Cash System”, написана під псевдонімом
      Satoshi Nakamoto (https://bitcoin.org/bitcoin.pdf, дивіться Додаток&nbsp;
      A). Nakamoto зібрав декілька попередніх винаходів, таких, як b-money та<br>
      HashCash, щоб створити повністю децентралізовані електронні гроші, що не
      покладаються на центральну установу для випуску грошей, або закріплення та
      валідацію транзакцій. Ключовим винаходом було використання розподіленої
      системи обчислень (що назівається алгоритмом доказу виконаної роботи), щоб
      проводити глобальні “вибори” кожні 10 хвилин, дозволяючи децентралізованій
      системі досягати консенсусу щодо стану транзакцій. Це елегантно вирішує
      проблему подвійної витрати, коли одна сума може бути витрачена двічи. До
      цього проблема подвійної витрати була слабкістю цифрових грошей, та
      вирішувалась через очищення всіх транзакцій через централізовану
      клірингову установу. </p>
    <p>Мережа біткоін стартувала в 2009-му році, базуючись на референсній
      реалізації, опублікованій Nakamoto, та з тих пір перевіреною багатьма
      іншими програмістами. Реалізація алгоритма доказу виконаної роботи
      (Proof-of-Work), також відомому як майнінг, що провадить безпеку та
      стійкість, зростаючі в експоненціальній ступіні, та наразі перевищує
      загальну потужність всіх найпотужних суперкомп'ютерів. Загальна ринкова
      вартість Bitcoin ставала часом більше $35 мільярдів доларів США (на кінець
      2017 загальна кількість біткоін складає 17 мільйонів, вартістю біля 92
      млрд. долларів ), в залежності від курсу долара до біткоіна. Найбільша
      оброблена транзакція, що досі проходила в мережі, складала $150 мільйонів
      доларів, вони були передані напряму та оброблені без жодних комісійних.</p>
    <p> Satoshi Nakamoto віддалився з публіки в 2011-му році, залишивши
      відповідальність за розробку кода та мережі на процвітаючу групу
      добровольців. Особистість людини або групи людей, що стоять за біткоіном,
      все ще невідома. Однак ані&nbsp; Satoshi Nakamoto, так само, як ніхто
      інший не має індивідуальний контроль над системою біткоін, що робить на
      базі прозорих математичних принципів, відкритого джерельного коду, та
      консенсусу між задіяними сторонами. Саме відкриття настільки новаторське,
      та вже породив нову науку в сфері розподіленого обчислення, економіки та
      економетрики.</p>
    <h3>Рішення проблеми розподілених обчислень</h3>
    <p> Винахід Satoshi Nakamoto також є практичним та новітнім рішенням
      проблеми розподілених обчислень, відомої як проблема візантійськіх
      генералів. Скорочено, ця проблема складається в намаганні скласти
      домовленість щодо стану системи, через обмін інформацією через ненадійну,
      та потенційно скомпроментовану мережу. Рішення Satoshi Nakamoto, що
      використовує концепцію доказу виконаної роботи для досягнення консенсусу
      без центральної установи, предсатвляє прорив в розподіленоих обчисленнях,
      та має застосування за межами валюти. Воно може використовуватись для
      досягнення консенсусу в розподілених мережах, щоб довести чесність
      виборів, лоторей, реєстрів рахунків, цифрових нотаріусів, і багато більше.
    </p>
    <h3> Bitcoin: використання, користувачі та їх історії</h3>
    <p> Біткоін є інновацією в старовинній технології грошей. В своїй основі
      гроші просто спрощують обмін вартістю між людьми. Таким чином, щоб
      повністю зрозуміти біткоін та його використання, ми подивимось на нього з
      перспективи людей, що використовують його. Кожний з людей та їх історій,
      які перелічено тут, ілюструє одну або більше зі специфічних способів
      використання. Ми побачимо їх на протязі цієї книги:</p>
    <h4> Північно-американський продавець дешевої нерухомості</h4>
    <p> Аліса живе в районі затоки Північної Каліфорнії. Вона чула про біткоін
      від своїх друзів, та почала використовувати їх. Ми прослідкуємо її
      історію, як вона пізнала про біткоін, як отримала декілька, та потім
      витратила свої біткоіни для придбання філіжанки кави в кав'ярні Боба в
      Пало Альто. Ця історія дасть вам вступ до програмного забезпечення,
      обміну, та базових транзакцій з перспективи продавця нерухомості.</p>
    <h4> Продавець коштовної власності в Північній Америці</h4>
    <p>Керол є власницею арт галереї в Сан Франциско. Вона продає коштовні
      малюнки за біткоін. Ця історія буде включати ризик консенсус-атаки “51%”
      для продавців коштовних речей.</p>
    <h4> Офшорні контрактні послуги</h4>
    <p> Боб, власник кав'ярні в Пало Альто, будує новий веб сайт. Він виняйняв
      по контракту індійського веб розробника, Гопеша, що живе в Банглорі,
      Індія. Гопеш погодився отримати платню в біткоіні. Ця історія перевірить
      використання біткоіну для аутсорсінгу, контрактних послуг, та міжнародних
      електронних платежів. </p>
    <h4> Веб крамниця</h4>
    <p> Габріель є молода людина-підприємець з Ріо-Де-Жанейро, що утримує
      маленьку веб крамницю, що продає майки з надрукованим логотипом біткоіну,
      а також чашки та наліпки. Габріель дуже юний щоб мати банківський рахунок,
      але його батьки підтримують його підприємницький хист.</p>
    <h4> Благодійні пожертви</h4>
    <p> Євгенія є директором благодійного фонду на Філіпінах. Нещодавно вона
      відкрила біткоін, та бажає використати цілу нову групу закордонних та
      місцевих донорів для фундації власного фонду. Вона також досліджує шляхи
      для використання біткоіну для швидкого розподілу фондів до місцевосцей, де
      в них є потреба. Ця історія покаже використання біткоіну для глобального
      фінансування за межами валют та границь, та використання відкритого обліку
      для прозорості діяльності благодійних організацій.</p>
    <h4> Імпорт/експорт</h4>
    <p> Мохамед є імпортером електроніки в Дубаї. Він намагається
      використовувати біткоін для придбання електроніки зі Сполучених Штатів та
      Китаю для імпорту в Емірати, щоб пришвидшити процес платежів для
      імпортерів. Ця історія покаже, як біткоін може бути використаний для
      великих міжнародних платежів бізнес-до-бізнесу, що пов'язані з фізичними
      товарами.</p>
    <h4> Майнінг (видобування) біткоіну</h4>
    <p> Джинг є студентом комп'ютерного інжинірингу в Шанхаї. Він побудував
      “майнинговий” пристрій, щоб видобувати біткоін з використанням інженерних
      навичок, щоб отримати прибуток. Ця історія висвітлює "індустріальну"
      сторону біткоіну: спеціалізоване обладнання для унебезпечення мережі
      біткоіну, та випуску нової валюти. </p>
    <p>Кожна з ціх історій базована на реальних людях та реальних галузях, що
      наразі використовують біткоін для створення нових ринків, нових галузей,
      та інновативних рішень проблем глобальної економіки. </p>
    <h3> Починаємо</h3>
    <p> Біткоін є протоколом, до якого можна отримати доступ з використанням
      клієнтського застосування, що розмовляє за цім протоколом. "Гаманець
      біткоіну" є найбільш загальним користувацьким інтерфейсом до системи
      біткоіна, так само, як переглядач є найбільш загальним користувацьким
      інтерфейсом до протоколу HTTP.</p>
    <p> Існує багато реалізацій та брендів гаманців біткоіну, так само, як є
      багато брендів веб переглядачів (Chrome, Safari, Firefox, та Internet
      Explorer). Та так само, як ви маєте свій улюблений веб переглядач (Mozilla
      Firefox, так!), та наші негідники (Internet Explorer, ні!), гаманці
      біткоін різняться за якістю, продуктивністю, безпекою, приватністю та
      надійністю. Також є референсна реалізація протоколу біткоіну, що включає
      гаманець, відома як "Клієнт Сатоші", що походить від оригінальної
      реалізації, написаної Satoshi Nakamoto.</p>
    <h3> Обираємо гаманець для біткоін</h3>
    <p> Гаманці біткоін є найбільш розроблювані застосування в екосистемі
      біткоін. Існує потужна конкуренція, та якщо новий гаманець буде
      розроблений прямо зараз, декілька з останнього року більше не отримують
      підтримки. Багато гаманців фокусуютсья на специфічних платформах, або
      специфічних використаннях, та деякі більш придатні для початківців, тоді
      як ініші перевантажені можливостями для досвідчених користувачів. Обирання
      гаманця дуже суб'єктивне, та залежить від його використання та
      кваліфікації користувача. Таким чином неможливо рекомендувати окремий
      бренд або проект гаманця. Однак ми можемо розкласти на категорії гаманці
      біткоіну, відповідно до платформи та функцій, та запровадити деяку ясність
      щодо всіх різних типів гаманців, що існують. Навіть краще, пересилання
      грошей між гаманцями біткоіну легке, дешеве та швидке, так що можна
      спробувати декілька різних гаманців, докі ви знайдете той, що задовільняє
      вашим потребам. </p>
    <p>Гаманці біткоін можуть бути розбиті на категорії наступним чином,
      відповідно до платформи:</p>
    <h4> Десктопні гаманці</h4>
    <p> Десктопні гаманці були першим типом гаманців біткоін, створені як
      референсна реалізація, та багато користувачів використовують десктопні
      гаманці для можливостей, автономії та контролю, що вони надають. Однак їх
      виконання на операційних системах загального використання, таких, як
      Windows або Mac OS, мають декілька недоліків безпеки, бо ці платформи
      часто небезпечні та невірно сконфігуровані.</p>
    <h4> Мобільні гаманці</h4>
    <p> Мобільні гаманці є найбільш загальним типом гаманців біткоін.
      Виконуючись на операційних системах смартфонів, як Apple iOS та Android,
      ці гаманці часто є гарним вибором для користуваа. В значній мірі
      розроблені для простоти та зручності в користуванні, вони, тим не менш,
      повністю фукціональні гаманці для потужних користувачів. </p>
    <h4> Веб гаманці</h4>
    <p> Веб гаманці мають доступ через веб переглядач, та зберігають гаманець
      користувача на сервері, що належить третій стороні. Це подібно до веб
      пошти, коли ви повністю покладаєтесь на сервер. Деякі з ціх сервісів
      оперують, використовуючи код на боці клієнта, що використовується в
      переглядачі клієнта, що утримує контроль над ключами біткоіну в руках
      користувача. Однак більшість представляють компроміс, відбираючи в
      користувача контроль над ключами біткоіну, в обмін на простоту
      використання. Не можна рекомендувати зберігання великої кількості біткоіну
      на системах третіх сторін. </p>
    <h4> Апаратні гаманці</h4>
    <p>Апаратні гаманці є пристроями, що оперують як самодостатній гаманець
      біткоіну на базі спеціального апаратного обладнання. Вони роблять через
      USB на десктопних веб переглядачах, або через коротко-досяжні комунікації
      (NFC) на мобільних пристроях. Через обробку всіх біткоін операцій на
      спеціалізованому обладнанні, ці гаманці визнані дуже безпечними, та
      підходять для зберігання великих кількостей біткоін.</p>
    <h4> Паперові гаманці</h4>
    <p> Ключі, що контролюють лбіткоін, також можуть бути роздруковані для
      довготривалого зберігання. Це відоме як паперові гаманці, навіть якщо
      можуть використовуватись інші матеріали (деревина, метал, тощо). Паперові
      гаманці пропонують низькотехнологічний, але дуже безпечний спосіб
      зберігання біткоіну на тривалий термін. Офлайн сховище часто посилаєтсья
      як холодне сховище.</p>
    <p>Інший шлях категоризації гаманців біткоін є їхня ступінь автономності, та
      як вони взаємодіють з мережею біткоін:</p>
    <h4> Повно-вузловий клієнт</h4>
    <p> Повний клієнт, або "повний вузол", це клієнт, що зберігає повну історію
      всіх транзакцій біткоін (кожну транзакцію для кожного користувача,
      будь-що), керує користувацькими гаманцями, та може ініціювати транзакції
      напряму в мережу біткоін.&nbsp; Повний вузол обробляє всі аспекти
      протоколу, та може незалежно перевіряти повний блокчейн, та кожну окрему
      транзакцію. Повно-вузловий клієнт споживає значні комп'ютерні ресурси
      (більше ніж 125Гб диску, 2Гб оперативної пам'яті), але пропонує повну
      автономію та незалежну верифікацію транзакцій.</p>
    <h4> Легковажний клієнт</h4>
    <p> Легковажний клієнт, також відомий як клієнт зі спрощеною перевіркою
      платежів (simple-payment-verification, SPV),<br>
      &nbsp;під'єднується до повних вузлів біткоіну (зазначених вище) для
      доступу до інформації щодо транзакцій, але зберігає гаманець користувача
      локально, та незалежно створює, перевіряє та передає транзакції.
      Легковажні клієнти напряму взаємодіють з мережею біткоін, без
      посередників.</p>
    <h4> Клієнти з власним API</h4>
    <p> Клієнти з API третіх сторін взаємодіють з біткоіном через системи третіх
      сторін, через програмні інтерфейси (API), замість того, щоб напряму
      під'єднуватись до мережі біткоін. Гаманець може зберігатись користувачем
      або на серверах, але всі транзакції ідуть через посередників.</p>
    <p>Комбінуючи ці категорізації, багато біткоін гаманців підпадають в
      декілька груп, де три найбільш загальніє є повний десктопний клієнт,
      мобільний легковажний клієнт та веб гаманець від третьої сторони. Межа між
      різними категоріям є досить розмитою, бо багато гаманців вміють
      виконуватись на декількох платформах, та можуть взаємодіяти з мережею в
      різний спосіб.</p>
    <p> Для цілей цієї книжки ми будемо демонструвати використання різноманітних
      клієнтів, що можна завантажити, від референсної реалізації (Bitcoin Core),
      до мобільних та веб гаманців. Деякі з прикладів будуть потребувати Bitcoin
      Core, що на додаток до того, що це повний клієнт, також пропонує API до
      послуг гаманця, мережі, та транзакцій. Якщо ви плануєте дослідити
      програмні інтерфейси в екосистемі біткоін, вам знадобиться Bitcoin Core,
      або один з альтенативних клієнтів (дивіться "Альтернативні клієнти,
      бібліотеки та тулкіти").</p>
    <h3> Швидкий початок</h3>
    <p> Аліса, з якою мипознайомились раніше, не є технічним користувачем, та
      тільки нещодавно почула про біткоін від друга Джо. Перебуваючи на вечірці,
      Джо раз за разом натхненно пояснював ідею біткоіна&nbsp; всім докола
      нього, та пропонував зробити демонстрацію. Заінтригована, Аліса запитала,
      як вона може розпочати взаємодію з біткоін. Джо сказав, що мобільний
      гаманець найкращий для початківців, та рекомендував декілька з його
      улюблених гаманців. Аліса завантажила "Mycelium" для Android, та
      встановила його на свій телефон.</p>
    <p> Потім Аліса запустила Mycelium в перший раз, та, як багато інших біткоін
      гаманців, застосування автоматично створило новий гаманець для неї. Аліса
      побачила свій гаманець на екрані, як показано на Малюнку 1-1 (зауваження:
      не надсилайте біткоін до цієї фіктивної адреси, вони будуть втрачені
      назавжди).<br>
      <br>
      Малюнок 1-1. Мобільний гаманець Mycelium<br>
    </p>
    <p>Найбільш важлива частина на цьому екрані є біткоін адреса Аліси. На
      екрані вона виглядає як довгий рядок літер та цифр:
      1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK. Далі за адресою біткоіну в гаманці іде
      QR код, певна форма бар-коду, що містить ту ж саму інформацію в форматі,
      що може біти просканований камерою смартфона. QR код є квадратом з
      шаблоном з чорних та білих крапок. Аліса може скопіювати адресу біткоін
      або QR код в свій буфер обміну, клацнувши на QR коді, або на кнопці
      Receive (Отримати). В більшості гаманців клацання на QR коді буде також
      збільшувати його, так що вам може більш просто скануватись камерою
      смартфона.<br>
    </p>
    <p>Адреса біткоіна починається з 1 або 3. Як адреси електронної пошти, вони
      можуть бути поділені з іншими користувачами біткоіну, які можуть
      використовувати їх для надсилання біткоінів прямо до гаманця. Тут немає
      нічого чутливого з точки зору безпеки, щодо адрес біткоіна. Він може бути
      опублікований будь-де, без ризику для безпеки рахунку. На відміну від
      поштової адреси, ви можете створити нову адресу так часто, як побажаєте,
      та всі вони будуть спрямовувати гроші в ваш гаманець. Фактично, багато
      сучасних гаманців автоматично створюють нові адреси для кожної транзакції,
      щоб максимізувати приватність. Гаманець просто колекція адрес та ключів,
      що відмикають суми з ціх адрес. </p>
    <p>Тепер Аліса готова приймати платежі. Її застосування-гаманець випадково
      генерує приватний ключ (як описане в деталях в розділі "Приватні ключі"),
      разом з відповідними адресами біткоін. В цій точці її адреса біткоін не
      відома для мережі біткоін, або не "зареєстрована" будь якою стороною в
      системі біткоін. Її адреса біткоін просто число, що відповідає до ключа,
      за допомогою вона може отримати контроль за сумами на цій адресі. Ключ був
      згенерований незалежно гаманцем, без посилань або реєстрації жодним
      сервісом. Фактично, в більшості гаманців, немає асоціації між адресами
      біткоіну та жодною зовнішньою ідентифікуючою інформацією, включаючи дані
      про користувача. До того часу, як ця адреса буде використана як отримувач
      вартості в транзакції, що надіслана в реєстр біткоін, адреса біткоін є
      просто частиною загального числа можливих адрес, що є валідними в біткоін.
      Тількуи коли вона стає асоційованою з транзакцією, тільки тоді вона стає
      частиною адрес, що відомі мережі. </p>
    <p>Наразі Аліса готова почати використовувати її новий біткоін гаманець. </p>
    <h3> Отримання ваших перших біткоінів</h3>
    <p> Першим, та часто найбільш складним завданням для нових користувачів, є
      отримання деяких біткоінів. На відміну від інших валют, ви ще доки не
      можете придбати біткоіни в банку або в пункті обміну валют. </p>
    <p> Транзакції біткоіну не мають зворотньої дії. Більшість мереж електронних
      платежів, такі, як кредитні картки, PayPal, та банківські рахунки, мають
      змогу відміни платежу. Для декого, хто продає біткоін, ця різниця додає
      дуже великий ризик, що покупець поверне електронний платіж після отримання
      біткоіну, тобто ошукає продавця. Щоб зменшити цей ризик, компанії, що
      приймають традиційні електронні платежі в обмін на біткоін, зазвичай
      потребують від покупців пройти перевірку особистості та
      платежеспроможнсоті, що може зайняти декілька днів або тижнів. Як для
      нового користувача, це означає, що ви не зможете придбати біткоін напряму,
      за допомогою кредитної картки. За допомогою певної терплячості та
      креативного мислення вам це і не знадобиться. <br>
    </p>
    <p><br>
      Ось декілька способів отримати біткоін для нових користувачів:<br>
    </p>
    <p>• Знайти товариша, який має біткоін, та купити в нього декільку суму
      напряму. Багато користувачів біткоіну почали цім шляхом. Цей метод найменш
      складний. Один зі способів познайомитись з людьми з біткоінами є завітати
      та місцеву подію зі списку Meetup.com.<br>
    </p>
    <p>• Використати перевірений сервіс зі списку localbitcoins.com, щоб знайти
      продавця в вашій місцевості, та купити біткоін за готівку при
      безпоседерній транзакції.<br>
    </p>
    <p>• Заробити біткоін через продажу продуктів або послуг за біткоін. Якщо ви
      програміст, продавайте ваші програмістські навички. Якщо ви перукар,
      стрижить волосся за біткоін.<br>
    </p>
    <p>• Використовуйте автомати ATM біткоіну в вашому місці. Автомати біткоіну
      є машиною, що приймає готівку, та надсилає біткоін на гаманець біткоін в
      вашому смартфоні. Знайдіть найближчий до вас біткоін ATM з використанням
      мапи від Coin ATM Radar.<br>
    </p>
    <p>• Використовуйте обмін валют на біткоін, пов'язаний з вашим банківськім
      рахунком. Багато країн наразі мають обміни валют, що пропонують продавцям
      та покупцям ринок продажу біткоін за місцеву валюту. Сервіси курсів обміну
      валют, такі, як BitcoinAverage, часто показують перелік обмінників біткоін
      для кожної з валют.<br>
    </p>
    <p>Одна з переваг біткоіну над інши платіжними системами є те, що коли
      застосована коректно, вона надає значно більшу приватність. Отримання,
      зберігання та витрата біткоіну не потребує від вас розголошення чутливої
      та персонально ідентифікуючої інформації третім сторонам. Однак там, де
      біткоін зачіпає традиційні системи, такі, як обмінники валют, часто
      застосовуются національні або міжнародні регулятивні норми. Щоб обміняти
      біткоін на вашу місцеву валюту, вам часто знадобиться запровадити доказ
      вашої особистості та надати банківську інформацію. Користувачі повинні
      бути попереджені, що як тільки адреса біткоін буде пов'язана з особистими
      даними, всі асоційовані транзакції біткоіну також буде легко
      ідентифікувати та відстежити. Це та причина, чому багато користувачів
      обирають обслуговувати окремі обмінні рахунки, не пов'язані з їх
      гаманцями. </p>
    <p>Аліса війша в світ біткоін завдяки товаришу, так що вона пройшла простим
      шляхом для отримання прерших біткоінів. Далі ми побачимо, як вона
      куауватиме свої біткоіни у друга Джо, та як Джо надішле біткоіни до її
      гаманця.</p>
    <h3> Пошук поточного курсу біткоін</h3>
    <p> Перед тим, як Аліса придбає перші біткоіни від Джо, вони мають
      домовитись щодо курсу обміну між біткоіном та доларами США. Це підіймає
      загальне запитання для новачків в біткоін: "Хто встановлює ціну
      біткоіна?". Коротка відповідь - ціну встановлює ринок.</p>
    <p>Біткоін, як і інші валюти, має плаваючий обмінний курс. Це означає, що
      вартість біткоіну до кожної іншої валюти змінюється відповідно до
      пропонування та попиту на різних ринках, де він торгуєтсья. Наприклад,
      "ціна" біткоіна до долара США обчислюється на кожному з ринків, базуючись
      на останніх торгах біткоіна до долару. Я к така, ціна має тенданцію
      змінюватись щохвилини, по декілька разів на секунду. Сервіси цін будуть
      агрегувати ціни від декількох ринків, та обчислювати взважене за об'ємом
      середнє, що представлє обмінний курс валюти для певної пари (BTC/USD).</p>
    <p>Існує сотні застосувань та веб сайтів, що можуть провадити поточні курси
      на ринку. Ось декілька найбільш популярних:</p>
    <h4> Bitcoin Average</h4>
    <p>Сайт, що провадить простий погляд на взаважене за об'ємом середнє для
      кожної валюти.</p>
    <h4> CoinCap</h4>
    <p>Сервіс переліку капіталізації ринку та обмінних курсів для сотен крипто
      валют, включаючи біткоін.</p>
    <h4> Chicago Mercantile Exchange Bitcoin Reference Rate</h4>
    <p> Рівень посилань, що може використовуватись для інституційного або
      контрактного посилання, що провадиться як частина інвестиційних фідів від
      CME.</p>
    <p>На додаток до ціх різноманітних сайтів та застосувань, більшість біткоін
      гаманців будуть автоматично конвертувати суми в біткоінах в інші валюти.
      Джо буде використовувати свій гаманець для автоматичної конвертації ціни,
      перед тим, як надіслати біткоін до Аліси.</p>
    <h3> Надсилання та отримання біткоіну</h3>
    <p> Аліса вирішила обміняти $10 на біткоін, щоб не дуже ризикувати грошима з
      новою технологією. Вона дає Джо $10 готівкою, відкриває свій
      гаманець-застосування Mycelium, та обирає Отримати (Receive). Це висвічує
      QR код з першою біткоін адресою Аліси. Потім Джо обирає Надіслати (Send)
      на своєму смартфоні та потрапляє у вікно з двома полями:<br>
    </p>
    <p>• Цільова адреса біткоін<br>
    </p>
    <p>• Суму, що надіслати, в біткоінах (BTC) або в місцевій валюті (USD)<br>
    </p>
    <p>В полі вводу для адреси біткоін є мала іконка, що виглядає як QR код. Це
      дозволяє Джо сканувати бар-код за допомогою камери смартфону, так що він
      не має набирати адресу біткоін Аліси, що досить довга та складна для
      вводу. Джо клацає по іконці QR, та активує камеру смартфона, скануючи QR
      код, що висвітлюється на смартфоні Аліси.<br>
    </p>
    <p>Тепер Джо має адресу біткоін Аліси в якості отримувача. Джо вводить суму
      $10, та гаманець конвертує її, отримуючи доступ до новітніх курсів обміну
      від онлайн сервісу. Курс обміну на той час становить $100 за біткоін, так
      що $10 вартує 0.10 біткоін (BTC), або 100 мілі біткоінів (mBTC), як
      показано на екрані з гаманця Джо (Малюнок 1-2).<br>
    </p>
    <p>Малюнок 1-2. Екран надсилання мобільного гаманця Airbitz<br>
    </p>
    <p>Тепер Джо уважно все перевіряє, щоб переконатись, що він ввів коректну
      суму, оскільки він збираєтсья перевести гроші, та помилки не мають
      зворотньої ходи.&nbsp; Після подвійної перевірки він натискає Надіслати
      (Send), щоб надіслати транзакцію. Мобільний гаманець біткоін Джо будує
      транзакцію, що присвоює 0.10 BTC адресі, наданій від Аліси, знімаючи гроші
      з гаманця Джо, та підписуючи транзакцію приватним ключем Джо. Це каже
      мережі біткоін, що Джо авторизований переказати вартість до нової адреси
      Аліси. Коли транзакція передана через двосторонній протокол, вона швидко
      поширюється по мережі біткоін. Швидше ніж за секунду більшість
      гарно-під'єднаних вузлів в мережі отримають цю транзакцію, та в перший раз
      побачать адресу Аліси.</p>
    <p> Тим часом, гаманець Аліси весь час "слухає" опубліковані транзакції в
      мережі біткоін, виглядачи на все, що співпадає з адресами в її гаманці.
      Через декілька секунд, після того, як гаманець Джо надіслав транзакцію,
      гаманець Аліси зафіксує, що отримав 0.10 BTC.</p>
    <h3> Підтвердження</h3>
    <p> Зпочатку адреси Аліси будуть показувати транзакції Джо я к
      непідтверджені (Unconfirmed). Це означає, що транзакція поширилась
      мережею, але все ще не записана в реєстрі транзакцій біткоін, що в
      середньому відбувається кожні 10 хвилин. В традиційних фінансових термінах
      це відоме як очистка. Щодо додаткових деталей про розповсюдження,
      валідацію та очистку (підтвердження) біткоін транзакцій дивіться Главу 10.<br>
    </p>
    <p>Тепер Аліса повновласний володар 0.10 BTC, які вона може витрачати. В
      наступній главі ми побачимо її перше придбання за допомогою біткоін, та
      дослідимо відповідну транзакцію та технологію розповсюдження більш
      детально.<br>
    </p>
    <h2> ГЛАВА 2</h2>
    <h1> Як робить біткоін</h1>
    <h3> Транзакції, блоки, майнинг та блокчейн</h3>
    <p> Система біткоін, на відміну від традиційних банків та платіжних систем,
      базується на децентралізованій довірі. Замість центральної довіреної
      установи, в біткоіні довіра досягаєтсья як неочевидна властивість від
      взаємодії різних приймаючих участь сторін в системі біткоін. В цій главі
      ми дослідимо біткоін на високому рівні, через відстеження поодинокої
      транзакції в системі літкоін, та побачимо, як вона стає "довіреною" та
      сприяється механізмом розподіленого консенсусу біткоін, та, нарешті,
      записується в блокчейн, розподілений реєстр всіх транзакцій. Наступні
      глави будуть занурюватись в технології позаду транзакцій, мережу та
      майнінг.</p>
    <h3> Огляд біткоіну</h3>
    <p> На оглядовій диаграмі, показаній на Малюнку 2-1, ми бачимо, що система
      біткоін складається з користувачів з гаманціми, що містять ключі,
      транзакції передаються мережею, та майнери, що продукують (через змагання
      в обчисленні) консенсус блокчейну, якій, загалом, є реєстром всіх
      транзакцій.</p>
    <p>Кожний приклад в цій главі базуєтся на справжній транзакції, зробленій в
      мережі біткоін, що симулює взаємодію між користувачами (Джо, Аліса, Боб та
      Гопеш), через надсилання фондів з одного гаманця на інший. При відстеженні
      трензакції по мережі біткоін до блокчейну, ми будемо використовувати
      сайт-переглядач блокчейну, щоб візуалізувати кожний крок. Переглядач
      блокчейну є веб застосуванням, що оперує як пошукова машина біткоіна, в
      тому сенсі, що дозволяє шукати адреси, транзакції та блоки, та бачити
      відношення та переходи між ними.<br>
    </p>
    <p>Популярні переглядачі блокчейну включають:<br>
      • Bitcoin Block Explorer<br>
      • BlockCypher Explorer<br>
      • blockchain.info<br>
      • BitPay Insight<br>
    </p>
    <p>Кожний з них має функції пошуку, що може сприймати адресу біткоін, хеш
      транзакції, номер блоку, або хеш блоку, та повертає відповідну інформацію
      з мережі біткоін. З кожною транзакцією або прикладом блоку, ми будемо
      провадити URL, так що ви можете побачити це самі та вивчити в деталях.</p>
    <h3> Придбання філіжанки кави</h3>
    <p> Аліса, з якою ми познайомились в попередній главі, є новим користувачем,
      що тільки отримала свій перший біткоін. В попередній главі вона зустрілась
      зі своїм товаришем Джо, щоб обміняти деяку готівку на біткоін. Транзакція,
      створена Джо, збагатила гаманець Аліси на 0.10 BTC. Тепер Аліса робить
      свою першу купівельну транзакцію, купуючи каву в кав'ярні Боба в Пало
      Альто, Каліфорнія.</p>
    <p>Кав'ярні Боба нещодавно почала приймати платежі в біткоіні, через
      додавання опції біткоіну до своєї платіжної системи. Ціни позначені в
      місцевій валюті (доларах), але на касі споживачі мають опцію заплатити або
      доларами, або біткоінами. Аліса отримала свій рахунок за свою каву, та Боб
      додав його до журналу, як він робить з усіма транзакціями. Система точки
      продажу автоматично конвертує загал з доларів США в біткоін за поточним
      ринковим курсом, та відображує вартість в обох валютах:</p>
    <pre>      Total:</pre>
    <pre>      $1.50 USD</pre>
    <pre>      0.015 BTC</pre>
    <p> Боб каже: "Це півтори долари або п'ятнадцять мілібіт". Система точки
      продажу Боба також автоматично створить окремий QR код, що міститиме запит
      на сплату (Малюнок 2-2). На відміну від QR коду, що просто містить цільову
      адресу біткоіну, запит на сплату є QR-кодованим URL, що містить цільову
      адресу, суму до сплати, та загальну інформацію, як "Bob’s Cafe". Це
      дозволяє гаманцю біткоін заповнити інформацію для сплати рахунку, при
      цьому показавши дані платежу користувачеві. Ви можете сканувати QR код за
      допомогою застосування біткоін гаманця, щоб побачити, що має побачити
      Аліса. </p>
    <p> Малюнок 2-2. QR код платіжного запиту</p>
    <p> Спробуйте сканувати цей код за допомогою вашого гаманця, щоб побачити
      адресу на суму, але НЕ НАДСИЛАЙТЕ ГРОШІ.</p>
    <pre>      bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?</pre>
    <pre>      amount=0.015&amp;</pre>
    <pre>      label=Bob%27s%20Cafe&amp;</pre>
    <pre>      message=Purchase%20at%20Bob%27s%20Cafe</pre>
    <h4> Компоненти URL</h4>
    <p> Адреса біткоін: "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"<br>
      Сума платежу: "0.015"<br>
      Мітка щодо отримувача: "Bob's Cafe"<br>
      Опис (коментар) до платежу: "Purchase at Bob's Cafe"<br>
    </p>
    <p>Аліса використовує власний смартфон для сканування бар-коду, що
      відображений. Її смартфон показує платіж на 0.0150 BTC до Bob’s Cafe, та
      вона обирає надіслати платіж. За декілька секунд (приблизно за час
      авторизації кредитної картки),<br>
      Боб бачить транзакцію в реєстрі, що завершує транзакцію.</p>
    <p>В наступних розділах ми дослідимо транзакції більше детально. Давайте
      зараз подивимось, як гаманець Аліси побудував її, як він поширив її в
      мережі, як вона стала верифікована, та, нарешті, як Боб зміг витратити цю
      суму в подальших транзакціях.<br>
    </p>
    <p>Мережа біткоін може обмінюватись частковими значеннями, від
      мілі-біткоінів (1/1000 біткоіна), аж до 1/100,000,000 від біткоіна, що
      відоме як сатоші. В цій книзі ми будемо використовувати термін "біткоін"
      для любої кількості валюти біткоін, від найменьших одиниць (1 сатоші) до
      загального числа (21,000,000) всіх біткоінів, що будь коли будуть
      видобуті. </p>
    <p> Ви можете перевірити транзакцію Аліси до Bob’s Cafe в блокчейні,
      викуористовуючи переглядач блокчену (Приклад 2-1):<br>
    </p>
    <p>Приклад 2-1. Перегляд транзакції Аліси на blockexplorer.com</p>
    <pre>      https://blockexplorer.com/tx/</pre>
    <pre>      0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</pre>
    <h3> Транзакції біткоін</h3>
    <p> В простих термінах, транзакція каже мережі, що власник деякої вартості
      біткоінів авторизовано передає цю вартість іншому власникові. Новий
      власник тепер може витратити біткоін для інших транзакцій, що авторизують
      передачі вартості іншим власникам. Новий власник тепер може витратити
      біткоін для іншої транзакції, що авторизує передачу до іншого власника, і
      так далі, по ланцюгу власників.</p>
    <h3> Входи та виходи транзакції</h3>
    <p> Транзакції подібні до рядків реєстру подвійної звітності. Кожна
      транзакція налічує один або більше "входів", що виступають як дебет
      відносно рахунку біткоіна. З іншого боку транзакції є один або більше
      "виходів", що виступають як кредити, додані до рахунку біткоін.&nbsp;
      Входи та виходи (дебіти та кредити) не обов'язково складають ту ж саму
      суму. Замість цього, виходи в сумі дещо менші, ніж входи, та різниця
      представляє призначені комісійні транзакції, що є малим платежем, що
      надходить до майнера, який включає транзакцію в реєстр. Транзакція біткоін
      показана як запис в бухгалтерській реєстр на Малюнку 2-3.</p>
    <p> Транзакція також містить доказ власності для кожної суми в біткоін
      (входів), суми яких витрачаються, та формують цифровий підпис власника, що
      може бути незалежно перевірений будь-ким. В термінах біткоіну,
      "витрачання" є підпис транзакції, що пересилає вартість від попереднього
      власника транзакції до нового власника, ідентифікованого адресою біткоін.</p>
    <p>Малюнок 2-3. Транзакція як запис за подвійною звітністю. </p>
    <h3> Ланцюги транзакцій</h3>
    <p> Платіж Аліси до Bob’s Cafe використовує попередні виходи транзакцій як
      входи. В попередній главі, Аліса отримала біткоіни від її товариша Джо, в
      обмін на готівку. Ця транзакція створила вартість біткоін, що закріплена
      за ключем Аліси. Її нова транзакція до кав'ярні Боба посилається на
      попередню транзакцію як на вхід, та створює нові виходи, щоб сплатити за
      каву, а також отримати решту. Транзакції утворюють ланцюг, де входи від
      останніх транзакцій відповідають виходам від попередніх транзакцій. Ключ
      Аліси провадить сигнатуру (цифровий підпис), що відмикає ці виходи
      попередніх транзакцій, таким чином запевняючи мережу біткоін, що вона є
      власником ціх фондів. Вона приєднує платіж за каву до адреси Боба, таким
      чином "ускладнюючи" цей вихід тією умовою, щоб Боб зпродукував сигнатуру,
      щоб витратити цю суму. Це і є передача вартості від Аліси до Боба. Цей
      ланцюг транзакцій, від Джо до Аліси, та від Аліси до Боба, проілюстрований
      на Малюнку 2-4.<br>
      <br>
      Малюнок 2-4. Ланцюг з транзакцій, де вихід з однієї транзакції є входом
      для наступної транзакції</p>
    <h3> Отримання решти</h3>
    <p> Багато транзакцій біткоін будуть включати виходи, що посилаються на
      обоє, адресу нового власника, та на поточного власника, що називається
      адресою решти. Це так, бо входи транзакцій, як і банкноти, не можуть бути
      поділені. Якщо ви купляєте на суму $5, але надаєте купюру $20, ви очікуєте
      значу в розмірі $15. Та ж концепція застосовується до входів транзакції
      біткоін. Якщо ви придбаєте дещо вартістю 5 біткоінів, але маєте на вході
      тільки 20 біткоінів, що можна витратити, ви маєте надіслати один вихід в 5
      біткоінів до власника крамниці, та один вихід в 15 біткоінів назад до
      себе, як решту (зменшивши суму на достатні комісійні з транзакції).</p>
    <p>Важливо, що адреса для решти не була тою самою адресою, що є на вході, та
      з причин приватності часто це нова адреса з гаманця власника. </p>
    <p>Різні гаманці можуть використовувати різні стратегії при накопичуванні
      входів, щоб зробити платіж на вимогу користувача. Вони можуть агрегувати
      багато малих входів, або використовувати один, що рівний або більший, ніж
      бажаний платіж. Якщо тільки гаманець не може підібрати входи в такий
      спосіб, щоб точно співпасти з бажаним платежем плюс комісійні, гаманець
      потребуватиме згенерувати деяку решту. Це дуже подібне до того, що люди
      роблять з готівкою. Якщо ви завжди використовуєте найбільшу купюру з вашої
      кишені, ви скінчите з повними карманами решти. Якщо ви використовуєте
      тільки роздріб зі решти, у вас залишаться лише крупні купюри. Люди
      підсвідомо знаходять баланс між ціма двома крайнощами, та розробники
      біткоін гаманців намагаються запрограмувати цей баланс.<br>
    </p>
    <p>Підсумовуючи, транзакції пересувають вартість від входів транзакції до
      виходів транзакцій. Вхід посилаєтся на вихід попередньої транзакції,
      показуючи, звідки походить вартість. Вихід транзакції спрямовує вказану
      вартість на адресу нового власника, та може включати решту, що надходить
      назад до попереднього власника.&nbsp; Виходи від однієї транзакції можуть
      бути використані як входи в новій транзакції, таким чином створюючи ланцюг
      з власників, по мірі того, як вартість пересувається від власника до
      власника (дивіться Малюнок 2-4).</p>
    <h3> Загальні форми транзакцій</h3>
    <p> Найбільш загальною формою транзакцій є прості платежі від однієї адреси
      до іншої, що часто включає деяку "решту", що повертається початковому
      власнику. Цей тип транзакцій має один вхід та два виходи, як показано на
      Малюнку&nbsp; 2-5.</p>
    <p> Малюнок 2-5. Найбільш загальна транзакція<br>
    </p>
    <p>Інша загальна форма транзакції є така, що агрегує (збирає) декілька
      входів в один вихід (дивіться Малюнок 2-6). Це представляє еквівалент з
      реального світу розміну груди монет та купюр на одну велику банкноту.
      Транзакції, подібні до цієї, іноді генеруються застосуванням гаманця, щоб
      очистити массу менших сум, що отримані як решти з платежів. <br>
    </p>
    <p>Малюнок 2-6. Транзакція, що збирає фонди<br>
    </p>
    <p>Нарешті, ще одна форма транзакції, що часто можна бачити в реєстрі
      біткоіну, є транзакція, що розпорошує один вхід на багато виходів, що
      представляють багато отримувачів (дивіться Малюнок 2-7). Цей тип
      транзакцій часом використовується комерційними засадами для розподілення
      фондів, таких, як при обробці виплат заробітної платні багатьом
      співробітникам. </p>
    <p>Малюнок 2-7. Транзакція з розпорошення фондів</p>
    <h3> Побудова транзакції</h3>
    <p> Застосування-гаманець Аліси містить всю логіку для вибору відповідних
      входів та виходів, щоб побудувати транзакцію за вимогами Аліси. Алісі
      тільки треба вказати призначення та суму, та загал відбувається в
      застосуванні гаманця, без того, щоб вона бачила деталі. Важливим є те, що
      застосування-гаманець може будувати транзакції, навіть якщо він повністю в
      офлайні. Так само, як написання чеку вдома, та подальше надсилання його до
      банку в конверті, транзакція не має бути сконструйована та підписана, доки
      ви під'єднані до мережі біткоін.</p>
    <h3> Отримання правильних входів</h3>
    <p> Застосування-гаманець Аліси зпочатку має знайти входи, що можуть
      сплатити суму, яку вона бажає надіслати Бобу. Більшість гаманців будуть
      відстежувати всі доступні виходи, що належать адресам, керованим гаманцем.
      таким чином, гаманець буде містити копію виходів транзакцій від транзакції
      Джо, що була утворена через обмін на готівку (дивіться "Отримання ваших
      перших біткоінів"). Застосування гаманця біткоін, яке виконуєтсья як
      повний клієнт, насправді містить копію всіх виходів для кожної транзакції
      в блокчейні. Це дозволяє гаманцю будувати входи транзакцій, так само, як
      швидко перевіряти надходячі транзакції, що вони мають коректні входи.
      Однак, оскільки повний вузол займає багато дискового простору, більшість
      користувачів виконують "легковажні" клієнти, що відстужують тільки власні
      невитрачені виходи користувача. </p>
    <p>Якщо застосування-гаманець не відстежує копію невитрачених виходів
      транзакцій, воно може запитати мережу біткоін, щоб отримати цю інформацію
      з використанням різних API, доступних через різних провайдерів, або через
      запит до повних вузлів, використовуючи виклики програмного
      інтерфейсу(API). Приклад 2-2 показує запит API, побудований як команда
      HTTP GET для специфічного URL. Цей URL поверне всі невитрачені транзакції
      для наданої адреси, надаючи кожному застосуванню інформацію, яка потрібна
      для побудови входів для витрати. Ми використовуємо простий клієнт HTTP
      командного рядка, cURL, для отримання відповіді.<br>
    </p>
    <p>Приклад 2-2. Перегляд всіх невитрачених виходів для біткоін адреси Аліси<br>
    </p>
    <pre>$ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK<br>
      {<br>
      "unspent_outputs":[<br>
      {<br>
      "tx_hash":"186f9f998a5...2836dd734d2804fe65fa35779",<br>
      "tx_index":104810202,<br>
      "tx_output_n": 0,<br>
      "script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",<br>
      "value": 10000000,<br>
      "value_hex": "00989680",<br>
      "confirmations":0<br>
      }<br>
      ]<br>
      }</pre>
    <p> Відповідь в Прикладі 2-2 показує один невитрачений вихід (один, що ще не
      був відчинений), яким володіє адреса Аліси,
      1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK. Відповідь включає посилання на
      транзакцію, що містить цей невитрачений вихід (платіж від Джо), та його
      вартість в сатоші, 10 мільйонів, що дорівнює 0.10 біткоін. Маючи ці
      інформацію, гаманець Аліси може побудувати надсилання цієї вартості на
      адресу нового власника. </p>
    <h3> Перегляд транзакції від Джо до Аліси.</h3>
    <p> Як ви можете бачити, гаманець Аліси містить досить біткоінів в одному
      невитраченому виході, щоб сплатити за каву. Якби це не було так,
      застосування-гаманець Аліси мав би "обшукувати" гору меньших невтрачених
      виходів, як шукаються монети по карманах, докі не знайдеться сума на каву.
      В обох випадках, може виникти потреба отримати щось в решту, як ми
      побачимо в наступних розділах, по мірі того, як застосування-гаманець
      створюватиме виходи транзакції (платежі).<br>
    </p>
    <h3> Створення виходів</h3>
    <p> Виходи транзакції створюються в формі скрипту, що створює перешкоду в
      вигляді значення, та може бути відчинений тільки через надання рішення до
      скрипта. Кажучи простіше, вихід транзакції Аліси буде містити скрипт, що
      каже щось подібне до такого: "Цей вихід може бути сплачений будь-ким, хто
      зможе представити сигнатуру від ключа, що відповідає публічній адресві
      Боба". Оскільки тільки Боб має гаманець з ключами, що відповідають цій
      адресі, тільки гаманець Боба може надати таку сигнатуру, щоб відчинити
      вихід. Аліса, таким чином,"обтяжує" значення виходу вимогою, щоб відкрити
      його за допомогою сигнатури від Боба.</p>
    <p> Ця транзакція також буде містити інший вихід, бо на рахунку Аліси є
      вихід в 0.10 BTC , що забагато грошей за каву вартістю 0.015 BTC. Аліса
      має отримати 0.085 BTC решти. Платіж решти Аліси створюється гаманцем
      Аліси, як вихід до тої самої транзакції, що і платіж до Боба. Загалом
      гаманець поділяє накопичення Аліси на два платежі: один до Боба, та інший
      знову собі. Вона може потім використати (витратити) решту в наступній
      транзакції.</p>
    <p>Нарешті, щоб транзакція була оброблена мережею в прийнятний час, гаманець
      Аліси додасть невеликі комісійні. Їх наочно не видно в транзакції, вони
      розуміються як різниця між входами та виходами. Якщо не брати решту в
      0.085, Аліса створить тільки 0.0845 на другому виході, та залишить "на
      чай" 0.0005 BTC (половину мілі-біткоіну). Вхід в 0.10 BTC не повністю
      витрачений двома виходами, оскільки разом вони складають менше ніж 0.10.
      Отримана різниця є комісійні за транзакцію, що збираєтсья майнером як
      комісійні за валідацію та включення транзакції в блок, що буде записаний в
      блокчейн. </p>
    <p>Результуюча транзакція може бути переглянута переглядачем блокчейну в веб
      застосуванні, як показано на Малюнку&nbsp; 2-8.</p>
    <p> Малюнок 2-8. Транзакція Аліси до Bob’s Cafe<br>
      <br>
      Витратьте час, та перегляньте цю транзакцію Аліси до Bob’s Cafe.</p>
    <h3> Додавання транзакції до реєстру</h3>
    <p> Транзакція, створена гаманцем Аліси, має 258 байтів за розміром, та
      містить все необхідне для підтверження прав власності над фондами, та
      призначення нового власника. Тепер транзакція має бути поширена в мережі
      біткоін, де вона має стати частиною блокчейна. В наступному розділі ми
      побачимо, як транзакція стає частиною нового блоку, та як цей блок
      "видобувається" (майниться). Нарешті, ми побачимо, як цей новий блок, один
      раз доданий до блокчейну, збільшує власну довіру з боку мережі, по мірі
      додавання нових блоків.</p>
    <h3> Передача транзакції</h3>
    <p> Оскільки транзакція містить всю інформацію, необхідну для обробки, не
      має значення, як та коли вона надійде до мережі біткоін. Мережа біткоін є
      мережею сторона-до-сторони, де кожний клієнт біткоін приймає участь через
      під'єднання до декількох інших клієнтів біткоін. Призначенням мережі
      біткоін є розповсюдження (просування) транзакцій та блоків між всіма
      зацікавленими сторонами.</p>
    <h3> Як вона розповсюджується</h3>
    <p>Люба система, така як сервер, десктопне застосування, або гаманець, що
      приймає участь в мережі біткоін, та "розмовляє" по біткоін протоколу,
      називаєтсья вузлом біткоін. Застосування гаманця Аліси може надсилати нові
      транзакції до любого вузла біткоін, до якого воно під'єднане через любе
      з'єднання: дріт, WiFi, мобільний, тощо. Її гаманець біткоін не має бути
      підключений до гаманця біткоін Боба напряму, та вона не має
      використовувати інтернет з'єднання в кафе, хоча ці обоє варіанти також
      можливі. Любий вузол біткоін, що отримує валідну транзакцію, яку він до
      цього не бачив, має безпосередньо передати її всім іншим вузлам, до яких
      він під'єднаний. Ця техніка просування відома як фладінг (наводнення).
      Таким чином, транзакція швидко просувається по двосторонній мережі,
      досягаючи великого відсотка вузлів за декілька секунд. </p>
    <h3> Погляд Боба</h3>
    <p> Якщо застосування гаманця Боба напряму з'єднане з застосуванням гаманця
      Аліси, застосування гаманця Боба може бути першум вузлом, що отримає
      транзакцію. Однак навіть якщо гаманець Аліси надсилає транзакцію через
      ініші вузли. вона досягне гаманця Боба через декілька секунд. Гаманець
      Боба безпосередньо ідентифікує транзакцію Аліси як вхідний платіж,
      оскільки він містить вихід, що декодуєтсья ключами Боба. Застосування
      гаманця Боба також може безпосередньо перевірити, що транзакція гарно
      сформована, використовує попередньо невитрачені входи, та містить
      достатньо комісійних за транзакцію, щоб бути включеною в наступний блок. В
      цій точці Боб може вважати, з невеликим ризиком, що транзакція буде скоро
      включеною в блок та підтвердженою.</p>
    <p> Загальне непорозуміння щодо транзакцій біткоіну є те, що вони мають
      отримати "підтвердження" через очікування 10 хвилин за новим блоком, або
      60 хвилин для повних шести підтверджень. Хоча підтвердження гарантують, що
      транзакція була сприйнята всією мережою, така затримка не є необхідною для
      невеликих сум, таких, як купівля кави. Продавець може прийняти валідну
      транзакцію на невелику суму без підтверджень, з не більшим ризиком, ніж
      платіж кредитною карткою без ID або підпису, які сьогодні приймають всі
      торгівці.</p>
    <h3> Біткоін майнинг</h3>
    <p> Тепер транзакція Аліси розповсюджується мережею біткоін. Вона не стала
      частиною блокчейна, доки вона не перевірена та включена в блок, завдяки
      процесу, що відомий як майнинг. Дивіться Главу 10 щодо детальних пояснень.</p>
    <p>Система довіри біткоін базується на обчисленнях. Транзакції складаються в
      блоки, які потребують неймовірної кількості обчислень, щоб мати доказ
      валідності, але тільки малої кількості для перевірки, що вони валідні.
      Процес майнингу прислуговуєтсья двом цілям в біткоін:</p>
    <p> • Майнінгові вузли перевіряють всі транзакції через правила консенсусу
      біткоіна. Таким чином, майнінг провадить безпеку для транзакцій біткоіна
      через відхиляння невалідних або зловмисних транзакцій.<br>
    </p>
    <p>• Майнінг створює новий біткоін в кожному блоці, майже так, як
      центральний банк друкує нові гроші. Кількість біткоіну, створена в кожному
      блоці, обмежена та зменшується з часом, слідуя за розкладом фіксованого
      випуску. </p>
    <p>Майнинг досягає гарного балансу між вартістю та винагородою. Майнинг
      використовує електрику для вирішення математичної проблеми. Успішний
      майнер буде збирати винагороди в формі нових біткоінів та комісійних від
      транзакцій. Однак збирання нагород буде відбуватись тільки якщо майнер
      буде коректно перевіряти всі транзакцї, що вони відповідають правилам
      консенсусу. Цей нав'язаний баланс провадить безпеку для біткоіна без
      центральної установи. </p>
    <p> Гарним шляхом описати майнинг є гігантська змагальна гра в судоку, що
      скидається кожного разу, коли дехто знаходить рішення, та чия складність
      автоматично підлаштовується, так, щоб дехто знаходив рішення кожні 10
      хвилин. Уявіть гігантську судоку, з декількома тисячами стовбчиків та
      рядків. Якщо я покажу вам готове рішення, ви можете швидко перевірити його
      досить швидко. Але якщо пазл має заповненими декілька клітин, та інше
      порожнє, рішення має зайняти багато роботи! Складність судоку може бути
      налаштована зміною розміру (більше або менше рядків та стовпчиків), але
      вона може бути перевірена досить просто, навіть якщо поле дуже велике.
      "Пазл", що використовується в біткоіні, базуєтся на криптографічному хеші,
      та має подібні характеристики: він асиметрично складний до розв'язання, та
      простий для перевірки, та його складність може бути налаштована.</p>
    <p> Раніше ми познайомились з Джингом, підприємцем з Шанхаю. Джинг побудував
      майнингову ферму, що є бізнесом, де задіяні тисячі спеціалізованих
      майнингових комп'ютерів, що змагаются за винагороду. Кожні 10 хвилин, або
      близько до цього, майнингові комп'ютери Джинга змагаютсья з тисячами
      подібних систем в глобальних перегонагх за пошук рішення для блока
      транзакцій. Пошук такого рішення, так званий доказ виконаної роботи,
      Proof-of-Work (PoW), потребує квадрільйонів операцій в секунду по всій
      мережі біткоін. Алгоритм Proof-of-Work включає постійне хешування
      заголовку блока, та випаадкового числа, за допомогою крипторафічного
      алгоритма SHA256, докі рішення не співпаде з заздалегідь визначеним
      шаблоном. Перший майнер, що знайде таке рішення, виграє раунд, та публікує
      цей блок в блокчейні. </p>
    <p>Джинг почав майнинг в 2010, використовуючи дуже швидкий десктоп для
      пошуку Proof-of-Work для нових блоків. По мірі того, як нові майнери
      почали долучатись до мережі біткоін, складність проблеми швидко зросла.
      Скоро Джинг та інші майнери перейшли на більш скеціалізоване обладнання,
      таке, як високо-потужні графічні карти (GPU), такі, що використовуютьсяв
      ігрових десктопах та консолях. На час написання цього абзацу складність
      стала такою високою, що майнинг залишається прибутковим лише на
      спеціальних інтегрованих пристроях (ASIC), де сотні майнингових алгоритмів
      видруковані в залізі, що роблять паралельно на одному кремнієвому чипі.
      Компанія Джинга також приймає участь в майнинговому пулі, що подібний до
      лотерейного пула, що дозволяє декільком учасникам розділити зусилля та
      винагороду. Компанія Джинга тепер скалає обчислювальний центр, що містить
      тисячі ASIC майнерів для добування біткоіну 24 години на добу. Компанія
      сплачує за електрику, через продаж біткоіну, що генерується від майнингу,
      створюючи деякі надходження від прибутків.</p>
    <h3> Майнинг транзакцій в блоки</h3>
    <p> Нові транзакції постійно надходять до мережі від користувацьких гаманців
      та інших застосувань. По мірі того, як вузли бачать їх, вони додаются до
      тимчасового пулу неверифікованих транзакцій, що підтримуєтся кожним
      вузлом. Коли майнери конструюють новий блок, вони додають неперевірені
      транзакції з цього пулу до нового блоку, та потім намагаются довести
      валідність нового блока за допомогою&nbsp; майнінгового алгоритму
      (Proof-of-Work). Процес майнинга пояснений в Главі 10.</p>
    <p>Транзакції, що додаються до нового блоку, приоритезуються за сплаченими
      комісійними, та декількома іншими критеріями. Кожний майнер починає процес
      майнингу нового блока транзакцй, як тільки він отримує попередній блок з
      мережі, що повідомляє його, що він програв попередній раунд змагання. Він
      зразу ж створює новий блок, заповнює його транзакціями, та ставить мітку
      попереднього блоку, та починає обчислювати доказ виконаної роботи,
      Proof-of-Work, для нового блока. Кожний майнер включає особливу транзакцію
      в свій блок, що сплачує на його власну адресу біткоін винагороду за блок
      (наразі 12.5 новостворених біткоінів), плюс суму з комісійних за всі
      транзакції, включені в блок. Якщо він знаходить рішення, що робить блок
      валідним, він "виграє" винагороду, оскільки його успішний блок додаєтся до
      глобального блокчейну, та транзакція-вианагорода стає витратною. </p>
    <p>Джинг, який приймає участь в майнинговому пулі, встановив своє програмне
      забезпечення, що створює нові блоки, які надсилають винагороду на адресу
      пулу. З цього часу частина винагороди розподіляється на Джинга та інших
      майнерів, пропорційно до кількості роботи, які вони витратили в останньому
      раунді.</p>
    <p> Транзакція Аліси була підхоплена мережею та включена в пул неперевірених
      (неверифікованих) транзакцій. Коли вона була валідована майнинговим
      програмним забезпеченням, вона стає включеною в новий блок, що
      згенерований майнинговим пулом Джинга. Всі майнери, що приймають участь в
      майниновому пулі, безпосередньо починають обчислення Proof-of-Work для
      блока-кандидата. Приблизно через п'ять хвилин, після того, як транзакція
      Аліси була передана гаманцем Аліси, один з ASIC майнерів Джинга знайшов
      рішення для блока-кандидати, та анонсував це в мережі. Коли інші майнери
      перевірили переможний блок, вони починають перегони за генерацію
      наступного блока. </p>
    <p>Переможний блок Джинга стає частиною блокчпейна як блок 277316, та
      містить 420 транзакцій, включаючи транзакцію Аліси. Блок, що містить
      транзакцію Аліси, рахується як одне "підтвердження" цієї транзакції. Ви
      можете бачити блок, що включає транзакцію Аліси.</p>
    <p>Приблизно через 19 зхвилин пізніше новий блок, 277317, видобуваєтсья
      іншим майнером. Оскільки цей блок побудований на основі блоку 277316, що
      містить транзакцію Аліси, він додає навіть більше обчислень до блокчейна,
      таким чином підсилюючи довіру до ціх транзакцій. Кожний блок, побудований
      на тому, що містить транзакцію, разується як додаткове підтвердження для
      транзакції Аліси. По мірі того, як блоки накопичуються один на одному,
      стає експоненціально складнішим відкатити транзакцію, так що вона стає все
      надійнішою з боку зору мережі. </p>
    <p>Діаграма на Малюнку 2-9 показує блок 277316, що містить транзакцію Аліси.
      Нижче є 277,316 блоків (включаючи блок #0), пов'язані один з одним в
      ланцюг блоків (блокчейн), далі і далі до блоку 0, відомий як блок
      творення.</p>
    <p> З часом "висота" блоків збільшується, так само як складність обчислення
      для кожного блока, та ланцюга загалом. Блоки, добуті після того, що
      містить абісину транзакцію, служать для додаткового переконання, бо вони
      грунтуються на все більших обчисленнях, в все більшому ланцюгу. За
      домовленостю, кожний блок, що має більше ніж шість підтверджень,
      розглядаєтся як неспростовний, оскільки він потребує неможливої кількості
      обчислень для відкликання та переобчислення шести блоків. Ми будемо
      вивчати процес майнінгу, та те, як він побудовує довіру, більш детально в
      Главі 10.</p>
    <p> Малюнок 2-9. Транзакція Аліси, включена в блок #277316</p>
    <h3> Витрата транзакції</h3>
    <p> Тепер, коли транзакція Аліси була вбудована в блокчейн як частина блоку,
      вона стала частиною розподіленого реєстру біткоіна, та видимою для всіх
      застосувань біткоіна. Кожний клієнт біткоіна може незалежно перевірити
      транзакцію, як валідну та витратну. Повні клієтни можуть відстежити
      джерело фондів від моменту, коли біткоін був зпочатку згенерований в
      блоці, поступово, від транзакції до транзакції, доки вони не досягнуть
      адреси Боба. Легковажні клієнти можуть зробити те, що називаєтся спрощеною
      верифікацією платежів (дивіться Спрощена верифікація платежів, SPV), через
      підтвердження, що транзакція знаходиться в блокчейні, та має декілька
      блоків після цього, таким чином провадячи доказ, що майнери сприйняли її
      як валідну.</p>
    <p> Тепер Боб може витрачати вихід від цієї, та інших, транзакцій.
      Наприклад, Боб може сплатити контрактору або постачальнику, передавши
      вартість від платежу Аліси за каву цім новим володарям. Більш вірогідно,
      програмне забезпечення Боба буде збирати багато малих платежів в більший
      платіж, можливо, концентруючи всі щоденні надходження біткоіну в одну
      транзакцію. Таким чином можна зібрати всі різні платежі в один вихід (на
      одну адресу). Щодо діаграми агрегуючої транзакції дивіться Малюнок 2-6.</p>
    <p> Коли Боб витрачає платежі, отримані від Аліси та інших клієнтів, він
      продовжує ланцюг з транзакцій. Давайте вважати, що Боб сплачує своєму веб
      дизайнеру Гопешу з Банглора за нову сторінку веб сайту. Тепер ланцюг з
      транзакцій буде виглядати як Малюнок 2-10.<br>
    </p>
    <p>Малюнок 2-10. Транзакція Аліси як частина ланцюга транзакцій від Джо до
      Гопеша<br>
    </p>
    <p>В цій главі ми побачили, як транзакції будують ланцюг, що пересуває
      вартість від власника до власника. Ми також прослідили транзакцію Аліси,
      від моменту, коли вона була створена в її гаманці, по мережі біткоін, та
      до майнерів, які записали її в блокчейн. Далі в цій книзі ми будемо
      досліджувати специфічні технології, що стоять за гаманцями, сигнатурами,
      транзакціями, мережею, та, нарешті, майнингом.<br>
    </p>
    <h2>ГЛАВА 3</h2>
    <h1> Bitcoin Core: референсний дизайн</h1>
    <h3> Реалізація</h3>
    <p> Біткоін є проектом з вікритим кодом, та доступний під відкритою
      ліцензією (MIT), вільний до завантаження та для використання в любих
      цілях. Вікритий джерельний код означає більше, ніж просто вільне
      використання. Це також означає, що біткоін розроблений відкритою
      спільнотою волонтерів. З початку ці волонтери складались тільки з Satoshi
      Nakamoto. В 2016мц році первинний код біткоін мав більше ніж 400
      контриб'ютерів з майже дюжиною розробників, що працювали над кодом майже
      повний час, та набагато більше, що працювали на неповному часі. Будь-хто
      може докластись до створення коду, включаючи вас!</p>
    <p> Коли біткоін був створений Satoshi Nakamoto, програмне забезпечення було
      насправді завершене перед тим, як був створений опис, наданий в Додатку A.
      Satoshi бажав переконатись, що воно робить, перед тим, як писати про
      нього. Ця перша реалізація, відома як “Bitcoin” або “клієнт Satoshi”, була
      значно модифікована та покращена. Вона еволюціонувала в те, що зараз
      відоме як Bitcoin Core, щоб відрізіняти її від інших сумісних реалізацій.
      Bitcoin Core є референсною реалізацією системи біткоіну, що означає, що
      вона є авторитетним посиланням на кожну частину цієї технології, та як
      вона має бути реалізована. Bitcoin Core реалізує всі аспекти біткоіну,
      включаючи гаманець, рушій транзакцій та валідації блоків, та повний
      мережевий вузол в двосторонній мережі біткоін.</p>
    <p> Не зважаючи на факт, що Bitcoin Core включає референсну реалізацію
      гаманця, це не призначено для використання в якості промислового гаманця
      для користувачів або для застосувань. Розробникам застосувань радиться
      будувати гаманці з використанням сучасних стандартів, таких, як BIP-39 та
      BIP-32 (дивіться “Мнемонічні кодові слова (BIP-39)” та “HD <br>
      гаманці (BIP-32/BIP-44)”). BIP означає Bitcoin Improvement Proposal.</p>
    <p><span class="fontstyle0">Малюнок 3-1. Архитектура Bitcoin Core (Джерело:
        Eric Lombrozo)<br>
      </span></p>
    <h3><span class="fontstyle2">Оточення розробки біткоін</span></h3>
    <h3><span class="fontstyle2"></span></h3>
    <p><span class="fontstyle3">Якщо ви розробник, ви маєте бажати встановити
        оточення розробки, з усіма інструментами, бібліотеками та підтримуючим
        програмним забезпеченням для написання програм біткоін. В цій дуже
        технічній главі ми крок за кроком пройдемо цей процес. Якщо матеріал
        стане дуже щільним (та ви насправді не налаштовуєте оточення для
        розробки), почувайтесь вільним пропустити залишок до наступної статті,
        що є менш технічною.<br>
      </span></p>
    <h4><span class="fontstyle2">Компілювання Bitcoin Core з початкового коду</span></h4>
    <h3><span class="fontstyle2"></span></h3>
    <p><span class="fontstyle3">Джерельний код Bitcoin Core може бути
        завантажений як архів ZIP, або клонуванням репозиторія коду з GitHub. На
      </span><span class="fontstyle3" style="color:rgb(153,0,0);">GitHub
        сторінці біткоін</span><span class="fontstyle3">, оберіть </span>Download
      ZIP з бокового меню. Альтернативно, використовуйте командний рядок та git
      для створення локлаьної копії джерельного коду в вашій системі. </p>
    <p>В багатьох прикладах в цій главі ми будемо використовувати інтерфейс
      командного рядка операційної системи (також відомий як “оболонка”), до
      якого відбувається доступ через застосування “терміналу”. Оболонка буде
      відображувати підказку; ви набираєте команду, та оболонка буде відповідати
      деяким текстом та новою підказкою для вашої нової команди. Підказка може
      виглядати інакше для вашої системи, але в наступних прикладах вона буде
      позначатись як символ $. В ціх прикладах, коли ви бачите текст після
      символа $, не друкуйте символ $, але друкуйте команду, що слідує за цім
      символом, потім тисніть Enter для виконання команди. В прикладах, під
      рядками кожної команди розташовані відповіді операційної системи на цю
      команду. Коли ви бачите наступний префікс $, ви будете знати, що це інша
      команда, та ви продовжуєте обробку.<br>
    </p>
    <p>В цьому прикладі ми використовуємо команду git для створення локальної
      копії (“клону”) джерельного коду:</p>
    <pre>      $ <b>git clone https://github.com/bitcoin/bitcoin.git</b><br>
      Cloning into 'bitcoin'...<br>
      remote: Counting objects: 66193, done.<br>
      remote: Total 66193 (delta 0), reused 0 (delta 0), pack-reused 66193<br>
      Receiving objects: 100% (66193/66193), 63.39 MiB | 574.00 KiB/s, done.<br>
      Resolving deltas: 100% (48395/48395), done.<br>
      Checking connectivity... done.<br>
      $</pre>
    <p> Git є найбільш широко використованої розподіленої системи контролю
      версій, однієї з основних інструментів розробника програмних застосувань.
      Вам може знадобитись встановити команду git, або графічний користувацький
      інтерфейс для git, в вашій операційній системі, якщо ви ще не маєте його.</p>
    <p>Коли команда клонування git завершиться, ви матимете повну локальну копію
      джерельного коду репозитарія в каталозі bitcoin. Перейдіть в цей каталог,
      набравши наступну камонду в відповідь на підказку:</p>
    <pre>      $ <b>cd bitcoin</b></pre>
    <h3> Вибір релізу Bitcoin Core</h3>
    <p> По замовчанню, локальна копія буде синхронізована з найбільш новим
      кодом, що може бути нестабільною або бета версією біткоіна. Перед
      компіляцією кода можна обрати іншу версію через вибір тегу релізу. Це
      дасть можливість локальну копію з окремим станом репозитарію коду, що
      ідентифікуєтсья ключовим тегом. Теги використовуються розробниками, щоб
      відмітити особливі релізи коду через номери версій<span class="fontstyle0">.
        Зпершу, знайдіть всі теги, використовуючи команду </span><span class="fontstyle2"><b>git
          tag</b></span><span class="fontstyle0">:<br>
      </span></p>
    <pre><span class="fontstyle2" style="font-size:9pt;">$ <b>git tag</b></span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.1.5</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.1.6test1</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.10.0</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">...</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.11.2</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.11.2rc1</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.12.0rc1</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">v0.12.0rc2</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">...</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;"></span></pre>
    <p><span class="fontstyle0">Перелік тегів показує всі релізи версій біткоін.
        За домовленостю реліз-кандидати, що призначені для тестування, мають
        суфікс </span><span class="fontstyle0">“rc”. Стабільні релізи, що
        можуть виконуватись на промислових системах, не мають суфіксу. З
        попереднього списку, оберіть найвищу версію релізу, що на час написання
        була v0.11.2. Щоб синхронизувати локальний код з цією версіює,
        використавуйте команду </span><b><span class="fontstyle2">git checkout</span></b><span
        class="fontstyle0">:<br>
      </span></p>
    <pre><span class="fontstyle2" style="font-size:9pt;">$ <b>git checkout v0.11.2</b></span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">HEAD is now at 7e27892... Merge pull request #6975</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;"></span></pre>
    <p><span class="fontstyle0">Ви можете підтвердити, що ви маєте бажану версію
        “відміченою”, через команду </span><b><span class="fontstyle2">git
          status</span></b><span class="fontstyle0">:<br>
      </span></p>
    <pre><span class="fontstyle2" style="font-size:9pt;">$ <b>git status</b></span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">HEAD detached at v0.11.2</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;">nothing to commit, working directory clean</span></pre>
    <pre><span class="fontstyle2" style="font-size:9pt;"></span></pre>
    <h3><span class="fontstyle4">Конфігурація побудови Bitcoin Core</span></h3>
    <h3><span class="fontstyle4"></span></h3>
    <p><span class="fontstyle0">Первинний код містить документацію, що може бути
        знайдена в декількох файлах. Огляд головної документації розміщений в </span><span
        class="fontstyle3">README.md </span><span class="fontstyle0">в
        директорії </span><span class="fontstyle3">bitcoin, який можна
        передивитись, набравши </span><span class="fontstyle5"><b>more
          README.md</b> </span><span class="fontstyle0">на підказку, та
        використовуючи клавішу проміжку для пересування на наступну сторінку. В
        цій главі ми побудуємо клієнт біткоін командного рядка, також відомий як
      </span><span class="fontstyle2">bitcoind, на</span><span class="fontstyle0">
        Linux. Передивіться інструкції щодо компіляції клієнта командного рядка
      </span><span class="fontstyle2">bitcoind на вашій платформі, набравши </span><b><span
          class="fontstyle0"></span><span class="fontstyle5">more
          doc/build-unix.md</span></b><span class="fontstyle0">. Альтернативні
        інструкції для macOS та Windows можуть бути ззнайдені в директорії </span><span
        class="fontstyle3">doc</span><span class="fontstyle0">, як </span><span
        class="fontstyle3">build-osx.md або </span><span class="fontstyle3">build-windows.md</span><span
        class="fontstyle0">, відповідно.</span></p>
    <p><span class="fontstyle0">Уважно передивіться передумови побудови, що є
        першою частиною документації. Ці бібліотеки мають бути присутні в
        системі, перед тим, як ви почнете будувати біткоін. Якщо ці передумови
        відсутні, процес побудови схибить з помилкою. Якщо це трапиться через
        те, що ви випустили передумову, ви можете встановити її, та потім
        продовжити процес побудови, там, де ви його лишили. Вважаючи, що ви
        встановили передумови, ви починаєте процес побудови, генеруючи скрипти,
        через використання скрипту </span><b><span class="fontstyle3">autogen.sh</span></b><span
        class="fontstyle0">.</span> </p>
    <p><span class="fontstyle0">Процес побудови Bitcoin Core були змінені, що
        використовувати систему autogen/configure/make, починаючи з версії 0.9.
        Старіші версії використовували простий Makefile, та роблять трохи інакше
        від наступного приклада. Наступні інструкції для версій, що ви будете
        компілювати. Введені autogen/configure/make, що з'явились в версії 0.9,
        здається будуть використовуватись для всіх майбутніх версій кода, та ця
        система демонструється в наступних прикладах.<br>
      </span></p>
    <pre><span class="fontstyle2">$ <b>./autogen.sh</b></span></pre>
    <pre><span class="fontstyle2">...</span></pre>
    <pre><span class="fontstyle2">glibtoolize: copying file 'build-aux/m4/libtool.m4'</span></pre>
    <pre><span class="fontstyle2">glibtoolize: copying file 'build-aux/m4/ltoptions.m4'</span></pre>
    <pre><span class="fontstyle2">glibtoolize: copying file 'build-aux/m4/ltsugar.m4'</span></pre>
    <pre><span class="fontstyle2">glibtoolize: copying file 'build-aux/m4/ltversion.m4'</span></pre>
    <pre><span class="fontstyle2">...</span></pre>
    <pre><span class="fontstyle2">configure.ac:10: installing 'build-aux/compile'</span></pre>
    <pre><span class="fontstyle2">configure.ac:5: installing 'build-aux/config.guess'</span></pre>
    <pre><span class="fontstyle2">configure.ac:5: installing 'build-aux/config.sub'</span></pre>
    <pre><span class="fontstyle2">configure.ac:9: installing 'build-aux/install-sh'</span></pre>
    <pre><span class="fontstyle2">configure.ac:9: installing 'build-aux/missing'</span></pre>
    <pre><span class="fontstyle2">Makefile.am: installing 'build-aux/depcomp'</span></pre>
    <pre><span class="fontstyle2">...</span></pre>
    <pre><span class="fontstyle2"></span></pre>
    <p><span class="fontstyle0" style="font-size:11pt;">Скрипт </span><span class="fontstyle3">autogen.sh
        </span><span class="fontstyle0" style="font-size:11pt;">створює набір
        автоматичних скриптів конфігурації, що будуть досліджувати вашу систему,
        щоб винайти коректні налаштування, та переконатись, що присутні всі
        потрібні бібліотеки для компіляції коду. Найбільш важливим з них є
        скрипт </span><b><span class="fontstyle2" style="font-size:10pt;">configure</span></b><span
        class="fontstyle0" style="font-size:11pt;">, що пропонує декілька різних
        опцій, щоб налаштувати процес побудови.</span><br>
      <span class="fontstyle0" style="font-size:11pt;"></span></p>
    <span class="fontstyle0" style="font-size:11pt;">Наберіть </span><span class="fontstyle4"><b>./configure
        --help</b> щоб побачити різні опції</span><span class="fontstyle0" style="font-size:11pt;">:<br>
    </span>
    <pre><span class="fontstyle2">$ <b>./configure --help</b></span></pre>
    <pre><span class="fontstyle2"></span></pre>
    <pre><span class="fontstyle2">`configure' configures Bitcoin Core 0.11.2 to adapt to many kinds of systems.</span></pre>
    <pre><span class="fontstyle2">Usage: ./configure [OPTION]... [VAR=VALUE]...</span></pre>
    <pre><span class="fontstyle2">...</span></pre>
    <pre><span class="fontstyle2">Optional Features:</span></pre>
    <pre><span class="fontstyle2">--disable-option-checking ignore unrecognized --enable/--with options</span></pre>
    <pre><span class="fontstyle2">--disable-FEATURE do not include FEATURE (same as --enable-FEATURE=no)</span></pre>
    <pre><span class="fontstyle2">--enable-FEATURE[=ARG] include FEATURE [ARG=yes]</span></pre>
    <pre><span class="fontstyle2">--enable-wallet enable wallet (default is yes)</span></pre>
    <pre><span class="fontstyle2">--with-gui[=no|qt4|qt5|auto]</span></pre>
    <pre><span class="fontstyle2">...</span></pre>
    <pre><span class="fontstyle2"></span></pre>
    <p><span class="fontstyle0" style="font-size:11pt;">Скрипт </span><b><span
          class="fontstyle2" style="font-size:10pt;">configure </span></b><span
        class="fontstyle0" style="font-size:11pt;">дозволяє вам ввімкнути або
        вимкнути певні можливості </span><b><span class="fontstyle2" style="font-size:10pt;">bitcoind
          </span></b><span class="fontstyle0" style="font-size:11pt;">через
        використання флагів </span><span class="fontstyle2" style="font-size:10pt;"><b>--enable-FEATURE</b>
      </span><span class="fontstyle0" style="font-size:11pt;">та </span><b><span
          class="fontstyle2" style="font-size:10pt;">--disable-FEATURE</span></b><span
        class="fontstyle0" style="font-size:11pt;">, де </span><span class="fontstyle2"
        style="font-size:10pt;">FEATURE </span><span class="fontstyle0" style="font-size:11pt;">замінюється
        на назву можливості, як зазначено в виводі допомоги. В цій главі ми
        будемо будувати клієнт </span><span class="fontstyle2" style="font-size:10pt;"><b>bitcoind</b>
      </span><span class="fontstyle0" style="font-size:11pt;">з усіма
        налаштуваннями по замовчанню. Ми не користуємось</span> флагами
      конфігурації, але ви повинні переглядати їх, щоб розуміти, які опціональні
      частини є частиною клієнта. Якщо ви знаходитесь в академічному середовищу,
      обмеження комп'ютерної лабораторії можуть вимагати від вас встановлювати
      застосування в вашу домашню директорію (використовуючи <b> --prefix=$HOME</b>).</p>
    <p> Ось деякі корисні опеції, що перекривають поведінку по замовчанню
      скрипта конфігурації:<br>
    </p>
    <p><b>--prefix=$HOME</b> Це перекриває місце інсталяції по замовчанню
      (/usr/local/) для результуючого виконавчого файлу. Використовуйте $HOME,
      щоб розмістит все в домашній директорії, або по іншому шляху.</p>
    <p> <b>--disable-wallet</b> Це використовується для відключення реалізації
      референсного гаманця.</p>
    <p> <b>--with-incompatible-bdb</b> Якщо ви будуєте гаманець, дозволяє
      використовувати несумісної версії бібліотеки Berkeley DB.</p>
    <p><b>--with-gui=no</b> Не будувати графічний інтерфейс користувача, що
      потребує бібліотеку Qt. Це будує тільки сервер та біткоін командного
      рядка. </p>
    <p> Далі виконайте скрипт конфігурації, щоб автоматично визначити всі
      потрібні бібліотеки, та створити власний скрипт побудови для вашої
      системи:</p>
    <pre>      $ <b>./configure</b></pre>
    <pre>      checking build system type... x86_64-unknown-linux-gnu</pre>
    <pre>      checking host system type... x86_64-unknown-linux-gnu</pre>
    <pre>      checking for a BSD-compatible install... /usr/bin/install -c</pre>
    <pre>      checking whether build environment is sane... yes</pre>
    <pre>      checking for a thread-safe mkdir -p... /bin/mkdir -p</pre>
    <pre>      checking for gawk... gawk</pre>
    <pre>      checking whether make sets $(MAKE)... yes</pre>
    <pre>      ...</pre>
    <pre>      [many pages of configuration tests follow]</pre>
    <pre>      ...</pre>
    <pre>      $</pre>
    <p> Якщо все піде гарно, команда конфігурації завершиться створенням
      власного скрипта побудови, що дозволить нам побудувати bitcoind. Якщо є
      відсутні бібліотеки або помилки, команда конфігурації завершиться з
      помилкою, замість створення скриптів побудови. В разі виникнення помилки
      це станеться найбільш всього через відсутню або несумісну бібліотеку.
      Передивіться документацію з побудови, та переконайтесь, що ви встановили
      відсутні передумови. Потім знову виконайте конфігурацію, та подивіться, чи
      це вирішило помилку.</p>
    <pre>      rpcuser=bitcoinrpc</pre>
    <pre>      rpcpassword=CHANGE_THIS</pre>
    <pre>      Example 3-2 shows a resource-constrained node running on a smaller server.</pre>
    <pre>      Example 3-2. Sample configuration of a resource-constrained system</pre>
    <pre>      alertnotify=myemailscript.sh "Alert: %s"</pre>
    <pre>      maxconnections=15</pre>
    <pre>      prune=5000</pre>
    <pre>      minrelaytxfee=0.0001</pre>
    <pre>      maxmempool=200</pre>
    <pre>      maxreceivebuffer=2500</pre>
    <pre>      maxsendbuffer=500</pre>
    <pre>      rpcuser=bitcoinrpc</pre>
    <pre>      rpcpassword=CHANGE_THIS</pre>
    <p> Коли ви відрадегували файл конфігурації, та встановили опції, що
      найкраще представляють ваші потреби, ви можете протестувати bitcoind в цій
      конфігурації. Виконайте Bitcoin Core з опцією printtoconsole, щоб виконати
      його в фоні з виводом в консоль:</p>
    <pre>      $ <b>bitcoind -printtoconsole</b></pre>
    <pre>      Bitcoin version v0.11.20.0</pre>
    <pre>      Using OpenSSL version OpenSSL 1.0.2e 3 Dec 2015</pre>
    <pre>      Startup time: 2015-01-02 19:56:17</pre>
    <pre>      Using data directory /tmp/bitcoin</pre>
    <pre>      Using config file /tmp/bitcoin/bitcoin.conf</pre>
    <pre>      Using at most 125 connections (275 file descriptors available)</pre>
    <pre>      Using 2 threads for script verification</pre>
    <pre>      scheduler thread start</pre>
    <pre>      HTTP: creating work queue of depth 16</pre>
    <pre>      No rpcpassword set - using random cookie authentication</pre>
    <pre>      Generated RPC authentication cookie /tmp/bitcoin/.cookie</pre>
    <pre>      HTTP: starting 4 worker threads</pre>
    <pre>      Bound to [::]:8333</pre>
    <pre>      Bound to 0.0.0.0:8333</pre>
    <pre>      Cache configuration:</pre>
    <pre>      * Using 2.0MiB for block index database</pre>
    <pre>      * Using 32.5MiB for chain state database</pre>
    <pre>      * Using 65.5MiB for in-memory UTXO set</pre>
    <pre>      init message: Loading block index...</pre>
    <pre>      Opening LevelDB in /tmp/bitcoin/blocks/index</pre>
    <pre>      Opened LevelDB successfully</pre>
    <pre>      [... more startup messages ...]</pre>
    <p> Ви можете натиснути Ctrl-C для переривання процесу, коли ви будете
      задоволені, потрібні налаштування завантажені, та все робить як ви
      очікували. Щоб виконати Bitcoin Core в фоні як процес, запустіть його з
      опцією daemon</p>
    <pre>bitcoind -daemon</pre>
    Щоб відстежувати перебіг та статус вашого вузла біткоін, використовуйте
    команду bitcoin-cli getinfo:
    <pre>      $ <b>bitcoin-cli getinfo</b></pre>
    <pre>      {</pre>
    <pre>      }</pre>
    <pre>      "version" : 110200,</pre>
    <pre>      "protocolversion" : 70002,</pre>
    <pre>      "blocks" : 396328,</pre>
    <pre>      "timeoffset" : 0,</pre>
    <pre>      "connections" : 15,</pre>
    <pre>      "proxy" : "",</pre>
    <pre>      "difficulty" : 120033340651.23696899,</pre>
    <pre>      "testnet" : false,</pre>
    <pre>      "relayfee" : 0.00010000,</pre>
    <pre>      "errors" : ""</pre>
    <p> Це показує, що вузол виконує Bitcoin Core версії 0.11.2, з висотою
      блокчейна 396328 блоків, та 15 активних мережевих з'єднань.</p>
    <p> Коли ви будете задоволені опціями конфігурації, які ви обрали, ви маєте
      додати біткоін до скриптів запуску в вашій операційній системі, так що він
      буде постійно виконуватись та рестартувати, коли рестартує операційна
      система. Ви знайдете декілька скриптів запуску для різних операційних
      систем в contrib/init серед джерельного коду біткоіна, та файл README.md
      показують, які операційні системи використовують які скрипти.</p>
    <h3> Програмний інтерфейс застосування Bitcoin Core API</h3>
    <p> Клієнт Bitcoin Core реалізує інтерфейс JSON-RPC, до якого можна отримати
      доступ через допоміжну програму командного рядка, bitcoin-cli. Командний
      рядок дозволяє нам інтерактивно експериментувати з можливостями, що також
      доступні програмно через API. Щоб почати, викличте команду допомоги, щоб
      побачити список доступних команд біткоін RPC:</p>
    <pre>      $ <b>bitcoin-cli help</b></pre>
    <pre>      addmultisigaddress nrequired ["key",...] ( "account" )</pre>
    <pre>      addnode "node" "add|remove|onetry"</pre>
    <pre>      backupwallet "destination"</pre>
    <pre>      createmultisig nrequired ["key",...]</pre>
    <pre>      createrawtransaction [{"txid":"id","vout":n},...] {"address":amount,...}</pre>
    <pre>      decoderawtransaction "hexstring"</pre>
    <pre>      ...</pre>
    <pre>      ...</pre>
    <pre>      verifymessage "bitcoinaddress" "signature" "message"</pre>
    <pre>      walletlock</pre>
    <pre>      walletpassphrase "passphrase" timeout</pre>
    <pre>      walletpassphrasechange "oldpassphrase" "newpassphrase"</pre>
    <p> Кожна з ціх команд може сприймати декілька параметрів. Щоб отримати
      додаткову допомогу, детальний опис, та інформацію щодо параметрів, додайте
      назву команди після <b>help</b>. Наприклад, щоб побачити допомогу щодо
      команди <b>getblockhash</b> RPC:</p>
    <pre>      $ <b>bitcoin-cli help getblockhash</b></pre>
    <pre>      getblockhash index</pre>
    <pre> Returns hash of block in best-block-chain at index provided.<br>
      Arguments:<br>
      1. index<br>
      (numeric, required) The block index<br>
      Result:<br>
      "hash"<br>
      (string) The block hash<br>
      Examples:<br>
      &gt; bitcoin-cli getblockhash 1000<br>
      &gt; curl --user myusername --data-binary '{"jsonrpc": "1.0",
      "id":"curltest",<br>
      "method": "getblockhash", "params": [1000] }' -H 'content-type:
      text/plain;'<br>
      http://127.0.0.1:8332/<br>
    </pre>
    <p>В кінці інформації допомоги ви можете бачити два приклада команд RPC,
      використовуючи допоміжник bitcoin-cli, або клієнт HTTP curl. Ці приклади
      демонструють, як ви можете викликати команду. Скопіюйте перший приклад та
      побачите результат:</p>
    <pre>      $ <b>bitcoin-cli getblockhash 1000</b></pre>
    <pre>      00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09</pre>
    <p> Результом є хеш блоку, що описаний більш детально в наступних главах.
      Але зараз ця команда повинна повертати той самий результат на вашій
      системі, демонструючи, що ваш вузол Bitcoin Core робить, сприймаючи
      команди, та має інформацію про блок 1000, що повертається вам. В наступних
      розділах ми продемонструємо деякі дуже корисні RPC команди, та їх
      очікувані результати.</p>
    <h3> Отримання інформації щодо статусу клієнта Bitcoin Core</h3>
    <h4> Команда: getinfo</h4>
    <p> Команда біткоін RPC <b>getinfo</b> відображує базову інформацію щодо
      статусу мережевого вузла біткоін, гаманця та бази даних блокчейну.
      Використовуйте <b>bitcoin-cli</b> для її виконання:</p>
    <pre>      $ <b>bitcoin-cli getinfo</b></pre>
    <pre>      {</pre>
    <pre>      "version" : 110200,</pre>
    <pre>      "protocolversion" : 70002,</pre>
    <pre>      }</pre>
    <pre>      "blocks" : 396367,</pre>
    <pre>      "timeoffset" : 0,</pre>
    <pre>      "connections" : 15,</pre>
    <pre>      "proxy" : "",</pre>
    <pre>      "difficulty" : 120033340651.23696899,</pre>
    <pre>      "testnet" : false,</pre>
    <pre>      "relayfee" : 0.00010000,</pre>
    <pre>      "errors" : ""</pre>
    <p> Отримані дані повертаються в JavaScript Object Notation (JSON), форматі,
      що може бути просто “спожитий” всіма мовами програмування, але також є
      читаємий людиною. Крім цього, ми бачимо номери версій програми-клієнта
      біткоін (110200) та протокола біткоін (70002). Ми бачимо поточну висоту
      блока, показуючи нам, як багато блоків відомі клієнту (396367). Також ми
      бачимо різну статистику щодо мережі біткоін, та налаштування, що мають
      відношення до клієнта.</p>
    <p> Це займе деякий час, можливо більше ніж один день, докі клієнт
      “наздожене” поточну висоту блокчейну, бо йому треба завантажити всі блоки
      з інших клієнтів біткоіну. Ви можете перевірити прогрес, використовуючи <b>getinfo</b>,
      щоб побачити число відомих блоків. </p>
    <h3> Дослідження та декодування транзакцій</h3>
    <h4> Команди: getrawtransaction, decoderawtransaction</h4>
    <p> Коли Аліса придбала каву в Bob’s Cafe на початку книги, її транзакція
      була записана в блокчейні з ID транзакції (txid)
      0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2. Давайте
      використаємо API для отримання та дослідження цієї транзакції, передаючи
      ID транзакції в якості параметра:</p>
    <pre>      $ <b>bitcoin-cli getrawtransaction</b>
      <b>0627052b6f28912f2703066a912ea577f2ce4da4caa5a↵</b></pre>
    <pre>      5fbd8a57286c345c2f2</pre>
    <pre>0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000↵</pre>
    <pre>000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4↵</pre>
    <pre>ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813014↵</pre>
    <pre>10484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc54123363767↵</pre>
    <pre>89d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff0260e3160000000↵</pre>
    <pre>0001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9↵</pre>
    <pre>      147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000000</pre>
    <p> <br>
      ID транзакції непевне до того, як вона буде підтвердженою. Відсутність
      хеша транзакції в блокчейні не означає, що транзакція не оброблена. Це
      відоме як “піддатливість транзакції”, оскільки хеші транзакції можуть бути
      змінені до підтвердження блоку. Після підтвердження txid є незмінним та
      певним.</p>
    <p>Команда <b>getrawtransaction</b> повертає серіалізовану транзакцію в
      шістнадцятеричній нотації. Щоб декодувати її ми використовуємо команду <b>decoderawtransaction</b>,
      передаючи шістнадцятирічні дані як параметр. Ви можете копіювати дані,
      повернуті від <b>getrawtransaction</b>, та вставити їх як параметр до <b>decoderawtransaction</b>:</p>
    <pre>      $ <b>bitcoin-cli decoderawtransaction</b>
      <b>0100000001186f9f998a5aa6f048e51dd8419a14d8↵</b></pre>
    <pre>a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba474↵</pre>
    <pre>6ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298↵</pre>
    <pre>cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fd↵</pre>
    <pre>e0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa↵</pre>
    <pre>336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5↵</pre>
    <pre>d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8↵</pre>
    <pre>      88ac00000000</pre>
    <pre>      {</pre>
    <pre>      "txid":
      "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",</pre>
    <pre>      "size": 258,</pre>
    <pre>      "version": 1,</pre>
    <pre>      "locktime": 0,</pre>
    <pre>      "vin": [</pre>
    <pre>      {</pre>
    <pre>      "txid": "7957a35fe64f80d234d76d83a2...8149a41d81de548f0a65a8a999f6f18",</pre>
    <pre>      "vout": 0,</pre>
    <pre>      "scriptSig": {</pre>
    <pre>      "asm":"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1decc...",</pre>
    <pre>      "hex":"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1de..."</pre>
    <pre>      },</pre>
    <pre>      "sequence": 4294967295</pre>
    <pre>      }</pre>
    <pre>      ],</pre>
    <pre>      "vout": [</pre>
    <pre>      {</pre>
    <pre>      "value": 0.01500000,</pre>
    <pre>      "n": 0,</pre>
    <pre>      "scriptPubKey": {</pre>
    <pre>      "asm": "OP_DUP OP_HASH160 ab68...5f654e7 OP_EQUALVERIFY OP_CHECKSIG",</pre>
    <pre>      "hex": "76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",</pre>
    <pre>      "reqSigs": 1,</pre>
    <pre>      "type": "pubkeyhash",</pre>
    <pre>      "addresses": [</pre>
    <pre>      "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"</pre>
    <pre>      ]</pre>
    <pre>      }</pre>
    <pre>      },</pre>
    <pre>      {</pre>
    <pre>      "value": 0.08450000,</pre>
    <pre>      "n": 1,</pre>
    <pre>      "scriptPubKey": {</pre>
    <pre>      "asm": "OP_DUP OP_HASH160 7f9b1a...025a8 OP_EQUALVERIFY OP_CHECKSIG",</pre>
    <pre>      "hex": "76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",</pre>
    <pre>      "reqSigs": 1,</pre>
    <pre>      "type": "pubkeyhash",</pre>
    <pre>      "addresses": [</pre>
    <pre>      "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK"</pre>
    <pre>      ]</pre>
    <pre>      }</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <pre>      }</pre>
    <p> Команда <b>transaction decode</b> показує всі компоненти транзакції,
      включаючи входи та виходи транзакції. В цьому випадку ми бачимо, що
      транзакція поповнила нову адресу на 15 мілібіт, використовувала один вхід,
      та згенерувала два виходи. Входом до цієї транзакції був вихід від
      попередньо підтвердженої транзакції (показаної як <b>vin txid</b>, що
      починається з 7957a35fe). Два виходи відповідають 15 мілібітному кредиту
      (оплаті) та виходу зі рештою назад до надсилача.<br>
    </p>
    <p>Ми будемо далі вивчати блокчейн через перевірку попередніх транзакцій,
      посилаючись на їх <b>txid</b> в цій транзакції, використовуючи ті самі
      команди(<b>getrawtransaction</b>). Перестрибуючи від транзакції до
      транзакції ми можемо відслідкувати ланцюжок назад, по мірі того, як монети
      переходили від однієї адреси до іншої.</p>
    <h3> Дослідження блоків</h3>
    <h4> Команди: getblock, getblockhash</h4>
    <p> Дослідження блоку подібне до дослідження транзакцій. Однак, на блоки
      можна посилатись або по висоті блоку, або по його хешу. З початку давайте
      знайдемо блок за його висотою. Раніше ми бачили, що транзакція Аліси була
      вбудована в блок номер 277316. Ми використовуємо команду <b>getblockhash</b>,
      що приймає висоту блоку як параметр, та повертає хеш для цього блоку:</p>
    <pre>      $ <b>bitcoin-cli getblockhash 277316</b></pre>
    <pre>      0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4</pre>
    <p> Тепер, коли ми знаємо, в який блок включена транзакція Аліси, ми можемо
      отримати цей блок. Ми використовуємо команду <b>getblock</b> з хешем
      блока в якості параметра:</p>
    <pre>      $ <b>bitcoin-cli getblock</b>
      <b>0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b3↵</b></pre>
    <pre>      1b2cc7bdc4</pre>
    <pre>      {</pre>
    <pre>      "hash":
      "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",</pre>
    <pre>      "confirmations": 37371,</pre>
    <pre>      "size": 218629,</pre>
    <pre>      "height": 277316,</pre>
    <pre>      "version": 2,</pre>
    <pre>      "merkleroot":</pre>
    <pre>      "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",</pre>
    <pre>      "tx": [</pre>
    <pre>      "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",</pre>
    <pre>      "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",</pre>
    <pre>      "04905ff987ddd4cfe603b03cfb7ca50ee81d89d1f8f5f265c38f763eea4a21fd",</pre>
    <pre>      "32467aab5d04f51940075055c2f20bbd1195727c961431bf0aff8443f9710f81",</pre>
    <pre>      "561c5216944e21fa29dd12aaa1a45e3397f9c0d888359cb05e1f79fe73da37bd",</pre>
    <pre>      [... hundreds of transactions ...]</pre>
    <pre>      "78b300b2a1d2d9449b58db7bc71c3884d6e0579617e0da4991b9734cef7ab23a",</pre>
    <pre>      "6c87130ec283ab4c2c493b190c20de4b28ff3caf72d16ffa1ce3e96f2069aca9",</pre>
    <pre>      "6f423dbc3636ef193fd8898dfdf7621dcade1bbe509e963ffbff91f696d81a62",</pre>
    <pre>      "802ba8b2adabc5796a9471f25b02ae6aeee2439c679a5c33c4bbcee97e081196",</pre>
    <pre>      "eaaf6a048588d9ad4d1c092539bd571dd8af30635c152a3b0e8b611e67d1a1af",</pre>
    <pre>      "e67abc6bd5e2cac169821afc51b207127f42b92a841e976f9b752157879ba8bd",</pre>
    <pre>      "d38985a6a1bfd35037cb7776b2dc86797abbb7a06630f5d03df2785d50d5a2ac",</pre>
    <pre>      "45ea0a3f6016d2bb90ab92c34a7aac9767671a8a84b9bcce6c019e60197c134b",</pre>
    <pre>      "c098445d748ced5f178ef2ff96f2758cbec9eb32cb0fc65db313bcac1d3bc98f"</pre>
    <pre>      ],</pre>
    <pre>      "time": 1388185914,</pre>
    <pre>      "mediantime": 1388183675,</pre>
    <pre>      "nonce": 924591752,</pre>
    <pre>      "bits": "1903a30c",</pre>
    <pre>      "difficulty": 1180923195.258026,</pre>
    <pre>      "chainwork":</pre>
    <pre>      "000000000000000000000000000000000000000000000934695e92aaf53afa1a",</pre>
    <pre>      "previousblockhash":</pre>
    <pre>      "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",</pre>
    <pre>      "nextblockhash":</pre>
    <pre>      "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"</pre>
    <pre>      }</pre>
    <p>Блок містить 419 транзакцій та серед них платіж за каву Аліси має номер
      64th (0627052b...). Входження висоти каже нам, що це 277316-й блок в
      блокчейні.</p>
    <h3> Використання програмного інтерфейсу Bitcoin Core</h3>
    <p> Допоміжник bitcoin-cli є дуже корисним для дослідження Bitcoin Core API
      та для тестування функцій. Але загальний смисл програмного інтерфейсу
      застосування є доступ до функцій програмно. В цьому розділі ми
      продемонструємо доступ до Bitcoin Core з іншої програми. </p>
    <p> Bitcoin Core API є інтерфейсом JSON-RPC. JSON означає JavaScript Object
      Notation (об'єктна нотація JavaScript), та це є дуже зручним способом
      представляти дані, які одночасно гарно читаютсья людиною та програмами.
      RPC означає Remote Procedure Call (віддалений виклик процедур), що
      означає, що ми виклакаємо процедури (функції), що віддалені від нас (на
      вузлі Bitcoin Core) через мережевий протокол. В цьому випадку мережевим
      протоколом є HTTP або HTTPS (для зашифрованих з'єднань).<br>
    </p>
    <p>Коли ви використовували команду bitcoin-cli, щоб отримати допомогу про
      іншу команду, нам показувався приклад використання <b>curl</b>, швидкий
      клієнт HTTP командного рядка, що констурює один з ціх викликів JSON-RPC:</p>
    <pre>      $ <b>curl --user myusername --data-binary</b> '{"jsonrpc": "1.0",
      "id":"curltest", "method": "getinfo", "params": [] }' -H 'content-type: text/plain;'
      http://127.0.0.1:8332/</pre>
    <p> Ця команда показує, що curl надсилає запит HTTP до локального хосту
      (127.0.0.1), під'єднуючись до порту біткоін по замовчанню (8332), та
      надсилаючизапит jsonrpc для метода getinfo, використовуючи кодування
      text/plain. Якщо ви реалізуєте виклик JSON-RPC в вашій власній програмі,
      ви можете використовувати базову бібліотеку HTTP для побудови виклику,
      подібно до того, що показаний в попередньому прикладі curl.<br>
    </p>
    <p>Однак, існують бібліотеки майже у усіх мовах програмування, що
      "огортають" Bitcoin Core API в такий спосіб, що робить виклики значно
      простішими. Ми буде використовувати бібліотеку python-bitcoinlib для
      спрощення доступу до API. Пам'ятайте, що це потребує мати діючий екземпляр
      Bitcoin Core, що буде використовуватись для виконання викликів JSON-RPC.
      Скрипт на Python в Прикладі 3-3 робить простий виклик getinfo, та друкує
      параметри блоків з даних, що повертаються Bitcoin Core.<br>
    </p>
    <p>Приклад 3-3. Виконання getinfo чеерз Bitcoin Core JSON-RPC API від
      bitcoin.rpc </p>
    <pre>      import RawProxy</pre>
    <pre>      # Створюємо з'єднання до локального вузла Bitcoin Core<br>
      p = RawProxy()<br>
      # Виконуємо команду getinfo, зберігаємо результат даних в info<br>
      info = p.getinfo()<br>
      # Отримання елементу 'blocks' з info<br>
      print(info['blocks'])<br>
      <br>
      $ <b>python rpc_example.py</b><br>
      394075<br>
    </pre>
    <p>Це каже нам, що наш локальний вузол Bitcoin Core має 394075 блоків в
      блокчейні. Не дуже яскравий результат, але він демонструє базове
      використання бібліотеки як спрощеного інтерфейсу до Bitcoin Core JSON-RPC
      API.</p>
    <p> Далі давайте використаємо виклики <b>getrawtransaction</b> та <b>decodetransaction</b>
      для отримання деталей щодо платежу Аліси. В прикладі 3-4 ми отрумуємо
      транзакцію Аліси та перелічуємо виходи транзакції. Для кожного виходу ми
      показуємо адресу отримувача, та суму переказу. Нагадуємо, що транзакція
      Аліси має один вихід як платіж до Bob’s Cafe, та один вихід для отримання
      решти Алісою.</p>
    <p> Приклад 3-4. Отримання транзакції та сканування виходів від bitcoin.rpc
    </p>
    <pre><span style="font-family: serif;">	   </span>import RawProxy</pre>
    <pre>      p = RawProxy()<br>
      # ID транзакції Аліси<br>
      txid = "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2"<br>
      # З початку отримуємо сиру транзакцію в hex<br>
      raw_tx = p.getrawtransaction(txid)<br>
      # Декодуємо транзакцію з hex в об'єкт JSON<br>
      decoded_tx = p.decoderawtransaction(raw_tx)<br>
      # Отримуємо кожний з виходів від транзакції<br>
      for output in decoded_tx['vout']:<br>
      print(output['scriptPubKey']['addresses'], output['value'])<br>      <br>
      $ <b>python rpc_transaction.py</b><br>
      ([u'1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA'], Decimal('0.01500000'))<br>
      ([u'1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK'], Decimal('0.08450000'))<br>
    </pre>
    <p>Обоє з попередніх прикладів досить прості. Насправді вам не треба
      програма, щоб виконати їх, ви можете лише скористатись допоміжником
      bitcoin-cli. Наступний приклад, однак, потребує декількох сотен викликів
      RPC, та більш прозоро демонструє використання програмного інтерфейсу. В
      Прикладі 3-5, ми з початку отримуємо блок 277316, потім отримуємо кожну з
      419 транзакцій в ньому, через посилання на ID кожної транзакції. Далі ми
      ітеруємо по кожному з виходів транзакцій, та додаємо їх значення.<br>
    </p>
    <p>Приклад 3-5. Отримання блоку та додавання всіх виходів його транзакцій
      від bitcoin.rpc </p>
    <pre>&nbsp;&nbsp;&nbsp; &nbsp; import RawProxy</pre>
    <pre>      p = RawProxy()</pre>
    <pre>      # Висота блоку, де зберігаєтся транзакція Аліси</pre>
    <pre>      blockheight = 277316</pre>
    <pre>      # Отримання хешу блоку з висотою 277316</pre>
    <pre>      blockhash = p.getblockhash(blockheight)</pre>
    <pre>      # Отримання блоку за хешем</pre>
    <pre>      block = p.getblock(blockhash)</pre>
    <pre>      # Елемент tx містить список ID всіх транзакцій в блоці</pre>
    <pre>      transactions = block['tx']</pre>
    <pre>      block_value = 0</pre>
    <pre>      # Ітеруємо по кожній з транзакцій в блоці за їх ID</pre>
    <pre>      for txid in transactions:</pre>
    <pre>      	tx_value = 0</pre>
    <pre>      # Отримуємо ситу транзакцію за ID</pre>
    <pre>      	raw_tx = p.getrawtransaction(txid)</pre>
    <pre>      # Декодуємо транзакцію</pre>
    <pre>      	decoded_tx = p.decoderawtransaction(raw_tx)</pre>
    <pre>      # Ітеруємо по кожному виходу в транзакції</pre>
    <pre>      	for output in decoded_tx['vout']:</pre>
    <pre>      # Додаємо суму кожного виходу</pre>
    <pre>      		tx_value = tx_value + output['value']</pre>
    <pre>      # Додаємо суму цієї тразакції до загалу</pre>
    <pre>      	block_value = block_value + tx_value</pre>
    <pre>      print("Total value in block: ", block_value)</pre>
    <pre>      $ <b>python rpc_block.py</b></pre>
    <pre>      ('Total value in block: ', Decimal('10322.07722534'))</pre>
    <p> Код нашого прикладу обчислює залальну вартість, передану в блоці, що
      вона складає 10322.07722534 BTC (включаючи винагороду 25 BTC та 0.0909 BTC
      комісійних). Порівняйте це з сумою, що повідомляє дослідник блоків на
      деякому сайті, виконавши пошук хешу блока, або його висоту. Деякі
      дослідники блоків повідомляють загальну суму, за виключенням винагороди та
      за виключенням комісійних. Побачино, чи помітите ви різницю.</p>
    <h3> Альтернативні клієнти, бібліотеки та тулкіти</h3>
    <p> Існує багато альтернативних клієнтів, бібліотек, булкітів та навіть
      реалізацій повного вузла в екосистемі біткоіну. Вони реалізовані в різних
      програмних мовах, та пропонують природні програмні інтерфейси на улюблених
      мовах.<br>
      <br>
      Насутпний розділ перераховує деякі з ціх бібліотек, клієнтів та тулкітів,
      впорядкованих за мовами програмування.<br>
    </p>
    <p><b>C/C++</b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </p>
    <p>Bitcoin Core&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Референсна реалізація біткоін<br>
      libbitcoin&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; Між-платформений тулкіт розробника на C++, вузол та
      бібліотека консенсусу<br>
      bitcoin explorer&nbsp;&nbsp;&nbsp; &nbsp; Інструмент командного рядка
      Libbitcoin<br>
      picocoin&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp; Легковажна C клієнтська бібліотека для біткоіна
      від Jeff Garzik<br>
    </p>
    <p><b>JavaScript</b><br>
    </p>
    <p>bcoin&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Модулярна та
      маштабована реалізація повного вузла з API<br>
      Bitcore&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Повний вузол, API, та
      бібліотека від Bitpay<br>
      BitcoinJS&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Чиста бібліотека JavaScript Bitcoin для
      node.js та переглядача<br>
    </p>
    <p><b>Java</b><br>
    </p>
    <p>bitcoinj&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Бібліотека повного
      клієнтського вузла на Java<br>
      Bits of Proof (BOP)&nbsp;&nbsp;&nbsp; Реалізація біткоін рівня
      підприємства на Java<br>
    </p>
    <p><b>Python</b><br>
    </p>
    <p>python-bitcoinlib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Бібліотека біткоін на
      Python, бібліотека консенсусу, та вузол від Peter Todd<br>
      pycoin&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Бібліотека біткоін на Python
      від Richard Kiss<br>
      pybitcointools&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Бібліотека
      біткоін на Python від Vitalik Buterin<br>
      <br>
      <b>Ruby&nbsp;&nbsp;&nbsp; </b>bitcoin-client&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp; Бібліотека на Ruby, огортка до JSON-RPC API<br>
    </p>
    <p><b>Go&nbsp;&nbsp;&nbsp; </b>&nbsp;&nbsp;&nbsp; btcd&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Клієнт повного вузла на мові Go<br>
    </p>
    <p><b>Rust</b>&nbsp;&nbsp;&nbsp; rust-bitcoin&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Бібліотека на Rust для
      серіалізації, розбору та викликів API<br>
    </p>
    <p><b>C#</b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; NBitcoin&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Вичерпна
      бібліотека біткоін для фреймворку .NET</p>
    <p> <b>Objective-C&nbsp;</b> CoreBitcoin&nbsp; Тулкіт біткоін для ObjC та
      Swift<br>
    </p>
    <p>Існує багато інших бібліотек на багатьох інших мовах програмування, та
      багато створюються весь час.<br>
    </p>
    <h2>ГЛАВА 4</h2>
    <h1>Ключі та адреси</h1>
    <p> Мабуть ви чули, що біткоін базується на криптографії, що є галуззю
      математики, що інтенсивно використовується в комп'ютерній безпеці.
      Криптографія з грецької означає “потаємне письмо”, але наука криптографії
      опанувала більше ніж тільки утаємнення письмен, що відоме як шифрування.
      Криптографія також може бути використана для надання знання щодо секрету
      без викриття секрету (цифрового підпису), або провадження аутентифічності
      даних (цифровий підпис). Ці типи криптографічних доказів є математичними
      інструментами, критичними для біткоіна, та екстенсивно використовуються в
      застосуваннях біткоіну.</p>
    <p> Досить іронічним виглядає те, що шифрування не є важливою частиною
      біткоіну, бо його комунікації та дані транзакцій не зашифровані, та не
      мають шифруватись для захисту капіталу. В цій главі ми введемо деяку
      криптографію, що використовується в біткоіні для контролю за власністю над
      фондами, в формі ключів, адрес та гаманців.</p>
    <h3> Вступ</h3>
    <p> Власність біткоіну встановлюється через цифрові ключі, адреси біткоіну
      та цифрові сигнатури. Цифрові ключі несправді не зберігаються в мережі,
      та, замість цього, створюються та зберігаються користувачем в файлі або
      простій базі даних, що називається гаманцем. Цифрові ключі в гаманці
      користувача повністю незалежні від протоколу біткоін, та можуть бути
      згенеровані та підтримувані програмою користувацького гаманця, без
      посилань на блокчейн або підключення до інтернету. Ключі забезпечують
      багато з цікавих властивостей біткоін, включаючи децентралізовану довіру
      та контроль, атестацію власності, а також модель безпеки на базі
      криптографічних доказів.</p>
    <p> Більшість з транзакцій біткоін потребує валідний цифровий підпис, щоб
      бути включеним до блокчейну, що може бути згенерований тільки з секретного
      ключа. Таким чином, будь-хто з копією ключа має контроль над біткоіном.
      Цифрова сигнатура (підпис), яка використовується для витрати накопичень,
      також відома як доказ, в термінах криптографії. Дані доказу в транзакції
      біткоін перевіряє вірність щодо власності на фонди, що наразі
      витрачаються.<br>
    </p>
    <p> Ключі находять парами, що складаються з приватного (секретного) ключа,
      та публічного ключа. Думайте про публічний ключ подібно до номера разунку,
      на про приватний ключ подібно до секретного PIN, або секрету на чеку, що
      надає контроль над рахунком. Ці цифрові ключі дуже рідко видимі до
      користувачів біткоін. В більшості випадків вони зберігаються в файлі
      гаманця, та керуються програмою гаманця біткоін.</p>
    <p>В розділі платежу транзакції біткоін, публічний ключ представлний своїм
      цифровим відтиском, що має назву адреси біткоін, що використовується в той
      самий спосіб, що і ім'я отримувача на чеку (“Сплачено на користь”). В
      більшості випадків адреса біткоіну генерується на основі, та відповідає
      публічному ключеві. Однак не всі адреси біткоін представляють адреси
      біткоін, вони також можуть представляти інших бенефіціарів, таких, як
      скрипти, як ми побачимо пізніше в цій главі. Таким чином, адреси біткоіну
      абстрагують отримувача фондів, роблячі визначення транзакції гнучкими,
      подібно до паперових чеків: єдиний інструмент платежів, що може бути
      використаний для платежів на персональні рахунки, розрахунків з
      компаніями, платежів по рахунках та виплати в готівці. Адреса біткоіну є
      тільки репрезентацією ключів, що побачать користувачі, оскільки ця частина
      є єдино потрібною, що вони мають поділяти з усім світом. </p>
    <p> З початку ми будемо вводити криптографію та пояснимо математику, що
      використовується в біткоін. Далі ми подивимось на те, як генеруються
      ключі, як вони зберігаються та обробляються. Ми будемо переглядати різні
      формати кодування, що використовуються для представлення приватних та
      публічних ключів, адрес, та адрес скриптів. Нарешті, ми подивимось на
      просунуте використання ключів та адрес: марні адреси, мульти сигнатуру,
      скриптові адреси та паперові гаманці. </p>
    <h3> Криптографія публічних ключів та крипто валюти</h3>
    <p> Криптографія публічних клюічів була вперше введена в 1970х, та є
      математичною фундацією для комп'ютерної та інформаційної безпеки. </p>
    <p> З часу появи криптографії публічних ключів були винайдені декілька
      відповідних математичних функцій, таких, як генерація простих чисел та
      множення еліптичної кривої. Ці математичні функції є практично
      незворотними, що значить, що вони прості для обчислення в одному напрямку,
      та практично нездійснені для обчислення в зворотньому напрямку. Базуючись
      на математичних функціях, криптографія дозволяє створення цифрових
      секретів та непідробних цифрових підписів. Біткоін використовує множення
      еліптичної кривої як основу для криптографії.</p>
    <p> В біткоіні ми використовуємо криптографію публічного ключа для створення
      пари ключів, що контролюють доступ до біткоіну. Пара ключів складається з
      приватного ключа, та походячого від нього унікального публічного ключа.
      Публічний ключ використовується для отримання фондів, та приватний ключ
      використовуєтсья для підписування транзакцій для витрачення фондів.</p>
    <p>Існує математичне відношення між публічним та приватним ключем, що
      дозволяє використання приватного ключа для генерації сигнатур до
      повідомлень. Ця сигнатура може бути перевірена з приватним ключем, без
      викриття приватного ключа. <br>
    </p>
    <p>При витрачанні біткоіну поточний власник представляє публічний ключ та
      сигнатуру (кожний раз іншу, але що походить від того ж самого публічного
      ключа) в транзакції, щоб витратити ці біткоіни. Презентуючі ці публічний
      ключ та сигнатуру, кожний в мережі біткоін може перевірити та прийняти
      транзакцію як валідну, підтверджуючи що особа, що переводить біткоін,
      володіє єю на час трансферу. В більшості реалізацій гаманця приватний та
      публічний ключі зберігаються разом, як пара ключів, в цілях зручності.
      Однак публічний ключ може бути обчислений від приватного ключа, так що
      можливе зберігання тільки приватного ключа.</p>
    <h3> Приватні та публічні ключі</h3>
    <p> Гаманець біткоін містить колекцію пар ключів, кожна складається в
      приватного ключа та публічного ключа. Приватний ключ (k) є числом, що
      зазвичай обирається випадково. Від приватного ключа, ми використовуємо
      множення еліптичної кривої, однобічну криптографічну функцію, щоб
      згенерувати публічний ключ (K). Від публічного ключа (K) ми використовуємо
      однобічну криптографію, хеш функцію, щоб згенерувати біткоін адресу (A). В
      цьому розділі ми почнемо генерувати приватний ключ, подивимось на
      математику елептичної кривої, що використовується для перехід до
      публічного ключа, та, нарешті, генерування біткоін адреси від публічного
      ключа. Відношення між приватним ключем, публічним ключем, та адресою
      біткоін, показана на Малюнку 4-1.</p>
    <p><br>
      Малюнок 4-1. Приватний ключ, публічний ключ, та адреса біткоін</p>
    <h3> Чому треба використовувати асиметричну криптографію (публічні/приватні
      ключі)?</h3>
    <p> Чому в біткоін використовується асиметрична криптографія? Вона не
      використовується для “шифрування” (створення секрету) транзакції. Скоріше,
      корисною важливостю асиметричної криптографії є здатність для генерування
      цифрових сигнатур (підписів). Ця сигнатура може бути вироблена тільки
      деким, хто має знання щодо приватного ключа. Однак будь-хто з доступом до
      публічного ключа та відтиском транзкації може використовувати їх для
      перевірки підпису. Ця корисна властивість асиметричної криптографії робить
      можливим для будь-кого перевіряти кожну сигнатуру кожної транзакції, при
      цьому гарантуючи, що тільки власники приватних ключів можуть спродукувати
      валідний підпис.<br>
    </p>
    <h3> Приватні ключі</h3>
    <p> Приватний ключ - це лише число, обране випадково. Власність та контроль
      над приватним ключем є коренем контролю користувача над всіма фондами,
      асоційованими з відповідними адресами біткоін. Приватний ключ має
      залишатись секретним весь час, оскільки викриття його третій стороні
      еквівалентно наданню їм контролю над біткоінами, що захищені цім ключем.
      Приватний ключ має також бути зкопійований та захищений від випадкової
      втрати, оскільки його неможливо відновити, та фонди, які він захищав,
      також будуть невідворотньо втрачені назавжди, .</p>
    <p>Приватний ключ біткоіна є лише числом. Ви можете обрати ваш приватний
      ключ випадково, використовуючи лише монету, олівець та папір: киньте
      монету 256 разів, та ви отримаєте двоїчні цифри випадкового приватного
      ключа, що ви можете використовувати як приватний ключ. Публічний ключ
      потім може бути згенерований з приватного ключа.</p>
    <h3> Генерація приватного ключа з випадкового числа</h3>
    <p> Перший, та найбільш важливий крок в генеруванні ключа, є пошук джерела
      ентропії, або випадковості. Створення ключа це просто те ж саме що
      “Оберіть число від 1 до 2<sup>256</sup>.” Точний метод, що ви
      використовуєте для отримання цього числа, не має значення, до тих пір,
      доки він непередбачуваний або повторюваний. Програма біткоіну використовує
      генератори операційної системи, на якій робить, щоб спродукувати 256 біт
      ентропії (випадковості). Зазвичай, генератор випадкових чисел операційної
      системи ініціалізується через людське джерело випадковості, та ось чому
      вас можуть запросити випадково порухати мишею протягом декількох секунд.</p>
    <p> Більш точно кажучи, приватний ключ може бути любим числом між 1 та n -
      1, де n є константою (n = 1.158 * 10<sup>77</sup>, трохи менше ніж 2<sup>256</sup>),
      визначений як порядок еліптичної кривої, що використовується в біткоіні
      (дивіться пояснення в “Криптографія еліптичної кривої”). Щоб створити
      такий ключ, ми випадково обираємо 256-бітне число, та перевіряємо, чи воно
      меньшим, ніж n - 1. В термінах програмування це звичано досягається через
      подачу довшого рядка випадкових біт, отриманих від криптографічно
      безпечного джерела випадковості, до хеш алгоритму SHA256, який дуже зручно
      спродукує 256-бітне число. Якщо результат менший за n - 1, ми маємо
      підходящий приватний ключ. Інакше ми просто продовжуємо ще раз з іншим
      випадковим числом.<br>
    </p>
    <p>Не пишіть власний код для створення випадкового числа, або не
      використовуйте "простий" генератор випадкових чисел, що надається вашою
      мовою програмування. Використовуйте криптографічно безпечний генератор
      псевдовипадкових чисел (CSPRNG) з зерном від джерела з достатньою
      ентропією. Вивчайте документацію бібліотеки генерації випадкових чисел, що
      ви обираєте, щоб переконатись, що вона криптографічно безпечна. Коректна
      реалізація CSPRNG є критичною для безпеки ключів.</p>
    <p> Наступний випадково згенерований приватний ключ (k) показаний в HEX
      форматі (256 біт показані як 64 шістнадцятирічні цифри, кожна з 4 біт):</p>
    <pre>      1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</pre>
    <p> Розмір простору приватних ключів біткоін (2<sup>256</sup>) є неуявно
      великим числом. Це близько 10<sup>77</sup> в десятичнй системі. Для
      порівняння, досяжний нам всевіт за розрахунками містить 10<sup>80</sup>
      атомів. Щоб згенерувати новий ключ за допомогою клієнта Bitcoin Core
      (дивіться Главу 3), використовуйте команду <b>getnewaddress</b>.
      З причин безпеки, вона показує тільки публічний ключ, але не приватний.
      Щоб змусити <b>bitcoind</b> показати приватний ключ, використовуйте
      команду <b>dumpprivkey</b>. Вона покаже приватний ключ в форматі Base58
      checksum-encoded, що називаєтся Wallet Import Format (WIF), що ми
      дослідимо більш детально в “Формати приватних ключів”. Ось приклад
      генерації та відображення приватного ключа за допомогою ціх двох команд:</p>
    <pre>      $ <b>bitcoin-cli getnewaddress</b></pre>
    <pre>      1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</pre>
    <pre>      $ <b>bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</b></pre>
    <pre>      KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</pre>
    <p> Команда <b>dumpprivkey</b> відкриває гаманець, та виділяє приватний
      ключ, що був згенерований командою <b>getnewaddress</b>. Неможливо для <b>bitcoind</b>
      узнати приватний ключ від публічного ключа, якщо вони обоє не зберігаються
      в гаманці. Команда <b>dumpprivkey</b> не генерує приватний ключ з
      публічного ключа, бо це неможливо. Команда просто отримує приватний ключ,
      що вже відомий гаманцеві, та що був згенерований командою <b>getnewaddress</b>.<br>
    </p>
    <p>Також ви можете використовувати інструмент командного рядка Bitcoin
      Explorer (дивіться Додаток G) для генерації та показу приватних ключів за
      допомогою команд <b>seed</b>, <b>ec-new</b>, та <b>ec-to-wif</b>:</p>
    <pre>      $ bx seed | bx ec-new | bx ec-to-wif</pre>
    <pre>      5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</pre>
    <h3> Публічні ключі</h3>
    <p> Публічні ключі генеруються з приватних ключів з використанням множення
      еліптичної кривої, що є незворотною дією : K = k * G, де k є приватним
      ключем, та G є сталою точкою, що називається точкою генератора, та K є
      результуючим публічним ключем. Зворотня операція, відома як "пошук
      дискретного логаріфму", обчислення k при відомому K, так само складна, як
      спробувати всі можливі значення k, тобто як брутальний перебір. Перед
      демонстрацією того, як згенерувати публічний ключ з приватного, давайте
      подивимось на криптографію еліптичної кривої трохі більш детально.</p>
    <p> Множення еліптичної кривої є різновидом функцій, що в криптографії
      називають функціями-пастками: їх легко виконати в одному напрямку
      (множення), та неможливо виконати в зворотньому напрямку (ділення).
      Власник приватного ключа може просто створити публічний ключ, та потім
      поширити його усім світом, знаючи, що ніхто не зможе обернути функцію, та
      обчислити приватний ключ від публічного ключа. Цей математичний трюк стає
      основою для несхибних та безпечних цифрових сигнатур (підписів), що
      доводять власність фондів біткоін.</p>
    <h3> Криптонрафія еліптичної кривої, пояснення</h3>
    <p> Криптографія еліптичної кривої є типом асиметричної, або криптографії
      публічного ключа, що базується на проблемі дискретного логарифму, який
      виразений через додавання та множення точок еліптичної кривої.</p>
    <p> Малюнок&nbsp; 4-2 є прикладом еліптичної кривої, подібно до тої, що
      використовується в біткоіні.<br>
    </p>
    <p>Малюнок&nbsp; 4-2. An elliptic curve<br>
    </p>
    <p>Bitcoin uses a specific elliptic curve and set of mathematical constants,
      as defined in a<br>
      standard called secp256k1, established by the National Institute of
      Standards and<br>
      Technology (NIST). The secp256k1 curve is defined by the following
      function, which<br>
      produces an elliptic curve:</p>
    <pre>      y2 = x3 + 7 over � p</pre>
    <p> or</p>
    <pre>      y2 mod p = x3 + 7 mod p</pre>
    <p> The mod p (modulo prime number p) indicates that this curve is over a
      finite field of<br>
      prime order p, also written as � p, where p = 2256 – 232 – 29 – 28 – 27 –
      26 – 24 – 1, a very<br>
      large prime number.</p>
    <p> Because this curve is defined over a finite field of prime order instead
      of over the real<br>
      numbers, it looks like a pattern of dots scattered in two dimensions,
      which makes it<br>
      difficult to visualize. However, the math is identical to that of an
      elliptic curve over<br>
      real numbers. As an example, Малюнок&nbsp; 4-3 shows the same elliptic
      curve over a much<br>
      smaller finite field of prime order 17, showing a pattern of dots on a
      grid. The<br>
      secp256k1 bitcoin elliptic curve can be thought of as a much more complex
      pattern<br>
      of dots on a unfathomably large grid.<br>
      Малюнок&nbsp; 4-3. Elliptic curve cryptography: visualizing an elliptic
      curve over F(p), with p=17<br>
    </p>
    <p><br>
      So, for example, the following is a point P with coordinates (x,y) that is
      a point on the<br>
      secp256k1 curve:</p>
    <pre>      P =</pre>
    <pre>(55066263022277343669578718895168534326250603453777594175500187360389116729240,</pre>
    <pre>32670510020758816978083085130507043184471273380659243275938904335757337482424)</pre>
    <pre>      Example 4-1 shows how you can check this yourself using Python:</pre>
    <pre>      Example 4-1. Using Python to confirm that this point is on the elliptic
      curve</pre>
    <pre>      Python 3.4.0 (default, Mar 30 2014, 19:23:13)</pre>
    <pre>      [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin</pre>
    <pre>      Type "help", "copyright", "credits" or "license" for more information.</pre>
    <pre>      &gt;&gt;&gt; p =</pre>
    <pre>115792089237316195423570985008687907853269984665640564039457584007908834671663</pre>
    <pre>      &gt;&gt;&gt; x =</pre>
    <pre>55066263022277343669578718895168534326250603453777594175500187360389116729240</pre>
    <pre>      &gt;&gt;&gt; y =</pre>
    <pre>32670510020758816978083085130507043184471273380659243275938904335757337482424</pre>
    <pre>      &gt;&gt;&gt; (x ** 3 + 7 - y**2) % p</pre>
    <pre>      0</pre>
    <p> In elliptic curve math, there is a point called the “point at infinity,”
      which roughly cor‐<br>
      responds to the role of zero in addition. On computers, it’s sometimes
      represented by<br>
      x = y = 0 (which doesn’t satisfy the elliptic curve equation, but it’s an
      easy separate<br>
      case that can be checked).</p>
    <p> There is also a + operator, called “addition,” which has some properties
      similar to the<br>
      traditional addition of real numbers that gradeschool children learn.
      Given two<br>
      points P1 and P2 on the elliptic curve, there is a third point P3 = P1 +
      P2, also on the<br>
      elliptic curve.</p>
    <p> Geometrically, this third point P3 is calculated by drawing a line
      between P1 and P2.<br>
      This line will intersect the elliptic curve in exactly one additional
      place. Call this point<br>
      P3' = (x, y). Then reflect in the x-axis to get P3 = (x, –y).<br>
      There are a couple of special cases that explain the need for the “point
      at infinity.”<br>
      If P1 and P2 are the same point, the line “between” P1 and P2 should
      extend to be the<br>
      tangent on the curve at this point P1. This tangent will intersect the
      curve in exactly<br>
      one new point. You can use techniques from calculus to determine the slope
      of the<br>
      tangent line. These techniques curiously work, even though we are
      restricting our<br>
      interest to points on the curve with two integer coordinates!<br>
      In some cases (i.e., if P1 and P2 have the same x values but different y
      values), the tan‐<br>
      gent line will be exactly vertical, in which case P3 = “point at
      infinity.”<br>
      <br>
      If P1 is the “point at infinity,” then P1 + P2 = P2. Similarly, if P2 is
      the point at infinity,<br>
      then P1 + P2 = P1. This shows how the point at infinity plays the role of
      zero.<br>
      It turns out that + is associative, which means that (A + B) + C = A + (B
      + C). That<br>
      means we can write A + B + C without parentheses and without ambiguity.<br>
      Now that we have defined addition, we can define multiplication in the
      standard way<br>
      that extends addition. For a point P on the elliptic curve, if k is a
      whole number, then<br>
      kP = P + P + P + ... + P (k times). Note that k is sometimes confusingly
      called an<br>
      “exponent” in this case.</p>
    <h3> Generating a Public Key</h3>
    <p> Starting with a private key in the form of a randomly generated number
      k, we multi‐<br>
      ply it by a predetermined point on the curve called the generator point G
      to produce<br>
      another point somewhere else on the curve, which is the corresponding
      public key K.<br>
      The generator point is specified as part of the secp256k1 standard and is
      always the<br>
      same for all keys in bitcoin:</p>
    <pre>      K = k * G</pre>
    <p> where k is the private key, G is the generator point, and K is the
      resulting public key, a<br>
      point on the curve. Because the generator point is always the same for all
      bitcoin<br>
      users, a private key k multiplied with G will always result in the same
      public key K.<br>
      The relationship between k and K is fixed, but can only be calculated in
      one direction,<br>
      from k to K. That’s why a bitcoin address (derived from K) can be shared
      with anyone<br>
      and does not reveal the user’s private key (k).</p>
    <p> A private key can be converted into a public key, but a public key<br>
      cannot be converted back into a private key because the math only<br>
      works one way.</p>
    <p> Implementing the elliptic curve multiplication, we take the private key
      k generated<br>
      previously and multiply it with the generator point G to find the public
      key K:<br>
      K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G<br>
      Public key K is defined as a point K = (x,y):<br>
      K = (x, y)<br>
      where,<br>
      x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A<br>
      y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB<br>
      <br>
      To visualize multiplication of a point with an integer, we will use the
      simpler elliptic<br>
      curve over real numbers—remember, the math is the same. Our goal is to
      find the<br>
      multiple kG of the generator point G, which is the same as adding G to
      itself, k times<br>
      in a row. In elliptic curves, adding a point to itself is the equivalent
      of drawing a tan‐<br>
      gent line on the point and finding where it intersects the curve again,
      then reflecting<br>
      that point on the x-axis.</p>
    <p> Малюнок&nbsp; 4-4 shows the process for deriving G, 2G, 4G, as a
      geometric operation on the<br>
      curve.</p>
    <p> Most bitcoin implementations use the OpenSSL cryptographic<br>
      library to do the elliptic curve math. For example, to derive the<br>
      public key, the function EC_POINT_mul() is used.<br>
      Малюнок&nbsp; 4-4. Elliptic curve cryptography: visualizing the
      multiplication of a point G by an<br>
      integer k on an elliptic curve</p>
    <h3> Bitcoin Addresses</h3>
    <p> A bitcoin address is a string of digits and characters that can be
      shared with anyone<br>
      who wants to send you money. Addresses produced from public keys consist
      of a<br>
      string of numbers and letters, beginning with the digit “1.” Here’s an
      example of a bit‐<br>
      coin address:</p>
    <pre>      1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</pre>
    <p> The bitcoin address is what appears most commonly in a transaction as
      the “recipi‐<br>
      ent” of the funds. If we compare a bitcoin transaction to a paper check,
      the bitcoin<br>
      address is the beneficiary, which is what we write on the line after “Pay
      to the order<br>
      of.” On a paper check, that beneficiary can sometimes be the name of a
      bank account<br>
      holder, but can also include corporations, institutions, or even cash.
      Because paper<br>
      checks do not need to specify an account, but rather use an abstract name
      as the<br>
      recipient of funds, they are very flexible payment instruments. Bitcoin
      transactions<br>
      use a similar abstraction, the bitcoin address, to make them very
      flexible. A bitcoin<br>
      address can represent the owner of a private/public key pair, or it can
      represent some‐<br>
      thing else, such as a payment script, as we will see in
      “Pay-to-Script-Hash (P2SH)” on<br>
      page 151. For now, let’s examine the simple case, a bitcoin address that
      represents,<br>
      and is derived from, a public key.</p>
    <p> The bitcoin address is derived from the public key through the use of
      one-way cryp‐<br>
      tographic hashing. A “hashing algorithm” or simply “hash algorithm” is a
      one-way<br>
      function that produces a fingerprint or “hash” of an arbitrary-sized
      input. Crypto‐<br>
      graphic hash functions are used extensively in bitcoin: in bitcoin
      addresses, in script<br>
      addresses, and in the mining Proof-of-Work algorithm. The algorithms used
      to make<br>
      a bitcoin address from a public key are the Secure Hash Algorithm (SHA)
      and the<br>
      RACE Integrity Primitives Evaluation Message Digest (RIPEMD), specifically<br>
      SHA256 and RIPEMD160.</p>
    <p> Starting with the public key K, we compute the SHA256 hash and then
      compute the<br>
      RIPEMD160 hash of the result, producing a 160-bit (20-byte) number:</p>
    <pre>      A = RIPEMD160 SHA256 K</pre>
    <p> where K is the public key and A is the resulting bitcoin address.<br>
    </p>
    <p>A bitcoin address is not the same as a public key. Bitcoin addresses<br>
      are derived from a public key using a one-way function.<br>
    </p>
    <p>Bitcoin addresses are almost always encoded as “Base58Check” (see “Base58
      and<br>
      Base58Check Encoding” on page 66), which uses 58 characters (a Base58
      number sys‐<br>
      tem) and a checksum to help human readability, avoid ambiguity, and
      protect against<br>
      errors in address transcription and entry. Base58Check is also used in
      many other<br>
      ways in bitcoin, whenever there is a need for a user to read and correctly
      transcribe a<br>
      number, such as a bitcoin address, a private key, an encrypted key, or a
      script hash. In<br>
      the next section we will examine the mechanics of Base58Check encoding and
      decoding and the resulting representations. Малюнок&nbsp; 4-5 illustrates
      the conversion of a public<br>
      key into a bitcoin address.<br>
      Малюнок&nbsp; 4-5. Public key to bitcoin address: conversion of a public
      key into a bitcoin<br>
      address</p>
    <h3> Base58 and Base58Check Encoding</h3>
    <p> In order to represent long numbers in a compact way, using fewer
      symbols, many<br>
      computer systems use mixed-alphanumeric representations with a base (or
      radix)<br>
      higher than 10. For example, whereas the traditional decimal system uses
      the 10<br>
      numerals 0 through 9, the hexadecimal system uses 16, with the letters A
      through F as<br>
      the six additional symbols. A number represented in hexadecimal format is
      shorter<br>
      than the equivalent decimal representation. Even more compact, Base64
      representa‐<br>
      tion uses 26 lowercase letters, 26 capital letters, 10 numerals, and 2
      more characters such as “+” and “/” to transmit binary data over
      text-based media such as email.</p>
    <p> Base64 is most commonly used to add binary attachments to email. Base58
      is a text-<br>
      based binary-encoding format developed for use in bitcoin and used in many
      other<br>
      cryptocurrencies. It offers a balance between compact representation,
      readability, and<br>
      error detection and prevention. Base58 is a subset of Base64, using upper-
      and lower‐<br>
      case letters and numbers, but omitting some characters that are frequently
      mistaken<br>
      for one another and can appear identical when displayed in certain fonts.
      Specifically,<br>
      Base58 is Base64 without the 0 (number zero), O (capital o), l (lower L),
      I (capital i),<br>
      and the symbols “+” and “/”. Or, more simply, it is a set of lowercase and
      capital letters<br>
      and numbers without the four (0, O, l, I) just mentioned. Example 4-2
      shows the full<br>
      Base58 alphabet.<br>
    </p>
    <p>Example 4-2. Bitcoin’s Base58 alphabet<br>
    </p>
    <pre>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</pre>
    <p>To add extra security against typos or transcription errors, Base58Check
      is a Base58<br>
      encoding format, frequently used in bitcoin, which has a built-in
      error-checking<br>
      code. The checksum is an additional four bytes added to the end of the
      data that is<br>
      being encoded. The checksum is derived from the hash of the encoded data
      and can<br>
      therefore be used to detect and prevent transcription and typing errors.
      When pre‐<br>
      sented with Base58Check code, the decoding software will calculate the
      checksum of<br>
      the data and compare it to the checksum included in the code. If the two
      do not<br>
      match, an error has been introduced and the Base58Check data is invalid.
      This pre‐<br>
      vents a mistyped bitcoin address from being accepted by the wallet
      software as a valid<br>
      destination, an error that would otherwise result in loss of funds.<br>
      To convert data (a number) into a Base58Check format, we first add a
      prefix to the<br>
      data, called the “version byte,” which serves to easily identify the type
      of data that is<br>
      encoded. For example, in the case of a bitcoin address the prefix is zero
      (0x00 in hex),<br>
      whereas the prefix used when encoding a private key is 128 (0x80 in hex).
      A list of<br>
      common version prefixes is shown in Table 4-1.</p>
    <p> Next, we compute the “double-SHA” checksum, meaning we apply the SHA256
      hash-<br>
      algorithm twice on the previous result (prefix and data):</p>
    <pre>      checksum = SHA256(SHA256(prefix+data))</pre>
    <p> From the resulting 32-byte hash (hash-of-a-hash), we take only the first
      four bytes.<br>
      These four bytes serve as the error-checking code, or checksum. The
      checksum is<br>
      concatenated (appended) to the end.</p>
    <p> The result is composed of three items: a prefix, the data, and a
      checksum. This result<br>
      is encoded using the Base58 alphabet described previously. Малюнок&nbsp;
      4-6 illustrates the<br>
      Base58Check encoding process.</p>
    <p><br>
      Малюнок&nbsp; 4-6. Base58Check encoding: a Base58, versioned, and
      checksummed format for<br>
      unambiguously encoding bitcoin data</p>
    <p> In bitcoin, most of the data presented to the user is
      Base58Check-encoded to make it<br>
      compact, easy to read, and easy to detect errors. The version prefix in
      Base58Check<br>
      encoding is used to create easily distinguishable formats, which when
      encoded in<br>
      Base58 contain specific characters at the beginning of the
      Base58Check-encoded pay‐<br>
      load. These characters make it easy for humans to identify the type of
      data that is<br>
      encoded and how to use it. This is what differentiates, for example, a
      Base58Check-<br>
      encoded bitcoin address that starts with a 1 from a Base58Check-encoded
      private key<br>
      WIF that starts with a 5. Some example version prefixes and the resulting
      Base58<br>
      characters are shown in Table 4-1.</p>
    <p> Table 4-1. Base58Check version prefix and encoded result examples</p>
    <p> Type&nbsp; Version prefix (hex) Base58 result prefix<br>
      Bitcoin Address&nbsp; 0x00&nbsp; 1<br>
      Pay-to-Script-Hash Address&nbsp; 0x05&nbsp; 3<br>
      Bitcoin Testnet Address&nbsp; 0x6F&nbsp; m or n</p>
    <p>Table 4-3. Example: Same key, different formats<br>
      Hex&nbsp; 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd<br>
      WIF&nbsp; 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn<br>
      WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ<br>
    </p>
    <p>All of these representations are different ways of showing the same
      number, the same<br>
      private key. They look different, but any one format can easily be
      converted to any<br>
      other format. Note that the “raw binary” is not shown in Table 4-3 as any
      encoding<br>
      for display here would, by definition, not be raw binary data.<br>
      We use the wif-to-ec command from Bitcoin Explorer (see Appendix G) to
      show<br>
      that both WIF keys represent the same private key:<br>
      $ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn<br>
      1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd<br>
      $ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ<br>
      1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p>
    <h3> Decode from Base58Check</h3>
    <p> The Bitcoin Explorer commands (see Appendix G) make it easy to write
      shell scripts<br>
      and command-line “pipes” that manipulate bitcoin keys, addresses, and
      transactions.<br>
      You can use Bitcoin Explorer to decode the Base58Check format on the
      command<br>
      line.<br>
      We use the base58check-decode command to decode the uncompressed key:<br>
      $ bx base58check-decode
      5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p>
    <pre>      wrapper</pre>
    <pre>      {</pre>
    <pre>      checksum 4286807748</pre>
    <pre>      payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</pre>
    <pre>      version 128</pre>
    <pre>      }</pre>
    <pre>      The result contains the key as payload, the WIF version prefix 128, and a
      checksum.</pre>
    <pre>      Notice that the “payload” of the compressed key is appended with the
      suffix 01, sig‐</pre>
    <pre>      nalling that the derived public key is to be compressed:</pre>
    <pre>      $ bx base58check-decode
      KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</pre>
    <pre>      wrapper</pre>
    <pre>      {</pre>
    <pre>      checksum 2339607926</pre>
    <pre>      payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01</pre>
    <pre>      version 128</pre>
    <pre>      }</pre>
    <p> Малюнок&nbsp; 4-7. Public key compression<br>
    </p>
    <p>Here’s the same public key generated previously, shown as a compressed
      public key<br>
      stored in 264 bits (66 hex digits) with the prefix 03 indicating the y
      coordinate is odd:<br>
      K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A<br>
      This compressed public key corresponds to the same private key, meaning it
      is gener‐<br>
      ated from the same private key. However, it looks different from the
      uncompressed<br>
      public key. More importantly, if we convert this compressed public key to
      a bitcoin<br>
      address using the double-hash function (RIPEMD160(SHA256(K))) it will
      produce a<br>
      different bitcoin address. This can be confusing, because it means that a
      single private<br>
      key can produce a public key expressed in two different formats
      (compressed and<br>
      uncompressed) that produce two different bitcoin addresses. However, the
      private<br>
      key is identical for both bitcoin addresses.<br>
      Compressed public keys are gradually becoming the default across bitcoin
      clients,<br>
      which is having a significant impact on reducing the size of transactions
      and there‐<br>
      fore the blockchain. However, not all clients support compressed public
      keys yet.<br>
      <br>
      Example 4-5. Key and address generation and formatting with the
      pybitcointools library</p>
    <pre>      import bitcoin</pre>
    <pre>      # Generate a random private key</pre>
    <pre>      valid_private_key = False</pre>
    <pre>      while not valid_private_key:</pre>
    <pre>      private_key = bitcoin.random_key()</pre>
    <pre>      decoded_private_key = bitcoin.decode_privkey(private_key, 'hex')</pre>
    <pre>      valid_private_key = 0 &lt; decoded_private_key &lt; bitcoin.N</pre>
    <pre>      print "Private Key (hex) is: ", private_key</pre>
    <pre>      print "Private Key (decimal) is: ", decoded_private_key</pre>
    <pre>      # Convert private key to WIF format</pre>
    <pre>      wif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key,
      'wif')</pre>
    <pre>      print "Private Key (WIF) is: ", wif_encoded_private_key</pre>
    <pre>      # Add suffix "01" to indicate a compressed private key</pre>
    <pre>      compressed_private_key = private_key + '01'</pre>
    <pre>      print "Private Key Compressed (hex) is: ", compressed_private_key</pre>
    <pre>      # Generate a WIF format from the compressed private key (WIF-compressed)</pre>
    <pre>      wif_compressed_private_key = bitcoin.encode_privkey(</pre>
    <pre>      bitcoin.decode_privkey(compressed_private_key, 'hex'), 'wif')</pre>
    <pre>      print "Private Key (WIF-Compressed) is: ", wif_compressed_private_key</pre>
    <pre>      # Multiply the EC generator point G with the private key to get a public
      key point</pre>
    <pre>      public_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)</pre>
    <pre>      print "Public Key (x,y) coordinates is:", public_key</pre>
    <pre>      # Encode as hex, prefix 04</pre>
    <pre>      hex_encoded_public_key = bitcoin.encode_pubkey(public_key,'hex')</pre>
    <pre>      print "Public Key (hex) is:", hex_encoded_public_key</pre>
    <pre>      # Compress public key, adjust prefix depending on whether y is even or odd</pre>
    <pre>      (public_key_x, public_key_y) = public_key</pre>
    <pre>      if (public_key_y % 2) == 0:</pre>
    <pre>      compressed_prefix = '02'</pre>
    <pre>      else:</pre>
    <pre>      compressed_prefix = '03'</pre>
    <pre>      hex_compressed_public_key = compressed_prefix +
      bitcoin.encode(public_key_x, 16)</pre>
    <pre>      print "Compressed Public Key (hex) is:", hex_compressed_public_key</pre>
    <pre>      # Generate bitcoin address from public key</pre>
    <pre>      print "Bitcoin Address (b58check) is:",
      bitcoin.pubkey_to_address(public_key)</pre>
    <pre>      # Generate compressed bitcoin address from compressed public key</pre>
    <pre>      print "Compressed Bitcoin Address (b58check) is:", \</pre>
    <pre>      bitcoin.pubkey_to_address(hex_compressed_public_key)</pre>
    <pre>      </pre>
    <p></p>
    <p>Example 4-6 shows the output from running this code.<br>
    </p>
    <p>Example 4-6. Running key-to-address-ecc-example.py<br>
    </p>
    <pre>$ python key-to-address-ecc-example.py</pre>
    <pre>      Private Key (hex) is:</pre>
    <pre>      3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6</pre>
    <pre>      Private Key (decimal) is:</pre>
    <pre>26563230048437957592232553826663696440606756685920117476832299673293013768870</pre>
    <pre>      Private Key (WIF) is:</pre>
    <pre>      5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K</pre>
    <pre>      Private Key Compressed (hex) is:</pre>
    <pre>      3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601</pre>
    <pre>      Private Key (WIF-Compressed) is:</pre>
    <pre>      KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S</pre>
    <pre>      Public Key (x,y) coordinates is:</pre>
    <pre>(41637322786646325214887832269588396900663353932545912953362782457239403430124L,</pre>
    <pre>16388935128781238405526710466724741593761085120864331449066658622400339362166L)</pre>
    <pre>      Public Key (hex) is:</pre>
    <pre>      045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵</pre>
    <pre>      243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176</pre>
    <pre>      Compressed Public Key (hex) is:</pre>
    <pre>      025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec</pre>
    <pre>      Bitcoin Address (b58check) is:</pre>
    <pre>      1thMirt546nngXqyPEz532S8fLwbozud8</pre>
    <pre>      Compressed Bitcoin Address (b58check) is:</pre>
    <pre>      14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3</pre>
    <pre>      Example 4-7 is another example, using the Python ECDSA library for the
      elliptic</pre>
    <pre>      curve math and without using any specialized bitcoin libraries.</pre>
    <pre>      Example 4-7. A script demonstrating elliptic curve math used for bitcoin
      keys</pre>
    <pre>      import ecdsa</pre>
    <pre>      import os</pre>
    <pre>      from ecdsa.util import string_to_number, number_to_string</pre>
    <pre>      # secp256k1, http://www.oid-info.com/get/1.3.132.0.10</pre>
    <pre>      _p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL</pre>
    <pre>      _r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L</pre>
    <pre>      _b = 0x0000000000000000000000000000000000000000000000000000000000000007L</pre>
    <pre>      _a = 0x0000000000000000000000000000000000000000000000000000000000000000L</pre>
    <pre>      _Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L</pre>
    <pre>      _Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L</pre>
    <pre>      curve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)</pre>
    <pre>      generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy,
      _r)</pre>
    <pre>      oid_secp256k1 = (1, 3, 132, 0, 10)</pre>
    <pre>      SECP256k1 = ecdsa.curves.Curve("SECP256k1", curve_secp256k1,
      generator_secp256k1,</pre>
    <pre>      oid_secp256k1)</pre>
    <pre>      ec_order = _r</pre>
    <pre>      curve = curve_secp256k1</pre>
    <pre>      generator = generator_secp256k1</pre>
    <p> </p>
    <pre>      def random_secret():</pre>
    <pre>      convert_to_int = lambda array: int("".join(array).encode("hex"), 16)</pre>
    <pre>      # Collect 256 bits of random data from the OS's cryptographically secure
      random</pre>
    <pre>      generator</pre>
    <pre>      byte_array = os.urandom(32)</pre>
    <pre>      return convert_to_int(byte_array)</pre>
    <pre>      def get_point_pubkey(point):</pre>
    <pre>      if point.y() &amp; 1:</pre>
    <pre>      key = '03' + '%064x' % point.x()</pre>
    <pre>      else:</pre>
    <pre>      key = '02' + '%064x' % point.x()</pre>
    <pre>      return key.decode('hex')</pre>
    <pre>      def get_point_pubkey_uncompressed(point):</pre>
    <pre>      key = '04' + \</pre>
    <pre>      '%064x' % point.x() + \</pre>
    <pre>      '%064x' % point.y()</pre>
    <pre>      return key.decode('hex')</pre>
    <pre>      # Generate a new private key.</pre>
    <pre>      secret = random_secret()</pre>
    <pre>      print "Secret: ", secret</pre>
    <pre>      # Get the public key point.</pre>
    <pre>      point = secret * generator</pre>
    <pre>      print "EC point:", point</pre>
    <pre>      print "BTC public key:", get_point_pubkey(point).encode("hex")</pre>
    <pre>      # Given the point (x, y) we can create the object using:</pre>
    <pre>      point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order)</pre>
    <pre>      assert point1 == point</pre>
    <p> Example 4-8 shows the output produced by running this script.</p>
    <p> Example 4-7 uses os.urandom, which reflects a cryptographically<br>
      secure random number generator (CSRNG) provided by the<br>
      underlying operating system. In the case of a Unix-like operating<br>
      system such as Linux, it draws from /dev/urandom; and in the case<br>
      of Windows, it calls CryptGenRandom(). If a suitable randomness<br>
      source is not found, NotImplementedError will be raised. While<br>
      the random number generator used here is for demonstration pur‐<br>
      poses, it is not appropriate for generating production-quality bit‐<br>
      coin keys as it is not implemented with sufficient security.<br>
      <br>
      Example 4-8. Installing the Python ECDSA library and running the
      ec_math.py script<br>
    </p>
    <p>$ # Install Python PIP package manager<br>
      $ sudo apt-get install python-pip<br>
      $ # Install the Python ECDSA library<br>
      $ sudo pip install ecdsa<br>
      $ # Run the script<br>
      $ python ec-math.py<br>
      Secret:<br>
38090835015954358862481132628887443905906204995912378278060168703580660294000<br>
      EC point:<br>
(70048853531867179489857750497606966272382583471322935454624595540007269312627,<br>
105262206478686743191060800263479589329920209527285803935736021686045542353380)<br>
      BTC public key:
      029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873<br>
      Advanced Keys and Addresses<br>
      In the following sections we will look at advanced forms of keys and
      addresses, such<br>
      as encrypted private keys, script and multisignature addresses, vanity
      addresses, and<br>
      paper wallets.</p>
    <h3> Encrypted Private Keys (BIP-38)</h3>
    <p> Private keys must remain secret. The need for confidentiality of the
      private keys is a<br>
      truism that is quite difficult to achieve in practice, because it
      conflicts with the equally<br>
      important security objective of availability. Keeping the private key
      private is much<br>
      harder when you need to store backups of the private key to avoid losing
      it. A private<br>
      key stored in a wallet that is encrypted by a password might be secure,
      but that wallet<br>
      needs to be backed up. At times, users need to move keys from one wallet
      to another<br>
      —to upgrade or replace the wallet software, for example. Private key
      backups might<br>
      also be stored on paper (see “Paper Wallets” on page 88) or on external
      storage media,<br>
      such as a USB flash drive. But what if the backup itself is stolen or
      lost? These con‐<br>
      flicting security goals led to the introduction of a portable and
      convenient standard<br>
      for encrypting private keys in a way that can be understood by many
      different wallets<br>
      and bitcoin clients, standardized by BIP-38 (see Appendix C).<br>
      BIP-38 proposes a common standard for encrypting private keys with a
      passphrase<br>
      and encoding them with Base58Check so that they can be stored securely on
      backup<br>
      media, transported securely between wallets, or kept in any other
      conditions where<br>
      the key might be exposed. The standard for encryption uses the Advanced
      Encryp‐<br>
      tion Standard (AES), a standard established by the NIST and used broadly
      in data<br>
      encryption implementations for commercial and military applications.<br>
      A BIP-38 encryption scheme takes as input a bitcoin private key, usually
      encoded in<br>
      the WIF, as a Base58Check string with the prefix of “5.” Additionally, the
      BIP-38<br>
      encryption scheme takes a passphrase—a long password—usually composed of
      several words or a complex string of alphanumeric characters. The result
      of the BIP-38<br>
      encryption scheme is a Base58Check-encoded encrypted private key that
      begins with<br>
      the prefix 6P. If you see a key that starts with 6P, it is encrypted and
      requires a pass‐<br>
      phrase in order to convert (decrypt) it back into a WIF-formatted private
      key (prefix<br>
      5) that can be used in any wallet. Many wallet applications now recognize
      BIP-38-<br>
      encrypted private keys and will prompt the user for a passphrase to
      decrypt and<br>
      import the key. Third-party applications, such as the incredibly useful
      browser-based<br>
      Bit Address (Wallet Details tab), can be used to decrypt BIP-38 keys.<br>
      The most common use case for BIP-38 encrypted keys is for paper wallets
      that can be<br>
      used to back up private keys on a piece of paper. As long as the user
      selects a strong<br>
      passphrase, a paper wallet with BIP-38 encrypted private keys is
      incredibly secure and<br>
      a great way to create offline bitcoin storage (also known as “cold
      storage”).<br>
      Test the encrypted keys in Table 4-5 using bitaddress.org to see how you
      can get the<br>
      decrypted key by entering the passphrase.<br>
    </p>
    <p>Table 4-5. Example of BIP-38 encrypted private key<br>
    </p>
    <p>Private Key (WIF)<br>
      &nbsp;5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn<br>
      Passphrase<br>
      &nbsp;MyTestPassphrase<br>
      Encrypted Key (BIP-38)
      6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ<br>
      Pay-to-Script Hash (P2SH) and Multisig Addresses</p>
    <p> As we know, traditional bitcoin addresses begin with the number “1” and
      are derived<br>
      from the public key, which is derived from the private key. Although
      anyone can send<br>
      bitcoin to a “1” address, that bitcoin can only be spent by presenting the
      correspond‐<br>
      ing private key signature and public key hash.</p>
    <p> Bitcoin addresses that begin with the number “3” are pay-to-script hash
      (P2SH)<br>
      addresses, sometimes erroneously called multisignature or multisig
      addresses. They<br>
      designate the beneficiary of a bitcoin transaction as the hash of a
      script, instead of the<br>
      owner of a public key. The feature was introduced in January 2012 with
      BIP-16 (see<br>
      Appendix C), and is being widely adopted because it provides the
      opportunity to add<br>
      functionality to the address itself. Unlike transactions that “send” funds
      to traditional<br>
      “1” bitcoin addresses, also known as a pay-to-public-key-hash (P2PKH),
      funds sent<br>
      to “3” addresses require something more than the presentation of one
      public key hash<br>
      and one private key signature as proof of ownership. The requirements are
      designated<br>
      at the time the address is created, within the script, and all inputs to
      this address will<br>
      be encumbered with the same requirements.<br>
      A P2SH address is created from a transaction script, which defines who can
      spend a<br>
      transaction output (for more details, see “Pay-to-Script-Hash (P2SH)” on
      page 151).</p>
    <p><br>
      Encoding a P2SH address involves using the same double-hash function as
      used dur‐<br>
      ing creation of a bitcoin address, only applied on the script instead of
      the public key:<br>
      script hash = RIPEMD160(SHA256(script))<br>
      The resulting “script hash” is encoded with Base58Check with a version
      prefix of 5,<br>
      which results in an encoded address starting with a 3. An example of a
      P2SH address<br>
      is 3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM, which can be derived using the
      Bitcoin<br>
      Explorer commands script-encode, sha256, ripemd160, and base58check-encode<br>
      (see Appendix G) as follows:<br>
      $ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ]
      equalverify<br>
      checksig &gt; script<br>
      $ bx script-encode &lt; script | bx sha256 | bx ripemd160 | bx
      base58check-encode<br>
      --version 5<br>
      3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM<br>
      P2SH is not necessarily the same as a multisignature standard<br>
      transaction. A P2SH address most often represents a multi-<br>
      signature script, but it might also represent a script encoding other<br>
      types of transactions.</p>
    <h3> Multisignature addresses and P2SH</h3>
    <p> Currently, the most common implementation of the P2SH function is the
      multi-<br>
      signature address script. As the name implies, the underlying script
      requires more<br>
      than one signature to prove ownership and therefore spend funds. The
      bitcoin multi-<br>
      signature feature is designed to require M signatures (also known as the
      “threshold”)<br>
      from a total of N keys, known as an M-of-N multisig, where M is equal to
      or less than<br>
      N. For example, Bob the coffee shop owner from Chapter 1 could use a
      multisigna‐<br>
      ture address requiring 1-of-2 signatures from a key belonging to him and a
      key<br>
      belonging to his spouse, ensuring either of them could sign to spend a
      transaction<br>
      output locked to this address. This would be similar to a “joint account”
      as imple‐<br>
      mented in traditional banking where either spouse can spend with a single
      signature.<br>
      Or Gopesh, the web designer paid by Bob to create a website, might have a
      2-of-3<br>
      multisignature address for his business that ensures that no funds can be
      spent unless<br>
      at least two of the business partners sign a transaction.<br>
      We will explore how to create transactions that spend funds from P2SH (and
      multi-<br>
      signature) addresses in Chapter 6.</p>
    <h3> Vanity Addresses</h3>
    <p> Vanity addresses are valid bitcoin addresses that contain human-readable
      messages. For example, 1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33 is a valid
      address that contains the letters forming the word “Love” as the first
      four Base-58 letters. Vanity addresses require generating and testing
      billions of candidate private keys, until a bitcoin address with the
      desired pattern is found. Although there are some optimizations in the
      vanity generation algorithm, the process essentially involves picking a
      private key at random, deriving the public key, deriving the bitcoin
      address, and checking to see<br>
      if it matches the desired vanity pattern, repeating billions of times
      until a match is found.</p>
    <p> Once a vanity address matching the desired pattern is found, the private
      key from which it was derived can be used by the owner to spend bitcoin in
      exactly the same way as any other address. Vanity addresses are no less or
      more secure than any other<br>
      address. They depend on the same Elliptic Curve Cryptography (ECC) and SHA
      as any other address. You can no more easily find the private key of an
      address starting with a vanity pattern than you can any other address.<br>
      In Chapter 1, we introduced Eugenia, a children’s charity director
      operating in the Philippines. Let’s say that Eugenia is organizing a
      bitcoin fundraising drive and wants to use a vanity bitcoin address to
      publicize the fundraising. Eugenia will create a vanity address that
      starts with “1Kids” to promote the children’s charity fundraiser. Let’s
      see how this vanity address will be created and what it means for the
      security of Eugenia’s charity.</p>
    <h3> Generating vanity addresses</h3>
    <p> It’s important to realize that a bitcoin address is simply a number
      represented by sym‐<br>
      bols in the Base58 alphabet. The search for a pattern like “1Kids” can be
      seen as<br>
      searching for an address in the range from
      1Kids11111111111111111111111111111<br>
      to 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz. There are approximately 5829
      (approxi‐<br>
      mately 1.4 * 1051) addresses in that range, all starting with “1Kids.”
      Table 4-6 shows<br>
      the range of addresses that have the prefix 1Kids.<br>
      Table 4-6. The range of vanity addresses starting with “1Kids”<br>
      From 1Kids11111111111111111111111111111<br>
      1Kids11111111111111111111111111112<br>
      1Kids11111111111111111111111111113<br>
      ...<br>
      To<br>
      &nbsp;1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p>
    <p><br>
      Let’s look at the pattern “1Kids” as a number and see how frequently we
      might find this pattern in a bitcoin address (see Table 4-7). An average
      desktop computer PC, without any specialized hardware, can search
      approximately 100,000 keys per second.<br>
      <br>
      Table 4-7. The frequency of a vanity pattern (1KidsCharity) and average
      search time on a<br>
      desktop PC</p>
    <p> Length Pattern&nbsp; Frequency&nbsp; Average search time<br>
      1&nbsp; 1K&nbsp; 1 на 58 keys&nbsp; &lt; 1 milliseconds<br>
      2&nbsp; 1Ki&nbsp; 1 на 3,364&nbsp; 50 milliseconds<br>
      3&nbsp; 1Kid&nbsp; 1 на 195,000&nbsp; &lt; 2 seconds<br>
      4&nbsp; 1Kids&nbsp; 1 на 11 million&nbsp; 1 minute<br>
      5&nbsp; 1KidsC&nbsp; 1 на 656 million&nbsp; 1 hour<br>
      6&nbsp; 1KidsCh&nbsp; 1 на 38 billion&nbsp; 2 days<br>
      7&nbsp; 1KidsCha&nbsp; 1 на 2.2 trillion&nbsp; 3–4 months<br>
      8&nbsp; 1KidsChar&nbsp; 1 на 128 trillion&nbsp; 13–18 years<br>
      9&nbsp; 1KidsChari&nbsp; 1 на 7 quadrillion&nbsp; 800 years<br>
      10&nbsp; 1KidsCharit&nbsp; 1 на 400 quadrillion 46,000 years<br>
      11&nbsp; 1KidsCharity 1 на 23 quintillion&nbsp; 2.5 million years</p>
    <p> As you can see, Eugenia won’t be creating the vanity address
      “1KidsCharity” anytime soon, even if she had access to several thousand
      computers. Each additional character increases the difficulty by a factor
      of 58. Patterns with more than seven characters are usually found by
      specialized hardware, such as custom-built desktops with multiple GPUs.
      These are often repurposed bitcoin mining “rigs” that are no longer
      profitable for bitcoin mining but can be used to find vanity addresses.
      Vanity searches on GPU systems are many orders of magnitude faster than on
      a general-purpose CPU.</p>
    <p> Another way to find a vanity address is to outsource the work to a pool
      of vanity min‐ ers, such as the pool at Vanity Pool. A pool is a service
      that allows those with GPU hardware to earn bitcoin searching for vanity
      addresses for others. For a small pay‐<br>
      ment (0.01 bitcoin or approximately $5 at the time of this writing),
      Eugenia can outsource the search for a seven-character pattern vanity
      address and get results in a few hours instead of having to run a CPU
      search for months.<br>
    </p>
    <p>Generating a vanity address is a brute-force exercise: try a random key,
      check the resulting address to see if it matches the desired pattern,
      repeat until successful.</p>
    <p>Example 4-9 shows an example of a “vanity miner,” a program designed to
      find vanity addresses, written in C++. The example uses the libbitcoin
      library, which we introduced in “Alternative Clients, Libraries, and
      Toolkits” on page 51.<br>
    </p>
    <p>Example 4-9. Vanity address miner<br>
    </p>
    <pre>#include &lt;random&gt;<br>
      #include &lt;bitcoin/bitcoin.hpp&gt;<br>
      // The string we are searching for<br>
      const std::string search = "1kid";<br>
      // Generate a random secret key. A random 32 bytes.<br>
      bc::ec_secret random_secret(std::default_random_engine&amp; engine);<br>
      // Extract the Bitcoin address from an EC secret.<br>
      std::string bitcoin_address(const bc::ec_secret&amp; secret);<br>
      // Case insensitive comparison with the search string.<br>
      bool match_found(const std::string&amp; address);<br>
      int main()<br>
      {<br>
      // random_device on Linux uses "/dev/urandom"<br>
      // CAUTION: Depending on implementation this RNG may not be secure enough!<br>
      // Do not use vanity keys generated by this example in production<br>
      std::random_device random;<br>
      std::default_random_engine engine(random());<br>
      }<br>
      // Loop continuously...<br>
      while (true)<br>
      {<br>
      // Generate a random secret.<br>
      bc::ec_secret secret = random_secret(engine);<br>
      // Get the address.<br>
      std::string address = bitcoin_address(secret);<br>
      // Does it match our search string? (1kid)<br>
      if (match_found(address))<br>
      {<br>
      // Success!<br>
      std::cout &lt;&lt; "Found vanity address! " &lt;&lt; address &lt;&lt;
      std::endl;<br>
      std::cout &lt;&lt; "Secret: " &lt;&lt; bc::encode_base16(secret) &lt;&lt;
      std::endl;<br>
      return 0;<br>
      }<br>
      }<br>
      // Should never reach here!<br>
      return 0;<br>
      bc::ec_secret random_secret(std::default_random_engine&amp; engine)<br>
      {<br>
      // Create new secret...<br>
      bc::ec_secret secret;<br>
      // Iterate through every byte setting a random value...<br>
      for (uint8_t&amp; byte: secret)<br>
      byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max();<br>
      // Return result.<br>
      return secret;<br>
      }<br>
      std::string bitcoin_address(const bc::ec_secret&amp; secret)<br>
      {<br>
      // Convert secret to payment address<br>
      bc::wallet::ec_private private_key(secret);<br>
      bc::wallet::payment_address payaddr(private_key);<br>
      <br>
      }<br>
      // Return encoded form.<br>
      return payaddr.encoded();<br>
      bool match_found(const std::string&amp; address)<br>
      {<br>
      auto addr_it = address.begin();<br>
      // Loop through the search string comparing it to the lower case<br>
      // character of the supplied address.<br>
      for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)<br>
      if (*it != std::tolower(*addr_it))<br>
      return false;<br>
      // Reached end of search string, so address matches.<br>
      return true;<br>
      }<br>
    </pre>
    <p>Example 4-10 uses std::random_device. Depending on the implementation it
      may reflect a CSRNG provided by the underlying<br>
      operating system. In the case of a Unix-like operating system such as
      Linux, it draws from /dev/urandom. The random number generator used here
      is for demonstration purposes, and it is not appropriate for generating
      production-quality bitcoin keys as it is not implemented with sufficient
      security.</p>
    <p> The example code must be compiled using a C++ compiler and linked
      against the libbitcoin library (which must be first installed on that
      system). To run the example, run the vanity-miner executable with no
      parameters (see Example 4-10) and it will<br>
      attempt to find a vanity address starting with “1kid.”</p>
    <p> Example 4-10. Compiling and running the vanity-miner example<br>
    </p>
    <pre>$ # Compile the code with g++<br>
      $ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs
      libbitcoin)<br>
      $ # Run the example<br>
      $ ./vanity-miner<br>
      Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT<br>
      Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f<br>
      $ # Run it again for a different result<br>
      $ ./vanity-miner<br>
      Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn<br>
      Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623<br>
      # Use "time" to see how long it takes to find a result<br>
      $ time ./vanity-miner<br>
      Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM<br>
      Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349<br>
      real<br>
      user<br>
      sys<br>
      0m8.868s<br>
      0m8.828s<br>
      0m0.035s</pre>
    <pre></pre>
    <p> The example code will take a few seconds to find a match for the
      three-character pattern “kid,” as we can see when we use the time Unix
      command to measure the execution time. Change the search pattern in the
      source code and see how much longer it<br>
      takes for four- or five-character patterns!</p>
    <h3> Vanity address security</h3>
    <p> Vanity addresses can be used to enhance and to defeat security measures;
      they are truly a double-edged sword. Used to improve security, a
      distinctive address makes it harder for adversaries to substitute their
      own address and fool your customers into<br>
      paying them instead of you. Unfortunately, vanity addresses also make it
      possible for anyone to create an address that resembles any random
      address, or even another vanity address, thereby fooling your customers.</p>
    <p> Eugenia could advertise a randomly generated address (e.g.,
      1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy) to which people can send their
      donations. Or, she could generate a vanity address that starts with 1Kids,
      to make it more distinctive. In both cases, one of the risks of using a
      single fixed address (rather than a separate dynamic address per donor) is
      that a thief might be able to infiltrate your website and replace it with
      his own address, thereby diverting donations to himself. If you have
      advertised your donation address in a number of different places, your
      users may visually inspect the address before making a payment to ensure
      it is the same one they saw on your website, on your email, and on your
      flyer. In the case of a random address like
      1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy, the average user will perhaps inspect
      the first few characters “1J7mdg” and be satisfied that the address
      matches.</p>
    <p>Using a vanity address generator, someone with the intent to steal by
      substituting a similar-looking address can quickly generate addresses that
      match the first few characters, as shown in Table 4-8.</p>
    <p> Table 4-8. Generating vanity addresses to match a random address<br>
    </p>
    <p>Original Random Address<br>
      &nbsp;1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy<br>
      Vanity (4-character match) 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy<br>
      Vanity (5-character match) 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n<br>
      Vanity (6-character match) 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX<br>
    </p>
    <p>So does a vanity address increase security? If Eugenia generates the
      vanity address<br>
      1Kids33q44erFfpeXrmDSz7zEqG2FesZEN, users are likely to look at the vanity
      pattern<br>
      word and a few characters beyond, for example noticing the “1Kids33” part
      of the<br>
      address. That would force an attacker to generate a vanity address
      matching at least<br>
      six characters (two more), expending an effort that is 3,364 times (58 ×
      58) higher<br>
      than the effort Eugenia expended for her 4-character vanity. Essentially,
      the effort<br>
      Eugenia expends (or pays a vanity pool for) “pushes” the attacker into
      having to produce a longer pattern vanity. If Eugenia pays a pool to
      generate an 8-character vanity<br>
      address, the attacker would be pushed into the realm of 10 characters,
      which is infea‐<br>
      sible on a personal computer and expensive even with a custom
      vanity-mining rig or<br>
      vanity pool. What is affordable for Eugenia becomes unaffordable for the
      attacker,<br>
      especially if the potential reward of fraud is not high enough to cover
      the cost of the<br>
      vanity address generation.</p>
    <h3> Паперові гаманці</h3>
    <p> Паперові гаманці є приватними ключами біткоін, надрукованими на папері.
      Часто паперові гаманці також включають відповідну адресу біткоін для
      зручності, але це не потрібно, бо її можна отримати від приватного ключа.
      Паперові гаманці є дуже ефективним шляхом для створення резервних копій
      або офлайн сховищ біткоін, також відомих як "холодні сховища". Як механізм
      резервного копіювання, паперовий гаманець може запровадити безпеку проти
      втрати ключа через збій комп'ютера, такий, як відмова жорсткого диску,
      крадіжка, або випадкове видалення. Як механізм "холодного сховища", якщо
      ключі паперового гаманця згенеровані офлайн, та ніколи не зберігались на
      комп'ютерній системі, вони значно більше безпечні проти хакерів,
      считувачів клавіатури, та інших онлайн загроз. </p>
    <p>Паперові гаманці ідуть в багатьох формах, розмірах та виглядах, але не
      дуже базовому рівні є тільки ключем та адресою, що надруковані на папері.
      Таблиця 4-9 показує найпростішу форму паперового гаманця.</p>
    <p> Таблиця 4-9. Найпростіша форма паперового гаманця, роздруковані біткоін
      адреса та приватний ключ</p>
    <pre>
      Public address 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</pre>
    <pre>
      Private key (WIF) 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</pre>
    <p>Паперові гаманці можуть бути просто згенеровані з використанням
      інструменту, як клієнтській JavaScript генератор bitaddress.org. Ця
      сторінка містить весь код, потрібний для генерації ключів та паперових
      гаманців, навіть якщо ви повністю відключені від інтернету. Щоб
      використати його, збережіть сторінку HTML на вашому локальному пристрої,
      або на зовнішньому флеш пристрої USB. Від'єднайтесь від інтернету, та
      відкрийте файл в переглядачі. Навіть краще, завантажте ваш комп'ютер з
      використанням обмеженої операційної системи, як Linux OS з лазерного
      диску. Любі ключі, згенеровані за допомогою цього інструменту в стані
      офлайн можуть бути надруковані на локальному принтері по кабелю USB (не
      бездротовому), і так створивши паперові гаманці, чиї ключі існують тільки
      на папері та ніколи не зберігались на онлайн системі. Покладіть цей папір
      в незгораючий сейф, та "надішліть" біткоін на їх біткоін адреси, щоб
      реалізувати простий, але високоефективний спосіб "холодного зберігання".
      Малюнок 4-8 показує паперовий гаманець, згенерований сайтом
      bitaddress.org.</p>
    <p>Малюнок 4-8. Приклад простого паперового гаманця від bitaddress.org<br>
    </p>
    <p>Недолік системи паперових гаманців полягає в тому, що вони чутливі до
      крадіжок. Крадій, що має змогу отримати доступ до папіру, в жодному разі
      може викрасти його, або сфотографувати ключі, та обрати контроль над
      біткоінами, що заблоковані ціма ключами. Більш складна система зберігання
      паперових гаманців використовує шифровані приватні ключі BIP-38. Ключі,
      надруковані на папері, захищені паролем, який власник має запам'ятати. Без
      пароля зашифровані ключі не мають сенсу. Також вони все ще кращі за
      захищений паролем гаманець, оскільки ключі ніколи не були онлайн, та мають
      бути фізично отримані з сейфу, або інакше фізично безпечного сховища.
      Малюнок 4-9 показує паперовий гаманець з зашифрованим приватним ключем
      (BIP-38), створений на сайті bitaddress.org.</p>
    <p>Малюнок 4-9. Приклад шифрованого паперового гаманця з bitaddress.org.
      Ключове слово “test.”<br>
      <br>
      Хоча ви можете покласти фонди в паперовий гаманець декілька разів, ви
      можете списати фонди з них тільки один раз, витративши все. Це так, бо в
      процесі розблокування та витрачання фондів деякі гаманці будуть генерувати
      адресу решти, якщо ви витратите меньше, ніж ціла сума. Додатково, якщо
      комп'ютер, що ви використовуєте для підпису транзакцій, буде зломаний, ви
      ризикуєте виказати приватний ключ. Витрачаючи цілий баланс з паперового
      гаманця тільки один раз, ви зменшуєте ризик компрометації. Якщо вам треба
      тільки невелика сума, надішліть решту на новий паперовий гаманець в тій
      самій транзакції.</p>
    <p> Паперові гаманці надходять в різних виглядах та розмірах, з багатьма
      різними можливостями. Деякі призначені для того, щоб дути подарованими, та
      мають сезонні теми, такі як Новий рік або Різдво. Інші розроблені для
      зберігання в банкових скринях або сейфах, з приватним ключем, прихованим в
      деякий спосіб, або через непрозорі наліпки, або вкладені та закорковані в
      непрозору фольгу. Малюнки 4-10 до 4-12 показують різні приклади паперових
      гаманців, з можливостями безпеки та зберігання.</p>
    <p> Малюнок&nbsp; 4-10. Приклад паперового гаманця з bitcoinpaperwallet.com
      з приватним ключем на вкладеному флаєрі<br>
    </p>
    <p>Малюнок&nbsp; 4-11. Паперовий гаманець bitcoinpaperwallet.com з
      прихованим приватним ключем<br>
      <br>
      Інші варіанти мають додаткові копії ключа та адреси в формі від'єднуваних
      частин, подібних на білетні корінці, що дозволяє вам зберігати декілька
      копій для захисту проти вогню, повені, та інших природних лих.</p>
    <p>Малюнок 4-12. Приклад паперового гаманця з додатковими копіями ключів на
      додатковому "коренці"</p>
    <h2> CHAPTER 5</h2>
    <h1> Wallets</h1>
    <p> The word “wallet” is used to describe a few different things in bitcoin.<br>
      At a high level, a wallet is an application that serves as the primary
      user interface. The<br>
      wallet controls access to a user’s money, managing keys and addresses,
      tracking the<br>
      balance, and creating and signing transactions.</p>
    <p> More narrowly, from a programmer’s perspective, the word “wallet” refers
      to the data<br>
      structure used to store and manage a user’s keys.</p>
    <p> In this chapter we will look at the second meaning, where wallets are
      containers for<br>
      private keys, usually implemented as structured files or simple databases.</p>
    <h3> Wallet Technology Overview</h3>
    <p> In this section we summarize the various technologies used to construct
      user-<br>
      friendly, secure, and flexible bitcoin wallets.<br>
      A common misconception about bitcoin is that bitcoin wallets contain
      bitcoin. In<br>
      fact, the wallet contains only keys. The “coins” are recorded in the
      blockchain on the<br>
      bitcoin network. Users control the coins on the network by signing
      transactions with<br>
      the keys in their wallets. In a sense, a bitcoin wallet is a keychain.<br>
      Bitcoin wallets contain keys, not coins. Each user has a wallet con‐<br>
      taining keys. Wallets are really keychains containing pairs of pri‐<br>
      vate/public keys (see “Private and Public Keys” on page 57). Users<br>
      sign transactions with the keys, thereby proving they own the<br>
      transaction outputs (their coins). The coins are stored on the<br>
      blockchain in the form of transaction outputs (often noted as vout<br>
      or txout).<br>
    </p>
    <p> There are two primary types of wallets, distinguished by whether the
      keys they con‐<br>
      tain are related to each other or not.</p>
    <p> The first type is a nondeterministic wallet, where each key is
      independently generated<br>
      from a random number. The keys are not related to each other. This type of
      wallet is<br>
      also known as a JBOK wallet from the phrase “Just a Bunch Of Keys.”</p>
    <p> The second type of wallet is a deterministic wallet, where all the keys
      are derived from<br>
      a single master key, known as the seed. All the keys in this type of
      wallet are related to<br>
      each other and can be generated again if one has the original seed. There
      are a num‐<br>
      ber of different key derivation methods used in deterministic wallets. The
      most com‐<br>
      monly used derivation method uses a tree-like structure and is known as a<br>
      hierarchical deterministic or HD wallet.</p>
    <p> Deterministic wallets are initialized from a seed. To make these easier
      to use, seeds<br>
      are encoded as English words, also known as mnemonic code words.<br>
      The next few sections introduce each of these technologies at a high
      level.</p>
    <h3> Nondeterministic (Random) Wallets</h3>
    <p> In the first bitcoin wallet (now called Bitcoin Core), wallets were
      collections of ran‐<br>
      domly generated private keys. For example, the original Bitcoin Core
      client pregener‐<br>
      ates 100 random private keys when first started and generates more keys as
      needed,<br>
      using each key only once. Such wallets are being replaced with
      deterministic wallets<br>
      because they are cumbersome to manage, back up, and import. The
      disadvantage of<br>
      random keys is that if you generate many of them you must keep copies of
      all of<br>
      them, meaning that the wallet must be backed up frequently. Each key must
      be<br>
      backed up, or the funds it controls are irrevocably lost if the wallet
      becomes inaccessi‐<br>
      ble. This conflicts directly with the principle of avoiding address reuse,
      by using each<br>
      bitcoin address for only one transaction. Address reuse reduces privacy by
      associating<br>
      multiple transactions and addresses with each other. A Type-0
      nondeterministic wal‐<br>
      let is a poor choice of wallet, especially if you want to avoid address
      reuse because it<br>
      means managing many keys, which creates the need for frequent backups.
      Although<br>
      the Bitcoin Core client includes a Type-0 wallet, using this wallet is
      discouraged by<br>
      developers of Bitcoin Core. Малюнок&nbsp; 5-1 shows a nondeterministic
      wallet, containing a<br>
      loose collection of random keys.</p>
    <p> The use of nondeterministic wallets is discouraged for anything<br>
      other than simple tests. They are simply too cumbersome to back<br>
      up and use. Instead, use an industry-standard–based HD wallet<br>
      with a mnemonic seed for backup.<br>
    </p>
    <p>Малюнок&nbsp; 5-1. Type-0 nondeterministic (random) wallet: a collection
      of randomly generated<br>
      keys</p>
    <h3> Deterministic (Seeded) Wallets</h3>
    <p> Deterministic, or “seeded,” wallets are wallets that contain private
      keys that are all<br>
      derived from a common seed, through the use of a one-way hash function.
      The seed<br>
      is a randomly generated number that is combined with other data, such as
      an index<br>
      number or “chain code” (see “HD Wallets (BIP-32/BIP-44)” on page 96) to
      derive the<br>
      private keys. In a deterministic wallet, the seed is sufficient to recover
      all the derived<br>
      keys, and therefore a single backup at creation time is sufficient. The
      seed is also suffi‐<br>
      cient for a wallet export or import, allowing for easy migration of all
      the user’s keys<br>
      between different wallet implementations. Малюнок&nbsp; 5-2 shows a
      logical diagram of a<br>
      deterministic wallet.</p>
    <p> Малюнок&nbsp; 5-2. Type-1 deterministic (seeded) wallet: a deterministic
      sequence of keys derived<br>
      from a seed<br>
    </p>
    <h3> Seeds and Mnemonic Codes (BIP-39)</h3>
    <p> HD wallets are a very powerful mechanism for managing many keys and
      addresses.<br>
      They are even more useful if they are combined with a standardized way of
      creating<br>
      seeds from a sequence of English words that are easy to transcribe,
      export, and<br>
      import across wallets. This is known as a mnemonic and the standard is
      defined by<br>
      BIP-39. Today, most bitcoin wallets (as well as wallets for other
      cryptocurrencies) use<br>
      this standard and can import and export seeds for backup and recovery
      using intero‐<br>
      perable mnemonics.</p>
    <p> Let’s look at this from a practical perspective. Which of the following
      seeds is easier to<br>
      transcribe, record on paper, read without error, export, and import into
      another wal‐<br>
      let?<br>
      0C1E24E5917779D297E14D45F14E1A1A<br>
      army van defense carry jealous true<br>
      garbage claim echo media make crunch</p>
    <h3> Wallet Best Practices</h3>
    <p> As bitcoin wallet technology has matured, certain common industry
      standards have<br>
      emerged that make bitcoin wallets broadly interoperable, easy to use,
      secure, and flex‐<br>
      ible. These common standards are:<br>
      • Mnemonic code words, based on BIP-39<br>
      • HD wallets, based on BIP-32<br>
      • Multipurpose HD wallet structure, based on BIP-43<br>
      • Multicurrency and multiaccount wallets, based on BIP-44<br>
      These standards may change or may become obsolete by future developments,
      but for<br>
      now they form a set of interlocking technologies that have become the de
      facto wallet<br>
      standard for bitcoin.<br>
      The standards have been adopted by a broad range of software and hardware
      bitcoin<br>
      wallets, making all these wallets interoperable. A user can export a
      mnemonic gener‐<br>
      ated on one of these wallets and import it in another wallet, recovering
      all transac‐<br>
      tions, keys, and addresses.<br>
      Some example of software wallets supporting these standards include
      (listed alpha‐<br>
      betically) Breadwallet, Copay, Multibit HD, and Mycelium. Examples of
      hardware<br>
      wallets supporting these standards include (listed alphabetically)
      Keepkey, Ledger,<br>
      and Trezor.<br>
      The following sections examine each of these technologies in detail.<br>
      <br>
      If you are implementing a bitcoin wallet, it should be built as a HD<br>
      wallet, with a seed encoded as mnemonic code for backup, follow‐<br>
      ing the BIP-32, BIP-39, BIP-43, and BIP-44 standards, as described<br>
      in the following sections.</p>
    <h3> Using a Bitcoin Wallet</h3>
    <p> In “Bitcoin Uses, Users, and Their Stories” on page 5 we introduced
      Gabriel, an enter‐<br>
      prising young teenager in Rio de Janeiro, who is running a simple web
      store that sells<br>
      bitcoin-branded t-shirts, coffee mugs, and stickers.</p>
    <p> Gabriel uses a Trezor bitcoin hardware wallet (Малюнок&nbsp; 5-4) to
      securely manage his bit‐<br>
      coin. The Trezor is a simple USB device with two buttons that stores keys
      (in the<br>
      form of an HD wallet) and signs transactions. Trezor wallets implement all
      the indus‐<br>
      try standards discussed in this chapter, so Gabriel is not reliant on any
      proprietary<br>
      technology or single vendor solution.</p>
    <p> Малюнок&nbsp; 5-4. A Trezor device: a bitcoin HD wallet in hardware</p>
    <p> When Gabriel used the Trezor for the first time, the device generated a
      mnemonic<br>
      and seed from a built-in hardware random number generator. During this
      initializa‐<br>
      tion phase, the wallet displayed a numbered sequence of words, one by one,
      on the<br>
      screen (see Малюнок&nbsp; 5-5).</p>
    <p> Малюнок&nbsp; 5-5. Trezor displaying one of the mnemonic words<br>
      By writing down this mnemonic, Gabriel created a backup (see Table 5-1)
      that can be<br>
      used for recovery in the case of loss or damage to the Trezor device. This
      mnemonic<br>
      can be used for recovery in a new Trezor or in any one of the many
      compatible soft‐<br>
      ware or hardware wallets. Note that the sequence of words is important, so
      mnemonic paper backups have numbered spaces for each word. Gabriel had to
      carefully record each word in the numbered space to preserve the correct
      sequence.<br>
    </p>
    <p>Table 5-1. Gabriel’s paper backup of the mnemonic<br>
      1.<br>
      &nbsp;army<br>
      &nbsp;7.<br>
      &nbsp;garbage<br>
      2.<br>
      &nbsp;van<br>
      &nbsp;8.<br>
      &nbsp;claim<br>
      3.<br>
      &nbsp;defense<br>
      &nbsp;9.<br>
      &nbsp;echo<br>
      4.<br>
      &nbsp;carry<br>
      &nbsp;10.<br>
      &nbsp;media<br>
      5.<br>
      &nbsp;jealous<br>
      &nbsp;11.<br>
      &nbsp;make<br>
      6.<br>
      &nbsp;true<br>
      &nbsp;12.<br>
      &nbsp;crunch</p>
    <p> A 12-word mnemonic is shown in Table 5-1, for simplicity. In fact,<br>
      most hardware wallets generate a more secure 24-word mnemonic.<br>
      The mnemonic is used in exactly the same way, regardless of<br>
      length.</p>
    <p> For the first implementation of his web store, Gabriel uses a single
      bitcoin address,<br>
      generated on his Trezor device. This single address is used by all
      customers for all<br>
      orders. As we will see, this approach has some drawbacks and can be
      improved upon<br>
      with an HD wallet.<br>
      Wallet Technology Details<br>
      Let’s now examine each of the important industry standards that are used
      by many<br>
      bitcoin wallets in detail.</p>
    <h3> Mnemonic Code Words (BIP-39)</h3>
    <p> Mnemonic code words are word sequences that represent (encode) a random
      num‐<br>
      ber used as a seed to derive a deterministic wallet. The sequence of words
      is sufficient<br>
      to re-create the seed and from there re-create the wallet and all the
      derived keys. A<br>
      wallet application that implements deterministic wallets with mnemonic
      words will<br>
      show the user a sequence of 12 to 24 words when first creating a wallet.
      That<br>
      sequence of words is the wallet backup and can be used to recover and
      re-create all<br>
      the keys in the same or any compatible wallet application. Mnemonic words
      make it<br>
      easier for users to back up wallets because they are easy to read and
      correctly tran‐<br>
      scribe, as compared to a random sequence of numbers.<br>
    </p>
    <p>Mnemonic words are often confused with “brainwallets.” They are<br>
      not the same. The primary difference is that a brainwallet consists<br>
      of words chosen by the user, whereas mnemonic words are created<br>
      randomly by the wallet and presented to the user. This important<br>
      difference makes mnemonic words much more secure, because<br>
      humans are very poor sources of randomness.</p>
    <p> Mnemonic codes are defined in BIP-39 (see Appendix C). Note that BIP-39
      is one<br>
      implementation of a mnemonic code standard. There is a different standard,
      with a<br>
      different set of words, used by the Electrum wallet and predating BIP-39.
      BIP-39 was<br>
      proposed by the company behind the Trezor hardware wallet and is
      incompatible<br>
      with Electrum’s implementation. However, BIP-39 has now achieved broad
      industry<br>
      support across dozens of interoperable implementations and should be
      considered<br>
      the de facto industry standard.</p>
    <p> BIP-39 defines the creation of a mnemonic code and seed, which we
      describe here in<br>
      nine steps. For clarity, the process is split into two parts: steps 1
      through 6 are shown<br>
      in “Generating mnemonic words” on page 100 and steps 7 through 9 are shown
      in<br>
      “From mnemonic to seed” on page 101.</p>
    <h3> Generating mnemonic words</h3>
    <p> Mnemonic words are generated automatically by the wallet using the
      standardized<br>
      process defined in BIP-39. The wallet starts from a source of entropy,
      adds a check‐<br>
      sum, and then maps the entropy to a word list:</p>
    <p> 1. Create a random sequence (entropy) of 128 to 256 bits.<br>
    </p>
    <p>2. Create a checksum of the random sequence by taking the first (entropy-<br>
      length/32) bits of its SHA256 hash.<br>
    </p>
    <p>3. Add the checksum to the end of the random sequence.<br>
    </p>
    <p>4. Divide the sequence into sections of 11 bits.<br>
    </p>
    <p>5. Map each 11-bit value to a word from the predefined dictionary of 2048
      words.<br>
    </p>
    <p>6. The mnemonic code is the sequence of words.<br>
    </p>
    <p>Малюнок&nbsp; 5-6 shows how entropy is used to generate mnemonic words.<br>
    </p>
    <p>Малюнок&nbsp; 5-6. Generating entropy and encoding as mnemonic words<br>
      Table 5-2 shows the relationship between the size of the entropy data and
      the length<br>
      of mnemonic codes in words.<br>
      Table 5-2. Mnemonic codes: entropy and word length<br>
      Entropy (bits) Checksum (bits) Entropy + checksum (bits) Mnemonic length
      (words)<br>
      128<br>
      &nbsp;4<br>
      &nbsp;132<br>
      &nbsp;12<br>
      160<br>
      &nbsp;5<br>
      &nbsp;165<br>
      &nbsp;15<br>
      192<br>
      &nbsp;6<br>
      &nbsp;198<br>
      &nbsp;18<br>
      224<br>
      &nbsp;7<br>
      &nbsp;231<br>
      &nbsp;21<br>
      256<br>
      &nbsp;8<br>
      &nbsp;264<br>
      &nbsp;24</p>
    <h3> From mnemonic to seed</h3>
    <p> The mnemonic words represent entropy with a length of 128 to 256 bits.
      The entropy<br>
      is then used to derive a longer (512-bit) seed through the use of the
      key-stretching<br>
      function PBKDF2. The seed produced is then used to build a deterministic
      wallet and<br>
      derive its keys.<br>
      <br>
      The key-stretching function takes two parameters: the mnemonic and a salt.
      The pur‐<br>
      pose of a salt in a key-stretching function is to make it difficult to
      build a lookup table<br>
      enabling a brute-force attack. In the BIP-39 standard, the salt has
      another purpose—it<br>
      allows the introduction of a passphrase that serves as an additional
      security factor<br>
      protecting the seed, as we will describe in more detail in “Optional
      passphrase in<br>
      BIP-39” on page 104.<br>
      The process described in steps 7 through 9 continues from the process
      described pre‐<br>
      viously in “Generating mnemonic words” on page 100:<br>
      7. The first parameter to the PBKDF2 key-stretching function is the
      mnemonic pro‐<br>
      duced from step 6.<br>
      8. The second parameter to the PBKDF2 key-stretching function is a salt.
      The salt is<br>
      composed of the string constant "mnemonic" concatenated with an optional
      user-<br>
      supplied passphrase string.<br>
      9. PBKDF2 stretches the mnemonic and salt parameters using 2048 rounds of
      hash‐<br>
      ing with the HMAC-SHA512 algorithm, producing a 512-bit value as its final<br>
      output. That 512-bit value is the seed.<br>
      Малюнок&nbsp; 5-7 shows how a mnemonic is used to generate a seed.<br>
      Малюнок&nbsp; 5-7. From mnemonic to seed<br>
    </p>
    <p><br>
      The key-stretching function, with its 2048 rounds of hashing, is a<br>
      very effective protection against brute-force attacks against the<br>
      mnemonic or the passphrase. It makes it extremely costly (in com‐<br>
      putation) to try more than a few thousand passphrase and<br>
      mnemonic combinations, while the number of possible derived<br>
      seeds is vast (2512).<br>
      Tables 5-3, 5-4, and 5-5 show some examples of mnemonic codes and the
      seeds they<br>
      produce (without any passphrase).<br>
      Table 5-3. 128-bit entropy mnemonic code, no passphrase, resulting seed<br>
      Entropy input (128 bits)<br>
      0c1e24e5917779d297e14d45f14e1a1a<br>
      Mnemonic (12 words)<br>
      army van defense carry jealous true garbage claim echo media make crunch<br>
      Passphrase<br>
      (none)<br>
      Seed (512 bits)<br>
5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39<br>
      a88b76373733891bfaba16ed27a813ceed498804c0570<br>
      Table 5-4. 128-bit entropy mnemonic code, with passphrase, resulting seed<br>
      Entropy input (128 bits)<br>
      0c1e24e5917779d297e14d45f14e1a1a<br>
      Mnemonic (12 words)<br>
      army van defense carry jealous true garbage claim echo media make crunch<br>
      Passphrase<br>
      SuperDuperSecret<br>
      Seed (512 bits)<br>
3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0<br>
      715861dc8a18358f80b79d49acf64142ae57037d1d54<br>
      Table 5-5. 256-bit entropy mnemonic code, no passphrase, resulting seed<br>
      Entropy input (256 bits)<br>
      2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c<br>
      Mnemonic (24 words)<br>
      cake apple borrow silk endorse fitness top denial coil riot stay wolf<br>
      luggage oxygen faint major edit measure invite love trap field dilemma
      oblige<br>
      Passphrase<br>
      (none)<br>
      Seed (512 bits)<br>
3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5<br>
      5f1e0deaa082df8d487381379df848a6ad7e98798404</p>
    <h3> Optional passphrase in BIP-39</h3>
    <p> The BIP-39 standard allows the use of an optional passphrase in the
      derivation of the<br>
      seed. If no passphrase is used, the mnemonic is stretched with a salt
      consisting of the<br>
      constant string "mnemonic", producing a specific 512-bit seed from any
      given<br>
      mnemonic. If a passphrase is used, the stretching function produces a
      different seed<br>
      from that same mnemonic. In fact, given a single mnemonic, every possible
      pass‐<br>
      phrase leads to a different seed. Essentially, there is no “wrong”
      passphrase. All pass‐<br>
      phrases are valid and they all lead to different seeds, forming a vast set
      of possible<br>
      uninitialized wallets. The set of possible wallets is so large (2512) that
      there is no prac‐<br>
      tical possibility of brute-forcing or accidentally guessing one that is in
      use.<br>
      There are no “wrong” passphrases in BIP-39. Every passphrase<br>
      leads to some wallet, which unless previously used will be empty.<br>
    </p>
    <p>The optional passphrase creates two important features:<br>
      • A second factor (something memorized) that makes a mnemonic useless on
      its<br>
      own, protecting mnemonic backups from compromise by a thief.<br>
      • A form of plausible deniability or “duress wallet,” where a chosen
      passphrase<br>
      leads to a wallet with a small amount of funds used to distract an
      attacker from<br>
      the “real” wallet that contains the majority of funds.<br>
      However, it is important to note that the use of a passphrase also
      introduces the risk<br>
      of loss:<br>
      • If the wallet owner is incapacitated or dead and no one else knows the
      pass‐<br>
      phrase, the seed is useless and all the funds stored in the wallet are
      lost forever.<br>
      • Conversely, if the owner backs up the passphrase in the same place as
      the seed, it<br>
      defeats the purpose of a second factor.<br>
      While passphrases are very useful, they should only be used in combination
      with a<br>
      carefully planned process for backup and recovery, considering the
      possibility of sur‐<br>
      viving the owner and allowing his or her family to recover the
      cryptocurrency estate.<br>
    </p>
    <h3> Working with mnemonic codes</h3>
    <p> BIP-39 is implemented as a library in many different programming
      languages:<br>
      python-mnemonic<br>
      The reference implementation of the standard by the SatoshiLabs team that
      pro‐<br>
      posed BIP-39, in Python<br>
      bitcoinjs/bip39<br>
      An implementation of BIP-39, as part of the popular bitcoinJS framework,
      in<br>
      JavaScript<br>
      libbitcoin/mnemonic<br>
      An implementation of BIP-39, as part of the popular Libbitcoin framework,
      in<br>
      C++<br>
      There is also a BIP-39 generator implemented in a standalone webpage,
      which is<br>
      extremely useful for testing and experimentation. Малюнок&nbsp; 5-8 shows
      a standalone web<br>
      page that generates mnemonics, seeds, and extended private keys.<br>
      Малюнок&nbsp; 5-8. A BIP-39 generator as a standalone web page<br>
      The page (https://iancoleman.github.io/bip39/) can be used offline in a
      browser, or<br>
      accessed online.<br>
    </p>
    <h3> Creating an HD Wallet from the Seed</h3>
    <p> HD wallets are created from a single root seed, which is a 128-, 256-,
      or 512-bit ran‐<br>
      dom number. Most commonly, this seed is generated from a mnemonic as
      detailed in<br>
      the previous section.</p>
    <p> Every key in the HD wallet is deterministically derived from this root
      seed, which<br>
      makes it possible to re-create the entire HD wallet from that seed in any
      compatible<br>
      HD wallet. This makes it easy to back up, restore, export, and import HD
      wallets con‐<br>
      taining thousands or even millions of keys by simply transferring only the
      mnemonic<br>
      that the root seed is derived from.</p>
    <p> The process of creating the master keys and master chain code for an HD
      wallet is<br>
      shown in Малюнок&nbsp; 5-9.</p>
    <p> Малюнок&nbsp; 5-9. Creating master keys and chain code from a root seed<br>
    </p>
    <p>The root seed is input into the HMAC-SHA512 algorithm and the resulting
      hash is<br>
      used to create a master private key (m) and a master chain code (c).<br>
      The master private key (m) then generates a corresponding master public
      key (M)<br>
      using the normal elliptic curve multiplication process m * G that we saw
      in “Public<br>
      Keys” on page 60.</p>
    <p> The chain code (c) is used to introduce entropy in the function that
      creates child keys<br>
      from parent keys, as we will see in the next section.<br>
      Private child key derivation<br>
      HD wallets use a child key derivation (CKD) function to derive child keys
      from parent<br>
      keys.</p>
    <p><br>
      The child key derivation functions are based on a one-way hash function
      that com‐<br>
      bines:<br>
      • A parent private or public key (ECDSA uncompressed key)<br>
      • A seed called a chain code (256 bits)<br>
      • An index number (32 bits)<br>
    </p>
    <p>The chain code is used to introduce deterministic random data to the
      process, so that<br>
      knowing the index and a child key is not sufficient to derive other child
      keys. Know‐<br>
      ing a child key does not make it possible to find its siblings, unless you
      also have the<br>
      chain code. The initial chain code seed (at the root of the tree) is made
      from the seed,<br>
      while subsequent child chain codes are derived from each parent chain
      code.<br>
      These three items (parent key, chain code, and index) are combined and
      hashed to<br>
      generate children keys, as follows.<br>
    </p>
    <p>The parent public key, chain code, and the index number are combined and
      hashed<br>
      with the HMAC-SHA512 algorithm to produce a 512-bit hash. This 512-bit
      hash is<br>
      split into two 256-bit halves. The right-half 256 bits of the hash output
      become the<br>
      chain code for the child. The left-half 256 bits of the hash are added to
      the parent<br>
      private key to produce the child private key. In Малюнок&nbsp; 5-10, we
      see this illustrated<br>
      with the index set to 0 to produce the “zero” (first by index) child of
      the parent.<br>
      Малюнок&nbsp; 5-10. Extending a parent private key to create a child
      private key<br>
      Changing the index allows us to extend the parent and create the other
      children in<br>
      the sequence, e.g., Child 0, Child 1, Child 2, etc. Each parent key can
      have 2,147,483,647 (231) children (231 is half of the entire 232 range
      available because the other half is reserved for a special type of
      derivation we will talk about later in this<br>
      chapter).</p>
    <p> Repeating the process one level down the tree, each child can in turn
      become a parent<br>
      and create its own children, in an infinite number of generations.</p>
    <h3> Using derived child keys</h3>
    <p> Child private keys are indistinguishable from nondeterministic (random)
      keys.<br>
      Because the derivation function is a one-way function, the child key
      cannot be used<br>
      to find the parent key. The child key also cannot be used to find any
      siblings. If you<br>
      have the nth child, you cannot find its siblings, such as the n–1 child or
      the n+1 child,<br>
      or any other children that are part of the sequence. Only the parent key
      and chain<br>
      code can derive all the children. Without the child chain code, the child
      key cannot<br>
      be used to derive any grandchildren either. You need both the child
      private key and<br>
      the child chain code to start a new branch and derive grandchildren.<br>
      So what can the child private key be used for on its own? It can be used
      to make a<br>
      public key and a bitcoin address. Then, it can be used to sign
      transactions to spend<br>
      anything paid to that address.</p>
    <p> A child private key, the corresponding public key, and the bitcoin<br>
      address are all indistinguishable from keys and addresses created<br>
      randomly. The fact that they are part of a sequence is not visible<br>
      outside of the HD wallet function that created them. Once created,<br>
      they operate exactly as “normal” keys.</p>
    <h3> Extended keys</h3>
    <p> As we saw earlier, the key derivation function can be used to create
      children at any<br>
      level of the tree, based on the three inputs: a key, a chain code, and the
      index of the<br>
      desired child. The two essential ingredients are the key and chain code,
      and com‐<br>
      bined these are called an extended key. The term “extended key” could also
      be thought<br>
      of as “extensible key” because such a key can be used to derive children.<br>
      Extended keys are stored and represented simply as the concatenation of
      the 256-bit<br>
      key and 256-bit chain code into a 512-bit sequence. There are two types of
      extended<br>
      keys. An extended private key is the combination of a private key and
      chain code and<br>
      can be used to derive child private keys (and from them, child public
      keys). An exten‐<br>
      ded public key is a public key and chain code, which can be used to create
      child pub‐<br>
      lic keys (public only), as described in “Generating a Public Key” on page
      63.<br>
      Think of an extended key as the root of a branch in the tree structure of
      the HD wal‐<br>
      let. With the root of the branch, you can derive the rest of the branch.
      The extended private key can create a complete branch, whereas the
      extended public key can only create a branch of public keys.</p>
    <p> An extended key consists of a private or public key and chain code.<br>
      An extended key can create children, generating its own branch in<br>
      the tree structure. Sharing an extended key gives access to the<br>
      entire branch.</p>
    <p> Extended keys are encoded using Base58Check, to easily export and import
      between<br>
      different BIP-32–compatible wallets. The Base58Check coding for extended
      keys uses<br>
      a special version number that results in the prefix “xprv” and “xpub” when
      encoded<br>
      in Base58 characters to make them easily recognizable. Because the
      extended key is<br>
      512 or 513 bits, it is also much longer than other Base58Check-encoded
      strings we<br>
      have seen previously.</p>
    <p> Here’s an example of an extended private key, encoded in Base58Check:</p>
    <p> xprv9tyUQV64JT5qs3RSTJkXCWKMyU-<br>
      goQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNM-<br>
      KUga5biW6Hx4tws2six3b9c</p>
    <p> Here’s the corresponding extended public key, encoded in Base58Check:</p>
    <p> xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgy-<br>
      peQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</p>
    <h3> Public child key derivation</h3>
    <p> As mentioned previously, a very useful characteristic of HD wallets is
      the ability to<br>
      derive public child keys from public parent keys, without having the
      private keys.<br>
      This gives us two ways to derive a child public key: either from the child
      private key,<br>
      or directly from the parent public key.</p>
    <p> An extended public key can be used, therefore, to derive all of the
      public keys (and<br>
      only the public keys) in that branch of the HD wallet structure.</p>
    <p> This shortcut can be used to create very secure public key–only
      deployments where a<br>
      server or application has a copy of an extended public key and no private
      keys what‐<br>
      soever. That kind of deployment can produce an infinite number of public
      keys and<br>
      bitcoin addresses, but cannot spend any of the money sent to those
      addresses. Mean‐<br>
      while, on another, more secure server, the extended private key can derive
      all the cor‐<br>
      responding private keys to sign transactions and spend the money.</p>
    <p> One common application of this solution is to install an extended public
      key on a<br>
      web server that serves an ecommerce application. The web server can use
      the public<br>
      key derivation function to create a new bitcoin address for every
      transaction (e.g., for<br>
      a customer shopping cart). The web server will not have any private keys
      that would<br>
      However, the little web store became quite successful and attracted many
      orders from<br>
      the local community. Soon, Gabriel was overwhelmed. With all the orders
      paying the<br>
      same address, it became difficult to correctly match orders and
      transactions, espe‐<br>
      cially when multiple orders for the same amount came in close together.</p>
    <p> Gabriel’s HD wallet offers a much better solution through the ability to
      derive public<br>
      child keys without knowing the private keys. Gabriel can load an extended
      public key<br>
      (xpub) on his website, which can be used to derive a unique address for
      every cus‐<br>
      tomer order. Gabriel can spend the funds from his Trezor, but the xpub
      loaded on the<br>
      website can only generate addresses and receive funds. This feature of HD
      wallets is a<br>
      great security feature. Gabriel’s website does not contain any private
      keys and there‐<br>
      fore does not need high levels of security.</p>
    <p> To export the xpub, Gabriel uses the web-based software in conjunction
      with the Tre‐<br>
      zor hardware wallet. The Trezor device must be plugged in for the public
      keys to be<br>
      exported. Note that hardware wallets will never export private keys—those
      always<br>
      remain on the device. Малюнок&nbsp; 5-12 shows the web interface Gabriel
      uses to export the<br>
      xpub.</p>
    <p> Малюнок&nbsp; 5-12. Exporting an xpub from a Trezor hardware wallet</p>
    <p> Gabriel copies the xpub to his web store’s bitcoin shop software. He
      uses Mycelium<br>
      Gear, which is an open source web-store plugin for a variety of web
      hosting and content platforms. Mycelium Gear uses the xpub to generate a
      unique address for every<br>
      purchase.</p>
    <h3> Hardened child key derivation</h3>
    <p> The ability to derive a branch of public keys from an xpub is very
      useful, but it comes<br>
      with a potential risk. Access to an xpub does not give access to child
      private keys.<br>
      However, because the xpub contains the chain code, if a child private key
      is known, or<br>
      somehow leaked, it can be used with the chain code to derive all the other
      child pri‐<br>
      vate keys. A single leaked child private key, together with a parent chain
      code, reveals<br>
      all the private keys of all the children. Worse, the child private key
      together with a<br>
      parent chain code can be used to deduce the parent private key.</p>
    <p> To counter this risk, HD wallets use an alternative derivation function
      called hard‐<br>
      ened derivation, which “breaks” the relationship between parent public key
      and child<br>
      chain code. The hardened derivation function uses the parent private key
      to derive<br>
      the child chain code, instead of the parent public key. This creates a
      “firewall” in the<br>
      parent/child sequence, with a chain code that cannot be used to compromise
      a parent<br>
      or sibling private key. The hardened derivation function looks almost
      identical to the<br>
      normal child private key derivation, except that the parent private key is
      used as input<br>
      to the hash function, instead of the parent public key, as shown in the
      diagram in<br>
      Малюнок&nbsp; 5-13.<br>
    </p>
    <p>Малюнок&nbsp; 5-13. Hardened derivation of a child key; omits the parent
      public key<br>
    </p>
    <p>Table 5-6. HD wallet path examples<br>
      HD path<br>
      &nbsp;Key described<br>
      m/0<br>
      &nbsp;The first (0) child private key from the master private key (m)<br>
      m/0/0<br>
      &nbsp;The first grandchild private key of the first child (m/0)<br>
      m/0'/0<br>
      &nbsp;The first normal grandchild of the first hardened child (m/0')<br>
      m/1/0<br>
      &nbsp;The first grandchild private key of the second child (m/1)<br>
      M/23/17/0/0 The first great-great-grandchild public key of the first
      great-grandchild of the 18th grandchild of the 24th<br>
      child</p>
    <h3> Navigating the HD wallet tree structure</h3>
    <p> The HD wallet tree structure offers tremendous flexibility. Each parent
      extended key<br>
      can have 4 billion children: 2 billion normal children and 2 billion
      hardened children.<br>
      Each of those children can have another 4 billion children, and so on. The
      tree can be<br>
      as deep as you want, with an infinite number of generations. With all that
      flexibility,<br>
      however, it becomes quite difficult to navigate this infinite tree. It is
      especially diffi‐<br>
      cult to transfer HD wallets between implementations, because the
      possibilities for<br>
      internal organization into branches and subbranches are endless.</p>
    <p> Two BIPs offer a solution to this complexity by creating some proposed
      standards for<br>
      the structure of HD wallet trees. BIP-43 proposes the use of the first
      hardened child<br>
      index as a special identifier that signifies the “purpose” of the tree
      structure. Based on<br>
      BIP-43, an HD wallet should use only one level-1 branch of the tree, with
      the index<br>
      number identifying the structure and namespace of the rest of the tree by
      defining its<br>
      purpose. For example, an HD wallet using only branch m/i'/ is intended to
      signify a<br>
      specific purpose and that purpose is identified by index number “i.”</p>
    <p> Extending that specification, BIP-44 proposes a multiaccount structure
      as “purpose”<br>
      number 44' under BIP-43. All HD wallets following the BIP-44 structure are
      identi‐<br>
      fied by the fact that they only used one branch of the tree: m/44'/.<br>
      BIP-44 specifies the structure as consisting of five predefined tree
      levels:<br>
      m / purpose' / coin_type' / account' / change / address_index</p>
    <p> The first-level “purpose” is always set to 44'. The second-level
      “coin_type” specifies<br>
      the type of cryptocurrency coin, allowing for multicurrency HD wallets
      where each<br>
      currency has its own subtree under the second level. There are three
      currencies<br>
      defined for now: Bitcoin is m/44'/0', Bitcoin Testnet is m/44'/1', and
      Litecoin is<br>
      m/44'/2'.</p>
    <p> The third level of the tree is “account,” which allows users to
      subdivide their wallets<br>
      into separate logical subaccounts, for accounting or organizational
      purposes. For<br>
      example, an HD wallet might contain two bitcoin “accounts”: m/44'/0'/0'
      and<br>
      m/44'/0'/1'. Each account is the root of its own subtree.<br>
    </p>
    <p><br>
      On the fourth level, “change,” an HD wallet has two subtrees, one for
      creating receiv‐<br>
      ing addresses and one for creating change addresses. Note that whereas the
      previous<br>
      levels used hardened derivation, this level uses normal derivation. This
      is to allow this<br>
      level of the tree to export extended public keys for use in a nonsecured
      environment.<br>
      Usable addresses are derived by the HD wallet as children of the fourth
      level, making<br>
      the fifth level of the tree the “address_index.” For example, the third
      receiving address<br>
      for bitcoin payments in the primary account would be M/44'/0'/0'/0/2.
      Table 5-7<br>
      shows a few more examples.<br>
      Table 5-7. BIP-44 HD wallet structure examples<br>
      HD path<br>
      &nbsp;Key described<br>
      M/44'/0'/0'/0/2<br>
      &nbsp;The third receiving public key for the primary bitcoin account<br>
      M/44'/0'/3'/1/14 The fifteenth change-address public key for the fourth
      bitcoin account<br>
      m/44'/2'/0'/0/1</p>
    <p>&nbsp; The second private key in the Litecoin main account, for signing
      transactions<br>
    </p>
    <h2>ГЛАВА 6</h2>
    <h1> Транзакції</h1>
    <h3> Вступ</h3>
    <p> Транзакції є найбільш важливою частиною системи біткоіну. Все інше в
      біткоіні розроблене, щоб впевнитись, що транзакції можуть бути створені,
      розповсюджені в мережі, перевірені, та, нарешті, додані до глобального
      реєстру транзакцій (блокчейну). Транзакції є структурами даних, що кодують
      трансфер вартості між учасниками системи біткоіна. Кожна транзакція є
      публічним записом в блокчейні біткоіна, глобальному реєстрі бухгалтерії з
      подвійною реєстрацією. В цій главі ми будемо досліджувати всі різноманітні
      форми транзакцій, що вони мають містити, як вони створюються, як вони
      перевіряються, та як вони стають частиною сталого запису всіх транзакцій.
      Коли ми використовуємо термін “гаманець” в цій главі, ми посилаємось не
      тільки базу даних ключів, але також на програмне забезпечення, що
      конструює транзакції.</p>
    <h3> Транзакції в деталях</h3>
    <p> В Главі 2 ми подивились на транзакцію Аліси, що викостала її для
      придбання кофе в кав'ярні Боба, використовуючи переглядач блоків (Малюнок
      6-1). Застосування переглядача блоків показує транзакцію з алісиної
      “адреси” на<br>
      “адресу” Боба. Це досить спрощений погляд на те, що міститься в
      транзакції. Фактично, як ми побачимо в ції главі, більшість показаної
      інформації сконструйована переглядачем блоків, та, насправді , не є
      частиною транзакції.<br>
      <br>
      Малюнок 6-1. Транзакція Аліси до Боба</p>
    <h3> Транзакції: за лаштунками сцени</h3>
    <p> За лаштунками сцени справжня транзакція виглядає дуже відмінно від
      транзакції, що провадиться типовим переглядачем блоків. Фактично,
      більшість високорівневих конструкцій, що ми бачили в різних застосуваннях
      користувацького інтерфейсу біткоіну, неасправді не існують в системі
      біткоіну.</p>
    <p> Ми можемо використовувати інтерфейс командного рядка Bitcoin Core
      (getrawtransaction та decoder<br>
      awtransaction) для отримання “сирої” транзакції Аліси, її декодування, щоб
      побачити, що вона містить насправді. Результат виглядає таким чином:</p>
    <pre>      {</pre>
    <pre>      "version": 1,</pre>
    <pre>      "locktime": 0,</pre>
    <pre>      "vin": [</pre>
    <pre>      {</pre>
    <pre>      "txid":</pre>
    <pre>      "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",</pre>
    <pre>      "vout": 0,</pre>
    <pre>      "scriptSig" :</pre>
    <pre>"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204</pre>
    <pre>      b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL]</pre>
    <pre>0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1</pre>
    <pre>      72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",</pre>
    <pre>      "sequence": 4294967295</pre>
    <pre>      }</pre>
    <pre>      ],</pre>
    <pre>      "vout": [</pre>
    <pre>      {</pre>
    <pre>      	"value": 0.01500000,</pre>
    <pre>      	"scriptPubKey": "OP_DUP OP_HASH160</pre>
    <pre>      	ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"</pre>
    <pre>      },</pre>
    <pre>      {</pre>
    <pre>      	"value": 0.08450000,</pre>
    <pre>      	"scriptPubKey": "OP_DUP OP_HASH160</pre>
    <pre>      	7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <pre>      }</pre>
    <p><br>
    </p>
    <p>Ви можете помітити декілька речей щодо транзакції, здебільшого речі, що
      відсутні! Де тут адреса Аліси? Де адреса Боба? Де вхід 0.1, “надісланий ”
      Алісою? В біткоіні немає ані монет, ані надсилача або отримувача, немає
      балансу, ані разунків, та немає і адрес. Всі ці речі конструюються на
      вищому рівні для вигід користувача, щоб зробити речі простішими для
      розуміння.</p>
    <p> Ви також могли помітити багато дивних та неочікуваних полів та
      шістнадцятирічних рядків. Не турбуйтесь, в цій главі ми детально пояснимо
      кожне показане тут поле.</p>
    <h3> Виходи та входи транзакцій</h3>
    <p> Фундаментальним будівним блоком транзакцій біткоіну є вихід транзакції.
      Виходи транзакцій є неподільні частки валюти біткоіну, записчані на
      блокчейні, та визнані як валідні всією мережею. Повні вузли біткоіну
      відсліджують всі доступні та витратні виходи, відомі як невитрачені виходи
      транзакцій (unspent transaction outputs, скорочено UTXO). Множина всіх
      UTXO відома як UTXO-множина, наразі налічує мільйони UTXO. UTXO-множина
      зростає по мірі того, як створюються нові UTXO, та зменшується по мірі
      споживання UTXO. Кожна транзакція представляє зміну (перезід стану) в
      наборі UTXO.</p>
    <p> Коли ми кажемо, що гаманець користувача “отримав” біткоін, ми маємо на
      увазі, що гаманець детектував UTXO, що може бути витрачене за допомогою
      одного з ключів, які контролюються цім гаманцем. Таким чином біткоіновим
      “балансом” користувача є сума всіх UTXO, що може витрачати гаманець
      користувача, та що можуть бути розкидані по сотням транзакцій та сотням
      блоків. Концепція балансу створюється застосуванням гаманця. Гаманець
      обчислює баланс користувача, сканучи блокчейн та накопичуючи вартість
      кожного UTXO, які гаманець може витратити за допомогою ключів, що
      контролює. Більшість гаманців підтримують базу даних, щоб зберігати швидке
      посилання на всі UTXO, які вони можуть витратити за допомогою
      контрольованих ключів.</p>
    <p> Вихід транзакції може бути мати довільне (ціле) значення, визначене як
      кількість сатоші. Так само, як долар може бути поділений до двох
      десятичних значень в якості центів, біткоіни можуть бути поділені до
      восьми десятичних позицій, як сатоші. Хоча вихід може мати довільне
      значення, коли створений, він стає неділимим. Це важлива характеристика
      виходів, на яку треба зробити наголос: виходи є дискретними та
      неподільними одиницями вартості, визначені в цілих сатоші. Невитрачений
      вихід може бути спожитий транзакцією тільки цілим. Якщо UTXO більший, ніж
      бажана віртість транзакції, він все одне має бути спожитим цілим, та для
      транзакції має бути згенерована решта. Іншими словами, якщо ви маєте UTXO
      вартістю 20 біьткоін, та бажаєте сплатити тільки 1 біткоін, ваша
      транзакція має спожити весь 20-біткоіновий UTXO, та спродукувати два
      виходи: один сплачує 1 біткоін до вашого бажаного отримувача, та інший
      платить 19 біткоінів решти на ваш гаманець. Як результат неподільної
      природи виходів транзакції, більшість біткоін транзакцій будуть генерувати
      решту. Уявіть покупця, який бажає придбати напій за $1.50, що бере власний
      гаманець, та намагаєтсья знайти комбінацію з монет та банкнот, щоб скласти
      суму в $1.50. Покупець обере точну суму, якщо це можливо, тобто долар і
      дві чверті ($0.25), або комбінацію менших номіналів (наприклад, шість
      чвертей), або, якщо необхідно, більшу купюру, як $5. Якщо покупець дасть
      власнику магазину більше грошей, скажімо, $5, він буде очікувати решту
      $3.50, що надійдуть назад в гаманець, та будуть доступні для подальших
      транзакцій. Подібно до цього, транзакції біткоін мають бути створені з
      користувацького UTXO, в тих номіналах, які доступні користувачеві.
      Користувач не може обрізати UTXO навпіл, як він не може перерізати
      доларову банкноту навпіл, та використовувати частини як гроші.
      Користувацьке застосування гаманця типово буде обирати між доступними UTXO
      користувача для компонування суми, більшої або рівної до бажаної суми
      транзакції. Як і в реальному житті, застосування біткоін може
      використовувати різні стратегії, щоб задовільнити вимогам придбання:
      комбінувати декілька менших одиниць, пошук точної решти, або пошук єдиної
      одиниці, що більше ніж сума транзакції, та утворення решти. Всі з ціх
      складних комбінацій витратних UTXO виконуєтья гаманцем користувача
      автоматично, та невидимо для користувача. Це має значення тільки в
      випадку, якщо ви програмно конструююте сирі транзакції з UTXO. </p>
    <p>Транзакція споживає попередньо записані невитрачені виходи транзакцій, та
      створює нові виходи транзакцій, що можуть бути спожиті в подальших
      транзакціях. Таким чином, частки вартості біткоін рухаються далі, від
      власника до власника, в ланцюгу транзакцій, що споживають та створюють
      UTXO. </p>
    <p>Виключення до ланцюга входів та виходів є особливий тип транзакцій, що
      називаються коінбейс транзакціями в кожному блоці. Ця транзакція
      записуєтсья “переможним” майнером, та створює повністю нові біткоіни,
      якими майнер може розраховуватись в якості винагороди за майнинг. Ця
      особлива коінбейс транзакція не споживає UTXO; замість цього, це особливий
      тип входу з назвою “коінбейс”. Саме в цей спосіб створюється біткоін в
      результаті процесу майнингу, як ми побачимо в Главі 10. </p>
    <p> Що виникло першим, входи або виходи, курча або яйце? Кажучи відверто,
      виходи надходять першими, завдяки коінбейс транзакціям, що генерують новий
      біткоін, не маючи входів, та створюючи виходи з нічого.</p>
    <h3> Виходи транзакцій</h3>
    <p> Кожна транзакція біткоін створює виходи, що записуються в реєстрі
      біткоіна. Майже всі з ціх виходів, за одним виключенням (дивіться “Вихід
      запису даних (RETURN)”), створюють витратні частини біткоіна, що
      називаються UTXO, що потім розпізнаються всією мережею, та доступні для
      власника, щоб споживати в наступній транзакції.</p>
    <p> UTXO відсліджуються кожним повним вузлом біткоін, в наборі UTXO. нові
      транзакції споживають (вирачають) один або більше з ціх виходів з набору
      UTXO.</p>
    <p> Виходи транзакцій складаютья з двох частин:</p>
    <p> • Сума біткоін, виражена в сатоші, найменьшій одиниці біткоіна<br>
      • Криптографічна загадка, що визначає умови, потрібні для витрачання
      виходу<br>
    </p>
    <p>Криптографічна загадка, також відома як блокуючий скрипт, або
      підтверджуючий скрипт, або scriptPubKey.<br>
    </p>
    <p>Скриптова мова транзакцій, що використовується в згаданому блокуючому
      скрипті, обговорюється в деталях в “Скрипти транзакцій та скриптова мова”.
      Тепер давайте поглянемо на транзакцю Аліси (показану раніше в цій главі),
      та подивимось, чи ми зможемо ідентифікувати виходи. В кодуванні JSON
      виходи надходять в масиві (списку) на ім'я vout:</p>
    <pre>      "vout": [</pre>
    <pre>      {</pre>
    <pre>      "value": 0.01500000,</pre>
    <pre>      "scriptPubKey": "OP_DUP OP_HASH160
      ab68025513c3dbd2f7b92a94e0581f5d50f654e7</pre>
    <pre>      OP_EQUALVERIFY</pre>
    <pre>      OP_CHECKSIG"</pre>
    <pre>      },</pre>
    <pre>      {</pre>
    <pre>      "value": 0.08450000,</pre>
    <pre>      "scriptPubKey": "OP_DUP OP_HASH160
      7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8</pre>
    <pre>      OP_EQUALVERIFY OP_CHECKSIG",</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <p> Як ви можете бачити, транзакція містить два виходи. Кожинй вихід
      визначений через значення та криптографічну загадку. В кодуванні Bitcoin
      Core, значення надане в біткоінах, але сама транзакція записана як ціле,
      деноміноване в сатоші. Друга частина кожного виходу є криптографічна
      загадка, що визначає умови витрачання. Bitcoin Core показує це як
      scriptPubKey, так показує нам людино-орієнтоване представлення скрипта.</p>
    <p> Тема блокування та розблокування UTXO буде обговорюватись пізніше, в
      розділі “Конструкція скрипта (блокування + розблокування)”. Мова скриптів,
      що використовується для скрипта в scriptPubKey, обговорюється в “Скрипти
      транзакцій та мова скриптів”. Але перед тим, як ми заглибимось в ці теми,
      нам треба зрозуміти загальну структуру входів та виходів транзакцій.</p>
    <h3> Серіалізація транзакцій - виходи</h3>
    <p> Коли транзакція передаєтся по мережі, або обміюється між застосуваннями,
      вона серіалізується. Сериалізація є процесом конвертації внутрішнього
      представлення структури даних в формат, що може бути переданий байт за
      байтом, що також відоме як потік байтів. Сериалізація найбільш загально
      використовується для кодування структур даних, для передачі по мережі або
      для зберігання в файлі. Формат сериалізації транзакції показаний в Таблиці
      6-1.<br>
    </p>
    <p>Таблиця 6-1. Сериалізація виходу транзакції<br>
    </p>
    <p>Розмір &nbsp;&nbsp;&nbsp; Поле&nbsp;&nbsp;&nbsp; Опис</p>
    <p>8 байт (little-endian) Сума Вартість біткоін в сатоші (10-8 біткоіну)<br>
      1–9 bytes (VarInt)&nbsp; Розмір блокуючого скрипта в байтах<br>
      Зміний Блокуючий скрипт, що визначає умови, потрібні для витрати виходу<br>
    </p>
    <p>Більшість бібліотек та фреймворків біткоіну не зберігають транзакції самі
      по собі як потоки байтів, бо знадобиться складний робір кожного разу, коли
      треба отримати доступ до одного поля. Для зручності та читаємості
      біблиотеки біткоін зберігають транзакції всередині як структури даних
      (зазавичай, об'єктно-орієнтованих структурах).<br>
    </p>
    <p>Процес перетворення від представлення байт-потоку транзакцій до
      внутрішньої структури даних бібліотеки має назву десеариалізації, або
      розбором транзації. Процес конвертації в зворотньому напрямку до потоку
      байтів для передачі по мережі , хешування, або зберігання на диску, має
      назву сериалізації. Більшість бібліотек біткоін мають вбудовані функції
      для перетворень сериалізації та десеариалізації.</p>
    <p> Подивимось, чи ви зможнте вручну декодувати транзакцію Аліси з
      серіалізованої щістнадцятиричної форми, винайшовши деякі з елементів, що
      ми бачили разніше. Розділ містить два виходи в Прикладі 6-1, щоб допомогти
      вам:<br>
      <br>
      Приклад 6-1. Транзакція Аліси, серіалізована та представлена в
      шістнадцятирічній нотації<br>
    </p>
    <p>0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73<br>
      4d2804fe65fa35779000000008b483045022100884d142d86652a3f47<br>
      ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039<br>
      ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813<br>
      01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84<br>
      16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1<br>
      7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6<br>
      8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000<br>
      1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac 00000000<br>
    </p>
    <p>Ось деякі підказки:<br>
      • Тут два виходи в підкресленому розділі, кожний серіалізований як
      показано в Таблиці 6-1.<br>
      • Значення 0.015 біткоіннів те саме, що 1,500,000 сатоші. Це 16 e3 60
      шістнадцятерічною.<br>
      • В серіалізованій транзакції значення 16 e3 60 закодоване в порядку байт
      little-endian (найменш значущий байт перший), так що це виглядає 60 e3 16.<br>
      • Довжина scriptPubKey є 25 байт, що шістнадцятирічною є 19.</p>
    <h3> Входи транзакції</h3>
    <p> Входи транзакції ідентифікують (через посилання), UTXO, що буде спожите,
      та провадить доказ власності через посередництво розблокуючого скрипта.</p>
    <p> Щоб побудувати транзакцію, гаманець обирає з контрольованих ним UTXO,
      UTXO з достатньою вартістю, щоб зробити запитаний платіж. Іноді досить
      одного UTXO, іншого разу потрібно більше одного. Для кожного UTXO, що буде
      спожите для виконання цього платежу, гаманець створює один вхід, що вказує
      на UTXO, та відмикає його за допомогою розблокуючого скрипта. </p>
    <p> Давайте подивимось на компоненти входу більш детально. Черша частина
      входу є вказівник на UTXO через посилання на хеш транзакції, та номера
      послідовності, де UTXO записаний в блокчейні. Друга частина є розблокуючий
      скрипт, що конструює гаманець, щоб задовільнити умові витрачання,
      встановленій в UTXO. ЧАстіше за все розблокуючий скрипт є цифровим
      підписом та публічним ключем, що провадять власність біткоіну. Однак, не
      всі відмикаючі скрипти містять сигнатури. Третя частина є послідовним
      номером, що буде обговорене пізніше.</p>
    <p>Розглянемо наш приклад в “Транзакції: за лаштунками сцени”. В ходи
      транзакції є масивом (списком), що називаються vin:<br>
    </p>
    <pre>      "vin": [</pre>
    <pre>      {</pre>
    <pre>      "txid":
      "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",</pre>
    <pre>      "vout": 0,</pre>
    <pre>      "scriptSig" :</pre>
    <pre>"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204</pre>
    <pre>      b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL]</pre>
    <pre>0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1</pre>
    <pre>      72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",</pre>
    <pre>      "sequence": 4294967295</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <p> Як ви бачите, в списку тільки один вхід (оскільки один UTXO містить
      досить вартості для платежу). Вхід містить чотири елементи:<br>
      • ID транзакції, що посилаєтсья на транзакцію, що містить UTXO, що буде
      витрачено<br>
      • Інедкс виходу (vout), що ідентифікує, на який UTXO з транзакції іде
      посилання (починаючи з нуля)<br>
      • scriptSig, що задовільняє умовам, покладеним до UTXO, що розблокує для
      витрачання<br>
      • Послідовний номер (обговорюється пізніше)<br>
    </p>
    <p>В транзакції Аліси вхід вказує на ID транзакції:</p>
    <pre>      7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18<br>
      </pre>
    <p>та індекс входу 0 (тобто, це перший UTXO, створений цією транзакцією).
      Розблокуючий скрипт побудований гаманцем Аліси, зпершу отримавши посиланий
      UTXO, перевіривши блокуючий скрипт, та потім використовуючи його для
      побудови потрібного розблокуючого скрипту, що задовільнить йому.<br>
    </p>
    <p>Дивлячись тільки на вхід, ви можете помітити, що ми нічого не знаємо щодо
      цього UTXO, окрім посилання на транзакцію, що містить його. Ми не знаємо
      його вартість (кількість сатоші), та ми не знаємо блокуючий скрипт, що
      встановлює умови для його витрачання. Щоб знайти цю інформацію, ми повинні
      отримати посилане UTXO, отримавши підлеглу транзакцію. Зауважте, що
      оскільки вартість входу явно не зазначена, нам треба також використовувати
      посилане UTXO, щоб обчислити комісійні, що будуть сплачені за транзакцію
      (дивіться “Комісійні за транзакцію”). Це не тільки гаманець Аліси, хто
      потребує отримати UTXO, посиланий у вході. Коли ця транзакція поширюється
      мережею, кожний перевіряючий вузол також буде потребувати отримання UTXO,
      на який посилаються як на вхід транзакції, щоб перевірити транзакцію.<br>
      <br>
      Транзакції самі по собі виглядають неповними, бо їм бракує контексту. Вони
      посилаються на UTXO у своїх входах, але без отримання ціх UTXO ми не
      можемо знати вартість входів, або їх блокуючі умови. Коли пишете програмне
      забезпечення біткоін, кожного разу, коли ви декодуєте транзакцію з наміром
      її перевірки, або з метою підрахування комісійних, або перевіряючі
      розблокуючих скрипт, ваш код зпочатку має отримати посилане UTXO з
      блокчейна, щоб побудувати контекст, що мається на увазі, але не присутній
      в UTXO посиланнях у входах. Наприклад, щоб обчислити суму, сплачену як
      комісійні, вам треба знати суму значень входів та виходів. Але без
      отримання UTXO посилань у входах, ви не знаєте їх вартість. Так що на
      перший вигляд проста операція, як підрахунок комісійних однієї транзакції,
      фактчно включає багато кроків та даних з декількох транзакцій.</p>
    <p> Ми можемо використати ту саму послідовність команд за допомогою Bitcoin
      Core, що ми використовували, коли отримували транзакцію Аліси
      (getrawtransaction та decoderawtransaction). Таким чином ми можемо
      отримати посилане&nbsp; UTXO в попередньому вході, та поглянути на нього:</p>
    <pre>      "vout": [</pre>
    <pre>      {</pre>
    <pre>      "value": 0.10000000,</pre>
    <pre>      "scriptPubKey": "OP_DUP OP_HASH160</pre>
    <pre>      7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <p> Ми бачимо, що цей UTXO має значення 0.1 BTC, та що він має блокуючий
      скрипт (PubKey), що містить “OP_DUP OP_HASH160...”.</p>
    <p>Щоб повністю зрозуміти транзакцію Аліси, нам треба отримати попередні
      транзакції, на які є повилання у вході. Функція, що отримує попередні
      транзакції та невитрачені транзакції, є дуже загальною, та існує для
      кожної бібліотеки та API біткоіну.</p>
    <h3> Сериалізація транзакцій: входи</h3>
    <p> Коли транзакції суриалізуються для передачі по мережі, їх входи
      кодуються в потік байтів, як показано в Таблиці 6-2.<br>
    </p>
    <p>Таблиця 6-2. Сериалізація входів транзакцій<br>
    </p>
    <p>Розмір&nbsp; Поле&nbsp; Опис<br>
      32 байт&nbsp; Хеш транзакції&nbsp;&nbsp; Вказівник на транзакцію, що
      містить UTXO до витрати<br>
      4 байти&nbsp; Індекс виходу Номер індексу UTXO, що буде витрачено; перший
      індекс 0<br>
      1–9 байт (VarInt) Розмір розблокуючого скрипта в байтах<br>
      Variable Розблокуючий скрипт, що задовільняє умовам блокуючого скрипта
      UTXO<br>
      4 байти Послідовний номер, використовується для часу блокування, або
      відключене (0xFFFFFFFF)<br>
      <br>
      Так само, як для виходів. давайте поглянемо, чи ми можемо знайти входи з
      транзакції Аліси в серіалізованому форматі. Зпершу, декодуємо формат
      входів: </p>
    <p><br>
    </p>
    <pre>"vin": [
 {
 "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
 "vout": 0,
 "scriptSig" :
"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204
b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL]
0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1
72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
 "sequence": 4294967295
 }
], </pre>
    <p>Тепер давайте подивимось, чи ми можемо ідентифікувати ці поля в
      серіалізованому шістнадцятирічному кодування в Прикладі 6-2: </p>
    <p>Example 6-2. Alice’s transaction, serialized and presented in hexadecimal
      notation </p>
    <p>0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73
      4d2804fe65fa35779000000008b483045022100884d142d86652a3f47
      ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039
      ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813
      01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84
      16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1
      7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6
      8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000
      1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000 000 </p>
    <p>Hints: </p>
    <p>• The transaction ID is serialized in reversed byte order, so it starts
      with (hex) 18 and ends with 79 • The output index is a 4-byte group of
      zeros, easy to identify • The length of the scriptSig is 139 bytes, or 8b
      in hex • The sequence number is set to FFFFFFFF, again easy to identify </p>
    <h3>Transaction Fees</h3>
    <p>Most transactions include transaction fees, which compensate the bitcoin
      miners for securing the network. Fees also serve as a security mechanism
      themselves, by making it economically infeasible for attackers to flood
      the network with transactions. Min‐ 126 | Chapter 6: Transactions ing and
      the fees and rewards collected by miners are discussed in more detail in
      Chapter 10.</p>
    <p> This section examines how transaction fees are included in a typical
      transaction.<br>
      Most wallets calculate and include transaction fees automatically.
      However, if you are<br>
      constructing transactions programmatically, or using a command-line
      interface, you<br>
      must manually account for and include these fees.</p>
    <p> Transaction fees serve as an incentive to include (mine) a transaction
      into the next<br>
      block and also as a disincentive against abuse of the system by imposing a
      small cost<br>
      on every transaction. Transaction fees are collected by the miner who
      mines the block<br>
      that records the transaction on the blockchain.</p>
    <p> Transaction fees are calculated based on the size of the transaction in
      kilobytes, not<br>
      the value of the transaction in bitcoin. Overall, transaction fees are set
      based on mar‐<br>
      ket forces within the bitcoin network. Miners prioritize transactions
      based on many<br>
      different criteria, including fees, and might even process transactions
      for free under<br>
      certain circumstances. Transaction fees affect the processing priority,
      meaning that a<br>
      transaction with sufficient fees is likely to be included in the next
      block mined,<br>
      whereas a transaction with insufficient or no fees might be delayed,
      processed on a<br>
      best-effort basis after a few blocks, or not processed at all. Transaction
      fees are not<br>
      mandatory, and transactions without fees might be processed eventually;
      however,<br>
      including transaction fees encourages priority processing.</p>
    <p> Over time, the way transaction fees are calculated and the effect they
      have on transac‐<br>
      tion prioritization has evolved. At first, transaction fees were fixed and
      constant<br>
      across the network. Gradually, the fee structure relaxed and may be
      influenced by<br>
      market forces, based on network capacity and transaction volume. Since at
      least the<br>
      beginning of 2016, capacity limits in bitcoin have created competition
      between trans‐<br>
      actions, resulting in higher fees and effectively making free transactions
      a thing of the<br>
      past. Zero fee or very low fee transactions rarely get mined and sometimes
      will not<br>
      even be propagated across the network.</p>
    <p> In Bitcoin Core, fee relay policies are set by the minrelaytxfee option.
      The current<br>
      default minrelaytxfee is 0.00001 bitcoin or a hundredth of a millibitcoin
      per kilo‐<br>
      byte. Therefore, by default, transactions with a fee less than 0.0001
      bitcoin are treated<br>
      as free and are only relayed if there is space in the mempool; otherwise,
      they are<br>
      dropped. Bitcoin nodes can override the default fee relay policy by
      adjusting the value<br>
      of minrelaytxfee.</p>
    <p> Any bitcoin service that creates transactions, including wallets,
      exchanges, retail<br>
      applications, etc., must implement dynamic fees. Dynamic fees can be
      implemented<br>
      through a third-party fee estimation service or with a built-in fee
      estimation algo‐<br>
      rithm. If you’re unsure, begin with a third-party service and as you gain
      experience<br>
      design and implement your own algorithm if you wish to remove the
      third-party<br>
      dependency.</p>
    <p> Fee estimation algorithms calculate the appropriate fee, based on
      capacity and the<br>
      fees offered by “competing” transactions. These algorithms range from
      simplistic<br>
      (average or median fee in the last block) to sophisticated (statistical
      analysis). They<br>
      estimate the necessary fee (in satoshis per byte) that will give a
      transaction a high<br>
      probability of being selected and included within a certain number of
      blocks. Most<br>
      services offer users the option of choosing high, medium, or low priority
      fees. High<br>
      priority means users pay higher fees but the transaction is likely to be
      included in the<br>
      next block. Medium and low priority means users pay lower transaction fees
      but the<br>
      transactions may take much longer to confirm.</p>
    <p> Many wallet applications use third-party services for fee calculations.
      One popular<br>
      service is http://bitcoinfees.21.co, which provides an API and a visual
      chart showing<br>
      the fee in satoshi/byte for different priorities.</p>
    <p> Static fees are no longer viable on the bitcoin network. Wallets that<br>
      set static fees will produce a poor user experience as transactions<br>
      will often get “stuck” and remain unconfirmed. Users who don’t<br>
      understand bitcoin transactions and fees are dismayed by “stuck”<br>
      transactions because they think they’ve lost their money.</p>
    <p> The chart in Малюнок&nbsp; 6-2 shows the real-time estimate of fees in
      10 satoshi/byte incre‐<br>
      ments and the expected confirmation time (in minutes and number of blocks)
      for<br>
      transactions with fees in each range. For each fee range (e.g., 61–70
      satoshi/byte), two<br>
      horizontal bars show the number of unconfirmed transactions (1405) and
      total num‐<br>
      ber of transactions in the past 24 hours (102,975), with fees in that
      range. Based on<br>
      the graph, the recommended high-priority fee at this time was 80
      satoshi/byte, a fee<br>
      likely to result in the transaction being mined in the very next block
      (zero block<br>
      delay). For perspective, the median transaction size is 226 bytes, so the
      recommended<br>
      fee for a transaction size would be 18,080 satoshis (0.00018080 BTC).</p>
    <p> The fee estimation data can be retrieved via a simple HTTP REST API, at
      https://<br>
      bitcoinfees.21.co/api/v1/fees/recommended. For example, on the command
      line using<br>
      the curl Команда:</p>
    <p> $ curl https://bitcoinfees.21.co/api/v1/fees/recommended<br>
      {"fastestFee":80,"halfHourFee":80,"hourFee":60}<br>
      The API returns a JSON object with the current fee estimate for fastest
      confirmation<br>
      (fastestFee), confirmation within three blocks (halfHourFee) and six
      blocks (hour<br>
      Fee), in satoshi per byte.<br>
      <br>
      Малюнок&nbsp; 6-2. Fee estimation service bitcoinfees.21.co</p>
    <h3> Adding Fees to Transactions</h3>
    <p> The data structure of transactions does not have a field for fees.
      Instead, fees are<br>
      implied as the difference between the sum of inputs and the sum of
      outputs. Any<br>
      excess amount that remains after all outputs have been deducted from all
      inputs is the<br>
      fee that is collected by the miners:</p>
    <p> Fees = Sum(Inputs) – Sum(Outputs)<br>
    </p>
    <p>This is a somewhat confusing element of transactions and an important
      point to<br>
      understand, because if you are constructing your own transactions you must
      ensure<br>
      you do not inadvertently include a very large fee by underspending the
      inputs. That<br>
      means that you must account for all inputs, if necessary by creating
      change, or you<br>
      will end up giving the miners a very big tip!<br>
      For example, if you consume a 20-bitcoin UTXO to make a 1-bitcoin payment,
      you<br>
      must include a 19-bitcoin change output back to your wallet. Otherwise,
      the 19-<br>
      bitcoin “leftover” will be counted as a transaction fee and will be
      collected by the<br>
      miner who mines your transaction in a block. Although you will receive
      priority pro‐<br>
      cessing and make a miner very happy, this is probably not what you
      intended.<br>
      If you forget to add a change output in a manually constructed<br>
      transaction, you will be paying the change as a transaction fee.<br>
      “Keep the change!” might not be what you intended.<br>
      Let’s see how this works in practice, by looking at Alice’s coffee
      purchase again. Alice<br>
      wants to spend 0.015 bitcoin to pay for coffee. To ensure this transaction
      is processed<br>
      promptly, she will want to include a transaction fee, say 0.001. That will
      mean that the<br>
      total cost of the transaction will be 0.016. Her wallet must therefore
      source a set of<br>
      UTXO that adds up to 0.016 bitcoin or more and, if necessary, create
      change. Let’s say<br>
      her wallet has a 0.2-bitcoin UTXO available. It will therefore need to
      consume this<br>
      UTXO, create one output to Bob’s Cafe for 0.015, and a second output with
      0.184 bit‐<br>
      coin in change back to her own wallet, leaving 0.001 bitcoin unallocated,
      as an<br>
      implicit fee for the transaction.</p>
    <p> Now let’s look at a different scenario. Eugenia, our children’s charity
      director in the<br>
      Philippines, has completed a fundraiser to purchase schoolbooks for the
      children. She<br>
      received several thousand small donations from people all around the
      world, totaling<br>
      50 bitcoin, so her wallet is full of very small payments (UTXO). Now she
      wants to<br>
      purchase hundreds of schoolbooks from a local publisher, paying in
      bitcoin.<br>
      As Eugenia’s wallet application tries to construct a single larger payment
      transaction,<br>
      it must source from the available UTXO set, which is composed of many
      smaller<br>
      amounts. That means that the resulting transaction will source from more
      than a<br>
      hundred small-value UTXO as inputs and only one output, paying the book
      pub‐<br>
      lisher. A transaction with that many inputs will be larger than one
      kilobyte, perhaps a<br>
      kilobyte or several kilobytes in size. As a result, it will require a much
      higher fee than<br>
      the median-sized transaction.</p>
    <p> Eugenia’s wallet application will calculate the appropriate fee by
      measuring the size of<br>
      the transaction and multiplying that by the per-kilobyte fee. Many wallets
      will over‐<br>
      pay fees for larger transactions to ensure the transaction is processed
      promptly. The<br>
      higher fee is not because Eugenia is spending more money, but because her
      transac‐<br>
      tion is more complex and larger in size—the fee is independent of the
      transaction’s<br>
      bitcoin value.<br>
    </p>
    <h3> Transaction Scripts and Script Language</h3>
    <p> The bitcoin transaction script language, called Script, is a Forth-like
      reverse-polish<br>
      notation stack-based execution language. If that sounds like gibberish,
      you probably<br>
      haven’t studied 1960s programming languages, but that’s ok—we will explain
      it all in<br>
      this chapter. Both the locking script placed on a UTXO and the unlocking
      script are<br>
      written in this scripting language. When a transaction is validated, the
      unlocking<br>
      script in each input is executed alongside the corresponding locking
      script to see if it<br>
      satisfies the spending condition.</p>
    <p> Script is a very simple language that was designed to be limited in
      scope and exe‐<br>
      cutable on a range of hardware, perhaps as simple as an embedded device.
      It requires<br>
      minimal processing and cannot do many of the fancy things modern
      programming<br>
      languages can do. For its use in validating programmable money, this is a
      deliberate<br>
      security feature.</p>
    <p> Today, most transactions processed through the bitcoin network have the
      form “Pay‐<br>
      ment to Bob’s bitcoin address” and are based on a script called a
      Pay-to-Public-Key-<br>
      Hash script. However, bitcoin transactions are not limited to the “Payment
      to Bob’s<br>
      bitcoin address” script. In fact, locking scripts can be written to
      express a vast variety<br>
      of complex conditions. In order to understand these more complex scripts,
      we must<br>
      first understand the basics of transaction scripts and script language.<br>
      In this section, we will demonstrate the basic components of the bitcoin
      transaction<br>
      scripting language and show how it can be used to express simple
      conditions for<br>
      spending and how those conditions can be satisfied by unlocking scripts.<br>
      Bitcoin transaction validation is not based on a static pattern, but<br>
      instead is achieved through the execution of a scripting language.<br>
      This language allows for a nearly infinite variety of conditions to be<br>
      expressed. This is how bitcoin gets the power of “programmable<br>
      money.”</p>
    <h3> Turing Incompleteness</h3>
    <p> The bitcoin transaction script language contains many operators, but is
      deliberately<br>
      limited in one important way—there are no loops or complex flow control
      capabili‐<br>
      ties other than conditional flow control. This ensures that the language
      is not Turing<br>
      Complete, meaning that scripts have limited complexity and predictable
      execution<br>
      times. Script is not a general-purpose language. These limitations ensure
      that the lan‐<br>
      guage cannot be used to create an infinite loop or other form of “logic
      bomb” that<br>
      could be embedded in a transaction in a way that causes a
      denial-of-service attack<br>
      against the bitcoin network. Remember, every transaction is validated by
      every full<br>
      node on the bitcoin network. A limited language prevents the transaction
      validation<br>
      mechanism from being used as a vulnerability.</p>
    <h3> Stateless Verification</h3>
    <p> The bitcoin transaction script language is stateless, in that there is
      no state prior to<br>
      execution of the script, or state saved after execution of the script.
      Therefore, all the<br>
      information needed to execute a script is contained within the script. A
      script will<br>
      predictably execute the same way on any system. If your system verifies a
      script, you<br>
      can be sure that every other system in the bitcoin network will also
      verify the script,<br>
      meaning that a valid transaction is valid for everyone and everyone knows
      this. This<br>
      predictability of outcomes is an essential benefit of the bitcoin system.</p>
    <h3> Script Construction (Lock + Unlock)</h3>
    <p> Bitcoin’s transaction validation engine relies on two types of scripts
      to validate trans‐<br>
      actions: a locking script and an unlocking script.</p>
    <p> A locking script is a spending condition placed on an output: it
      specifies the condi‐<br>
      tions that must be met to spend the output in the future. Historically,
      the locking<br>
      script was called a scriptPubKey, because it usually contained a public
      key or bitcoin<br>
      address (public key hash). In this book we refer to it as a “locking
      script” to acknowl‐<br>
      edge the much broader range of possibilities of this scripting technology.
      In most bit‐<br>
      coin applications, what we refer to as a locking script will appear in the
      source code as<br>
      scriptPubKey. You will also see the locking script referred to as a
      witness script (see<br>
      Appendix D) or more generally as a cryptographic puzzle. These terms all
      mean the<br>
      same thing, at different levels of abstraction.</p>
    <p> An unlocking script is a script that “solves,” or satisfies, the
      conditions placed on an<br>
      output by a locking script and allows the output to be spent. Unlocking
      scripts are<br>
      part of every transaction input. Most of the time they contain a digital
      signature pro‐<br>
      duced by the user’s wallet from his or her private key. Historically, the
      unlocking<br>
      script was called scriptSig, because it usually contained a digital
      signature. In most bit‐<br>
      coin applications, the source code refers to the unlocking script as
      scriptSig. You<br>
      will also see the unlocking script referred to as a witness (see Appendix
      D). In this<br>
      book, we refer to it as an “unlocking script” to acknowledge the much
      broader range<br>
      of locking script requirements, because not all unlocking scripts must
      contain signa‐<br>
      tures.</p>
    <p> Every bitcoin validating node will validate transactions by executing
      the locking and<br>
      unlocking scripts together. Each input contains an unlocking script and
      refers to a<br>
      previously existing UTXO. The validation software will copy the unlocking
      script,<br>
      retrieve the UTXO referenced by the input, and copy the locking script
      from that<br>
      UTXO. The unlocking and locking script are then executed in sequence. The
      input is<br>
      valid if the unlocking script satisfies the locking script conditions (see
      “Separate exe‐<br>
      cution of unlocking and locking scripts” on page 136). All the inputs are
      validated<br>
      independently, as part of the overall validation of the transaction.</p>
    <p> Note that the UTXO is permanently recorded in the blockchain, and
      therefore is<br>
      invariable and is unaffected by failed attempts to spend it by reference
      in a new trans‐<br>
      action. Only a valid transaction that correctly satisfies the conditions
      of the output<br>
      results in the output being considered as “spent” and removed from the set
      of<br>
      unspent transaction outputs (UTXO set).</p>
    <p> Малюнок&nbsp; 6-3 є прикладом of the unlocking and locking scripts for
      the most common<br>
      type of bitcoin transaction (a payment to a public key hash), showing the
      combined<br>
      script resulting from the concatenation of the unlocking and locking
      scripts prior to<br>
      script validation.<br>
      Малюнок&nbsp; 6-3. Combining scriptSig and scriptPubKey to evaluate a
      transaction script</p>
    <h3> The script execution stack</h3>
    <p> Bitcoin’s scripting language is called a stack-based language because it
      uses a data<br>
      structure called a stack. A stack is a very simple data structure that can
      be visualized<br>
      as a stack of cards. A stack allows two operations: push and pop. Push
      adds an item<br>
      on top of the stack. Pop removes the top item from the stack. Operations
      on a stack<br>
      can only act on the topmost item on the stack. A stack data structure is
      also called a<br>
      Last-In-First-Out, or “LIFO” queue.<br>
      The scripting language executes the script by processing each item from
      left to right.<br>
      Numbers (data constants) are pushed onto the stack. Operators push or pop
      one or<br>
      more parameters from the stack, act on them, and might push a result onto
      the stack.<br>
      For example, OP_ADD will pop two items from the stack, add them, and push
      the<br>
      resulting sum onto the stack.<br>
      Conditional operators evaluate a condition, producing a boolean result of
      TRUE or<br>
      FALSE. For example, OP_EQUAL pops two items from the stack and pushes TRUE<br>
      (TRUE is represented by the number 1) if they are equal or FALSE
      (represented by<br>
      zero) if they are not equal. Bitcoin transaction scripts usually contain a
      conditional<br>
      operator, so that they can produce the TRUE result that signifies a valid
      transaction.<br>
    </p>
    <h3> A simple script</h3>
    <p> Now let’s apply what we’ve learned about scripts and stacks to some
      simple examples.<br>
      In Малюнок&nbsp; 6-4, the script 2 3 OP_ADD 5 OP_EQUAL demonstrates the
      arithmetic addi‐<br>
      tion operator OP_ADD, adding two numbers and putting the result on the
      stack, fol‐<br>
      lowed by the conditional operator OP_EQUAL, which checks that the
      resulting sum is<br>
      equal to 5. For brevity, the OP_ prefix is omitted in the step-by-step
      example. For<br>
      more details on the available script operators and functions, see Appendix
      B.<br>
      Although most locking scripts refer to a public key hash (essentially, a
      bitcoin<br>
      address), thereby requiring proof of ownership to spend the funds, the
      script does not<br>
      have to be that complex. Any combination of locking and unlocking scripts
      that<br>
      results in a TRUE value is valid. The simple arithmetic we used as an
      example of the<br>
      scripting language is also a valid locking script that can be used to lock
      a transaction<br>
      output.<br>
    </p>
    <p>Use part of the arithmetic example script as the locking script:<br>
    </p>
    <p>3 OP_ADD 5 OP_EQUAL<br>
    </p>
    <p>which can be satisfied by a transaction containing an input with the
      unlocking script:<br>
    </p>
    <p>2<br>
    </p>
    <p>The validation software combines the locking and unlocking scripts and
      the resulting<br>
      script is:<br>
    </p>
    <p>2 3 OP_ADD 5 OP_EQUAL<br>
    </p>
    <p>As we saw in the step-by-step example in Малюнок&nbsp; 6-4, when this
      script is executed, the<br>
      result is OP_TRUE, making the transaction valid. Not only is this a valid
      transaction<br>
      output locking script, but the resulting UTXO could be spent by anyone
      with the<br>
      arithmetic skills to know that the number 2 satisfies the script.<br>
      Transactions are valid if the top result on the stack is TRUE (noted<br>
      as {0x01}), any other nonzero value, or if the stack is empty after<br>
      script execution. Transactions are invalid if the top value on the<br>
      stack is FALSE (a zero-length empty value, noted as {}) or if script<br>
      execution is halted explicitly by an operator, such as OP_VERIFY,<br>
      OP_RETURN, or a conditional terminator such as OP_ENDIF. See<br>
      Appendix B for details.<br>
      <br>
      Малюнок&nbsp; 6-4. Bitcoin’s script validation doing simple math<br>
      Transaction Scripts and Script Language</p>
    <p><br>
      The following is a slightly more complex script, which calculates 2 + 7 —
      3 + 1.<br>
      Notice that when the script contains several operators in a row, the stack
      allows the<br>
      results of one operator to be acted upon by the next operator:<br>
    </p>
    <p>2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL<br>
    </p>
    <p>Try validating the preceding script yourself using pencil and paper. When
      the script<br>
      execution ends, you should be left with the value TRUE on the stack.<br>
      Separate execution of unlocking and locking scripts<br>
      In the original bitcoin client, the unlocking and locking scripts were
      concatenated<br>
      and executed in sequence. For security reasons, this was changed in 2010,
      because of<br>
      a vulnerability that allowed a malformed unlocking script to push data
      onto the stack<br>
      and corrupt the locking script. In the current implementation, the scripts
      are exe‐<br>
      cuted separately with the stack transferred between the two executions, as
      described<br>
      next.<br>
      First, the unlocking script is executed, using the stack execution engine.
      If the<br>
      unlocking script is executed without errors (e.g., it has no “dangling”
      operators left<br>
      over), the main stack (not the alternate stack) is copied and the locking
      script is exe‐<br>
      cuted. If the result of executing the locking script with the stack data
      copied from the<br>
      unlocking script is “TRUE,” the unlocking script has succeeded in
      resolving the con‐<br>
      ditions imposed by the locking script and, therefore, the input is a valid
      authorization<br>
      to spend the UTXO. If any result other than “TRUE” remains after execution
      of the<br>
      combined script, the input is invalid because it has failed to satisfy the
      spending con‐<br>
      ditions placed on the UTXO.</p>
    <h3> Pay-to-Public-Key-Hash (P2PKH)</h3>
    <p> The vast majority of transactions processed on the bitcoin network spend
      outputs<br>
      locked with a Pay-to-Public-Key-Hash or “P2PKH” script. These outputs
      contain a<br>
      locking script that locks the output to a public key hash, more commonly
      known as a<br>
      bitcoin address. An output locked by a P2PKH script can be unlocked
      (spent) by pre‐<br>
      senting a public key and a digital signature created by the corresponding
      private key<br>
      (see “Digital Signatures (ECDSA)” on page 138).</p>
    <p> For example, let’s look at Alice’s payment to Bob’s Cafe again. Alice
      made a payment<br>
      of 0.015 bitcoin to the cafe’s bitcoin address. That transaction output
      would have a<br>
      locking script of the form:<br>
    </p>
    <p>OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG<br>
    </p>
    <p>The Cafe Public Key Hash is equivalent to the bitcoin address of the
      cafe, without<br>
      the Base58Check encoding. Most applications would show the public key hash
      in hex‐<br>
      adecimal encoding and not the familiar bitcoin address Base58Check format
      that<br>
      begins with a “1.”<br>
      <br>
      Малюнок&nbsp; 6-6. Evaluating a script for a P2PKH transaction (part 2 of
      2)</p>
    <h3> Digital Signatures (ECDSA)</h3>
    <p> So far, we have not delved into any detail about “digital signatures.”
      In this section we<br>
      look at how digital signatures work and how they can present proof of
      ownership of a<br>
      private key without revealing that private key.<br>
      The digital signature algorithm used in bitcoin is the Elliptic Curve
      Digital Signature<br>
      Algorithm, or ECDSA. ECDSA is the algorithm used for digital signatures
      based on<br>
      elliptic curve private/public key pairs, as described in “Elliptic Curve
      Cryptography<br>
      Explained” on page 60. ECDSA is used by the script functions OP_CHECKSIG,<br>
      OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, and OP_CHECKMULTISIGVERIFY. Any time<br>
      you see those in a locking script, the unlocking script must contain an
      ECDSA signa‐<br>
      ture.</p>
    <p> A digital signature serves three purposes in bitcoin (see the following
      sidebar). First,<br>
      the signature proves that the owner of the private key, who is by
      implication the<br>
      owner of the funds, has authorized the spending of those funds. Secondly,
      the proof<br>
      of authorization is undeniable (nonrepudiation). Thirdly, the signature
      proves that<br>
      the transaction (or specific parts of the transaction) have not and cannot
      be modified<br>
      by anyone after it has been signed.</p>
    <p> Note that each transaction input is signed independently. This is
      critical, as neither<br>
      the signatures nor the inputs have to belong to or be applied by the same
      “owners.” In<br>
      fact, a specific transaction scheme called “CoinJoin” uses this fact to
      create multi-<br>
      party transactions for privacy.</p>
    <p> Each transaction input and any signature it may contain is com‐<br>
      pletely independent of any other input or signature. Multiple par‐<br>
      ties can collaborate to construct transactions and sign only one<br>
      input each.</p>
    <h3> Wikipedia’s Definition of a “Digital Signature”</h3>
    <p> A digital signature is a mathematical scheme for demonstrating the
      authenticity of a<br>
      digital message or documents. A valid digital signature gives a recipient
      reason to<br>
      believe that the message was created by a known sender (authentication),
      that the<br>
      sender cannot deny having sent the message (nonrepudiation), and that the
      message<br>
      was not altered in transit (integrity).</p>
    <p> Source: https://en.wikipedia.org/wiki/Digital_signature</p>
    <h3> How Digital Signatures Work</h3>
    <p> A digital signature is a mathematical scheme that consists of two parts.
      The first part is<br>
      an algorithm for creating a signature, using a private key (the signing
      key), from a<br>
      message (the transaction). The second part is an algorithm that allows
      anyone to ver‐<br>
      ify the signature, given also the message and a public key.</p>
    <h3> Creating a digital signature</h3>
    <p> In bitcoin’s implementation of the ECDSA algorithm, the “message” being
      signed is<br>
      the transaction, or more accurately a hash of a specific subset of the
      data in the trans‐<br>
      action (see “Signature Hash Types (SIGHASH)” on page 141). The signing key
      is the<br>
      user’s private key. The result is the signature:<br>
      <br>
      Sig = F sig Fhash m , dA<br>
      where:<br>
      • dA is the signing private key<br>
      • m is the transaction (or parts of it)<br>
      • Fhash is the hashing function<br>
      • Fsig is the signing algorithm<br>
      • Sig is the resulting signature<br>
      More details on the mathematics of ECDSA can be found in “ECDSA Math” on
      page<br>
      143.<br>
      The function Fsig produces a signature Sig that is composed of two values,
      commonly<br>
      referred to as R and S:</p>
    <p> Sig = (R, S)<br>
    </p>
    <p>Now that the two values R and S have been calculated, they are serialized
      into a byte-<br>
      stream using an international standard encoding scheme called the
      Distinguished<br>
      Encoding Rules, or DER.</p>
    <h3> Serialization of signatures (DER)</h3>
    <p> Let’s look at the transaction Alice created again. In the transaction
      input there is an<br>
      unlocking script that contains the following DER-encoded signature from
      Alice’s wal‐<br>
      let:</p>
    <p>
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b<br>
      9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301<br>
    </p>
    <p>That signature is a serialized byte-stream of the R and S values produced
      by Alice’s<br>
      wallet to prove she owns the private key authorized to spend that output.
      The seriali‐<br>
      zation format consists of nine elements as follows:<br>
      • 0x30—indicating the start of a DER sequence<br>
      • 0x45—the length of the sequence (69 bytes)<br>
      • 0x02—an integer value follows<br>
      • 0x21—the length of the integer (33 bytes)<br>
      • R—<br>
      00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb<br>
      • 0x02—another integer follows<br>
      • 0x20—the length of the integer (32 bytes)<br>
      • S—4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813<br>
      • A suffix (0x01) indicating the type of hash used (SIGHASH_ALL)<br>
      See if you can decode Alice’s serialized (DER-encoded) signature using
      this list. The<br>
      important numbers are R and S; the rest of the data is part of the DER
      encoding<br>
      scheme.</p>
    <h3> Verifying the Signature</h3>
    <p> To verify the signature, one must have the signature (R and S), the
      serialized transac‐<br>
      tion, and the public key (that corresponds to the private key used to
      create the signa‐<br>
      ture). Essentially, verification of a signature means “Only the owner of
      the private key<br>
      that generated this public key could have produced this signature on this
      transaction.”<br>
      The signature verification algorithm takes the message (a hash of the
      transaction or<br>
      parts of it), the signer’s public key and the signature (R and S values),
      and returns<br>
      TRUE if the signature is valid for this message and public key.</p>
    <h3> Signature Hash Types (SIGHASH)</h3>
    <p> Digital signatures are applied to messages, which in the case of
      bitcoin, are the trans‐<br>
      actions themselves. The signature implies a commitment by the signer to
      specific<br>
      transaction data. In the simplest form, the signature applies to the
      entire transaction,<br>
      thereby committing all the inputs, outputs, and other transaction fields.
      However, a<br>
      signature can commit to only a subset of the data in a transaction, which
      is useful for<br>
      a number of scenarios as we will see in this section.</p>
    <p> Bitcoin signatures have a way of indicating which part of a
      transaction’s data is<br>
      included in the hash signed by the private key using a SIGHASH flag. The
      SIGHASH flag<br>
      is a single byte that is appended to the signature. Every signature has a
      SIGHASH flag<br>
      and the flag can be different from to input to input. A transaction with
      three signed<br>
      inputs may have three signatures with different SIGHASH flags, each
      signature signing<br>
      (committing) different parts of the transaction.</p>
    <p> Remember, each input may contain a signature in its unlocking script. As
      a result, a<br>
      transaction that contains several inputs may have signatures with
      different SIGHASH<br>
      flags that commit different parts of the transaction in each of the
      inputs. Note also<br>
      that bitcoin transactions may contain inputs from different “owners,” who
      may sign<br>
      only one input in a partially constructed (and invalid) transaction,
      collaborating with<br>
      others to gather all the necessary signatures to make a valid transaction.
      Many of the<br>
      SIGHASH flag types only make sense if you think of multiple participants
      collaborating<br>
      outside the bitcoin network and updating a partially signed transaction.<br>
      <br>
      There are three SIGHASH flags: ALL, NONE, and SINGLE, as shown in Table
      6-3.<br>
    </p>
    <p>Table 6-3. SIGHASH types and their meanings<br>
    </p>
    <p>SIGHASH flag Value Description<br>
      ALL<br>
      &nbsp;0x01<br>
      &nbsp;Signature applies to all inputs and outputs<br>
      NONE<br>
      &nbsp;0x02<br>
      &nbsp;Signature applies to all inputs, none of the outputs<br>
      SINGLE<br>
      &nbsp;0x03<br>
      &nbsp;Signature applies to all inputs but only the one output with the
      same index number as the signed<br>
      input<br>
      In addition, there is a modifier flag SIGHASH_ANYONECANPAY, which can be
      combined<br>
      with each of the preceding flags. When ANYONECANPAY is set, only one input
      is signed,<br>
      leaving the rest (and their sequence numbers) open for modification. The
      ANYONECAN<br>
      PAY has the value 0x80 and is applied by bitwise OR, resulting in the
      combined flags<br>
      as shown in Table 6-4.<br>
      Table 6-4. SIGHASH types with modifiers and their meanings<br>
      SIGHASH flag<br>
      &nbsp;Value Description<br>
      ALL|ANYONECANPAY<br>
      &nbsp;0x81 Signature applies to one inputs and all outputs<br>
      NONE|ANYONECANPAY<br>
      &nbsp;0x82<br>
      &nbsp;Signature applies to one inputs, none of the outputs<br>
      SINGLE|ANYONECANPAY 0x83<br>
      &nbsp; </p>
    <p>Signature applies to one input and the output with the same index number<br>
      The way SIGHASH flags are applied during signing and verification is that
      a copy of the<br>
      transaction is made and certain fields within are truncated (set to zero
      length and<br>
      emptied). The resulting transaction is serialized. The SIGHASH flag is
      added to the end<br>
      of the serialized transaction and the result is hashed. The hash itself is
      the “message”<br>
      that is signed. Depending on which SIGHASH flag is used, different parts
      of the trans‐<br>
      action are truncated. The resulting hash depends on different subsets of
      the data in<br>
      the transaction. By including the SIGHASH as the last step before hashing,
      the signa‐<br>
      ture commits the SIGHASH type as well, so it can’t be changed (e.g., by a
      miner).<br>
      All SIGHASH types sign the transaction nLocktime field (see “Trans‐<br>
      action Locktime (nLocktime)” on page 157). In addition, the SIGH<br>
      ASH type itself is appended to the transaction before it is signed, so<br>
      that it can’t be modified once signed.<br>
      In the example of Alice’s transaction (see the list in “Serialization of
      signatures<br>
      (DER)” on page 140), we saw that the last part of the DER-encoded
      signature was 01,<br>
      which is the SIGHASH_ALL flag. This locks the transaction data, so Alice’s
      signature is<br>
      committing the state of all inputs and outputs. This is the most common
      signature<br>
      form.<br>
      <br>
      Let’s look at some of the other SIGHASH types and how they can be used in
      practice:<br>
      ALL|ANYONECANPAY<br>
      This construction can be used to make a “crowdfunding”-style transaction.<br>
      Someone attempting to raise funds can construct a transaction with a
      single out‐<br>
      put. The single output pays the “goal” amount to the fundraiser. Such a
      transac‐<br>
      tion is obviously not valid, as it has no inputs. However, others can now
      amend it<br>
      by adding an input of their own, as a donation. They sign their own input
      with<br>
      ALL|ANYONECANPAY. Unless enough inputs are gathered to reach the value of
      the<br>
      output, the transaction is invalid. Each donation is a “pledge,” which
      cannot be<br>
      collected by the fundraiser until the entire goal amount is raised.<br>
      NONE<br>
      This construction can be used to create a “bearer check” or “blank check”
      of a<br>
      specific amount. It commits to the input, but allows the output locking
      script to<br>
      be changed. Anyone can write their own bitcoin address into the output
      locking<br>
      script and redeem the transaction. However, the output value itself is
      locked by<br>
      the signature.<br>
      NONE|ANYONECANPAY<br>
      This construction can be used to build a “dust collector.” Users who have
      tiny<br>
      UTXO in their wallets can’t spend these without the cost in fees exceeding
      the<br>
      value of the dust. With this type of signature, the dust UTXO can be
      donated for<br>
      anyone to aggregate and spend whenever they want.<br>
      There are some proposals to modify or expand the SIGHASH system. One such
      pro‐<br>
      posal is Bitmask Sighash Modes by Blockstream’s Glenn Willen, as part of
      the Ele‐<br>
      ments project. This aims to create a flexible replacement for SIGHASH
      types that allows<br>
      “arbitrary, miner-rewritable bitmasks of inputs and outputs” that can
      express “more<br>
      complex contractual precommitment schemes, such as signed offers with
      change in a<br>
      distributed asset exchange.”<br>
      You will not see SIGHASH flags presented as an option in a user’s<br>
      wallet application. With few exceptions, wallets construct P2PKH<br>
      scripts and sign with SIGHASH_ALL flags. To use a different SIGHASH<br>
      flag, you would have to write software to construct and sign trans‐<br>
      actions. More importantly, SIGHASH flags can be used by special-<br>
      purpose bitcoin applications that enable novel uses.<br>
      ECDSA Math<br>
      As mentioned previously, signatures are created by a mathematical function
      Fsig that<br>
      produces a signature composed of two values R and S. In this section we
      look at the<br>
      function Fsig in more detail.<br>
      <br>
      The signature algorithm first generates an ephemeral (temporary) private
      public key<br>
      pair. This temporary key pair is used in the calculation of the R and S
      values, after a<br>
      transformation involving the signing private key and the transaction hash.<br>
      The temporary key pair is based on a random number k, which is used as the
      tempo‐<br>
      rary private key. From k, we generate the corresponding temporary public
      key P (cal‐<br>
      culated as P = k*G, in the same way bitcoin public keys are derived; see
      “Public Keys”<br>
      on page 60). The R value of the digital signature is then the x coordinate
      of the<br>
      ephemeral public key P.</p>
    <p> From there, the algorithm calculates the S value of the signature, such
      that:<br>
      S = k-1 (Hash(m) + dA * R) mod p<br>
      where:<br>
      • k is the ephemeral private key<br>
      • R is the x coordinate of the ephemeral public key<br>
      • dA is the signing private key<br>
      • m is the transaction data<br>
      • p is the prime order of the elliptic curve<br>
      Verification is the inverse of the signature generation function, using
      the R, S values<br>
      and the public key to calculate a value P, which is a point on the
      elliptic curve (the<br>
      ephemeral public key used in signature creation):<br>
      P = S-1 * Hash(m) * G + S-1 * R * Qa<br>
      where:<br>
      • R and S are the signature values<br>
      • Qa is Alice’s public key<br>
      • m is the transaction data that was signed<br>
      • G is the elliptic curve generator point<br>
      If the x coordinate of the calculated point P is equal to R, then the
      verifier can con‐<br>
      clude that the signature is valid.<br>
      Note that in verifying the signature, the private key is neither known nor
      revealed.<br>
      The math of ECDSA is complex and difficult to understand. There<br>
      are a number of great guides online that might help. Search for<br>
      “ECDSA explained” or try this one: http://bit.ly/2r0HhGB.<br>
    </p>
    <h3> Важливість випадкових підписів</h3>
    <p> Як ви бачили в розділі “Математика ECDSA”, алгоритм генерації підпису
      використовує випадковий ключ k, як основу для ефермерної пари з приватного
      та публічного ключів. Значення k не є важливим, доки воно є випадковим.
      Якщо одне значення k використовується для виробництва двох сигнатур для
      різних повідомлень (транзакцій), тоді приватний ключ для підпису може бути
      обчислений для кожного з них. Повторне використання того ж значення k в
      алгоритмі підпису дає витік до викриття приватного ключа!</p>
    <p> Якщо те саме значення k використовуєтсья в алгоритмі підписування до
      двох різних транзакцій, приватний ключ може обчислений та викритий перед
      усім світом!</p>
    <p> це не тільки теоретична пожливісь. Ми бачили, як ця проблема призвела до
      викриття приватних ключів в різних реалізаціях алгоритмів підпису
      транзакцій буткоін. Люди зтикнулись з викраденням власних коштів через
      ненавмисне повторне використання значення k. Найбільш важлива причина для
      повторного використання значення k є невідповідна ініціалізація генератора
      випадкових чисел.</p>
    <p> Щоб уникнути цієї вразливості, найкраща індустріальна практика є відказ
      від генерування k за допомогою генератора випадкових чисел на базі
      ентропії, та замість цього використовувати детерміністичний випадковий
      процес, що базується на даних самої транзакції. Це дає переконання, що
      кожна транзакція дає продукує інше k. Стандартний індустріальний алгоритм
      для детермінистичної ініціалізації k визначений в RFC 6979, опублікований
      Internet Engineering Task Force.</p>
    <p>Якщо ви реалізуєте алгоритм для підпису транзакцій в біткоін, ви повинні
      використовувати RFC 6979, або подібний детермінистично-випадковий
      алгоритм, щоб бути впевненим, що ви генеруєте інший k для кожної
      транзакції.</p>
    <h3> Біткоін адреси, баланси, та інші абстракції<br>
    </h3>
    <p>Ми почали цю главу з дослідження, що транзакції виглядають дуже відмінно
      “за лаштунками сцени”, на відміну від того, як вони представвляються
      гаманцями, переглядачами блокчейну, та іншими користувацькими
      застосуваннями. Багато зі спрощених та знайомих концепцій з попередньої
      глави, такі, як біткоін адреси та баланси, виглядають відсутніми в
      структурі транзакцій. Ми бачили, що транзакції не містять біткоін адрес,
      як таких, але замість цього оперують через посередництво скриптів, що
      блокують та розблокують окермі вартості біткоіна. Баланси не представлені
      будь-де в системі, та досі не кожне застосування гаманця окремо відображує
      баланс гаманця користувача.<br>
      <br>
      Тепер, коли ми дослідили, що саме входить в транзакцію біткоін, ми можемо
      дослідити, як абстракції верхнього рівня походять від очевидно примітивних
      компонент транзакції. Давайте знову подивимось, як транзакція Аліси була
      представленою на популярному переглядачеві блоків (Малюнок 6-7).</p>
    <p> Малюнок 6-7. Транзакція Аліси в кав'ярні Боба<br>
    </p>
    <p>В лівій частині транзакції переглядач блокчейну показує біткоін адресу
      Аліси, як “надсилач”. Фактично, ця інформація не міститься в самій
      транзакції. Коли переглядач блокчейну отримує транзакцію, він також
      отримує попередню транзакцію, на яку посилаєтсья вхід, та виділяє перший
      вихід зі старішой транзакції. В цьому виході є блокуючий скрипт, що блокує
      UTXO хешем публічного ключа Аліси (скрипт P2PKH). Переглядач блокчейну
      виділяє хеш публічного ключа, та кодує його з використанням кодування
      Base58Check, щоб спродукувати та відобразити біткоін адресу, що
      представляє публічний ключ.</p>
    <p>Подібно до цього, в правій стороні переглядач блокчейну показує два
      виходи; перший до біткоін адреси Боба, та другий не біткоін адресу Аліси
      (як решта). Ще раз, щоб створити ці адреси біткоін, переглядач блокчейну
      викреслив блокуючий скрипт для кожного виходу, розпізнав P2PKH скрипт, та
      виділив з нього хеш публічного ключа. Нарешті, переглядач блокчейну
      перекодував цей публічний ключ за допомогою Base58Check, щоб спродукувати
      та відобразити адреси біткоін. Якщо ви клацнете на адресі біткоіна Боба,
      переглядач блокчейну покаже вам дещо, подібне до Малюнка 6-8.<br>
      <br>
      Малюнок 6-8. Баланс біткоін адреси Боба<br>
    </p>
    <p>Переглядач біткоін відображує баланс адреси біткоін Боба. Але ніде в
      системі біткоін немає концепції “балансу”. Скоріше, значення, відображені
      тут, сконструйовані переглядачем блокчейна, як показане нижче.<br>
    </p>
    <p>Щоб побудувати суму “Загально отримано” (Final Balance), переглядач
      блокчейну зпершу буде декодувати кодування Base58Check адреси біткоіну,
      щоб отримати 160-бітний хеш бобівського публічного ключа, що закодований в
      адресі. Потім переглядач блокчейну буде шукати в базі даних транзакцій,
      шукаючи виходи з блокуючими скриптами P2PKH, що містять хеш публічного
      ключа Бота. Через складання значень всіх виходів переглядач блокчейну може
      спродукувати загальну отриману суму. <br>
    </p>
    <p>Конструювання поточного балансу (відображується як “Final Balance”)
      потребує трохи більше роботи. Переглядач блокчейну має окрему базу даних
      віходів, що наразі не витрачені, тобто набір UTXO. Щоб підтримувати цю
      базу даних, переглядач блокчейну має мониторити мережу біткоін, додавати
      нові створені UTXO, та видаляти витрачені UTXO, в реальному часі, по мірі
      того, як вони з'являються в непідтверджених транзакціях. Це складний
      процес, що залежить від відсліджування транзакцій по мірі їх просування,
      так само, як обслуговування консенсусу мережі біткоіну, щоб переконатись,
      що ми слідуємо коректному відгалуженню ланцюга. Іноді переглядач блокчейну
      розсинхронізується, та його персектива на набір UTXO наповна або
      некоректна.<br>
    </p>
    <p>З набору UTXO переглядач блокчейну підсумовує вартість всіх невитрачених
      виходів, що посилаються на публічний ключ Боба, та продукують “остаточний
      баланс”, число, що показується користувачему.<br>
    </p>
    <p>Щоб спродукувати один цей образ з двома “балансами” переглядач блокчейну
      має індексувати та шукати часом десятки, сотні, або часом і сотні тисяч
      транзакцій. <br>
    </p>
    <p>Підсумовуючи, інформація, що представляється користувачеву через
      застосування гаманця, переглядачі блокчейну, або інші користувацькі
      інтерфейси біткоіну, часто є компонуванням високорівневих абстракцій, що
      походять від сканування багатьох різних транзакцій, пеервірки їх вмісту,
      та маніпуляцій даними, що там містяться. Через презентування цього
      спрощеного погляду на трензакції біткоін, що копіюють банківські чеки від
      одного надсилача до одного отримувача, ці застосування мають
      абстрагуватись від багатьох підлеглих деталей. Вони в основному
      фокусуються на загальних типах транзакцій: P2PKH з сигнатурами SIGHASH_ALL
      на кожному вході. Таким чином, хоча застосування біткоіну можуть
      представляти більше ніж 80% з усіх транзакцій в просто-читаємій манері,
      вони часом плутаються в транзакціях, що відхиляються від норми.
      Транзакції, що містять більш складні блокуючі скрипти, або інші флаги
      SIGHASH, або багато входів та виходів, демонструють простоту та слабкість
      ціх абстракцій.<br>
    </p>
    <p>Кожного дня сотні транзакцій, що не містять виходів P2PKH, отримують
      підтвердження блокчейну. Переглядачі блокчейну часто представляють їх з
      червоними повідомленнями попереджень, які кажуть, що адресу неможливо
      декодувати. Наступне посилання містить найпізніші “дивні транзакції”, що
      не були повністю декодовані: </p>
    <pre>      https://blockchain.info/strange-transactions.<br>
      </pre>
    <p>Як ми бачили в попередній главі, це не обов'язково дивні транзакції. Це
      транзакції, що містять більш складні блокуючі скрипти, ніж загальні P2PKH.
      Ми вивчимо щодо декодування та розуміння більш складних скриптів, та про
      застосування, що використовують їх, трохи далі. <br>
    </p>
    <h2> ГЛАВА 7</h2>
    <h1> Advanced Transactions and Scripting</h1>
    <h3> Introduction</h3>
    <p> In the previous chapter, we introduced the basic elements of bitcoin
      transactions and<br>
      looked at the most common type of transaction script, the P2PKH script. In
      this<br>
      chapter we will look at more advanced scripting and how we can use it to
      build trans‐<br>
      actions with complex conditions.</p>
    <p> First, we will look at multisignature scripts. Next, we will examine the
      second most<br>
      common transaction script, Pay-to-Script-Hash, which opens up a whole
      world of<br>
      complex scripts. Then, we will examine new script operators that add a
      time dimen‐<br>
      sion to bitcoin, through timelocks.</p>
    <h3> Multisignature</h3>
    <p> Multisignature scripts set a condition where N public keys are recorded
      in the script<br>
      and at least M of those must provide signatures to unlock the funds. This
      is also<br>
      known as an M-of-N scheme, where N is the total number of keys and M is
      the thres‐<br>
      hold of signatures required for validation. For example, a 2-of-3
      multisignature is one<br>
      where three public keys are listed as potential signers and at least two
      of those must<br>
      be used to create signatures for a valid transaction to spend the funds.
      At this time,<br>
      standard multisignature scripts are limited to at most 15 listed public
      keys, meaning<br>
      you can do anything from a 1-of-1 to a 15-of-15 multisignature or any
      combination<br>
      within that range. The limitation to 15 listed keys might be lifted by the
      time this<br>
      book is published, so check the isStandard() function to see what is
      currently<br>
      accepted by the network.</p>
    <p> The general form of a locking script setting an M-of-N multisignature
      condition is:<br>
    </p>
    <p>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N
      CHECKMULTISIG<br>
      <br>
      where N is the total number of listed public keys and M is the threshold
      of required<br>
      signatures to spend the output.<br>
    </p>
    <p>A locking script setting a 2-of-3 multisignature condition looks like
      this:<br>
    </p>
    <p>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3
      CHECKMULTISIG<br>
    </p>
    <p>The preceding locking script can be satisfied with an unlocking script
      containing<br>
      pairs of signatures and public keys:<br>
    </p>
    <p>&lt;Signature B&gt; &lt;Signature C&gt;<br>
    </p>
    <p>or any combination of two signatures from the private keys corresponding
      to the<br>
      three listed public keys.<br>
    </p>
    <p>The two scripts together would form the combined validation script:<br>
    </p>
    <p>&lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public
      Key B&gt; &lt;Public Key C&gt; 3<br>
      CHECKMULTISIG<br>
    </p>
    <p>When executed, this combined script will evaluate to TRUE if, and only
      if, the<br>
      unlocking script matches the conditions set by the locking script. In this
      case, the<br>
      condition is whether the unlocking script has a valid signature from the
      two private<br>
      keys that correspond to two of the three public keys set as an
      encumbrance.</p>
    <h3> A bug in CHECKMULTISIG execution</h3>
    <p> There is a bug in CHECKMULTISIG’s execution that requires a slight
      workaround. When<br>
      CHECKMULTISIG executes, it should consume M+N+2 items on the stack as
      parame‐<br>
      ters. However, due to the bug, CHECKMULTISIG will pop an extra value or
      one value<br>
      more than expected.<br>
      Let’s look at this in greater detail using the previous validation
      example:<br>
      &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public
      Key B&gt; &lt;Public Key C&gt; 3<br>
      CHECKMULTISIG<br>
      First, CHECKMULTISIG pops the top item, which is N (in this example “3”).
      Then it pops<br>
      N items, which are the public keys that can sign. In this example, public
      keys A, B, and<br>
      C. Then, it pops one item, which is M, the quorum (how many signatures are
      needed).<br>
      Here M = 2. At this point, CHECKMULTISIG should pop the final M items,
      which are the<br>
      signatures, and see if they are valid. However, unfortunately, a bug in
      the implemen‐<br>
      tation causes CHECKMULTISIG to pop one more item (M+1 total) than it
      should. The<br>
      extra item is disregarded when checking the signatures so it has no direct
      effect on<br>
      CHECKMULTISIG itself. However, an extra value must be present because if
      it is not<br>
      present, when CHECKMULTISIG attempts to pop on an empty stack, it will
      cause a stack<br>
      error and script failure (marking the transaction as invalid). Because the
      extra item is<br>
      disregarded it can be anything, but customarily 0 is used.<br>
      <br>
      in every full node, until it was spent. All of these issues make using
      complex locking<br>
      scripts difficult in practice.<br>
      P2SH was developed to resolve these practical difficulties and to make the
      use of<br>
      complex scripts as easy as a payment to a bitcoin address. With P2SH
      payments, the<br>
      complex locking script is replaced with its digital fingerprint, a
      cryptographic hash.<br>
      When a transaction attempting to spend the UTXO is presented later, it
      must contain<br>
      the script that matches the hash, in addition to the unlocking script. In
      simple terms,<br>
      P2SH means “pay to a script matching this hash, a script that will be
      presented later<br>
      when this output is spent.”<br>
      In P2SH transactions, the locking script that is replaced by a hash is
      referred to as the<br>
      redeem script because it is presented to the system at redemption time
      rather than as a<br>
      locking script. Table 7-1 shows the script without P2SH and Table 7-2
      shows the same<br>
      script encoded with P2SH.<br>
      Table 7-1. Complex script without P2SH<br>
      Locking Script<br>
      &nbsp;2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG<br>
      Unlocking Script Sig1 Sig2<br>
      Table 7-2. Complex script as P2SH<br>
      Redeem Script<br>
      &nbsp;2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG<br>
      Locking Script<br>
      &nbsp;HASH160 &lt;20-byte hash of redeem script&gt; EQUAL<br>
      Unlocking Script Sig1 Sig2 &lt;redeem script&gt;<br>
      As you can see from the tables, with P2SH the complex script that details
      the condi‐<br>
      tions for spending the output (redeem script) is not presented in the
      locking script.<br>
      Instead, only a hash of it is in the locking script and the redeem script
      itself is presen‐<br>
      ted later, as part of the unlocking script when the output is spent. This
      shifts the bur‐<br>
      den in fees and complexity from the sender to the recipient (spender) of
      the<br>
      transaction.<br>
      Let’s look at Mohammed’s company, the complex multisignature script, and
      the<br>
      resulting P2SH scripts.<br>
      First, the multisignature script that Mohammed’s company uses for all
      incoming pay‐<br>
      ments from customers:<br>
      2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2
      Public Key&gt; &lt;Partner3<br>
      Public Key&gt; &lt;Attorney Public Key&gt; 5 CHECKMULTISIG<br>
      If the placeholders are replaced by actual public keys (shown here as
      520-bit numbers<br>
      starting with 04) you can see that this script becomes very long:<br>
      152<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      2<br>
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395<br>
D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23<br>
E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D7<br>
8D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5<br>
737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD<br>
7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D0872274<br>
40645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF5<br>
0D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7E<br>
      D238F4D800 5 CHECKMULTISIG<br>
      This entire script can instead be represented by a 20-byte cryptographic
      hash, by first<br>
      applying the SHA256 hashing algorithm and then applying the RIPEMD160
      algo‐<br>
      rithm on the result. The 20-byte hash of the preceding script is:<br>
      54c557e07dde5bb6cb791c7a540e0a4796f5e97e<br>
      A P2SH transaction locks the output to this hash instead of the longer
      script, using<br>
      the locking script:<br>
      HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL<br>
      which, as you can see, is much shorter. Instead of “pay to this 5-key
      multisignature<br>
      script,” the P2SH equivalent transaction is “pay to a script with this
      hash.” A customer<br>
      making a payment to Mohammed’s company need only include this much shorter<br>
      locking script in his payment. When Mohammed and his partners want to
      spend this<br>
      UTXO, they must present the original redeem script (the one whose hash
      locked the<br>
      UTXO) and the signatures necessary to unlock it, like this:<br>
      &lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt;<br>
      The two scripts are combined in two stages. First, the redeem script is
      checked<br>
      against the locking script to make sure the hash matches:<br>
      &lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt; HASH160 &lt;redeem
      scriptHash&gt; EQUAL<br>
      If the redeem script hash matches, the unlocking script is executed on its
      own, to<br>
      unlock the redeem script:<br>
      &lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG<br>
      Almost all the scripts described in this chapter can only be implemented
      as P2SH<br>
      scripts. They cannot be used directly in the locking script of a UTXO.<br>
      P2SH Addresses<br>
      Another important part of the P2SH feature is the ability to encode a
      script hash as an<br>
      address, as defined in BIP-13. P2SH addresses are Base58Check encodings of
      the 20-<br>
      byte hash of a script, just like bitcoin addresses are Base58Check
      encodings of the 20-<br>
      byte hash of a public key. P2SH addresses use the version prefix “5,”
      which results in<br>
      Base58Check-encoded addresses that start with a “3.” For example,
      Mohammed’s<br>
      Pay-to-Script-Hash (P2SH)<br>
      &nbsp;|<br>
      &nbsp;153<br>
      complex script, hashed and Base58Check-encoded as a P2SH address, becomes<br>
      39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw. Now, Mohammed can give this “address”
      to<br>
      his customers and they can use almost any bitcoin wallet to make a simple
      payment,<br>
      as if it were a bitcoin address. The 3 prefix gives them a hint that this
      is a special type<br>
      of address, one corresponding to a script instead of a public key, but
      otherwise it<br>
      works in exactly the same way as a payment to a bitcoin address.<br>
      P2SH addresses hide all of the complexity, so that the person making a
      payment does<br>
      not see the script.<br>
      Benefits of P2SH<br>
      The P2SH feature offers the following benefits compared to the direct use
      of complex<br>
      scripts in locking outputs:<br>
      • Complex scripts are replaced by shorter fingerprints in the transaction
      output,<br>
      making the transaction smaller.<br>
      • Scripts can be coded as an address, so the sender and the sender’s
      wallet don’t<br>
      need complex engineering to implement P2SH.<br>
      • P2SH shifts the burden of constructing the script to the recipient, not
      the sender.<br>
      • P2SH shifts the burden in data storage for the long script from the
      output (which<br>
      is in the UTXO set) to the input (stored on the blockchain).<br>
      • P2SH shifts the burden in data storage for the long script from the
      present time<br>
      (payment) to a future time (when it is spent).<br>
      • P2SH shifts the transaction fee cost of a long script from the sender to
      the recipi‐<br>
      ent, who has to include the long redeem script to spend it.<br>
      Redeem Script and Validation<br>
      Prior to version 0.9.2 of the Bitcoin Core client, Pay-to-Script-Hash was
      limited to the<br>
      standard types of bitcoin transaction scripts, by the isStandard()
      function. That<br>
      means that the redeem script presented in the spending transaction could
      only be one<br>
      of the standard types: P2PK, P2PKH, or multisig nature, excluding RETURN
      and P2SH<br>
      itself.<br>
      As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can
      contain any valid<br>
      script, making the P2SH standard much more flexible and allowing for
      experimenta‐<br>
      tion with many novel and complex types of transactions.<br>
      Note that you are not able to put a P2SH inside a P2SH redeem script,
      because the<br>
      P2SH specification is not recursive. While it is technically possible to
      include RETURN<br>
      in a redeem script, as nothing in the rules prevents you from doing so, it
      is of no<br>
      154<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      practical use because executing RETURN during validation will cause the
      transaction to<br>
      be marked invalid.<br>
      Note that because the redeem script is not presented to the network until
      you attempt<br>
      to spend a P2SH output, if you lock an output with the hash of an invalid
      redeem<br>
      script it will be processed regardless. The UTXO will be successfully
      locked. However,<br>
      you will not be able to spend it because the spending transaction, which
      includes the<br>
      redeem script, will not be accepted because it is an invalid script. This
      creates a risk,<br>
      because you can lock bitcoin in a P2SH that cannot be spent later. The
      network will<br>
      accept the P2SH locking script even if it corresponds to an invalid redeem
      script,<br>
      because the script hash gives no indication of the script it represents.<br>
      P2SH locking scripts contain the hash of a redeem script, which<br>
      gives no clues as to the content of the redeem script itself. The<br>
      P2SH transaction will be considered valid and accepted even if the<br>
      redeem script is invalid. You might accidentally lock bitcoin in such<br>
      a way that it cannot later be spent.<br>
      Data Recording Output (RETURN)<br>
      Bitcoin’s distributed and timestamped ledger, the blockchain, has
      potential uses far<br>
      beyond payments. Many developers have tried to use the transaction
      scripting lan‐<br>
      guage to take advantage of the security and resilience of the system for
      applications<br>
      such as digital notary services, stock certificates, and smart contracts.
      Early attempts<br>
      to use bitcoin’s script language for these purposes involved creating
      transaction out‐<br>
      puts that recorded data on the blockchain; for example, to record a
      digital fingerprint<br>
      of a file in such a way that anyone could establish proof-of-existence of
      that file on a<br>
      specific date by reference to that transaction.<br>
      The use of bitcoin’s blockchain to store data unrelated to bitcoin
      payments is a con‐<br>
      troversial subject. Many developers consider such use abusive and want to
      discourage<br>
      it. Others view it as a demonstration of the powerful capabilities of
      blockchain tech‐<br>
      nology and want to encourage such experimentation. Those who object to the
      inclu‐<br>
      sion of nonpayment data argue that it causes “blockchain bloat,” burdening
      those<br>
      running full bitcoin nodes with carrying the cost of disk storage for data
      that the<br>
      blockchain was not intended to carry. Moreover, such transactions create
      UTXO that<br>
      cannot be spent, using the destination bitcoin address as a freeform
      20-byte field.<br>
      Because the address is used for data, it doesn’t correspond to a private
      key and the<br>
      resulting UTXO can never be spent; it’s a fake payment. These transactions
      that can<br>
      never be spent are therefore never removed from the UTXO set and cause the
      size of<br>
      the UTXO database to forever increase, or “bloat.”<br>
      In version 0.9 of the Bitcoin Core client, a compromise was reached with
      the intro‐<br>
      duction of the RETURN operator. RETURN allows developers to add 80 bytes
      of nonpay‐<br>
      Data Recording Output (RETURN)<br>
      &nbsp;|<br>
      &nbsp;155<br>
      ment data to a transaction output. However, unlike the use of “fake” UTXO,
      the<br>
      RETURN operator creates an explicitly provably unspendable output, which
      does not<br>
      need to be stored in the UTXO set. RETURN outputs are recorded on the
      blockchain,<br>
      so they consume disk space and contribute to the increase in the
      blockchain’s size, but<br>
      they are not stored in the UTXO set and therefore do not bloat the UTXO
      memory<br>
      pool and burden full nodes with the cost of more expensive RAM.<br>
      RETURN scripts look like this:<br>
      RETURN &lt;data&gt;<br>
      The data portion is limited to 80 bytes and most often represents a hash,
      such as the<br>
      output from the SHA256 algorithm (32 bytes). Many applications put a
      prefix in front<br>
      of the data to help identify the application. For example, the Proof of
      Existence digital<br>
      notarization service uses the 8-byte prefix DOCPROOF, which is ASCII
      encoded as 44<br>
      4f 43 50 52 4f 4f 46 in hexadecimal.<br>
      Keep in mind that there is no “unlocking script” that corresponds to
      RETURN that<br>
      could possibly be used to “spend” a RETURN output. The whole point of
      RETURN is that<br>
      you can’t spend the money locked in that output, and therefore it does not
      need to be<br>
      held in the UTXO set as potentially spendable—RETURN is provably
      unspendable.<br>
      RETURN is usually an output with a zero bitcoin amount, because any
      bitcoin assigned<br>
      to such an output is effectively lost forever. If a RETURN is referenced
      as an input in a<br>
      transaction, the script validation engine will halt the execution of the
      validation script<br>
      and mark the transaction as invalid. The execution of RETURN essentially
      causes the<br>
      script to “RETURN” with a FALSE and halt. Thus, if you accidentally
      reference a<br>
      RETURN output as an input in a transaction, that transaction is invalid.<br>
      A standard transaction (one that conforms to the isStandard() checks) can
      have<br>
      only one RETURN output. However, a single RETURN output can be combined in
      a<br>
      transaction with outputs of any other type.<br>
      Two new command-line options have been added in Bitcoin Core as of version
      0.10.<br>
      The option datacarrier controls relay and mining of RETURN transactions,
      with the<br>
      default set to “1” to allow them. The option datacarriersize takes a
      numeric argu‐<br>
      ment specifying the maximum size in bytes of the RETURN script, 83 bytes
      by default,<br>
      which, allows for a maximum of 80 bytes of RETURN data plus one byte of
      RETURN<br>
      opcode and two bytes of PUSHDATA opcode.<br>
      RETURN was initially proposed with a limit of 80 bytes, but the limit<br>
      was reduced to 40 bytes when the feature was released. In February<br>
      2015, in version 0.10 of Bitcoin Core, the limit was raised back to<br>
      80 bytes. Nodes may choose not to relay or mine RETURN, or only<br>
      relay and mine RETURN containing less than 80 bytes of data.<br>
      156<br>
      &nbsp;| Chapter 7: Advanced Transactions and Scripting<br>
      Timelocks<br>
      Timelocks are restrictions on transactions or outputs that only allow
      spending after a<br>
      point in time. Bitcoin has had a transaction-level timelock feature from
      the begin‐<br>
      ning. It is implemented by the nLocktime field in a transaction. Two new
      timelock<br>
      features were introduced in late 2015 and mid-2016 that offer UTXO-level
      timelocks.<br>
      These are CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY.<br>
      Timelocks are useful for postdating transactions and locking funds to a
      date in the<br>
      future. More importantly, timelocks extend bitcoin scripting into the
      dimension of<br>
      time, opening the door for complex multistep smart contracts.<br>
      Transaction Locktime (nLocktime)<br>
      From the beginning, bitcoin has had a transaction-level timelock feature.
      Transaction<br>
      locktime is a transaction-level setting (a field in the transaction data
      structure) that<br>
      defines the earliest time that a transaction is valid and can be relayed
      on the network<br>
      or added to the blockchain. Locktime is also known as nLocktime from the
      variable<br>
      name used in the Bitcoin Core codebase. It is set to zero in most
      transactions to indi‐<br>
      cate immediate propagation and execution. If nLocktime is nonzero and
      below 500<br>
      million, it is interpreted as a block height, meaning the transaction is
      not valid and is<br>
      not relayed or included in the blockchain prior to the specified block
      height. If it is<br>
      above 500 million, it is interpreted as a Unix Epoch timestamp (seconds
      since<br>
      Jan-1-1970) and the transaction is not valid prior to the specified time.
      Transactions<br>
      with nLocktime specifying a future block or time must be held by the
      originating sys‐<br>
      tem and transmitted to the bitcoin network only after they become valid.
      If a transac‐<br>
      tion is transmitted to the network before the specified nLocktime, the
      transaction will<br>
      be rejected by the first node as invalid and will not be relayed to other
      nodes. The use<br>
      of nLocktime is equivalent to postdating a paper check.<br>
      Transaction locktime limitations<br>
      nLocktime has the limitation that while it makes it possible to spend some
      outputs in<br>
      the future, it does not make it impossible to spend them until that time.
      Let’s explain<br>
      that with the following example.<br>
      Alice signs a transaction spending one of her outputs to Bob’s address,
      and sets the<br>
      transaction nLocktime to 3 months in the future. Alice sends that
      transaction to Bob<br>
      to hold. With this transaction Alice and Bob know that:<br>
      • Bob cannot transmit the transaction to redeem the funds until 3 months
      have<br>
      elapsed.<br>
      • Bob may transmit the transaction after 3 months.<br>
      Timelocks<br>
      &nbsp;|<br>
      &nbsp;157<br>
      However:<br>
      • Alice can create another transaction, double-spending the same inputs
      without a<br>
      locktime. Thus, Alice can spend the same UTXO before the 3 months have<br>
      elapsed.<br>
      • Bob has no guarantee that Alice won’t do that.<br>
      It is important to understand the limitations of transaction nLocktime.
      The only<br>
      guarantee is that Bob will not be able to redeem it before 3 months have
      elapsed.<br>
      There is no guarantee that Bob will get the funds. To achieve such a
      guarantee, the<br>
      timelock restriction must be placed on the UTXO itself and be part of the
      locking<br>
      script, rather than on the transaction. This is achieved by the next form
      of timelock,<br>
      called Check Lock Time Verify.<br>
      Check Lock Time Verify (CLTV)<br>
      In December 2015, a new form of timelock was introduced to bitcoin as a
      soft fork<br>
      upgrade. Based on a specifications in BIP-65, a new script operator called
      CHECK‐<br>
      LOCKTIMEVERIFY (CLTV) was added to the scripting language. CLTV is a per-<br>
      output timelock, rather than a per-transaction timelock as is the case
      with nLocktime.<br>
      This allows for much greater flexibility in the way timelocks are applied.<br>
      In simple terms, by adding the CLTV opcode in the redeem script of an
      output it<br>
      restricts the output, so that it can only be spent after the specified
      time has elapsed.<br>
      While nLocktime is a transaction-level timelock, CLTV is an output-<br>
      based timelock.<br>
      CLTV doesn’t replace nLocktime, but rather restricts specific UTXO such
      that they can<br>
      only be spent in a future transaction with nLocktime set to a greater or
      equal value.<br>
      The CLTV opcode takes one parameter as input, expressed as a number in the
      same<br>
      format as nLocktime (either a block height or Unix epoch time). As
      indicated by the<br>
      VERIFY suffix, CLTV is the type of opcode that halts execution of the
      script if the out‐<br>
      come is FALSE. If it results in TRUE, execution continues.<br>
      In order to lock an output with CLTV, you insert it into the redeem script
      of the out‐<br>
      put in the transaction that creates the output. For example, if Alice is
      paying Bob’s<br>
      address, the output would normally contain a P2PKH script like this:<br>
      DUP HASH160 &lt;Bob's Public Key Hash&gt; EQUALVERIFY CHECKSIG<br>
      158<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      To lock it to a time, say 3 months from now, the transaction would be a
      P2SH trans‐<br>
      action with a redeem script like this:<br>
      &lt;now + 3 months&gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &lt;Bob's
      Public Key Hash&gt;<br>
      EQUALVERIFY CHECKSIG<br>
      where &lt;now + 3 months&gt; is a block height or time value estimated 3
      months from the<br>
      time the transaction is mined: current block height + 12,960 (blocks) or
      current Unix<br>
      epoch time + 7,760,000 (seconds). For now, don’t worry about the DROP
      opcode that<br>
      follows CHECKLOCKTIMEVERIFY; it will be explained shortly.<br>
      When Bob tries to spend this UTXO, he constructs a transaction that
      references the<br>
      UTXO as an input. He uses his signature and public key in the unlocking
      script of<br>
      that input and sets the transaction nLocktime to be equal or greater to
      the timelock in<br>
      the CHECKLOCKTIMEVERIFY Alice set. Bob then broadcasts the transaction on
      the bit‐<br>
      coin network.<br>
      Bob’s transaction is evaluated as follows. If the CHECKLOCKTIMEVERIFY
      parameter Alice<br>
      set is less than or equal the spending transaction’s nLocktime, script
      execution contin‐<br>
      ues (acts as if a “no operation” or NOP opcode was executed). Otherwise,
      script exe‐<br>
      cution halts and the transaction is deemed invalid.<br>
      More precisely, CHECKLOCKTIMEVERIFY fails and halts execution, marking the
      transac‐<br>
      tion invalid if (source: BIP-65):<br>
      1. the stack is empty; or<br>
      2. the top item on the stack is less than 0; or<br>
      3. the lock-time type (height versus timestamp) of the top stack item and
      the nLock<br>
      time field are not the same; or<br>
      4. the top stack item is greater than the transaction’s nLocktime field;
      or<br>
      5. the nSequence field of the input is 0xffffffff.<br>
      CLTV and nLocktime use the same format to describe timelocks,<br>
      either a block height or the time elapsed in seconds since Unix<br>
      epoch. Critically, when used together, the format of nLocktime<br>
      must match that of CLTV in the inputs—they must both reference<br>
      either block height or time in seconds.<br>
      After execution, if CLTV is satisfied, the time parameter that preceded it
      remains as the<br>
      top item on the stack and may need to be dropped, with DROP, for correct
      execution<br>
      of subsequent script opcodes. You will often see CHECKLOCKTIMEVERIFY
      followed by<br>
      DROP in scripts for this reason.<br>
      Timelocks<br>
      &nbsp;|<br>
      &nbsp;159<br>
      By using nLocktime in conjunction with CLTV, the scenario described in
      “Transaction<br>
      locktime limitations” on page 157 changes. Because Alice locked the UTXO
      itself, it is<br>
      now impossible for either Bob or Alice to spend it before the 3-month
      locktime has<br>
      expired.<br>
      By introducing timelock functionality directly into the scripting
      language, CLTV<br>
      allows us to develop some very interesting complex scripts.<br>
      The standard is defined in BIP-65 (CHECKLOCKTIMEVERIFY).<br>
      Relative Timelocks<br>
      nLocktime and CLTV are both absolute timelocks in that they specify an
      absolute point<br>
      in time. The next two timelock features we will examine are relative
      timelocks in that<br>
      they specify, as a condition of spending an output, an elapsed time from
      the confir‐<br>
      mation of the output in the blockchain.<br>
      Relative timelocks are useful because they allow a chain of two or more
      interdepend‐<br>
      ent transactions to be held off chain, while imposing a time constraint on
      one trans‐<br>
      action that is dependent on the elapsed time from the confirmation of a
      previous<br>
      transaction. In other words, the clock doesn’t start counting until the
      UTXO is recor‐<br>
      ded on the blockchain. This functionality is especially useful in
      bidirectional state<br>
      channels and Lightning Networks, as we will see in “Payment Channels and
      State<br>
      Channels” on page 284.<br>
      Relative timelocks, like absolute timelocks, are implemented with both a
      transaction-<br>
      level feature and a script-level opcode. The transaction-level relative
      timelock is<br>
      implemented as a consensus rule on the value of nSequence, a transaction
      field that is<br>
      set in every transaction input. Script-level relative timelocks are
      implemented with<br>
      the CHECKSEQUENCEVERIFY (CSV) opcode.<br>
      Relative timelocks are implemented according to the specifications in
      BIP-68, Rela‐<br>
      tive lock-time using consensus-enforced sequence numbers and BIP-112,
      CHECKSE‐<br>
      QUENCEVERIFY.<br>
      BIP-68 and BIP-112 were activated in May 2016 as a soft fork upgrade to
      the consen‐<br>
      sus rules.<br>
      Relative Timelocks with nSequence<br>
      Relative timelocks can be set on each input of a transaction, by setting
      the nSequence<br>
      field in each input.<br>
      Original meaning of nSequence<br>
      The nSequence field was originally intended (but never properly
      implemented) to<br>
      allow modification of transactions in the mempool. In that use, a
      transaction contain‐<br>
      160<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      ing inputs with nSequence value below 232 (0xFFFFFFFF) indicated a
      transaction that<br>
      was not yet “finalized.” Such a transaction would be held in the mempool
      until it was<br>
      replaced by another transaction spending the same inputs with a higher
      nSequence<br>
      value. Once a transaction was received whose inputs had an nSequence value
      of 232 it<br>
      would be considered “finalized” and mined.<br>
      The original meaning of nSequence was never properly implemented and the
      value of<br>
      nSequence is customarily set to 232 in transactions that do not utilize
      timelocks. For<br>
      transactions with nLocktime or CHECKLOCKTIMEVERIFY, the nSequence value
      must be<br>
      set to less than 232 for the timelock guards to have effect. Customarily,
      it is set to<br>
      232 – 1 (0xFFFFFFFE).<br>
      nSequence as a consensus-enforced relative timelock<br>
      Since the activation of BIP-68, new consensus rules apply for any
      transaction contain‐<br>
      ing an input whose nSequence value is less than 231 (bit 1&lt;&lt;31 is
      not set). Program‐<br>
      matically, that means that if the most significant (bit 1&lt;&lt;31) is
      not set, it is a flag that<br>
      means “relative locktime.” Otherwise (bit 1&lt;&lt;31 set), the nSequence
      value is reserved<br>
      for other uses such as enabling CHECKLOCKTIMEVERIFY, nLocktime,
      Opt-In-Replace-<br>
      By-Fee, and other future developments.<br>
      Transaction inputs with nSequence values less than 231 are interpreted as
      having a rel‐<br>
      ative timelock. Such a transaction is only valid once the input has aged
      by the relative<br>
      timelock amount. For example, a transaction with one input with an
      nSequence rela‐<br>
      tive timelock of 30 blocks is only valid when at least 30 blocks have
      elapsed from the<br>
      time the UTXO referenced in the input was mined. Since nSequence is a
      per-input<br>
      field, a transaction may contain any number of timelocked inputs, all of
      which must<br>
      have sufficiently aged for the transaction to be valid. A transaction can
      include both<br>
      timelocked inputs (nSequence &lt; 231) and inputs without a relative
      timelock (nSe<br>
      quence &gt;= 231).<br>
      The nSequence value is specified in either blocks or seconds, but in a
      slightly different<br>
      format than we saw used in nLocktime. A type-flag is used to differentiate
      between<br>
      values counting blocks and values counting time in seconds. The type-flag
      is set in<br>
      the 23rd least-significant bit (i.e., value 1&lt;&lt;22). If the type-flag
      is set, then the nSe<br>
      quence value is interpreted as a multiple of 512 seconds. If the type-flag
      is not set, the<br>
      nSequence value is interpreted as a number of blocks.<br>
      When interpreting nSequence as a relative timelock, only the 16 least
      significant bits<br>
      are considered. Once the flags (bits 32 and 23) are evaluated, the
      nSequence value is<br>
      usually “masked” with a 16-bit mask (e.g., nSequence &amp; 0x0000FFFF).<br>
      Малюнок&nbsp; 7-1 shows the binary layout of the nSequence value, as
      defined by BIP-68.<br>
      Timelocks<br>
      &nbsp;|<br>
      &nbsp;161<br>
      Малюнок&nbsp; 7-1. BIP-68 definition of nSequence encoding (Source:
      BIP-68)<br>
      Relative timelocks based on consensus enforcement of the nSequence value
      are<br>
      defined in BIP-68.<br>
      The standard is defined in BIP-68, Relative lock-time using
      consensus-enforced<br>
      sequence numbers.<br>
      Relative Timelocks with CSV<br>
      Just like CLTV and nLocktime, there is a script opcode for relative
      timelocks that lev‐<br>
      erages the nSequence value in scripts. That opcode is CHECKSEQUENCEVERIFY,
      com‐<br>
      monly referred to as CSV for short.<br>
      The CSV opcode when evaluated in a UTXO’s redeem script allows spending
      only in a<br>
      transaction whose input nSequence value is greater than or equal to the
      CSV parame‐<br>
      ter. Essentially, this restricts spending the UTXO until a certain number
      of blocks or<br>
      seconds have elapsed relative to the time the UTXO was mined.<br>
      As with CLTV, the value in CSV must match the format in the corresponding
      nSe<br>
      quence value. If CSV is specified in terms of blocks, then so must
      nSequence. If CSV is<br>
      specified in terms of seconds, then so must nSequence.<br>
      Relative timelocks with CSV are especially useful when several (chained)
      transactions<br>
      are created and signed, but not propagated, when they’re kept “off-chain.”
      A child<br>
      transaction cannot be used until the parent transaction has been
      propagated, mined,<br>
      and aged by the time specified in the relative timelock. One application
      of this use<br>
      case can be seen in “Payment Channels and State Channels” on page 284 and
      “Routed<br>
      Payment Channels (Lightning Network)” on page 297.<br>
      CSV is defined in detail in BIP-112, CHECKSEQUENCEVERIFY.<br>
      Median-Time-Past<br>
      As part of the activation of relative timelocks, there was also a change
      in the way<br>
      “time” is calculated for timelocks (both absolute and relative). In
      bitcoin there is a<br>
      subtle, but very significant, difference between wall time and consensus
      time. Bitcoin<br>
      162<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      is a decentralized network, which means that each participant has his or
      her own per‐<br>
      spective of time. Events on the network do not occur instantaneously
      everywhere.<br>
      Network latency must be factored into the perspective of each node.
      Eventually<br>
      everything is synchronized to create a common ledger. Bitcoin reaches
      consensus<br>
      every 10 minutes about the state of the ledger as it existed in the past.<br>
      The timestamps set in block headers are set by the miners. There is a
      certain degree of<br>
      latitude allowed by the consensus rules to account for differences in
      clock accuracy<br>
      between decentralized nodes. However, this creates an unfortunate
      incentive for min‐<br>
      ers to lie about the time in a block so as to earn extra fees by including
      timelocked<br>
      transactions that are not yet mature. See the following section for more
      information.<br>
      To remove the incentive to lie and strengthen the security of timelocks, a
      BIP was<br>
      proposed and activated at the same time as the BIPs for relative
      timelocks. This is<br>
      BIP-113, which defines a new consensus measurement of time called
      Median-Time-<br>
      Past.<br>
      Median-Time-Past is calculated by taking the timestamps of the last 11
      blocks and<br>
      finding the median. That median time then becomes consensus time and is
      used for<br>
      all timelock calculations. By taking the midpoint from approximately two
      hours in<br>
      the past, the influence of any one block’s timestamp is reduced. By
      incorporating 11<br>
      blocks, no single miner can influence the timestamps in order to gain fees
      from trans‐<br>
      actions with a timelock that hasn’t yet matured.<br>
      Median-Time-Past changes the implementation of time calculations for
      nLocktime,<br>
      CLTV, nSequence, and CSV. The consensus time calculated by
      Median-Time-Past is<br>
      always approximately one hour behind wall clock time. If you create
      timelock trans‐<br>
      actions, you should account for it when estimating the desired value to
      encode in<br>
      nLocktime, nSequence, CLTV, and CSV.<br>
      Median-Time-Past is specified in BIP-113.<br>
      Timelock Defense Against Fee Sniping<br>
      Fee-sniping is a theoretical attack scenario, where miners attempting to
      rewrite past<br>
      blocks “snipe” higher-fee transactions from future blocks to maximize
      their profita‐<br>
      bility.<br>
      For example, let’s say the highest block in existence is block #100,000.
      If instead of<br>
      attempting to mine block #100,001 to extend the chain, some miners attempt
      to<br>
      remine #100,000. These miners can choose to include any valid transaction
      (that<br>
      hasn’t been mined yet) in their candidate block #100,000. They don’t have
      to remine<br>
      the block with the same transactions. In fact, they have the incentive to
      select the<br>
      most profitable (highest fee per kB) transactions to include in their
      block. They can<br>
      include any transactions that were in the “old” block #100,000, as well as
      any transac‐<br>
      Timelocks<br>
      &nbsp;|<br>
      &nbsp;163<br>
      tions from the current mempool. Essentially they have the option to pull
      transactions<br>
      from the “present” into the rewritten “past” when they re-create block
      #100,000.<br>
      Today, this attack is not very lucrative, because block reward is much
      higher than<br>
      total fees per block. But at some point in the future, transaction fees
      will be the<br>
      majority of the reward (or even the entirety of the reward). At that time,
      this scenario<br>
      becomes inevitable.<br>
      To prevent “fee sniping,” when Bitcoin Core creates transactions, it uses
      nLocktime to<br>
      limit them to the “next block,” by default. In our scenario, Bitcoin Core
      would set<br>
      nLocktime to 100,001 on any transaction it created. Under normal
      circumstances,<br>
      this nLocktime has no effect—the transactions could only be included in
      block<br>
      #100,001 anyway; it’s the next block.<br>
      But under a blockchain fork attack, the miners would not be able to pull
      high-fee<br>
      transactions from the mempool, because all those transactions would be
      timelocked<br>
      to block #100,001. They can only remine #100,000 with whatever
      transactions were<br>
      valid at that time, essentially gaining no new fees.<br>
      To achieve this, Bitcoin Core sets the nLocktime on all new transactions
      to &lt;current<br>
      block # + 1&gt; and sets the nSequence on all the inputs to 0xFFFFFFFE to
      enable nLock<br>
      time.<br>
      Scripts with Flow Control (Conditional Clauses)<br>
      One of the more powerful features of Bitcoin Script is flow control, also
      known as<br>
      conditional clauses. You are probably familiar with flow control in
      various program‐<br>
      ming languages that use the construct IF...THEN...ELSE. Bitcoin
      conditional clauses look<br>
      a bit different, but are essentially the same construct.<br>
      At a basic level, bitcoin conditional opcodes allow us to construct a
      redeem script that<br>
      has two ways of being unlocked, depending on a TRUE/FALSE outcome of
      evaluating a<br>
      logical condition. For example, if x is TRUE, the redeem script is A and
      the ELSE<br>
      redeem script is B.<br>
      Additionally, bitcoin conditional expressions can be “nested”
      indefinitely, meaning<br>
      that a conditional clause can contain another within it, which contains
      another, etc.<br>
      Bitcoin Script flow control can be used to construct very complex scripts
      with hun‐<br>
      dreds or even thousands of possible execution paths. There is no limit to
      nesting, but<br>
      consensus rules impose a limit on the maximum size, in bytes, of a script.<br>
      Bitcoin implements flow control using the IF, ELSE, ENDIF, and NOTIF
      opcodes. Addi‐<br>
      tionally, conditional expressions can contain boolean operators such as
      BOOLAND,<br>
      BOOLOR, and NOT.<br>
      164<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      At first glance, you may find the bitcoin’s flow control scripts
      confusing. That is<br>
      because Bitcoin Script is a stack language. The same way that 1 + 1 looks
      “backward”<br>
      when expressed as 1 1 ADD, flow control clauses in bitcoin also look
      “backward.”<br>
      In most traditional (procedural) programming languages, flow control looks
      like this:<br>
      if (condition):<br>
      code to run when condition is true<br>
      else:<br>
      code to run when condition is false<br>
      code to run in either case<br>
      In a stack-based language like Bitcoin Script, the logical condition comes
      before the<br>
      IF, which makes it look “backward,” like this:<br>
      condition<br>
      IF<br>
      code to run when condition is true<br>
      ELSE<br>
      code to run when condition is false<br>
      ENDIF<br>
      code to run in either case<br>
      When reading Bitcoin Script, remember that the condition being evaluated
      comes<br>
      before the IF opcode.<br>
      Conditional Clauses with VERIFY Opcodes<br>
      Another form of conditional in Bitcoin Script is any opcode that ends in
      VERIFY. The<br>
      VERIFY suffix means that if the condition evaluated is not TRUE, execution
      of the<br>
      script terminates immediately and the transaction is deemed invalid.<br>
      Unlike an IF clause, which offers alternative execution paths, the VERIFY
      suffix acts as<br>
      a guard clause, continuing only if a precondition is met.<br>
      For example, the following script requires Bob’s signature and a pre-image
      (secret)<br>
      that produces a specific hash. Both conditions must be satisfied to
      unlock:<br>
      HASH160 &lt;expected hash&gt; EQUALVERIFY &lt;Bob's Pubkey&gt; CHECKSIG<br>
      To redeem this, Bob must construct an unlocking script that presents a
      valid pre-<br>
      image and a signature:<br>
      &lt;Bob's Sig&gt; &lt;hash pre-image&gt;<br>
      Without presenting the pre-image, Bob can’t get to the part of the script
      that checks<br>
      for his signature.<br>
      This script can be written with an IF instead:<br>
      HASH160 &lt;expected hash&gt; EQUAL<br>
      IF<br>
      Scripts with Flow Control (Conditional Clauses)<br>
      &nbsp;|<br>
      &nbsp;165<br>
      &lt;Bob's Pubkey&gt; CHECKSIG<br>
      ENDIF<br>
      Bob’s unlocking script is identical:<br>
      &lt;Bob's Sig&gt; &lt;hash pre-image&gt;<br>
      The script with IF does the same thing as using an opcode with a VERIFY
      suffix; they<br>
      both operate as guard clauses. However, the VERIFY construction is more
      efficient,<br>
      using one fewer opcode.<br>
      So, when do we use VERIFY and when do we use IF? If all we are trying to
      do is to<br>
      attach a precondition (guard clause), then VERIFY is better. If, however,
      we want to<br>
      have more than one execution path (flow control), then we need an
      IF...ELSE flow<br>
      control clause.<br>
      An opcode such as EQUAL will push the result (TRUE/FALSE) onto<br>
      the stack, leaving it there for evaluation by subsequent opcodes. In<br>
      contrast, the opcode EQUALVERIFY suffix does not leave anything on<br>
      the stack. Opcodes that end in VERIFY do not leave the result on the<br>
      stack.<br>
      Using Flow Control in Scripts<br>
      A very common use for flow control in Bitcoin Script is to construct a
      redeem script<br>
      that offers multiple execution paths, each a different way of redeeming
      the UTXO.<br>
      Let’s look at a simple example, where we have two signers, Alice and Bob,
      and either<br>
      one is able to redeem. With multisig, this would be expressed as a 1-of-2
      multisig<br>
      script. For the sake of demonstration, we will do the same thing with an
      IF clause:<br>
      IF<br>
      &lt;Alice's Pubkey&gt; CHECKSIG<br>
      ELSE<br>
      &lt;Bob's Pubkey&gt; CHECKSIG<br>
      ENDIF<br>
      Looking at this redeem script, you may be wondering: “Where is the
      condition?<br>
      There is nothing preceding the IF clause!”<br>
      The condition is not part of the redeem script. Instead, the condition
      will be offered<br>
      in the unlocking script, allowing Alice and Bob to “choose” which
      execution path they<br>
      want.<br>
      Alice redeems this with the unlocking script:<br>
      &lt;Alice's Sig&gt; 1<br>
      The 1 at the end serves as the condition (TRUE) that will make the IF
      clause execute<br>
      the first redemption path for which Alice has a signature.<br>
      166<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      For Bob to redeem this, he would have to choose the second execution path
      by giving<br>
      a FALSE value to the IF clause:<br>
      &lt;Bob's Sig&gt; 0<br>
      Bob’s unlocking script puts a 0 on the stack, causing the IF clause to
      execute the sec‐<br>
      ond (ELSE) script, which requires Bob’s signature.<br>
      Since IF clauses can be nested, we can create a “maze” of execution paths.
      The<br>
      unlocking script can provide a “map” selecting which execution path is
      actually exe‐<br>
      cuted:<br>
      IF<br>
      script A<br>
      ELSE<br>
      IF<br>
      scriptELSE<br>
      scriptENDIF<br>
      ENDIF<br>
      B<br>
      C<br>
      In this scenario, there are three execution paths (script A , script B ,
      and script C).<br>
      The unlocking script provides a path in the form of a sequence of TRUE or
      FALSE val‐<br>
      ues. To select path script B, for example, the unlocking script must end
      in 1 0<br>
      (TRUE, FALSE). These values will be pushed onto the stack, so that the
      second value<br>
      (FALSE) ends up at the top of the stack. The outer IF clause pops the
      FALSE value and<br>
      executes the first ELSE clause. Then the TRUE value moves to the top of
      the stack and<br>
      is evaluated by the inner (nested) IF, selecting the B execution path.<br>
      Using this construct, we can build redeem scripts with tens or hundreds of
      execution<br>
      paths, each offering a different way to redeem the UTXO. To spend, we
      construct an<br>
      unlocking script that navigates the execution path by putting the
      appropriate TRUE<br>
      and FALSE values on the stack at each flow control point.<br>
      Complex Script Example<br>
      In this section we combine many of the concepts from this chapter into a
      single<br>
      example.<br>
      Our example uses the story of Mohammed, the company owner in Dubai who is<br>
      operating an import/export business.<br>
      In this example, Mohammed wishes to construct a company capital account
      with<br>
      flexible rules. The scheme he creates requires different levels of
      authorization depend‐<br>
      ing on timelocks. The participants in the multisig scheme are Mohammed,
      his two<br>
      partners Saeed and Zaira, and their company lawyer Abdul. The three
      partners make<br>
      decisions based on a majority rule, so two of the three must agree.
      However, in the<br>
      Complex Script Example<br>
      &nbsp;|<br>
      &nbsp;167<br>
      case of a problem with their keys, they want their lawyer to be able to
      recover the<br>
      funds with one of the three partner signatures. Finally, if all partners
      are unavailable<br>
      or incapacitated for a while, they want the lawyer to be able to manage
      the account<br>
      directly.<br>
      Here’s the script that Mohammed designs to achieve this:<br>
      IF<br>
      IF<br>
      2<br>
      ELSE<br>
      &lt;30 days&gt; CHECKSEQUENCEVERIFY DROP<br>
      &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIGVERIFY<br>
      1<br>
      ENDIF<br>
      &lt;Mohammed's Pubkey&gt; &lt;Saeed's Pubkey&gt; &lt;Zaira's Pubkey&gt; 3
      CHECKMULTISIG<br>
      ELSE<br>
      &lt;90 days&gt; CHECKSEQUENCEVERIFY DROP<br>
      &lt;Abdul the Lawyer's Pubkey&gt; CHECKSIG<br>
      ENDIF<br>
      Mohammed’s script implements three execution paths using nested IF...ELSE
      flow<br>
      control clauses.<br>
      In the first execution path, this script operates as a simple 2-of-3
      multisig with the<br>
      three partners. This execution path consists of lines 3 and 9. Line 3 sets
      the quorum<br>
      of the multisig to 2 (2-of-3). This execution path can be selected by
      putting TRUE<br>
      TRUE at the end of the unlocking script:<br>
      0 &lt;Mohammed's Sig&gt; &lt;Zaira's Sig&gt; TRUE TRUE<br>
      The 0 at the beginning of this unlocking script is because of a bug<br>
      in CHECKMULTISIG that pops an extra value from the stack. The<br>
      extra value is disregarded by the CHECKMULTISIG, but it must be<br>
      present or the script fails. Pushing 0 (customarily) is a workaround<br>
      to the bug, as described in “A bug in CHECKMULTISIG execution”<br>
      on page 150.<br>
      The second execution path can only be used after 30 days have elapsed from
      the cre‐<br>
      ation of the UTXO. At that time, it requires the signature of Abdul the
      lawyer and one<br>
      of the three partners (a 1-of-3 multisig). This is achieved by line 7,
      which sets the<br>
      quorum for the multisig to 1. To select this execution path, the unlocking
      script<br>
      would end in FALSE TRUE:<br>
      0 &lt;Saeed's Sig&gt; &lt;Abdul's Sig&gt; FALSE TRUE<br>
      168<br>
      &nbsp;|<br>
      &nbsp;Chapter 7: Advanced Transactions and Scripting<br>
      Why FALSE TRUE? Isn’t that backward? Because the two values are<br>
      pushed on to the stack, with FALSE pushed first, then TRUE pushed<br>
      second. TRUE is therefore popped first by the first IF opcode.<br>
      Finally, the third execution path allows Abdul the lawyer to spend the
      funds alone,<br>
      but only after 90 days. To select this execution path, the unlocking
      script has to end in<br>
      FALSE:<br>
      &lt;Abdul's Sig&gt; FALSE<br>
      Try running the script on paper to see how it behaves on the stack.<br>
      A few more things to consider when reading this example. See if you can
      find the<br>
      answers:<br>
      • Why can’t the lawyer redeem the third execution path at any time by
      selecting it<br>
      with FALSE on the unlocking script?<br>
      • How many execution paths can be used 5, 35, and 105 days, respectively,
      after the<br>
      UTXO is mined?<br>
      • Are the funds lost if the lawyer loses his key? Does your answer change
      if 91 days<br>
      have elapsed?<br>
      • How do the partners “reset” the clock every 29 or 89 days to prevent the
      lawyer<br>
      from accessing the funds?<br>
      • Why do some CHECKSIG opcodes in this script have the VERIFY suffix while
      others<br>
      don’t?<br>
    </p>
    <h2>Глава 8</h2>
    <h1> Мережа Bitcoin</h1>
    <h3> Мережева архитектура Peer-to-Peer</h3>
    <p> Bitcoin структуровано як мережу peer-to-peer зверху інтернету. Термін
      peer-to-peer, або P2P, означає, що комп'ютери, що приймають участь в
      мережі є сторонами один до одного, що вони всі рівні, що немає “особливих”
      вузлів, та що всі вузли розділяють тягар по запровадженню мережевих
      сервісів. Вузли мережі взаємодіють в решітчастій мережі з “пласкою”
      топологією. Немає сервера, немає централізованого сервісу, та немає
      ієрархії в мережі. Вузли в P2P мережі провадять та споживають послуги
      одночасно, на взаємних засадаї діючи як стимул для участі. Мережі P2P є
      природно стійкими, децентралізованими, та відкритими. Видатним прикладом
      архитектури P2P мережі був самий ранішній інтернет, коли вузли IP мережі
      були рівними. Сьогоднішня архитектура інтернет є більш ієрархічною, але
      протокол інтернета все ще зберігає свою пласко-рівневу основу. </p>
    <p>За межами біткоіна, найширше та найбільш успішне застосування P2P
      технологій є розділення файлів, де Napster був піонером, та BitTorrent
      став найпізнішою еволюцією архитектури.</p>
    <p>Мережева архитектура P2P Bitcoin є більше ніж вибір архитектури. Bitcoin
      є цифровою монетарною системою P2P по задумці, та мережева архітектура
      обоє, є відображення та основа цієї базової характеристики.
      Децентралізація керування є базовим принципом, що може бути досягнуто та
      підтримано пласкою, децентралізованою P2P мережею консенсуса. </p>
    <p> Термін “мережа біткоін” посилається на набір вузлів, що виконують P2P
      протокол біткоіна. На додаток до протокола біткоін P2P, існують також і
      інші протоколи, такі як Stratum, що використовуються для майнингу, та
      легковажних або мобільних гаманців. Ці додаткові протоколи провадяться
      через сервери маршрутизації, що отримують до мережі біткоін, з
      використанням протоколу біткоін P2P, та потім розширюють цю мережу
      вузлами, що виконують інші протоколи. Наприклад, сервери Stratum поєднують
      сервери майнінгу Stratum через протокол Stratum до головної мережі
      біткоін, та перекидають протокол Stratum до протоколу біткоін P2P. Ми
      використовуємо термін “розширена мережа біткоін” для посилання загальної
      мережі, що включає протокол біткоіна P2P, протоколи майнінгових пулів,
      протокол Stratum, та любі інші пов'язані протоколи, що поєднують
      компоненти системи біткоін.<br>
    </p>
    <h3>Типи та ролі вузлів</h3>
    <p> Хоча вузли в мережі біткоін P2P є рівними, вони можуть приймати на себе
      різні мови, в залежності від підтримуваної функціональності. Вузол біткоін
      є набором функцій: маршрутизація, база даних блокчейну, майнинг та послуги
      гаманця. Повний вузол з усіма ціма чотирма функціями, показаний на Малюнку
      8-1.</p>
    <p> Малюнок 8-1. Вузол мережі біткоін з усіма чотирма функціями: гаманець,
      майнер, повна база даних блокчена, та мережева маршрутизація<br>
    </p>
    <p>Всі вузли включають функцію маршрутизації, щоб брати участь в мережі, та
      можуть включати іншу функціональність. Всі вузли перевіряють та просувають
      транзакції та блоки, та знаходять і підтримують з'єднання до інших сторін.
      В прикладі повного вузла на Малюнку 8-1, функція маршрутизації позначена
      помаранчевим колом з надписом “Вузол мережевої маршрутизації” або літерою
      “N.”<br>
    </p>
    <p>Деякі вузли, що називаються повними вузлами, також підтримують повну та
      актуальну копію блокчейну. Повні вузли можуть автономно та авторитетно
      веріфікувати любу транзакцію без зовнішніх посилань. Деякі вузли
      обслуговують тільки підмножину блокчейну, та веріфікують транзакції,
      використовуючи метод, що називається спрощеною верифікацією платежів, або
      SPV. Ці вузли відомі як SPV вузли або легковажні вузли. В прикладі повного
      вузла на малюнку, функція зберігання повної бази даних блокчейну позначена
      синім колом з написом “Повний блокчейн”, або літерою “B.” На Малюнку 8-3,
      вузли SPV намальовані без синього кола, показуючи, що вони не мають повної
      копії блокчейна. </p>
    <p> Майнаючі вузли змагаються за створення нових блоків через використання
      спеціалізованого обладнання для вирішення алгоритма доказу виконаної
      роботи. Деякі майнаючі вузли також є повними вузлами, що обслуговують
      повну копію блокчейну, тоді коли інші є легковажними вузлами, що беруть
      участь в майнінгових пулах, та покладаються на сервер пула для підтримки
      повного вузла. Функція майнінгу показана на повному вузлі як корне коло з
      надписом “Майнер” або літерою “M.”</p>
    <p>Користувацькі гаманці можуть бути частиною повного вузла, як це загалом є
      для десктопних клієнтів біткоін. Все більше користувацьких гаманців,
      особливо що виконуються на ообмежених в ресурсах пристроях, як спартфони,
      є SPV вузлами. Функція гаманця показана на Малюнку 8-1 як зелене коло з
      надписом “Гаманець”, або літерою “W.”</p>
    <p> На додаток до головних типів вузлів на протоколі біткоіна P2P, існують
      сервери та вузли, що виконують інші протоколи, такі, як спеціалізовані
      протоколи протоколи майнінгових пулів, та легковажні протоколи доступу
      клієнтів. Малюнок 8-2 показує найбільш загальні типи вузлів для розширеної
      мережі біткоін.</p>
    <h3> Розширена мережа біткоін</h3>
    <p> Головна мережа біткоін, що виконує протокол біткоін P2P, складаєтсья з
      від 5000 до 8000 слухаючих вузлів, що виконують різні версії референсного
      клієнта біткоін (Bitcoin Core), та декілька сотен вузлів, що виконують
      інші реалізації біткоін протоколу P2P, таких як Bitcoin Classic, Bitcoin
      Unlimited, BitcoinJ, Lib‐bitcoin, btcd, та bcoin. Неувеликий відсоток
      вузлів мережі біткоін P2P також є майнуючими вузлами, що змагаються в
      процесі майнингу, валідують транзакції, та створюю нові блоки. Різні
      великі компанії взаємодіють з мережею біткоін через виконання повних
      клієнтів на базі клієнта Bitcoin Core, з повною копією блокчейна та
      мережевого вузла, але без майнингу та функцій гаманця. Ці вузли діють як
      прикордонні мережеві маршрутизатори, дозволяючи різноманітні послуги
      (обмін, гаманці, дослідження блоків, обробку торгових платежів), що
      будуються зверху.</p>
    <p> Розширена мережа біткоін включає мережу, що виконує мережевий протокол
      P2P. описаний вище, так само, як і вузли, що виконують спеціалізовані
      протоколи. Приєднані до головної мережі біткоін P2P network є декілька
      серверів пулів, та протокольних шлюзів, що поєднують вузли, які
      використовують різні протоколи. Ці інші вузли здебільшого є вузли пулів
      майнінгу (дивіться Главу 10) та легковажні клієнті гаманців, що не несе
      повної копії блокчейну.</p>
    <p>Малюнок 8-3 показує розширену меержу біткоін з різними типами вузлів,
      серверами-шлюзами, прикордонними маршрутизаторами, та клієнтами гаманців,
      ат різні протоколи, що вони використовують для з'єднання один до одного.</p>
    Малюнок 8-2. Різні типи вузлів на розширеній мережі біткоін<br>
    <p> Малюнок 8-3. Розширена мережа біткоін, що показує типи вузлів, шлюзи та
      протоколи</p>
    <h3> Релейні мережі Bitcoin</h3>
    <p> В той час, коли мережа біткоіна P2P прислуговується головним потребам
      широкого різноманіття типів вузлів, він виявляє дуже високу затримку
      мережі для спеціалізованих потреб вузлів майнінгу біткоіна. Майнери
      Bitcoin заохочуються в швидкому змаганні для вирішення проблеми доказу
      виконанної роботи, та розширення блокчейна (дивіться Главу 10). Під час
      цього змагання, майнери біткоін мають мінімізувати час між просуванням
      блока-переможця, та початком наступного раунду змагань. В майнінгу
      мережева затримка напряму пов'язана з рівнем доходів.<br>
    </p>
    <p>Релейна мережа Bitcoin Relay Network є мережею, що намагається
      мінімізувати затримкау в передачі блоків між майнерами. Оригінальна
      Bitcoin Relay Network була створена одним з головних розробників Matt
      Corallo в 2015му році, щоб дозволити синхронізацію блоків між майнерами з
      дуже малою затримкою. Мережа складається з декількох спеціалізованих
      вузлів, розташованих на інфраструктурі Amazon Web Services по всьому
      світі, та призначених для поєднання більшості майнерів та майнінгових
      пулів.</p>
    <p> Оригінальна мережа Bitcoin Relay Network була замінена в 2016му році з
      вступом в дію пришвидшеної системи Fast Internet Bitcoin Relay Engine або
      FIBRE, також створеною розробником Matt Corallo. FIBRE є основаною на UDP
      релейною мережою, що пересилає блоки в мережі з вузлів. FIBRE реалізує
      компактну оптимізацію блоків для подальшого зменшення числа переданих
      даних та мережевої затримки.</p>
    <p>Інша релейна мережа (все ще в фазі пропозиції) є Falcon, базована на
      дослідженнях в Cornell University. Falcon використовує “підрізану
      маршрутизацію”, замість “зберегти та переслати”, щоб зменшити затримку
      через просування блоків по мірі надходження, скоріше, ніж очікувати
      отримки цілого блока. </p>
    <p> Релейні мережі не є заміною для мережі біткоін P2P. Замість цього вони є
      надбудованими мережами, що провадять додаткові поєднання між вузлами з
      спеціальними потребами. Як автостради не є замінником сільських доріг, але
      скоріше скороченнями між двома точками з великим трафіком, ви все ще
      потребуєте малі дороги для виїзду на шосе.</p>
    <h3> Пошук мережі</h3>
    <p>Коли новий вузол розпочинає роботу, він має знайти інші вузли біткоіна в
      мережі, щоб прийняти участь в обміні. Щоб розпочати процес, новий вузол
      має визначити щонайменьше один існуючий вузол в мережі, та під'єднатись до
      нього. Географічне розташування інших вузлів не має значення; топологія
      мережі біткоін географічно невизначена. Таким чином, любі існуючі вузли
      біткоін можуть бути обрані випадково.<br>
    </p>
    <p>Щоб під'єднатись до відомого вузла, вузли встановлюють TCP з'єднання,
      звичайно на порту 8333 (порт, загально відомий, як той, що
      використовується в біткоін), або альтернативний порт, якщо він
      запроваджений. Під час встановлення з'єднання вузол почне з “привітання”
      (дивіться Малюнок 8-4), передаючи повідомлення з версією, що містить
      базову ідентифікуючу інформацію, включаючи:</p>
    <ul>
      <li>Версію. Версія протокола біткоін, на якій “розмовляє” клієнт
        (наприклад, 70002)</li>
      <li>Локальні сервіси. Перелік локальних сервісів, що підтримуються вузлом.
        Наразі тільки NODE_NETWORK</li>
      <li>Час. Поточний час</li>
      <li>Віддалена адреса addrYou. Адреса віддаленого вузла, як вона бачиться з
        цього вузла</li>
      <li>Власна адреса addrMe, IP адреса локального вузла, як визначено
        локальним вузлом</li>
      <li>Субверсія, субверсія, що показує тип програмного забезпечення, що
        виконується (напр. /Satoshi:0.9.2.1/)</li>
      <li>Найкраща висота. Висота блоку в блокчейні вузла.</li>
    </ul>
    <p>(Дивіться GitHub щодо приклада повідомлення версії мережі).<br>
    </p>
    <p>Повідомлення версії завжди є першим повідомленням, надісланим з кожного
      вузла до іншого, Локальна сторона, отримавши повідомлення версії, буде
      перевіряти надіслану віддаленим вузлом версію, та вирішить, чи віддалений
      вузол є сумісним. Якщо віддалений вузол є сумісним, локальний вузол прийме
      повідомлення версії, та встановить з'єднання, надіславши verack.</p>
    <p>Як новий вузол знаходить інші? Перший метод є запит DNS, використовуючи
      декілька “DNS зернят”, що є DNS серверами, що провадять список IP адрес
      вузлів. Деякі з ціх DNS зерен провадять статичний список IP адрес
      стабільно слухаючих вузлів біткоін. Деякі з DNS зерен є власними
      реалізаціями BIND (Berkeley Internet Name Daemon), що повертає випадковий
      набір зі списку адрес вузлів біткоін, що зібрані краулером або довго
      працюючим вузлом. Клієнт Bitcoin Core містить імена п'яти різних DNS
      зерен. Різноманітність в належності та різноманітність в реалізації різних
      DNS зерен забезпечує високій рівень надійності для початкового процесу
      розкрутки. В клієнті Bitcoin Core опція для використання DNS зернят
      контролюється опцією-перемикачем -dnsseed (встановлений в 1 по замовчанню
      для використання DNS зерен).</p>
    <p>Альтернативно, розпочинаючий роботу вузол, що нічого не знає по мережу,
      має отримати щонайменьше одну IP адресу одного вузла біткоін після чого
      він може встановити з'єднання через подальше дослідження. Можуть бути
      використаний аргумент командного рядка -seednode, щоб з'єднатись до одного
      вузла, тільки для запитів щодо інших вузлів, використовуючи його як
      зернятко. Після того, як початковий вузол-зерно використаний для
      початкового завантаження, клієнт відключається від нього, та використовує
      тільки но отримані сторони. </p>
    <p> Малюнок 8-4. Початкове привітання між сторонами<br>
    </p>
    <p>Коли один або більше з'єднань встановлено, новий вузол буде надсилати
      повідомлення addr, що містить його власну IP аддресу своїм сусідам. Сусіди
      будуть, в свою чергу, перевсилати повідомлення addr до своїх сусідів,
      переконуючись, що новий вузол стане гарно відомим та краще з'єднаним.
      Додатково, тільки що під'єднаний вузол може надіслати getaddr до своїх
      сусідів, запитуючи їх повернути список IP адреси інших сторін. Таким
      чином, вузол може знайти сторони, з якими можна зв'язатись, та
      прорекламувати своє існування в мережі для інших вузлів. Малюнок 8-5
      показує протокол пошуку адрес.<br>
    </p>
    <p>Малюнок 8-5. Просування адрес та виявлення</p>
    <p> Вузол має з'єднатись до декількох різних вузлів, щоб встановити різні
      шляхи в мережі біткоін. Шляхи не надійні&nbsp; — вузли з'являються та
      відходять — так що вузел має продовжувати виявляти нові вузли, по мірі
      втрати старих з'єднань, так само, як і допомагати іншим, коли вони
      розпочинають роботу. Для розкручування потрібне тільки одне з'єднання,
      оскільки перший вузол може запропонувати початкові свідоцтва до відомих
      сторін, та ті вузли можуть надати подальші адреси. Також не має потреби,
      та є марнотратством мережевих ресурсів, під'єднуватись більше ніж до
      декількох вузлів. Після розкручування вузол буде пам'ятати його найбільш
      останні вдалі з'єднання з вузлами, так що якщо він буде перезавантажений,
      він швидко перевстановить з'єднання з його минулою мережею сторін. Якщо не
      один з його відомих сторін не відповідає на запити, вузол може використати
      зерна знову для нового розкручування в мережі.<br>
    </p>
    <p>На вузлі, що виконує Bitcoin Core, ви можете перелічити його з'єднання за
      допомоги команди getpeerinfo:<br>
    </p>
    <p>$ bitcoin-cli getpeerinfo<br>
      [<br>
      {<br>
      "addr" : "85.213.199.39:8333",<br>
      "services" : "00000001",<br>
      "lastsend" : 1405634126,<br>
      "lastrecv" : 1405634127,<br>
      "bytessent" : 23487651,<br>
      "bytesrecv" : 138679099,<br>
      "conntime" : 1405021768,<br>
      "pingtime" : 0.00000000,<br>
      "version" : 70002,<br>
      "subver" : "/Satoshi:0.9.2.1/",<br>
      },<br>
      {</p>
    <p>"inbound" : false,<br>
      "startingheight" : 310131,<br>
      "banscore" : 0,<br>
      "syncnode" : true<br>
      "addr" : "58.23.244.20:8333",<br>
      "services" : "00000001",<br>
      "lastsend" : 1405634127,<br>
      "lastrecv" : 1405634124,<br>
      "bytessent" : 4460918,<br>
      "bytesrecv" : 8903575,<br>
      "conntime" : 1405559628,<br>
      "pingtime" : 0.00000000,<br>
      "version" : 70001,<br>
      "subver" : "/Satoshi:0.8.6/",<br>
      "inbound" : false,<br>
      "startingheight" : 311074,<br>
      "banscore" : 0,<br>
      "syncnode" : false<br>
    </p>
    }]<br>
    <p> Щоб перекрити автоматиче керування сторонами, та щоб задати список IP
      адрес, користувачі можуть запровадити опцію -connect=&lt;IPAddress&gt;, та
      вказати одну або більше IP адрес. Якщо використовується ця опція, вузол
      буде тільки з'єднуватись до обраних IP адрес, замість визначати та
      обслуговувати з'єднання зі сторонами автоматично. Якщо по з'єднанню немає
      трафіка, вузли будуть періодично надсилати повідомлення для підтримки
      з'єднання. Якщо вузол не комунікує по з'єднанню більше 90 хвилин,
      вважається, що він відключений, та буде обраний інший. Таким чином, мережа
      динамічно підлаштовується до нестійких вузлів та мережевих проблем, та
      може органічно зростати та зменшуватись без жодного централізованого
      контролю.</p>
    <h3> Повні вузли</h3>
    <p> Повні вузли є такі вузли, що обробляють повний блокчейн з усіма
      транзакціями. Більш точно, вони можливо повинні називатись “вузли з повним
      блокчейном”. В ранішні роки біткоіна всі вузли були повними вузлами, та на
      сьогодні клієнт Bitcoin Core є вузлом з повним блокчейном. Однак в останні
      два роки, з'явились нові форми клієнтів біткоін, що не керують повним
      блокчейном, але виконуються як легковажні клієнти. Ми розглянемо їх в
      наступному розділі.</p>
    <p>Повні вузли блокчейну підтримують повну та актуальну копію блокчейна
      біткоінів з усіма транзакціями, що вони незалежно будують та перевіряють,
      починаючи з самого першого блоку (блоку створення), та будуючи аж до
      останнього відомого блоку в мережі. Пвний вузол блокчейну може незалежно
      та достовірно перевірити любу транзакцію без звертання або покладання на
      любий інший вузол або джерело інформації. Повний вузол блокчейну
      покладається на мережу для отримання оновлень щодо нових блоків або
      транзакцій, які він потім верифікує та вставляє у власну копію блокчейна.
      Виконання повного вузла блокчейна надає вам чистий досвід біткоін:
      незалезжну верифікацію всіх транзакцій без потреби покладатись або
      довіряти любій іншій системі. Легко сказати, чи ви виконуєте повний вузол,
      оскільки це потребує більше ста гігабайт постійного сховища (дискового
      протосру), щоб зберігати повний блокчейн. Якщо вам треба багато диску, та
      це займає два або три дні для синхронізації з мережею, ви виконуєте повний
      вузол. Це ціна за повну незалежність та свободу від центральної влади. <br>
    </p>
    <p>Існує декілька альтернативних реалізацій повного клієна блокчейна,
      побудованих на на різних мовах програмування та системних архитектурах.
      Однак найбільш загальна реалізація є референсний клієнт Bitcoin Core,
      також відомий як клієнт <br>
      Satoshi. Більше ніж 75% вузлів мережі біткоін виконують різні версії
      Bitcoin Core. Він ідентифікується як “Satoshi” в рядку суб-версії, що
      надсилається в повідомленні версії, та показується командою getpeerinfo.
      як ми бачили раніше; наприклад, /Satoshi:0.8.6/.</p>
    <h3> Обмін “інвентарем”</h3>
    <p> Перша річ, що буде робити повний вузол, як тільки він з'єднається з
      іншою стороною, він буде намагатись побудувати повний блокчейн. Якщо це
      новий вузол, він не має блокчейну зовсім, він знає тільки один блок, блок
      творіння, що статично вбудований в клієнтське програмне забезпечення.
      Починаючи з блоку #0 (блок творення), новий вузол буде мати завантажити
      тисячі блоків для синхронізації з мережею, та відтворення повного
      блокчейну.&nbsp;</p>
    <p> Процес синхронізації блокчейну починається з повідомлення версії,
      оскільки воно містить BestHeight, поточну висоту блокчейна (кількість
      блоків). Вузол буде дивитись на повідомлення версії від сторін, знати,
      скільки блоків має кожний з них, та бути в змозі порівняти з тим, скільки
      блоків він має в своєму блокчейні. Вузли сторін будуть отмінюватись
      повідомленням getblocks, що містить хеш (відтиск) верхнього блоку їхнього
      локального блокчейну. Один з вузлів буде в змозі ідентифікувати отримаинй
      хеш, як той, що не належить блоку нагорі, але скоріше належить старішому
      блоку, з чого роблячи висновок, що його блокчейн довший, ніж його візаві.
      Сторона, що має довший блокчейн, та має більше блоків, ніж інший вузол,
      може визначити, які блоки потребує інший вузол, та має завантажити сотні
      тисячів блоків для синхронізації з мережою та відтворення повного
      блокчейну. Він визначить перші 500 блоків для передачі, та передасть їх
      хеші з використанням повідомлення inv (inventory). Вузол, якому не
      вистачає ціх блоків, потім буде отримувати їх, через віддачу повідомлень
      getdata, запитуючи повний блок даних, та ідентифікуючи запитані блоки з
      використанням хешів з повідомлення inv.<br>
    </p>
    <p>Давайте уявімо, наприклад, що вузол має тільки блок творіння. Потім він
      отримає повідомлення inv від своїх співрозмовників, що міститиме хеші для
      наступних 500 блоків в ланцюгу. Він почне запитувати блоки в усіх
      підключених сторін, розподіляючи навантаження, та переконуючись, що він не
      перевантажує жодний з вузлів запитами. Вузол відстежує, як багато блоків є
      “в дорозі” на кожне з'єднання, означаючи блоки, що були запрошені, але ще
      не отримані, перевіряючи, що це число не перевищує обмеження
      (MAX_BLOCKS_IN_TRANSIT_PER_PEER). В такий спосіб, якщо йому потрібно
      багато блоків, він буде запитувати тільки нові, та не перевантажувати
      мережу. По мірі отримання кожного блоку, він додається до блокчейну, як ми
      побачимо в Главі 9. По мірі того, як локальний блокчейн відбудовується,
      більше блоків запитується та отримується, та процес продовжується, доки
      вузол не наздожене всю іншу мережу.</p>
    <p>Цей процес порівняння локального блокчейну з вузлами, та отримання
      недістаючих блоків, трапляється тільки під час того, як блок знаходиться
      офлайн деякий період часу. В той час, коли вузол знаходився офлайн, та
      пропустив декілька блоків, або цілий місяць, та пропустив декілька тисяч,
      він починає з надсилання getblocks, отримує відповідь inv, та починає
      завантажувати відсутні блоки. Малюнок 8-6 показує протокол інвентарізації
      та просування блоків.<br>
    </p>
    <p>Малюнок 8-6. Синхронізація блокчейну вузлів через отримання блоків від
      сторін<br>
    </p>
    <h3> Вузли спрощеної верифікації Simplified Payment Verification (SPV)</h3>
    <p> Не всі вузли мають можливість зберігати повний блокчейн. Багато Багато
      клієнтів біткоін розроблені щоб виконуватись в простір- та
      потужність-обмежених пристроях, таких, як спартфони, планшети, або
      вбудовані системи. Для таких пристроїв використовується метод спрощеної
      верифікації платежів (SPV), що дозволяє їм оперувати без зберігання
      повного блокчейну. Ці типи клієнтів назіваються SPV клієнтами, або
      легковажними клієнтами. По мірі зростання сприфняття біткоіну, вузли SPV
      стають найбільш загальною формою вузлів біткоін, особливо для гаманців
      біткоін. </p>
    <p>Вузли SPV завантажують тільки заголовки блоків, та не завантажують
      транзакції, включені в кожний блок. Отриманий ланціг блоків, без
      транзакцій, в 1,000 разів меньший, ніж повний блокчейн. SPV вузли не
      можуть побудувати повну картину всіх UTXO, що доступні для витрачання, бо
      вони не знають щодо всіх транзакцій в мережі. SPV вузли перевіряють
      трензакції, використовуючи дещо іншу методологію, що покладається на
      сторони для отримання часткових розрізів маючих відношення частин
      блокчейна на вимогу. Як аналогія, повний вузол подібний до туриста в
      чужому місці, що оснащений детальною картою кожної вулиці та кожної
      адреси. Для порівняння, SPV вузол подубний до туриста в чужому місці, що
      питається випадкових перехожих, де повернути в певному напрямку, знаючи
      лише про головний бульвар. Хоча обоє туристи можуть перевірити наявність
      вулиці, навідавшись до неї, турист без мапи не знає, що розташоване в
      кінці кожної вулиці, та навіть не знає, що існують інші вулиці.
      Розташований перед домом на вулиці Будівельників 10, турист без мапи не
      може знати, чи є ще інші адреси Будівельників 10 в місці, та чи є ця
      адреса вірною. Турист без мапи в кращому випадку запитає досить людей, та
      сподіватись, які з них не намагаються пошуткувати з ним.&nbsp;</p>
    <p> SPV пеервіряє транзакції за посиланням до їх глибини в блокчейні,
      замість їх висоти. В той час, коли повний вузол блокчейну буде будувати
      повний перевірений ланцюг з тісячів блоків, та транзакції досягають низу
      блокчейну (назад в часі) до самого блоку творіння, вузли SPV будуть
      перевіряти ланцюг з усіх блоків (але не всі транзакції), та пов'язувати
      цей ланцюг з транзакцією, що нас цікавить. Наприклад, при дослідженні
      транзакцій в блоці 300,000, повний вузол пов'язує всі 300,000 блоків
      донизу до блока творення, та будує повну базу UTXO, встановлюючи
      валідність транзакції через те, що UTXO залишились невитраченими.</p>
    <p> Вузол SPV не може перевірити, що UTXO не витрачене. Замість цього вузол
      SPV буде встановлювати зв'язок між транзакцією та блоком, що містить її,
      використовуючи шлях Меркля (дивіться "Дерева Меркля"). Потім SPV вузол
      очікує, доки він не побачить шість блоків, від 300,001 до 300,006,
      накладені звурху блока, що містить транзакцію, та перевіряє її,
      встановлюючи її глибину під блоками від 300,006 до 300,001. Факт, що інші
      вузли мережі сприйняли блок 300,000, та потім виконали потрібну роботу для
      продукування ще шости блоків зверху для його підтвердження, та одночасно
      що транзакція не була двічі витрачена.&nbsp;</p>
    <p> SPV вузол не може бути переконаний, що транзакція існує в блоці, коли
      транзакція насправді не існує. Вузол SPV встановлює присутність транзакції
      в блоці, запитуючи підтвердження шляху Меркля, та через валідацію
      підтвордження виконаної роботи в ланцюзі блоків. Однак присутність
      транзакції може бути “прихована” від SPV вузла. Вузол SPV однозначно може
      впевнитись, що транзакція існує, але не може перевірити, що транзакція,
      така, як повторне витрачення того самого UTXO, не існує, оскільки він не
      має запису всіх транзакцій. Ця вразливість може біти використана в атаці
      типа відмови в обслуговувані, або для атак подвійного витрачання проти
      вузлів SPV. Щоб захиститись від цього, вузол SPV має випадково
      підключатись до декількох вузлів, щоб підвищити вірогідність, що він має
      з'язок з щонайменьше одним чесним вузлом. Ця потреба в випадкових зв'язках
      означає, що вузли SPV також вразливі до атак розділення мережі, або атак <br>
      Sybil (<em>захаращення мережі псевдонімами, найбільше відома через атаку
        на Tor. прим. перекл.</em>), коли вони під'єднуються до файкових вузлів,
      або фейкових мереж, та на мають доступа до реальної мережі біткоін.</p>
    <p> З більш практичних міркувань, гарно поєднані вузли SPV є досить
      безпечними, утримуючи баланс між потребами в русурсах, практичністю та
      безпекою. Однак для непохитної безпеки ніщо не зрівняється з повним вузлом
      блокчена. Повний вузол блокчейна перевіряє транзакцію через перевірку
      всього ланцюга з тисяч блоків пді нею, щоб гарантувати, що UTXO не
      витрачений, тоді як вузол SPV перевіряє, як глибоко блок похований під
      блоками нам ним.</p>
    <p> Щоб отримати заголовки блоків, вузли SPV використовують повідомлення
      getheaders, замість getblocks. Відповідаюча сторона буде надсилати до
      2,000 заголовків блоків, використовуючи одне повідомлення headers. В
      іншому процес той же самий, що і використовується повними вузлами для
      отримання повних блоків.&nbsp; Вузли SPV також встановлюють фільтр на
      з'єднання зі сторонами, щоб фільтрувати потік майбутніх блоків та
      транзакцій, надісланих сторонами. Любі цікаві транзакції отримуються з
      використанням запиту getdata. Сторона генерує повідомлення tx, що містить
      транзакції, в якості відповіді. Малюнок 8-7 показує синхронізацію
      заголовків блоків. Оскільки вузли SPV потребують отримувати специфічні
      транзакції, щоб вибірково перевіряти їх, вони також створюють ризик для
      приватності. На відміну від повних вузлів блокчейна, що збирають всі
      транзакції в кожному блоці, запити вузлів SPV щодо специфічних даних
      можуть ненавмисно виказати адресу в вашому гаманці. Наприклад, третя
      сторона, що моніторить мережу, може відстежити всі транзакції, запитані
      гаманцем вузла SPV, та використати це для асоціації адрес біткоіна з
      користувачем цього гаманці, зруйнувавши приватність користувача. </p>
    <p>Малюнок 8-7. Вузол SPV синхронізує аголовки блоків</p>
    <p> Швидко після появи SPV/легковажних вузлів, розробники біткоін додали
      можливість, що називається фільтрами Блума, щоб адресувати ризики
      приватності SPV вузлів. Фільтри Блума дозволяють SPV вузлам отримувати
      підмножину транзакцій, без розкриття, які саме адреси нас цікавлять, через
      механізм фільтрування, що використовує вірогідності, замість фіксованих
      шаблонів.&nbsp;</p>
    <h3> Фільтри Блума</h3>
    <p> Фільтри Блума (або блумівські фільтри) є вірогіднісні фільтри пошуку,
      спосіб описати бажаний шаблон без його явного задання. Фільтри Блума
      пропонують ефективний шлях виражати шаблон пошуку, при цьому захищаючи
      приватність. Вони використовуються SPV вузлами для опитування своїх
      співрозмовників в пошуках транзакцій, відповідаючих специічним шаблонам,
      без розкриття, які саме адреси, ключі або транзакції ми шукаємо.</p>
    <p>В нашій попередній аналогії, турист без мапи питає щодо певної адреси,
      Будівельників 10. Якщо він питає перехожих щодо напрямку до цієї вулиці,
      раніше чи пізніше він знайде напрямок. Блумівській фільтр схожий на запит
      "Чи є якісь вулиці пооблизу, чиї назви закінчуються на Н-К-В?". Запитання,
      як це, користувач розкриває трохи меньше щодо потрібного напрямку, ніж
      запитувати Будівельників 10. Використовуючи цей прийом, турист може
      вказати потірбну адресу в більших деталях, як “завершується на Л-Н-К-В”,
      або меньше деталей, як “завершується на В”. Через зміну точності пошуку,
      турист розкриває більше або меньше інформації, ціною отримання більших або
      меньших результатів. Якщо він запитує менш специфічний шаблон, він отримає
      більше можливих адрес, та кращу приватність, але багато результатів не
      будуть мати відношення. Якщо буде запитаний більш специфічний шаблон, буде
      отримано меньше результатів та втрачено більше приватності. </p>
    <p> Блумівські фільтри служать цій функції, що дозволяє вузлу SPV вказувати
      шаблон пошуку для транзакцій, що можуть бути налаштовані в напрямку
      точності або приватності. Більш специфічний блумівський фільтр продукує
      більш точні результати, але ціною розкриття, в яких шаблонах зацікавлений
      SPV вузол, і, таким чином, розкриваючи адреси, якими володіє гаманець
      користувача. Менш специфічний блумівській фільтр буде продукувати більше
      даних щодо транзакцій, багато не маючих відношення до вузла, але це
      дозволить вузлу підтримувати кращу приватність.&nbsp;</p>
    <h3> Як роблять блумівські фільтри</h3>
    <p> Блумівські фільтри реалізовані як масиви змінної довжини з N бінарних
      цифр (бітових полів), та змінного числа з M хеш функцій. Хеш функції
      розроблені так, щоб завжди продукувати на виході значення від 1 до N,
      відповідно до масиву бінарних цифр. Хеш функції генеруються
      детерміністично, так що любий вузол, що реалізує блумівській фільтр, буде
      завжди використовувати ті самі хеш функції, та отримувати той самий
      результат для однакових даних на вході. Обираючи різну довжину (N)
      блумівськіх фільтрів, та різне число (M) хеш функцій, блумівській фільтр
      може бути налаштований, змінюючи рівень точності, та, таким чином,
      приватності. </p>
    <p> На Малюнку 8-8 ми використовуємо дуже малий масив з 16 біт, та
      встановлюємо три хеш функції, щоб продемонструвати, як робить блумівській
      фільтр. </p>
    <p>Малюнок 8-8. Приклад спрощеного блумівського фільтра, з 16-бітним полем
      та трьома хеш функціями</p>
    <p>Блумівській фільтр ініціалізується так, що масив біт є всі нулі. Щоб
      додати шаблон до блумівського фільтра, шаблон хешується кожною хеш
      функцією по черзі. Застосовуючи першу хеш функцію до вхідних даних дає
      число від 1 до N. <br>
      <br>
      Малюнок 8-10. Додаючи другий шаблон “B” до нашого спрощеного блумівського
      фільтра</p>
    <p>Щоб протестувати, чи шаблон є частиною блумівського фільтра, шаблон
      хешується кожною функцією, та отриманий бітовий шаблон перевіряється по
      бітовому масиву. Якщо всі біти, індексовані хеш функцією, встановлені в 1,
      тоді шаблон, можливо, записаний в блумівській функції. Оскільки біти
      можуть бути встановлені як результат перекриття багатьох шаблонів,
      відповідь не є певною, але скоріше вірогіднісна. В простих виразах,
      позитивне співпадіння блумівського фільтра є "Можливо, так".&nbsp;</p>
    <p> Малюнок 8-11 є прикладом перевірки наявності шаблона “X” в простому
      блумівському фільтрі. Відповідні біти встановлені в 1, так що шаблоно
      можливо співпадає.</p>
    <p>Малюнок 8-11. Перевірка наявності шаблона “X” в блумівському фільтрі.
      Результат є вірогіднісним позитивним співпадінням, що означає "Можливо". <br>
    </p>
    <p>На відміну від цього, якщо шаблон перевіряється по блумівському фільтру,
      та один з бітів встановлений в 0, це напевно означає, що шаблон не
      записаний в блумівському фільтрі. Негативний результат не є вірогідністю,
      це визначеність. Простими словами, негативне співпадіння на блумівському
      фільтрі є "Напевне ні".</p>
    <p>Малюнок 8-12 є прикладом тестування існування шаблона “Y” в простому
      блумівському фільтрі. Один з відповідних біт встановллений в 0, так що
      шаблон напевне не співпадає.</p>
    <p> Малюнок 8-12. Тестування існування шаблону “Y” в блумівському фільтрі.
      Результатом є визначено негативне співпадіння, що означає "Напевне ні".</p>
    <h3> Як SPV вузли використовують блумівські фільтри</h3>
    <p>Блумівські фільтри використовуються для фільтрування транзакцій (та
      блоків, що містять їх), що вузол SPV отримує від сторін, відбираючи тільки
      транзакції, що цікавлять SPV вузол, без розкриття, в яких адресах або
      ключах вони зацікавлені. Вузол SPV буде ініуіалізувати блумівській фільтр
      як “пустий”; в цьому стані блумівській фільтр буде співпадати з любими
      шаблонами. Вузол SPV потім складатиме список всіх адрес, ключів та хешей,
      в яких він зацікавлений. Він робить це, через виділення хеша публічного
      ключа, та хеша скрипта та ID транзакцій з UTXO, що контролюються
      гаманцем.&nbsp; Після цього вузол SPV додає кожний з них до блумівського
      фільтра, так що блумівській фільтр буде “співпадати”, якщо ці шаблони
      представлені в транзакції, без розкриття самих шаблонів.&nbsp;</p>
    <p> Потім вузол SPV надсилатиме повідомлення filterload до іншої сторони, що
      містить блумівській фільтр, що треба використовувати в з'єднанні. На тій
      стороні блумівські фільтри перевіряються для кожної входячої транзакції.
      Повний вузол перевіряє декілька частин транзакції з блумівськім фільтром,
      шукаючи співпадіння, включаючи:<br>
      • ID транзакції<br>
      • Компоненти даних з блокуючих скриптів кожного виходу транзакцій (кожний
      ключ та хеш в скрипті)<br>
      • Кожний зі входів транзакції<br>
      • Кожний з компонентів даних сигнатури входящих (або скрипта
      підтвердження)</p>
    <p>Перевіряючи всі ці компоненти, блумівські фільтри можуть бути використані
      для порівняння хешів публічних ключів, скриптів, значень OP_RETURN,
      публічних ключів в сигнатурах, або любій майбутній компоненті смарт
      контракті або складному скрипті.&nbsp;</p>
    <p> Після встановлення фільтру сторона буде перевіряти вихід кожної
      транзакції на блумівському фільтрі. Тільки транзакції, що співпадають з
      фільтром, надсилаються до вузла. У відповідь на повідомлення getdata від
      вузла, сторони будуть надсилати повідомлення merkleblock, що містить
      тільки заголовки блоків, для блоків, що співпадають з фільтром та
      мерклівськім шляхом (дивіться “Мерклівські дерева”) для кожної транзакції.
      Інша сторона після цього надсилатиме tx повідомлення, що міститиме
      транзакції, що співпадають з фільтром. По мірі того, як повний вузол
      надсилає транзакції до SPV вузла, вузол SPV відхиляє любі фальшиві
      співпадіння, та використовує потрібні транзакції для оновлення свого
      набору UTXO та баланс в гаманці. По мірі того, як він оновлює свій погляд
      на набір UTXO, він також модифікує блумівській фільтр, щоб співпадати з
      подальшими транзакціями, що посилаються на тільки що знайдені UTXO. Повний
      вузол використовує новий блумівській фільтр для перевірки нових
      транзакцій, та весь процес повторюється.&nbsp;</p>
    <p> Налаштування вузла щодо блумівського фільтра може інтерактивно додавати
      шаблони до фільтра, надсилаючи повідомлення filteradd. Щоб очистити
      блумівській фільтр, вузол може надіслати повідомлення filterclear.
      Оскільки неможливо видалити шаблон з блумівського фільтра, вузол має
      очистити та встановити новий блумівській фільтр, якщо деякий шаблон більше
      не потрібний. Мережевий протокол та механізм фільтрування для SPV вузлів
      визначений в BIP-37 (Peer Services).</p>
    <h3> SPV вузли та приватність</h3>
    <p> Вузли, що реалізують SPV, мають слабшу приватність, ніж повний вузол.
      Повний вузол отримує всі транзакції, і, таким чином, не розкриває
      інформацію щодо того, чи використовує він деяку адресу в своєму гаманці.
      SPV вузол отримує фільтрований список транзакцій, що мають відношення до
      адрес, що є в його гаманці. Як результат, він зменшує приватність
      власника. Блумівські фільтри є шляхом для зменьшення втрати приватності.
      Без них вузол SPV буде мати явний список адрес, в яких він зацікавлений,
      створюючи суттєву прогалину в приватності. Однак, навіть з блумівськіми
      фільтрами, супротивник, що мониторить трафік SPV клієнта або напряму
      під'єднаний до нього як вузол P2P мережі, може з часом зібрати досить
      інформації, щоб розпізнати адреси в гаманці SPV клієнта.</p>
    <h3> Зашифровані та аутентифіковані з'єднання</h3>
    <p> Більшість нових користувачів біткоін вважають, що мережеві комунікації
      вузла біткоін є зашифровані. Фактично, оригінальна реалізація біткоін
      комунікує повністю відкрито. Хоча це не головна турбота безпеки повних
      вузлів, це велика проблема для SPV вузлів. Шляхом підвищити приватність
      мережі біткоін P2P, існує два рішення для запровадження шифрування
      комунікацій: транспорт Tor та P2P аутентифікація та шифрування
      BIP-150/151.</p>
    <h3> Транспорт Tor</h3>
    <p> Tor, що означає мережу The Onion Routing, є програмним проектом та
      мережею, що надає шифрування та енкапсуляцію даних, через випадкові
      мережеві шляхи, що пропонує анонімність, невідстежуваність та приватність.
      Bitcoin Core пропонує декілька опцій конфігурації, що дозволяють вам
      виконувати вузол біткоін, надсилаючи трафк через мережу Tor. На додаток,
      Bitcoin Core також може запропоеувати прихований Tor сервіс, дозволяючи
      іншим Tor вузлам з'єднуватись до вашого вузла напряму через Tor.</p>
    <p> В Bitcoin Core версії 0.12, вузол буде надавати прихований Tor сервіс
      автоматично, якщо він буде здатний підключитись до локального Tor сервіса.
      Якщо ви маєте встановлений Tor, та процес Bitcoin Core виконується як
      користувач з адекватними правами для доступу до аутефіканційного кукі Tor,
      він буде робити автоматично. Використовуйте флаг debug для ввімкнення
      налаштування Bitcoin Core для Tor сервісу, ось так:</p>
    <p> $ bitcoind --daemon --debug=tor<br>
    </p>
    <p>Ви маєте побачити “tor: ADD_ONION successful” в журналі, вказуючи, що
      Bitcoin Core додав прихований сервіс до Tor мережі. Ви можете знайти
      більше інструкцій по виконанню Bitcoin Core як прихованого сервісу Tor в
      документації Bitcoin Core (docs/tor.md), та різних інструкціях онлайн.</p>
    <h3> Аутентифікація та шифрування P2P</h3>
    <p> Дві пропозиції Bitcoin Improvement Proposals, BIP-150 та BIP-151,
      додають підтримку для P2P аутентифікації та шифруванняв мережі біткоін
      P2P. Ці два BIP визначають опціональні сервіси, що можуть бути надані
      через сумісні вузли біткоін. BIP-151 дозволяє домовлене шифрування для
      всіх комунікацій між двома вузлами, що підтримують BIP-151.&nbsp; BIP-150
      пропонує опціональну аутентифікацію сторони, що дозволяє вузлам
      вутентифікувати один одного з використанням ECDSA та приватних ключів.
      BIP-150 потребує, щоб перед аутентифікацією два вузли встановили шифроване
      з'єднання через BIP-151.</p>
    <p> Станом на січень 2017, BIP-150 та BIP-151 не реалізовані в&nbsp; Bitcoin
      Core. Однак ці дві пропозиції були реалізовані щонайменьше в одній
      альтернативній реалізації клієнта біткоін, bcoin.</p>
    <p> BIP-150 та BIP-151 дозволяють користувачам виконувати клієнти SPV, що
      під'єднані до довірених повних вузлів, використовуючи шифрування та
      аутентифікацію, для захисту приватності SPV клієнта. На додаток,
      аутентифікація може використовуватись для створення мереж довірених вузлів
      біткоін, та запобігання атакам посередників.&nbsp; Нарешті, шифрування
      P2P, при широкому розгортанні, посилить стійкість біткоіна до аналізу
      трафіка та порушуючих приватність досліджень, особливо в тоталітарних
      країнах, де використання інтернету значно контролюється та
      мониториться.&nbsp; Стандарт визначений в BIP-150 (Peer Authentication) та
      BIP-151 (Peer-to-Peer Communication Encryption).</p>
    <h3> Пули транзакцій</h3>
    <p> Майже кожний вузол в мережі біткоін підтримує тимчасовий список
      непідтверджених транзакцій, що називається пул в пам'яті, мемпул, або пул
      транзакцій. Вузли використовують цей пул для відсліджування транзакцій, що
      відомі для мережі, але доки не включені в блокчейн. Наприклад,
      вузол-гаманець використовує пул транзакцій для відстеження надходячих
      платежів до гаманця користувача, що були отримані мережею, але досі не
      підтверджені. По мірі того, як транзакції додаються та верифікуються, вони
      додаються до пула транзакцій, та розсилаються до сусідніх вузлів, щоб
      просувати їх в мережі. Деякі реалізації також підтримують окремий пул
      загублених транзакцій. Якщо входи транзакції посилаються не транзакцію, що
      досі не відома, така, як відсутній батько, загублена транзакція буде
      тимчасово зберігатись в пулі загублених, доки не з'явиться батьківська
      транзакція.</p>
    <p> Коли транзакція додана до пулу транзакцій, пул загублених перевіряється
      щодо жодних загублених транзакцій, що посилаються на вихід транзакції
      (дитину). Любі співпадаючі загублені транзакції валідуються. Якщо вона
      валідна, вона видаляється з пулу загублених, та додаються до пулу
      транзакцій, замикаючи ланцюг, що почався з батьківської транзакції. В
      світі нової доданої транзакції, що більше не загублена, процес
      повторюється рекурсивно, шукаючи подальших нащадків, доки інших нащадків
      не буде знайдено. На протязі цього процесу, надходження батьківської
      транзакції перемикає каскад реконструкції цілого ланцюга незалежних
      транзакцій, через поєднання загублених транзакцій з їхніми батьками, і так
      далі по ланцюгу. Обоє, пул транзакцій та пул загублених (якщо
      реалізований) зберігаються в локальній пам'яті, та не зберігаються в
      постійному сховищі; скоріше, вони динамічно заповнюються з входящих
      мережевих повідомлень. Коли вузол стартує, обоє пули пусті, та поступово
      заповнюються новими транзакціями, отриманими з мережі. <br>
    </p>
    <p>Деякі реалізації клієнтів біткоін обслуговують базу даних або пул UTXO,
      що є набором всіх невитрачених виходів блокчейну. Хоча ім'я “пул UTXO”
      виглядає подібним до пулу транзакцій, він представляє інший набір даних.
      На відміну від пулів транзакцій та загублених, пул UTXO не ініціалізується
      пустим, та замість цього містить мільйони входжень невитрачених виходів
      транзакцій, все що невитрачено за весь час з самого початку, до блоку
      творення.Пул UTXO може розміщуватись в локальній пам'яті, або як
      індексована база даних в постійному сховищі.<br>
    </p>
    <p>Хоча пули транзакцій та загублених представляють локальну перспективу
      поодинокого вузла, та можуть значно варіюватись від вузла до вузла, в
      залежності від того, коли вузол був стартований або рестартований, пул
      UTXO представляє досягнутий консенсус мережі, і, таким чином, може
      розрізнятись тільки незначно між вузлами. Більше того, пули транзакцій та
      загублених містять тільки непідтверджені транзакції, тоді як пул UTXO
      містить тільки підтверджені транзакції.<br>
    </p>
    <h2>Глава 9</h2>
    <h1>Блокчейн</h1>
    <h3> Вступ</h3>
    <p> Структура даних блокчейну є впорядкований, зв'язаний список блоків з
      транзакцій. Блокчейн може зберігатись в пласкому файлі, або в простій базі
      даних. Клієнт Bitcoin Core зберігає метадані блокчейну, використовуючи
      базу даних Google LevelDB. Блоки пов'язані “назад”, кожний посилається на
      попередній блок в ланцюжку. Блокчейн часто візуалізується як вертикальний
      стек, де блоки накладають зверху один одного, та блок творення
      прислуговується основою стеку. Візуалізація блоків в вигляді накладених
      один на одний призводить до виникнення відповідних термінів, таких, як
      "висота", що посилається на відстань від першого блоку, та "гора" або
      "верхівка", що посилаються на самий останній доданий блок. Кожний блок в
      блокчейні ідентифікується хешем, згенерованим криптографічним хеш
      алгоритмом SHA256 на заголовці блока. Кожний блок також посилається на
      попередній блок, відомий як батьківській блок, через поле "хеш
      попереднього блока" в заголовці блока. Іншими словами, кожний блок містить
      хеш свого батька в своєму заголовку. Послідовність хешів поєднує кожний
      блок з батьківськім та створює ланцюг, що іде назад до першого будь-коли
      створеного блоку, відомого як блок творення. Хотя блок має тільки одного
      батька, він може тимчасово мати більше одного нащадка. Кожний з нащадків
      посилається на той самий блок як на предок, та містить той самий
      (батьківський) хеш в полі "хеш попереднього блоку". Декілька дітей
      з'являються під час "розгалуження" блокчейну, тимчасової ситуації, що
      виникає, коли різні блоки винайдені майже одночасно різними майнерами
      (дивіться “Розгалуження&nbsp; блокчейну”). З часом один з дочірніх блоків
      стає частиною блокчпйну, та "розгалуження" стає влагодженин. Навіть
      зважаючи, що блок може мати більше одного нащадка, кожний блок може мати
      лише одного предка. Це так, бо блок має лише одне поле "хеш попереднього
      блока", що посилається на одного предка.</p>
    <p>Поле “хеш попереднього блока” розташоване в загаловці блока, і, таким
      чином, впливає на хеш поточного блоку. Власна ідентичність нащадка
      змінюється, якщо змінюється ідентичність батька. Якщо батько змінюється в
      деякий спосіб, змінюється і його хеш. Змінений хеш батька потребує зміну
      вказівника "хеш попереднього блоку" нащадка. Це, в свою чергу, викликає
      зміну хешу нащадка, та нащадка нащадка, і так далі. Цей каскадний ефект
      гарантує, що коли є багато поколінь після деякого блоку, він не може бути
      змінений без примусового переобчислення всіх послідовних блоків. Оскільки
      таке переобчислення може потребувати неможливих обчислень (і, таким чином,
      витрати енергії), наявність довгого ланцюга з блоків робить глибоку
      історію блокчена незмінною, що є ключовою властивістю безпеки
      біткоіна.&nbsp;</p>
    <p> Одним зі шляхів думати про блокчейн, це як про шари в геологічній
      формації, або зразом моделі льодовика. Поверхневі шари можуть змінюватись
      кожної пори року, або навіть змиті, доки вони не матимуть часу
      відкластись. Але коли ви переходите на декілька дюймів далі, геологічні
      шари стають більше і більше стабільними. Під час, коли ви дивитесь на
      декілька сотен футів нижче, ви дивитесь на знімок минулого, що залишалось
      непотурбованим мільйони років. В блокчейні найбільш останні блоки можуть
      переглянуті, якщо відбудеться переобчислення ланцюга через розгалуження.
      Верхівка з шести блоків подібні на зовнішні шару грунуту. Але коли ви
      йдете глибше в блокчейн, блоки все меньше та меньше вірогідно змінені.
      Після 100 блоків назад, існує так багато стабільності, що транзакція
      коінбейс — транзакція, що містить новий відкарбований біткоін — може бути
      витрачений. Декілька тисяч блоків назад (місяць) блокчейн є сталою
      історією, для всіх практичних застосувань. Тоді як протокол завжди
      дозволяє відкатити ланцюг через довший ланцюг, та в той час, коли завжди
      існує можливість зміни кожного блоку, вірогідність такої події
      зменьшується з плином часу, доки не стане нескінчено малою.</p>
    <h3> Структура блока</h3>
    <h3> </h3>
    <p>Блок є контейнерною структурою даних, що агрегує транзакції для включення
      в публічний часопис, блокчейн. Блок складається з заголовка, що містить
      метадані, за яким слідує довхий список транзакцій, що складають основну
      долю. Блок заголовку має 80 байт, тоді як середня транзакція є щонайменьше
      250 байтів, та середній блок містить більше ніж 500 транзакцій. Повний
      блок з усіма транзакціями є, таким чином, в 1000 разів довший, ніж
      заголовок блоку. Таблиця 9-1 описує структуру блоку. </p>
    <p>Таблиця 9-1. Структура блоку</p>
    <table style="width: 1049px; height: 118px;" border="0">
      <tbody>
        <tr>
          <td>Розмір<br>
          </td>
          <td>Поле<br>
          </td>
          <td>Опис<br>
          </td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>розмір блоку</td>
          <td>Розмір блоку, в байтах, що іде за цім полем</td>
        </tr>
        <tr>
          <td>80 байтів</td>
          <td>заголовок блоку</td>
          <td>Декілька полів з заголовку блока</td>
        </tr>
        <tr>
          <td>1-9 байт</td>
          <td>лічильник транзакцій</td>
          <td>Кількість транзакцій в блоці</td>
        </tr>
        <tr>
          <td>Варіант</td>
          <td>транзакції</td>
          <td>Транзакції, записані в блоці</td>
        </tr>
      </tbody>
    </table>
    <h3> Заголовок блоку</h3>
    <p> The block header consists of three sets of block metadata. First, there
      is a reference to<br>
      a previous block hash, which connects this block to the previous block in
      the block‐<br>
      chain. The second set of metadata, namely the difficulty, timestamp, and
      nonce, relate<br>
      to the mining competition, as detailed in Chapter 10. The third piece of
      metadata is<br>
      the merkle tree root, a data structure used to efficiently summarize all
      the transac‐<br>
      tions in the block. Table 9-2 describes the structure of a block header.<br>
      Table 9-2. The structure of the block header</p>
    <p> </p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td>Розмір</td>
          <td>Поле</td>
          <td>Опис</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>версія</td>
          <td>Числовий номер для відстеження оновлень програми або протокола</td>
        </tr>
        <tr>
          <td>32 байти</td>
          <td>хеш попереднього блока</td>
          <td>Посилання на хеш попереднього (бітьківського) блока в ланцюгу</td>
        </tr>
        <tr>
          <td>32 байти</td>
          <td>мерклівській корінь</td>
          <td>Хеш кореня мерклівського дерева транзакцій цього блока</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>часовий відтиск</td>
          <td>Приблизний час створення цього блока (секунди Юнікс-епохи)</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>цільова складність</td>
          <td>Ціль складності алгоритма підтвордження виконаної роботи для цього
            блока</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>довісок</td>
          <td>Лічильник, використаний в алгоритмі перевірки виконаної роботи</td>
        </tr>
      </tbody>
    </table>
    <p>Довісок, цільова складність та відтиск часу використовуються в процесі
      майнингу, та будуть обговорюватись більш детально в Главі 10.</p>
    <h3> Ідентифікатори блоку: хеш заголовку блока та висота блока</h3>
    <p>Первинний ідентифікатора блоку є його криптографічний хеш, цифровий
      відтиск, отриманих хешуванням заголовку блока двічи за допомогою алгоритма
      SHA256. Отриманий 32-байтний хеш називається хешем блока, але точніше його
      треба називати хешем заголовка блока, оскільки тільки заголовок блока
      використовується для його обчислення. Наприклад, <br>
      000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f є хешем
      блока першого створеного блоку біткоін. Хеш блоку ідентифікує блок
      унікально та безсумнівно, та може бути незалежно виведений любим вузлом
      простим хешуванням заголовка блока.</p>
    <p>Зауважте, що хеш блоку насправді не включений в структуру даних блоку, ні
      коли блок передається по мережі, ні коли він зберігається в постійному
      сховищі вузла як частина блокчейну. Замість цього хеш блока обчислюється
      кожний раз, коли блок отримується з мережі. Хеш блока може бути збережений
      в окремій таблиці бази даних, як частина метаданих блоків, щоб спростити
      індексування та скоріше отримувати блоки з диску.</p>
    <p> Другий блок ідентифікує блок по його позициї в блокчейні, що називається
      висотою блока. Перший будь-коли створений блок має висоту блока 0 (нуль),
      та той самий блок, що був попередньо посиланий наступним хешем блока <br>
      000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f. Блок
      може, таким чином, бути ідентифікований в два способи: через посилання на
      хеш блоку, або через посилання висоти блока. Кожний наступний блок додаєть
      "нагору" цього першого блоку на одну позицію вище в блокчейні, як ящики,
      поставлені один на одний. Висота блоків на 1 січня 2017 року був приблизно
      446,000, що означає, що 446,000 блоків покладені зверху першого блока,
      створеного в січні 2009. На відміну від хешу блока, висота блока не є
      унікальним ідентифікатором. Хоча окремий блок завжди має специфічну та
      незмінну висоту блока, зворотнє не є вірним — висота блока не завжди
      ідентифікує окремий блок. Два або більше блоків можуть мати ту саму висоту
      блока, змагаючись за ту саму позицію в блокчейні. Цей сценарій детально
      обговорений в розділі “Розгалуження блокчейн”. Висота блока також не є
      частиною структури даних блока; вона не збурігається в блоці. Кожний блок
      динамічно ідентифікується свою позицію блока (висоту) в блокчейні, коли
      він отримується з мережі біткоін. Висота блока може також зберігатись як
      метадані в індексованій базі даних для швидшого отримання. Хеш блоку
      завжди унікально індифікує блок. Блок також завжди має певну висоту блока.
      Однак не завжди так, що висота блока ідентифікує окремий блок. Скоріше,
      два або більше блоків можуть сперечатись за одну позицію в
      блокчейні.&nbsp;</p>
    <h3> Блок творення</h3>
    <p>Перший блок в блокчейні називається блоком творення, та був створений в
      2009му році. Він є загальним предком всіх блоків в блокчейні, що означає,
      що якщо ви почнете з любого блока, та прослідуюте назад в часі, ви з часом
      натрапите на блок творення.</p>
    <p>Кожний вузол завжди починається щонайменьше з одного блока, оскільки блок
      творення статично закодований в програмі клієнта біткоін, так що він не
      може бути змінений. Кожний вузол завжди “знає” хеш та структуру блока
      творення, фіксований час його створення, та навіть одну транзакцію в
      ньому. Таким чином, кожний вузол має стартову точку для блокчейну,
      безапечний “корінь”. від якого можна будувати довірений блокчейн.
      Подивіться на статичний блок творення в клієнті Bitcoin Core, в файлі
      chainparams.cpp.</p>
    <p> Наступний хеш ідентифікатор належить блоку творення:</p>
    <pre>      000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f<br>
      </pre>
    <p>Ви можете пошукати цей блок-хеш на любому сайті-переглядачі блока,
      такому, як blockchain.info, і в и знайдете сторінку, що описує вміст
      блоку, з URL, що містить хеш:</p>
    <p>
https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f<br>
https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</p>
    <p> Використовуючи референсний клієнт Bitcoin Core з командного рядка:<br>
    </p>
    <pre>$ bitcoin-cli getblock<br>
      000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f<br>
      {<br>
      "hash" :
      "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",<br>
      "confirmations" : 308321,<br>
      "size" : 285,<br>
      "height" : 0,<br>
      "version" : 1,<br>
      "merkleroot" : "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b",<br>
      "tx" : [<br>
      "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"<br>
      ],<br>
      "time" : 1231006505,<br>
      "nonce" : 2083236893,<br>
      "bits" : "1d00ffff",<br>
      "difficulty" : 1.00000000,<br>
      "nextblockhash" : "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048"<br>
      }</pre>
    <p> Блок творіння містить приховане в собі повідомлення. Вхід транзакції
      коінбейс містить текст “The Times 03/Jan/2009 Chancellor on brink of
      second bailout for banks”. Це повідомлення було признечене для надання
      гарантіі щодо самої ранішньої дати, коли був створений цей блок, через
      посилання на заголовок британської газети The Times. Воно також служить як
      грайливе нагадування про важливість незалежної монетарної системи, і що
      біткоін почав своє існування в той самий час, коли розгортався
      безпрецендентний світовий монетарний кризис. Повідомлення було вбудоване в
      перший блок Satoshi Nakamoto, створювачем біткоін.</p>
    <h3> Зв'язок блоків в біткоіні</h3>
    <p> Повні вузли біткоіну обслуговують локальну копію блокчейну, починаючи з
      блоку творіння. Локальна копія блокчейну постійно оновлюється, по мірі
      знаходження нових блоків, та вони використовуються для поширення ланцюга.
      Коли вузол отримує входящі блоки з мережи, він перевіряє ці блоки, та
      потім зв'язує їх з існуючим блокчейном. Щоб встановити зв'язок, вузол буде
      перевіряти заголовок надійшовшого блоку, та дивитись на "хеш попереднього
      блоку". </p>
    <p>Уявімо, наприклад, що вузол має 277,314 блоків в локальній копії
      блокчейну. Останній блок, про який знає вузол, є блок 277,314, з хешем
      заголовку:
      00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249. Потім
      вузол біткоін отримує новий блок з мережі, який він розбирає наступним
      чином:</p>
    <pre>      {</pre>
    <pre>      "size" : 43560,</pre>
    <pre>      "version" : 2,</pre>
    <pre>      "previousblockhash" : "00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249",</pre>
    <pre>      "merkleroot" : "5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d",</pre>
    <pre>      "time" : 1388185038,</pre>
    <pre>      "difficulty" : 1180923195.25802612,</pre>
    <pre>      "nonce" : 4215469401,</pre>
    <pre>      "tx" : [</pre>
    <pre>      "257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77",</pre>
    <pre>      #[... далі багато транзакцій пропущені ...]</pre>
    <pre>      }</pre>
    <pre>      ]</pre>
    <pre>      "05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"</pre>
    <pre>    </pre>
    <p>Дивлячись на цей новий блок, вузол знаходить поле previousblockhash, що
      містить хеш попереднього блоку. Цей хеш відомий вузлу, та він належить
      останньому блоку в ланцюгу на висоті 277,314. Таким чином, новий блок є
      дитиною останнього блоку в ланцюгу, та розширює існуючий блокчейн. Вузол
      додає цей новий блок в кінець ланцюга, що робить блокчейн довшим, з новою
      довжиною 277,315. Малюнок 9-1 показує ланцюг з трьох блоків, пов'язаних
      через посилання в полі previousblockhash.</p>
    <h3> Мерклівські дерева</h3>
    <p> Кожний блок в блокчейні біткоін містить підсумок всіх транзакцій в
      блоці, з використанням дерев Меркля. Мерклівське дерево, також відоме як
      бінарне хеш дерево, є структурою даних, що використовуються для
      ефективного підсумку та перевірки цілосності великих наборів даних.
      Мерклівські дерева є бінарними деревами, що містять криптографічні хеші.
      Термін "дерево" використовується в комп'ютерних науках, щоб описувати
      розгалужені структуру даних, але ці дерева зазвичай зображують до гори
      низом,&nbsp; з "коренем" зверху, та "листям" знизу діаграми, як ви бачита
      в наступних прикладах. <br>
    </p>
    <p>Малюнок 9-1. Блоки, пов'язані в ланцюг через посилання на хеш заголовку
      попереднього блоку</p>
    <p>Мерклівські дерева використовуються в біткоіні для підсумку всіх
      транзакцій в блоці, виробляючи загальний цифровий відтиск всього набору
      транзакцій, провадячи дуже ефективний процес для перевірки, чи транзакція
      включена в блок. Мерклівське дерево конструююється через рекурсивне
      хешування пар вузлів, доки не залишиться тільки один хеш, що називається
      коренем, або мерклівськім коренем. Криптографічний хеш алгоритм, що
      використовується в мерклівськіх деревах біткоін є SHA256, застосований
      двічі, також відомий як подвійний-SHA256.</p>
    <p>Коли N елементів даних хешуються та підсумовуються в мерклівському
      дереві, ви можете перевірити, та побачити, чи деякий елемент знаходиться в
      дереві щанайбільше за 2*log2(N) обчислень, роблячи це дуже ефективною
      структурою даних. Мерклівське дерево будується знизу догори. В наступному
      прикладі ми починаємо з чотирьох транзакцій, A, B, C, та D, що формують
      листя мерклівського дерева, як показно на Малюнку 9-2. Транзакції не
      зберігаються в мерклівському дереві; скоріше, їх дані захешовані, та
      отриманий хеш зберігається в кожному вузлі-листі, як&nbsp; HA, HB, HC, and
      HD:<br>
    </p>
    <p>HA = SHA256(SHA256(Транзакція A))<br>
    </p>
    <p>Послідовні пари листяних вузлів потім підсумовуються в батьківському
      вузлі, через конкатенацію двох хешів, та знову хешування отриманого рядка.
      Наприклад, щоб сконструювати батьківській вузол H AB, два 32-байтні хеші
      дітей конкатенуються, що створити 64-байтний рядок. Цей рядок потім двічі
      хешується, щоб отримати хеш батьківського вузла: HAB = SHA256(SHA256(HA +
      HB)). Процес продовжується, доки нагорі не залишиться лише один елемент,
      вузол, відомий я мерклівській корінь. Цей 32-байтний хеш зберігається в
      заголовку блока, та підсумовує всі дані в усіх транзакціях. Малюнок 9-2
      показує, як корінь обчислюється через попарні хеші вузлів.<br>
    </p>
    <img alt="" src="MBTC.pics/fig%209%202.png">
    <p>Малюнок 9-2. Обчислення вузлів в мерклівському дереві<br>
    </p>
    <p>Оскільки мерклівське дерево є бінарним деревом, йому потрібно мати парне
      число листів. Якщо треба підсумувати непарне число транзакцій, хеш
      останньої транзакції буде продубльовано, щоб створити парне число вузлів,
      що також відоме як збалансоване дерево. Це показано на Малюнку 9-3, де
      транзакція C продублікована.</p>
    <img alt="" src="MBTC.pics/fig%209%203.png">
    <p> Малюнок 9-3. Дублювання одного елементу даних дає парне число елементів
      даних</p>
    <p>Той самий метод конструювання дерева з восьми транзакцій може бути
      узагальнений для конструюванню дерев любого розміру. В біткоіні є
      загальним мати від декількох сотен та більше тисячі транзакцій в одному
      блоці, що підсумоване в рівно той самий спосіб, продукуючи тільки 32
      байтів даних, як єдиний мерклівській корінь. На Малюнку 9-4 ви бачите
      дерево, побудоване з 16 транзакцій. Зауважте, що хоча корінь виглядає
      більшим ніж вузли на диаграмі, він такого самого розміру, тільки 32
      байтів. Чи є в нас одна транзакція, або чи є сотня тисяч транзакцій в
      блоці, мерклівській корінь завжди дає їх підсумок розміром 32 байти.</p>
    <p> Щоб переконатись, що окрема транзакція включена в блок, вузлу треба
      тількки спродукувати log2(N) 32-байтних хешів, відбудовуючи шлях
      аутентифікації, або мерклівській шлях, що поєднує окремі транзакції до
      кореня дерева. Це особливо важливо, коли число транзакцій зростає, бо
      логарифм по сонові 2 від числа транзакцій зростає значно більш повільно.
      Це дозволяє вузлам біткоін ефективно продукувати шляхи з 10 або 12 хешів
      (320–384 байт), що може надати гарантію, що окрема транзакція є однією з
      більше ніж тисячі транзакцій в блоці розміром мегабайт. <br>
      <br>
      Малюнок 9-4. Мерклівське дерево підсумовує багато елементів даних<br>
    </p>
    <p>На Малюнку 9-5, вузол може переконатись, що транзакція K включена в блок,
      через продукування маркліського шляху, що довжиною тільки чотири 32-байтні
      хеші (128 байтів загалом). Шлях складається з чотирьох хешів (показаних з
      зафарбованим фоном на Малюнку 9-5) HL, HIJ,<br>
      HMNOP, та HABCDEFGH. З ціма чотирма хешами, що провадять шлях
      аутентифікації, кожний вузол може перевірити, що&nbsp; HK (з чорним фоном
      знизу діаграми) включений в мерклівській корінь, через обчислення
      додаткових попарних хешів HKL, HIJKL, HIJKLMNOP, та корінь мерклівсього
      дерева (обведене приривчастою лінією на діаграмі).<br>
    </p>
    <p>Малюнок 9-5. марклівській шлях, що використовується для перевірки
      входження елементу даних<br>
    </p>
    <p>Код в Прикладі 9-1 демонструє процес створення мерклівського дерева з
      хешів вузлів-листя, далі нагору до кореня, з використанням бібліотеки
      libbitcoin для деяких допоміжних функцій.<br>
    </p>
    <p>Приклад 9-1. Побудова мерклівського дерева</p>
    <pre> #include &lt;bitcoin/bitcoin.hpp&gt;<br>
      bc::hash_digest create_merkle(bc::hash_list&amp; merkle)<br>
      {<br>
      // Припинити, якщо список хешів порожній.<br>
      &nbsp;&nbsp;&nbsp; if (merkle.empty()) return bc::null_hash;<br>
      &nbsp;&nbsp;&nbsp; else if (merkle.size() == 1) return merkle[0];</pre>
    <pre>      // Доки існує більше одного хешу в списку...<br>
      &nbsp;&nbsp;&nbsp; while (merkle.size() &gt; 1) {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (merkle.size() % 2 != 0) merkle.push_back(merkle.back()); // Дублікуємо останній хеш, якщо список непарний.<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(merkle.size() % 2 == 0); // Тепер список парний. (<em>неуявна ситуація, коли це б не мало тут бути. прим. перекл.</em>)<br>
      </pre>
    <pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bc::hash_list new_merkle; // Новий список хешів.</pre>
    <pre>      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Проходимо до два за раз.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      for (auto it = merkle.begin(); it != merkle.end(); it += 2) {<br>
      </pre>
    <pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bc::data_chunk concat_data(bc::hash_size * 2); // Конкатенуємо два хеші разом.<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto concat = bc::serializer&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      decltype(concat_data.begin())&gt;(concat_data.begin());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      concat.write_hash(*it);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      concat.write_hash(*(it + 1));</pre>
    <pre>      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bc::hash_digest new_root = bc::bitcoin_hash(concat_data); // Хешуємо обоє хеши.<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new_merkle.push_back(new_root); // Додаємо до нового списку.<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; merkle = new_merkle; // Це новий список.<br>
      &nbsp;&nbsp;&nbsp; }<br>
      // DEBUG output -------------------------------------<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Поточний мерклівський хеш список:" &lt;&lt; std::endl;<br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; hash: merkle)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cout &lt;&lt; " " &lt;&lt; bc::encode_base16(hash) &lt;&lt;
      std::endl;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>
      // --------------------------------------------------<br>
      &nbsp;&nbsp;&nbsp; }<br>
      // Нарешті повертаємо один елемент.<br>
      &nbsp;&nbsp;&nbsp; return merkle[0];<br>
      }</pre>
    <pre>      int main()<br>
      {<br>
      // Замініть ці хеші з блоку, щоб відтворити той самий мерклівській корінь.<br>
      bc::hash_list tx_hashes{{<br>
      bc::hash_lit<br>
      eral("0000000000000000000000000000000000000000000000000000000000000000"),<br>
      bc::hash_lit<br>
      eral("0000000000000000000000000000000000000000000000000000000000000011"),<br>
      bc::hash_lit<br>
      eral("0000000000000000000000000000000000000000000000000000000000000022"),<br>
      }};<br>
      const bc::hash_digest merkle_root = create_merkle(tx_hashes);<br>
      std::cout &lt;&lt; "Result: " &lt;&lt; bc::encode_base16(merkle_root)
      &lt;&lt; std::endl;<br>
      return 0;<br>
      }<br>
      </pre>
    <p>Приклад 9-2 показує результат компіляції та виконання мерклівського коду.<br>
    </p>
    <p>Example 9-2. Компіляція та виконання прикладу мерклівського коду<br>
    </p>
    <pre>$ # Компілюємо код merkle.cpp<br>
      $ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin)<br>
      $ # Виконуємо мерклівську програму<br>
      $ ./merkle<br>
      Current merkle hash list:<br>
      32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d27006<br>
      30861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4<br>
      Current merkle hash list:<br>
      d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3<br>
      Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3<br>
      </pre>
    <p>Ефективність мерклівських дерев стає очевидною по мірі маштабування.
      Таблиця 9-3 показує обсяг дангих, що потрібен для обміну як мерклівський
      шлях, щоб переконатись, що транзакція є частиною блока. <br>
    </p>
    <p>Таблиця 9-3. Ефективність мерклівського шляху</p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td>Число транзакцій</td>
          <td>Примірний розмір блоку</td>
          <td>Розмір шляху (хешів)</td>
          <td>Розмір шляху (байт)</td>
        </tr>
        <tr>
          <td>16 транзакцій</td>
          <td>4Кб</td>
          <td>4 хеші</td>
          <td>128 байт</td>
        </tr>
        <tr>
          <td>512 транзакцій</td>
          <td>128Кб</td>
          <td>9 хешів</td>
          <td>288 байт</td>
        </tr>
        <tr>
          <td>2048 транзакцій</td>
          <td>512Кб</td>
          <td>11 хешів</td>
          <td>352 байтів</td>
        </tr>
        <tr>
          <td>65535 транзакцій</td>
          <td>12Мб</td>
          <td>16 хешів</td>
          <td>512 байтів</td>
        </tr>
      </tbody>
    </table>
    <br>
    Як ви можете бачити з цієї таблиці, навіть якщо розмір блоку зростає швидко,
    від 4Бб для 16 транзакцій до розміру блока 16Мб для розміщення 65535
    транзакцій, марклівський шлях, потрібний для перевірки включення транзакції,
    зростає значно повільніше, від 128 байт до тільки 512 байт. За допомогою
    мерклівських дерев, вузол може завантажити тільки заголовки блоку (80 байт
    на блок), та все ще будучи в змозі ідентифікувати включення транзакціх в
    блок, через отримання малого мерклівського шляху з повного вузла, без
    зберігання або передачі значної частини блокчейна, що може бути декілька
    гігабайт в розмірі. Вузли, що не обслуговують повний блокчейн, називають
    вузлами спрощеної верифікації платежів (SPV). Вони використовують
    мерклівські шляхи для верифікації транзакцій без повного завантаження повних
    блоків. <br>
    <h3> Мерклівські дерева та спрощена верифікація платежів (SPV)</h3>
    <p> Мерклівські дерева активно використовуються вузлами SPV. Вузли SPV не
      мають всіх транзакцій, та не завантажують повні блоки, але тільки
      заголовки блоків. Щоб перевірити, що транзакція включена в блок, без того,
      щоб завантажувати всі транзакції в блоці, вони використовують шлях
      аутентифікації, або мерклівський шлях.</p>
    <p>Розглянемо, наприклад, вузол SPV, що зацікавлений у вхідних платежах на
      адресу, що міститься в його гаманці. Вузол SPV буде встановлювати
      блумівській фільтр (дивіться "Блумівські фільтри") на своїх з'єднаннях до
      сторін, щоб обмежити отримані транзакції до тільки тих, що містять
      потрібну адресу. Коли сторона бачить транзакцію, що співпадає з
      блумівськім фільтром, вона надсилає цей блок з використанням повідомлення
      merkleblock. Повідомлення merkleblock містить заголовок блоку, так само,
      як і мерклівський шлях, що пов' язує цікаву транзакцію з мерклівським
      коренем блоку. Вузол SPV може використати цей мерклівській шлях для
      з'єднання транзакції з блоком, та перевірити, що транзакція включена в
      блок. Вузол SPV також використовує заголовок блоку для поєднання блоку з
      рештою блокчейну. Комбінація ціх двох посилань, між транзакцією та блоком,
      та між блоком та блокчейном, дає гарантію, що транзакція знаходиться в
      блокчейні. Врешті решт, вузол SPV має отримати меньше ніж кілобайт даних
      для заголовка блоку та мерклівського шляху, розмір даних, що більше ніж в
      тисячу разів меньше, ніж повний блок (наразі близько 1Мб).</p>
    <h3> Тестові блокчейни біткоін</h3>
    <p> Ви можете бути здивовані, коли пізнаєте, що існує більше одного
      блокчейну біткоін. "Головний" блокчейн біткоіна, той що створений Satoshi
      Nakamoto третього січня 2009го року, той самий що має блок творіння, про
      який ми казали в цій главі, ми називаємо mainnet. Існують інші блокчейни
      біткоіну, що використовуються для тестування: наразі це testnet, segnet,
      та regtest. Давайте поглянемо на кожний з них.</p>
    <h3> Testnet — тестова площадка біткоін</h3>
    <p> Testnet є назвою для тестового блокчейна, мережі та грошей, що
      використовуються для тестових цілей. Тестнет є повністю функціональню
      живою мережою P2P, з гаманцями, тестовими біткоінами (монетами тестнету),
      майнингом, та всіма іншими властивостями mainnet. Існує, насправді, тільки
      дві відмінності: монети тесткоіну призначені бути нічого не вартими, та
      складність майнінгу має бути досить низькою, щоб будь-хто міг майнати
      монети тестнету досить легко (залишаючи їх нічого не вартими).</p>
    <p> Люба розробка програмного забезпечення, що призначене для виробничого
      застосування в бітнет mainnet, повинна з початку бути протестована на
      testnet за допомогою тестових монет. Це захисстить обоє, і розробника від
      монетарних втрат через помилки, та мережу від несподіваної поведінки через
      помилки. </p>
    <p>Утримання монет не вартими нічого, та легкий майнинг, однак, не є
      простим. Не зважаючи на зауваження розробників, деякі люди використовують
      просунуте обладнання майнингу (GPU та ASIC) для майнингу на тестнеті. Це
      підвищує складність, роблячи неможливим майнинг за допомогою CPU, та з
      часом роблячи досить складним отримання тестових монет, так що люди
      починають цінувати їх, так що вони вже дечогось варті. Як результат, час
      від часу мережа testnet має бути очищеною та рестартованою, з нового блоку
      створіння, скидаючи складність.</p>
    <p>Поточний testnet має назву testnet3, третя ітерація testnet, рестартована
      в лютому 2011го року, щоб скинути складність від попереднього testnet.
      Майте на увазі, що testnet3 є великим блокчейном, що перевищує 20Гб на
      початок 2017го року. Вона займе день для синхронизації, та завантажить
      ресурси вашого комп'ютера. Не така велика як mainnet, але вже точно не
      “легковажна”. Один гарний спосіб запустити вузол testnet є використання
      образу віртуальної машини (тобто, VirtualBox, Docker, Cloud Server, тощо),
      виділеної для ціх цілей.</p>
    <h3> Використання testnet</h3>
    <p> Bitcoin Core, як майже любе інше програмне забезпечення біткоін, має
      повну підтримку для операцій з testnet, замість mainnet, але також
      дозволяє вам майнати тестові монети, та оперувати повним вузлом testnet.</p>
    <p>Щоб запустити Bitcoin Core на testnet замість mainnet, ви використовуєте
      ключ testnet:</p>
    <p> $ bitcoind -testnet<br>
    </p>
    <p>В ваших журналах ви повинні побачити, що bitcoind будує новий блокчейн в
      субкаталозі testnet3 директорії по замовчанню bitcoind:</p>
    <p> bitcoind: Using data directory /home/username/.bitcoin/testnet3<br>
    </p>
    <p>Щоб з'єднатись до bitcoind, ви використовуєте інструмент командного рядка
      bitcoin-cli, але вам також треба перемикнутись в режим testnet:<br>
    </p>
    <pre>      $ bitcoin-cli -testnet getinfo</pre>
    <pre>      {</pre>
    <pre>      "version": 130200,</pre>
    <pre>      "protocolversion": 70015,</pre>
    <pre>      "walletversion": 130000,</pre>
    <pre>      "balance": 0.00000000,</pre>
    <pre>      "blocks": 416,</pre>
    <pre>      "timeoffset": 0,</pre>
    <pre>      "connections": 3,</pre>
    <pre>      "proxy": "",</pre>
    <pre>      "difficulty": 1,</pre>
    <pre>      "testnet": true,</pre>
    <pre>      "keypoololdest": 1484801486,</pre>
    <pre>      "keypoolsize": 100,</pre>
    <pre>      "paytxfee": 0.00000000,</pre>
    <pre>      "relayfee": 0.00001000,</pre>
    <pre>      "errors": ""</pre>
    <pre>      }</pre>
    <p> Також ви можете іикористовувати команду getblockchaininfo, що
      підтвердити деталі мережі testnet3 та ваш прогрес синхронізації:<br>
    </p>
    <pre>$ bitcoin-cli -testnet getblockchaininfo<br>
      {<br>
      "chain": "test",<br>
      "blocks": 1088,<br>
      "headers": 139999,<br>
      "bestblockhash":<br>
      "0000000063d29909d475a1c4ba26da64b368e56cce5d925097bf3a2084370128",<br>
      "difficulty": 1,<br>
      "mediantime": 1337966158,<br>
      "verificationprogress": 0.001644065914099759,<br>
      "chainwork": "0000000000000000000000000000000000000000000000000000044104410441",<br>
      "pruned": false,<br>
      "softforks": [<br>
      [...]</pre>
    <p><br>
      Також ви можете робити з testnet3 за допомогою інших повно-вузлових
      реалізацій, таких, як btcd (написаний на Go), bcoin (написаний на
      JavaScript), щоб експеріментувати та навчатись в інших програмних мовах та
      фреймворках. На початок 2017го року, testnet3 підтримує всі можливості
      mainnet, на додаток до Segregated Witness (дивіться Додаток D), що ще має
      бути активований на mainnet. Таким чином,&nbsp; testnet3 може також бути
      використаний для тестування можливостей Segregated Witness.</p>
    <h3> Segnet — мережа Segregated Witness Testnet</h3>
    <p> В 2016му році була запущена тестова мережа спеціального призначення, щоб
      допомогти в розробці та тестуванні Segregated Witness (скорочено segwit;
      дивіться Додаток D). Це блокчейн, названий segnet, та може бути
      під'єднаний через виконання спеціальної версії (відгалуження) Bitcoin
      Core. Оскільки segwit був доданий до testnet3, більше не є необхідним
      використовувати&nbsp; segnet для тестування можливостей segwit. В
      майбутньому вірогідно ми побачимо інші блокчейни testnet, що спеціально
      розроблені для тестування окремої можливості або важливої архитектурної
      зміни, як segnet.</p>
    <h3> Regtest — локальний блокчейн</h3>
    <p> Regtest, що означає “Regression Testing”, є можливістю Bitcoin Core, що
      дозволяє вам створити локальний блокчейн для цілей тестування. На відміну
      від testnet3, що є публічним та загальним блокчейном, блокчейни regtest
      призначені для виконання як зачинена система для локального тестування. Ви
      запускаєте блокчейн regtest з самого початку, створюючи локальний блок
      творення. Ви можете додати інші вузли до мережі, або виконати її на
      окремому вузлі, тільки для тестування програмного забезпечення Bitcoin
      Core.</p>
    <p> Щоб запустити Bitcoin Core в режимі regtest, ви можете використовувати
      флаг regtest:</p>
    <pre> $ bitcoind -regtest</pre>
    <p> Так само, як з testnet, Bitcoin Core буде ініціалізувати новий блокчейн
      в субдиректорії regtest вашої директорії bitcoind по замовчанню:</p>
    <pre> bitcoind: Using data directory /home/username/.bitcoin/regtest<br>
    </pre>
    <p>Щоб задіяти інструмент командного рядка, вам треба вказати також флаг
      regtest. Давайте спробуємо команду getblockchaininfo для дослідження
      блокчейну regtest:</p>
    <pre> $ bitcoin-cli -regtest getblockchaininfo<br>
      {<br>
      "chain": "regtest",<br>
      "blocks": 0,<br>
      "headers": 0,<br>
      "bestblockhash":<br>
      "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",<br>
      "difficulty": 4.656542373906925e-10,<br>
      "mediantime": 1296688602,<br>
      "verificationprogress": 1,<br>
      "chainwork": "0000000000000000000000000000000000000000000000000000000000000002",<br>
      "pruned": false,<br>
      [...]<br>
      </pre>
    <p>Як ви можете бачити, досі немає жодних блоків. Давайте намайнаємо
      декілька (500 блоків), та отримаємо винагороду:<br>
    </p>
    <pre>$ bitcoin-cli -regtest generate 500<br>
      [<br>
      "7afed70259f22c2bf11e406cb12ed5c0657b6e16a6477a9f8b28e2046b5ba1ca",<br>
      "1aca2f154a80a9863a9aac4c72047a6d3f385c4eec5441a4aafa6acaa1dada14",<br>
      "4334ecf6fb022f30fbd764c3ee778fabbd53b4a4d1950eae8a91f1f5158ed2d1",<br>
      "5f951d34065efeaf64e54e91d00b260294fcdfc7f05dbb5599aec84b957a7766",<br>
      "43744b5e77c1dfece9d05ab5f0e6796ebe627303163547e69e27f55d0f2b9353",<br>
      [...]<br>
      "6c31585a48d4fc2b3fd25521f4515b18aefb59d0def82bd9c2185c4ecb754327"<br>
      ]<br>
      </pre>
    <p>Це займає лише декілька секунд, щоб намайнати всі ці блоки, що однозначно
      робить це простим для тестування. Якщо ви перевірите баланс вашого
      гаманця, ви побачите, що ви отримали винагороду за перші 400 блоків
      (винагорода коінбейс має мати 100 блоків в глибину, перед тим, як вона
      може бути витрачена):</p>
    <p> $ bitcoin-cli -regtest getbalance<br>
      12462.50000000</p>
    <h3> Використання тестового блокчейну для розробки</h3>
    <p> Різні блокчейни біткоін (regtest, segnet, testnet3, mainnet) надають
      диапазон тестових оточень для робобки біткоін. Використовуйте тестовий
      блокчейн для розробки біткоін. Використовуйте тестові блокчейни, коли ви
      розробляєте для Bitcoin Core, або іншого повно-вузлового клієнта;
      застосування, такого як гаманець, обмін, сайт онлайн комерції; або навіть
      розробки новітніх контрактів або складних скриптів. </p>
    <p>Ви можете використовувати тестові блокчейни для встановлення
      розробницьгого середовища. Тестуйте ваш код локально на regtest по мірі
      розробки. Коли ви станете готові щоб спробувати його на публічній мережі,
      перемикайтесь до testnet щоб показати ваш код в більш динамічному
      оточенні, з більшою різноманітністю коду та застосувань. Нарешті, коли ви
      досить переконались, що ваш код робить як очікувалось, перемикайтесь на
      mainnet, щоб розгорнути його в продакшині. Якщо ви зробите зміни,
      покращення, виправлення помилок, тощо, почните знову все з початку,
      розгортаючи кожну зміну на regtest, потім на testnet, та нарешті в
      продукцію.<br>
    </p>
    <h2>Глава 10</h2>
    <h1> Майнинг та консенсус</h1>
    <h3> Вступ</h3>
    <p> Слово "майнинг" є дещо недолуге. Через походження від добування цінних
      металів, воно фокусує нашу увагу на винагороді за майнинг, новий біткоін,
      створений в кожному блоці. Хоча майнинг стимульований через винагороду,
      первинне призначення майнингу є не винагорода або генерація нових монет.
      Якщо ви дивитесь на майнинг лише як на процес, як створюються нові монети,
      ви плутаєте засоби (стимули) як ціль процесу. Майнинг є механізмом, що
      створює децентралізований кліринговий центр, де транзакції валідуються та
      очищуються. Майниг є винаходом, що робить біткоін особливим,
      децентралізованим механізмом безпеки, що є основою для цифрових грошей
      P2P.</p>
    <p>Майнинг унебезпечує систему біткоіна, та робить можливим виникнення
      ціло-мережевого консенсуса, без центрального впливу. Винагорода за тільки
      но відкарбовані монети, та комісія за транзакції, є схемою заохочення, що
      підлаштовує дії майнерів до безпеки мережі, в той же час реалізуючи
      надходження монет. Призначення майнингу не є створення нового біткоіна. Це
      система заохочення. Майнинг є механізм, завдяки якому біткоін є безпечним
      та децентралізованим. </p>
    <p>Майнери перевіряють нові транзакції, та записують їх в глобальний реєстр.
      Новий блок, що містить транзакції, які відбулись після останнього блоку, в
      середньому "майнаються" кожні 10 хвилин, додаючи ці транзакції до
      блокчейну. Транзакції, що стали частиною блоку, та додані до блокчейну,
      розглядаються як “підтверджені”, що дозволяє новим власникам біткоіну
      витрачати біткоіни, що вони щойно отримали, в своїх транзакціях.</p>
    <p>Майнери отримують два типи винагород за безпеку, що вони провадять через
      майнинг: нові монети, створені в кожному блоці, та комісійні за транзакцію
      від всіх транзакцій, що включені в блок. Щоб отримати ці винагороди,
      майнери змагаються для вирішення складної математичної проблеми, базованої
      на алгоритмі криптографічного хешу. Рішення проблеми, що називається
      підтвердженням виконаної роботи, включається в кожний новий блок, та діє
      як підтвердження, що майнер витратив значні обчислювальні потуги. Змагання
      за вирішення алгоритму підтвердження виконанної роботи, щоб отримати
      винагороду, та право записувати транзакції в блокчейн, є основою моделі
      безпеки блокчейну.</p>
    <p> Процес названий майнингом завдяки нагороді (генерація нової монети)
      розроблений стимулювати зменшувані повернення, так само як майнинг для
      дорогоцінних металів. Постачання грошей біткоіну створюється через
      майнинг, подібно до того, як центральний банк випускає нові гроші через
      друк банківських білетів. Максимальна кількість нових створених біткоінів,
      що майнер може додати до блоку, зменьшується приблизно кожні чотири роки
      (якщо точніше, кожні&nbsp; 210,000 блоків ). Вона стартує з 50 біткоінів
      на блок в січні 2009, та переділилось до 25 біткоінів за блок в листопаді
      2012. Ще раз переділ відбувся до 12.5 біткоінів в липні 2016. Базуючись на
      цій формулі, винагороди від майнингу біткоіна зменьшуються
      експотенціально, приблизно до року 2140, коли всі біткоіни (20.99999998
      мільйонів) будуть в обігу. Після року 2140 нові біткоіни не будуть
      надходити.<br>
    </p>
    <p>Майнери біткоіну також отримують комісійні від транзакцій. Кожна
      транзакція може включати комісійні за транзакцію, в формі різниці
      біткоінів між входами транзакції та її виходами. Переможний майнер
      біткоіна отримує право “утримувати різницю” з транзакцій, включених в
      переможний блок. Сьогодні комісійні складають 0.5% або менше від
      мінімального надходження біткоін, значна більшість надходить від знову
      відкарбованих монет. Однак, докі винагорода зменшуватиметься з
      часом,&nbsp; та число транзакцій на блок збільшується, все більша частина
      доходів від майнингу буде приходитись на комісійні. Поступово, винагорода
      майнингу буде домінувати для комісійних від транзакцій, що буде формувати
      первинне заохочення для майнерів. Після 2140го року, число нових біткоінів
      в кожному блоці впаде до нуля, тамайнинг біткоіну буде заохочуватись
      тільки комісійними з транзакцій.</p>
    <p>В цій главі ми спочатку переглянемо майнинг як механізм монетарного
      забезпечення, та потім поглянемо на найбільш важливі функції майнингу:
      механізм децентралізованого консенсусу, що складає безпеку біткоіну.<br>
    </p>
    <p>Щоб зрозуміти майнинг та консенсус, ми будемо слідувати за транзакцією
      Аліси, коли вона була отримана, та додана до блоку майнинговим обладнанням
      Джінга. Потім ми послідкуємо за блоком, як він був змайнаний, доданий до
      блокчейну, та сприйнятий мережею біткоін через процес утворення
      консенсусу.<br>
    </p>
    <h3>Економіка біткоіну та створення грошей</h3>
    <p> Біткоін “карбується” впродовж створення кожного нового блоку, з
      фіксованою та зменшуваною частотою. Кожний блок, згенерований в середньому
      кожні 10 хвилин, містить повністю новий біткоін, створений з нічого. Кожні
      210000 блоків, або приблизно кожні чотири роки, вихід грошей зменьшується
      на 50%. Для перших чотирьох років діяльності мережі, кожний блок складав
      50 нових біткоінів. В листопаді 2012 нова частота утворення біткоінів
      склала 25 біткоінів на блок. В липні 2016 вона скоротилась знову, до 12.5
      біткоінів на блок. Вона буде знову переділена до 6.25 біткоінів на блоці
      630,000, що буде змайновано десь в&nbsp; 2020му році. Частота нових монет
      зменьшується таким чином до 32 “розполовинень”, доки блок 6720000 не буде
      змайнаний приблизно в 2137му, та тоді він досягне мінімума одиниці виміру
      в 1 сатоші. Нарешті, після 6.93 мільйонів блоків, або приблизно в 2140му
      році, близько 2,099,999,997,690,000 сатоші, або майже&nbsp; 21 мільйонів
      біткоінів, будуть видані в світ. Після цього, блоки не будуть містити
      нових біткоінів, та майнери будуть отримувати винагороду виключно через
      камісії з транзакцій. Малюнок 10-1 показує загальні біткоіни в обертанні з
      часом, по мірі зменшення їх випуску. </p>
    <p> Малюнок 10-1. Надходження грошей біткоін з часом, на основі геметричного
      зменшення частоти їх надходження<br>
    </p>
    <p>Максимальним числом монет, що змайнані, є обмеження верхнього ліміту
      винагороди за майнінг. На практиці, майнер може навмисне змайнати блок,
      заберучи меньше, ніж повна винагорода. Такі блоки вже насправді були
      змайнані, та ще можуть бути змайнані в майбутньому, що призведе до
      зменшення загальної кількості грощей в оберті. <br>
    </p>
    <p>В пркладі коду Приклад 10-1, ми обчислюємо загальну кількість біткоіну,
      що буде випущений.<br>
    </p>
    <p>Приклад 10-1. Скрипт для обчислення, як багато бітеоінів буде випущено<br>
    </p>
    <pre># Оригінальна винагорода за блок для майнерів була 50 BTC<br>
      start_block_reward = 50<br>
      # 210000 є обертається кожні 4 роки з 10 хвилинним інтервалом на блок<br>
      reward_interval = 210000<br>
      def max_money():<br>
      # 50 BTC = 50 0000 0000 Satoshi<br>
      current_reward = 50 * 10**8<br>
      total = 0<br>
      while current_reward &gt; 0:<br>
      total += reward_interval * current_reward<br>
      current_reward /= 2<br>
      return total<br>
      print "Total BTC to ever be created:", max_money(), "Satoshis"<br>
      </pre>
    <p>Приклад 10-2 показує результат роботи цього скрипта.<br>
    </p>
    <p>Приклад 10-2. Виконання скрипта max_money.py<br>
    </p>
    <pre>$ python max_money.py<br>
      </pre>
    <pre>Total BTC to ever be created: 2099999997690000 Satoshis<br>
      </pre>
    <p>Обмежений та зменшуваний випуск створює фіксоване постачання грошей, що
      чинить опір інфляції. На відміну від вільних грошей, що можуть бути
      надруковані в необмеженій кількості центральним банком, біткоін ніколи не
      піддасться інфляції через друк.&nbsp;</p>
    <h3> Дефляційні гроші</h3>
    <p> Найбільш важливе та спірний наслідок фіксованого та зменшуваного
      монетарного випуску є те, що валюта має тенденцію бути природно
      дефляційною. Дефляція це феномен підвищення значення через невідповідність
      між постачанням та попитом, що взвинчує значення (та рівень обміну)
      валюти. На протилежність до інфляції, цінова дефляція означає, що гроші
      набувають більшу купівельну спроможність з часом. Багато економістів
      аргументують, що дефляційна економіка є безлад, якого треба уникати за
      любу ціну. Це так, тому що в період швидкої дефляції люди схильні
      накопичувати гроші, а не витрачати їх, очікуючи, що ціни мають впасти.
      Такий феномен бів викритий під час “пропащого десятиліття” в Японії, коли
      повний колапс попиту зіштовхнув валюту в дефляційну спіраль.</p>
    <p> Експерти біткоін аргументують, що це не так погано само по собі.
      Скоріше, дефляція асоційована з колапсом попиту, оскільки це тільки один з
      прикладів дефляції, що миємо вивчити. З неприв'язаною валютою, з
      можливістю беобмеженого друку, дуже складно увійти в дефляційну спіраль,
      тільки якщо не буде повного колапсу з попитом, та небажання друкувати
      гроші. Дефляція біткоіну не викликаєтсья колапсом у попиті, але
      передбачуваним обмеженним постачанням. </p>
    <p> Позитивний аспект дефляції, звичайно, в тому, що це протилежність
      інфляції. Інфляція спричиняє повільне, але неминуче знецінення валюти, що
      призводить до форми прихованного оподаткування, якім обкладаються
      накопичувачі, щоб врятувати боржників (включаючи найбільших боржників,
      самі уряди). Валюта під контролем уряду потерпає від моральної загрози
      простого створення боргів, що потім можуть бути легко погашені через
      знецінення, за рахунок накопичувачів.&nbsp;</p>
    <p> Залишається побачити, чи дефляційний аспект валюти є проблемою, коли
      його рушій не швидке згортання економіки, або це перевага, оскільки це
      захист від інфляції та знецінення, що переважає ризики дефляції.</p>
    <h3>Децентралізований консенсус</h3>
    <p> В попередній главі ми дивились на блокчейн, глобальний публічний реєстр
      (список) всіх транзакцій, який кожний в мережі біткоін сприймає як
      авторитетний запис щодо власності. Але як може кожен в мережі погодитись з
      єдиною універсальною “правдою” щодо того, хто володіє чим, не довіряючи
      при цьому нікому? Всі традиційні платіжні системи залежать від моделі
      довіри, що має центральну інстранцію, та провадить послуги підтвердження,
      в основі верифікуючи та підтверджуючи всі транзакції. Біткоін не має
      центральної інстанції, та все одно кожний повний вузол має повну копію
      публічного облікового реєстра, якому він може довіряти як авторитетному
      запису. Блокчейн не створений центральною інстанцією, але збирається
      незалежно кожним вузлом в мережі. Якимось чином, кожний вузол в мережі,
      діючи з інформацією, переданою по небезпечним мережевим з'єднанням, може
      дійти того самого висновку, та зібрати копію того самого публічного
      реєстра, що і кожний інший. Ця глава перевіряє процес, завдяки якому
      мережа біткоін досягає глобального консенсусу без центрального довіреного
      органа.</p>
    <p> Головний винахід Satoshi Nakamoto є децентралізований механізм для
      виникнення консенсусу. Виникнення, бо консенсус не досягається явним чином
      — немає голосування, або фіксованого моменту, коли настає консенсус.
      Змість цього, консенсус є виникаючим артифактом від асинхронних інтеракцій
      тисячів незалежних вузлів, що всі слідують простим правилам. Всі
      властивості біткоіна, включаючи валюту, транзакції, платежі, та модель
      безпеки, що не спирається на центральний інструмент довіри, походять з
      цього винаходу. </p>
    <p> Децентралізований консенсус біткоін виникає з взаємодії чотирьох
      процесів, що відбуваються незалежно на вузлах по всій мережі:<br>
      • Незалежна верифікація кожної транзакції, кожним повним вузлом, базуючись
      на виключному списку крітерій<br>
      • Незалежна агрегація ціх транзакцій в нові блоки майнаючими вузлами,
      разом з демонстрацією обчислень через алгоритм доказу виконаної роботи<br>
      • Незалежна верифікація нових блоків на кожному вузлі, та збирання їх в
      блокчейн<br>
      • Незалежний вибір кожним вузлом ланцюга з найбільшим кумулятивним
      обчисленням, що демонструється через доказ виконаної роботи</p>
    <p>В декількох наступних розділах ми будемо досліджувати ці процеси, та як
      вони взаємодіють для створення виникаючої властивості мережевого
      консерсусу, що дозволяє вузлу біткоін зібрати власну копію довіреного,
      публічного, глобального реєстра. </p>
    <h3> Незалежна верифікація транзакцій</h3>
    <p> В Главі 6 ми бачили, як програмний гаманець створює транзакції через
      збирання UTXO, провадячи відповідний розблокуючий скрипт, та потім
      конструюючі нові виходи, призначені для нового власника. Результуюча
      транзакція потім надсилається до сусідніх вузлів в мережі біткоін, так що
      вони можуть просуватись по всій мережі біткоін.&nbsp;</p>
    <p> Однак перед передачею транзакцій до сусідів, кожний вузол біткоін, що
      отримує транзакцію, спершу має перевірити транзакцію. Це переконує, що
      тільки двалідні транзакції просуваються по мережі, тоді як невалідні
      транзакції відкидаються на першому ж вузлі, який виявить їх.</p>
    <p>Кожний вузол перевіряє кожну транзакцію згідно списку заданих критерій:<br>
      • Синтаксис транзакції та структура даних має бути коректною.<br>
      • Вхідні та вихідні списки не порожні.<br>
      • Розмір транзакції в байтах меньше ніж MAX_BLOCK_SIZE.<br>
      • Кожне вихідне значення, так само як і загал, має бути в допустимому
      диапазоні значень (меньше ніж 21 мільйонів монет, меньше ніж поріг пилу).<br>
      • Ніякий зі входів не має хеш рівним 0, N=–1 (транзакції коінбейсу не
      повинні пересилатись).<br>
      • nLocktime рівне INT_MAX, або значення nLocktime та nSequence
      задовільняють відповідно до MedianTimePast.<br>
      • Розмір транзакції в байтах більше ніж, або дорівнює 100.<br>
      • Число операцій сигнатури (SIGOPS), що міститься в транзакції, є меньшим,
      ніж обмеження на операції сигнатури. <br>
      • Розблокуючий скрипт (scriptSig) може заштовхувати в хеш лише числа, та
      блокуючий скрипт (scriptPubkey) має співпадати з формами isStandard (це
      відхиляє “нестандартні” транзакції).<br>
      • Має існувати співпадаюча транзакція в пулі, або в блоці в головній
      вітці.<br>
      • Для кожного входу, якщо відповідний вихід існує в любій іншій транзакції
      в пулі, транзакція має бути відхилена.<br>
      • Для кожного входу передивитись головну вітку та пул транзакцій, в
      пошуках відповідної вихідної транзакції. Якщо вихідна транзакція відсутня
      для любого входу, це буде загублена транзакція. Вона додається до пулу
      загублених, якщо така транзакція вже не знаходиться в пулі.<br>
      • Для кожного входу, якщо посилана вихідна транзакція є вихідом коінбейсу,
      вона повинна мати щонайменьше COINBASE_MATURITY (100) підтворджень.<br>
      • Для кожного входу, відповідний вихід має існувати, та не може бути вже
      витраченим. <br>
      • Використовуючи посилані виходи транзакції щоб отримати вхідні значення,
      перевіряється, що кожне вхідне значення, так само, як і сума, знаходиться
      в дозволеному диапазоні значень (менше 21 мільйона, більше ніж 0).<br>
      • Відхилити, якщо сума значень входів меньша, ніж сума значень виходів. <br>
      • Відхилити, якщо комісійні по транзакції будуть дуже низькими
      (minRelayTxFee), щоб опинитись в порожньому блоці. <br>
      • Розблокуючі скрипти для кожного входу мають валідуватись згідно
      відповідних вихідних блокуючих скриптів.</p>
    <p> Ці умови можуть бути побачені в деталях в функціях AcceptToMemoryPool,
      CheckTransaction, та CheckInputs в Bitcoin Core. Зауважте, що умови
      змінюються з часом, щоб відповідати новим типам атак відмови в
      обслуговуванні, або іноді для пом'якшення правил, так, щоб включити більшу
      кількість транзакцій.</p>
    <p>Незалежно перевіряючі кожну транзакцію по мірі надходження, та перед
      просуванням її далі, кожний вузол будує пул валідних (але непідтверджених)
      транзакцій, відомих як пул транзакцій, пул в пам'яті або mempool.</p>
    <h3> Вузли, що майнають</h3>
    <p> Деякі з вузлів в мережі біткоін є спеціалізованими вузлами, що
      називаються майнерами. В Главі 1 ми познайомились з Джингом, комп'ютерним
      студентом-інженером з Шанхаю, Китай, який є майнером біткоін. Джинг
      заробляє біткоін, запустивши “майнаючу установку”, що є спеціалізованою
      апаратною системою, розробленою для майнінгу біткоінів. На відміну від
      Джинга, деякі майнери майнять без повного вузла, як ми бачили в
      “Майнінгових пулах”. Як кожний інший вузол, вузол Джинга отримує та
      просуває непідтверджені транзакції в мережі біткоін. Однак вузол Джинга
      також збирає ці транзакції в нові блоки. Вузол Джинга слухаж щодо нових
      блоків, що передаються мережею біткоін, як це роблять всі вузли. Однак
      поява нового блоку має особливе значення для майнаючого блока. Змагання
      між майнерами ефективно завершується просуванням нового блоку, що діє як
      анонс на користь переможця. Для майнерів отримання валідного нового блоку
      означає, що хтось інший переміг в змаганні, а вони програли. Однак кінець
      одного раунду також є початком наступного раунду. Новий блок не тільки
      фінішний флаг, що позначає завершення перегонів; він також стартовий
      пістолет, що починає перегони за новим блоком.&nbsp;</p>
    <h3> Агрегація транзакцій в блоки</h3>
    <p> Після валідації транзакцій вузол біткоін додасть її до пулу в пам'яті,
      або пулу транзакцій, де транзакції будуть очікувати, доки вони не зможуть
      бути включені (змайнені) в блок. Вузол Джинга збирає, перевіряє, та
      пересилає нові транзакції, так само, як кожний інший вузол. Однак на
      відміну від інших вузлів, вузол Джинга буде агрегувати ці трензакції в
      блок-кандидат.&nbsp;</p>
    <p> Давайте прослідимо з блоками, що були створені під час того, як Аліса
      купила філіжанку кави в кафе Боба (дивіться “Купляючи філіжанку кави”).
      Транзакція Аліси була включена в блок 277,316. Для цілей демонстрації
      концепцій в цій главі, давайте вважати, що блок був смайнаний системой
      майнинга Джинга, та послідуємо за транзакцією Аліси, коли вона стає
      частиною нового блоку.&nbsp;</p>
    <p> Вузол майнингу Джинга підтримує локальну копію блокчейна. Коли Аліса
      купляє свою каву, вузол Джинга зібрав ланцюг аж до блока 277,314. Вузол
      Джинга слухає щодо транзакцій, намагаючись змайнати новий блок, а також
      слухає щодо блоків, винайдених іншими вузлами. Якщо вузол Джинга майнить,
      він отримає блок 277,315 по мережі біткоін. Надходження цього блоку
      означає кінець зманання за блок 277,315, та початок змагання за створення
      блока 277,316.</p>
    <p>На протязі попередніх 10 хвилин, доки вузол Джинга шукав рішення для
      блока 277,315, він також збирав транзакції в підготовці до нового блока.
      Тепер він назбирав декілька сотен транзакцій в пулі в пам'яті. Під час
      отримання блоку 277,315, та його валідації, вузол Джинга також порівнює
      його з усіма транзакціями в пулі в пам'яті, та видаляє всі, що включені в
      блок 277,315. Таким чином транзакції, що залишились в пулі є
      непідтвердженими, та очікують на запис в новий блок.&nbsp;</p>
    <p> Вузол Джинга безпосередньо конструює новий порожній блок, кандидата на
      блок 277,316. Цей блок називається блоком-кандидатом, тому що він досі не
      є валідним блоком, бо він не містить валідний доказ виконаної роботи. Цей
      блок стає валідним тільки якщо майнеру вдасться знайти рішення алгоритму
      доказу виконанної роботи.&nbsp;</p>
    <p>Коли вузол Джинга агрегує всі транзакції з пула в пам'яті, новий
      блок-кандидат має 418 транзакцій, з загальною комісією за транзакції в
      0.09094928 біткоінів. Ви можете побачити цей блок в блокчейні,
      використовуючи клієнт Bitcoin Core з інтерфейсом командного рядка, як
      показано в Прикладі 10-3.<br>
    </p>
    <p>Приклад 10-3. Використання командного рядка для отримання блока 277,316<br>
    </p>
    <pre>$ bitcoin-cli getblockhash 277316<br>
      0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4<br>
      $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d9\<br>
      44a9b31b2cc7bdc4<br>
      {<br>
      "hash" :
      "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",<br>
      "confirmations" : 35561,<br>
      "size" : 218629,<br>
      "height" : 277316,<br>
      "version" : 2,<br>
      "merkleroot" :<br>
      "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",<br>
      "tx" : [<br>
      "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",<br>
      "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",<br>
      ... 417 more transactions ...<br>
      ],<br>
      "time" : 1388185914,<br>
      "nonce" : 924591752,<br>
      "bits" : "1903a30c",<br>
      "difficulty" : 1180923195.25802612,<br>
      "chainwork" :<br>
      "000000000000000000000000000000000000000000000934695e92aaf53afa1a",<br>
      "previousblockhash" :<br>
      "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"<br>
      }</pre>
    <h3> Транзакція коінбейс</h3>
    <p> Перша транзакція в любому блоці є спеціальною транзакцією, що
      називається коінбейс-транзакцією. Ця транзакція сконструйована вузлом
      Джинга, та містить його винагороду за потуги по майнингу. Коли блок
      277,316 був змайнаний, винагорода була 25 біткоін на блок. З тих пір
      пройшов один період "переділу". Винагорода за блок змінилась до 12.5
      біткоінів в липні 2016. Вона буде переділена знову через 210,000 блоків, в
      2020 році.<br>
    </p>
    <p>Вузол Джинга створює коінбейс транзакцію як платіж до свого власного
      гаманця: “Сплатити на адресу Джинга&nbsp; 25.09094928 біткоінів”. Загальна
      сума винагороди, що назбирає Джинг від майнингу блока, є сумою винагороди
      коінбейсу (25 нових біткоінів), та комісійні за транзакції (0.09094928) з
      усіх транзакцій, що включені в блок, як показано в Прикладі 10-4.</p>
    <p>Приклад 10-4. Коінбейс транзакція</p>
    <pre>$ bitcoin-cli getrawtransaction</pre>
    <pre>d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1</pre>
    <pre>{</pre>
    <pre>    "hex" : </pre>
    <pre>"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0</pre>
    <pre>f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff</pre>
    <pre>6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000",</pre>
    <pre>    "txid" : "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",</pre>
    <pre>    "version" : 1,</pre>
    <pre>    "locktime" : 0,</pre>
    <pre>    "vin" : [</pre>
    <pre>      {</pre>
    <pre>        "coinbase" : "03443b0403858402062f503253482f",</pre>
    <pre>        "sequence" : 4294967295</pre>
    <pre>      }</pre>
    <pre>    ],</pre>
    <pre>    "vout" : [</pre>
    <pre>     {</pre>
    <pre>       "value" : 25.09094928,</pre>
    <pre>       "n" : 0,</pre>
    <pre>       "scriptPubKey" : {</pre>
    <pre>         "asm" :</pre>
    <pre>"02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG",</pre>
    <pre>         "hex" :</pre>
    <pre>"2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac",</pre>
    <pre>         "reqSigs" : 1,</pre>
    <pre>         "type" : "pubkey",</pre>
    <pre>         "addresses" : [</pre>
    <pre>           "1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N"</pre>
    <pre>         ]</pre>
    <pre>     }</pre>
    <pre>  }</pre>
    <pre>]</pre>
    <pre>}</pre>
    <p>На відміну від звичайних транзакцій, коінбейс транзакція не споживає
      (витрачає) UTXO на вході. Замість цього вона має тільки один вхід, що
      називається коінбейсом, що створює біткоіни з нічого. Транзакція коінбейс
      має один вихід, яким може сплатити майнер з власної адреси. Вихід
      транзакції коінбейс надсилає значення 25.09094928 біткоінів на біткоін
      адресу майнера; в цьому випадку це 1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N.</p>
    <h3>Винагорода та комісійні коінбейс</h3>
    <p>Щоб побудувати коінбейс транзакцію, вузол Джинга спершу обчислює загальну
      суму комісійних, додаючи всі входи та виходи для 418 транзакцій, що додані
      до блоку. Комісійні ообчислюються як:</p>
    <p>Щагальні комісійні = Sum(Входи) - Sum(Виходи)</p>
    <p>В блоці 277,316 загальні комісійні по транзакціях складають 0.09094928
      біткоінів. Далі вузол Джинга обчислює коректну винагороду за новий блок.
      Винагорода обчислюється на основі висоти нового блоку, починаючи з 50
      біткоінів за блок, та зменшуючись на половину кожні 210,000 блоків.
      Оскільки цей блок на висоті 277,316, коректна винагорода складає 25<br>
      біткоінів. Калькуляцію можна побачити в функції GetBlockSubsidy клієнта
      Bitcoin Core, як показано в Прикладі 10-5.</p>
    <p>Приклад 10-5. Обчислення винагороди за блок — функція GetBlockSubsidy,
      клієнт Bitcoin Core, main.cpp</p>
    <pre>CAmount GetBlockSubsidy(int nHeight, const Consensus::Params&amp; consensusParams)</pre>
    <pre>{</pre>
    <pre>  int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;</pre>
    <pre>  // Force block reward to zero when right shift is undefined.</pre>
    <pre>  if (halvings &gt;= 64)</pre>
    <pre>    return 0;</pre>
    <pre>  CAmount nSubsidy = 50 * COIN;</pre>
    <pre>  // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.</pre>
    <pre>  nSubsidy &gt;&gt;= halvings;</pre>
    <pre>  return nSubsidy;</pre>
    <pre>}</pre>
    <p>Початкова субсидія, обчислена в сатоші, та помножена на 50 за допомогою
      константи COIN (100,000,000 сатоші). Це встановлює початкову винагороду
      (nSubsidy) в 5 мільйонів сатоші. Далі, функція обчислює число переділень,
      що відбуваються діленням поточної висоти блоку на інтервал
      переділення(SubsidyHalvingInterval). В випадку блоку 277,316, з інтервалом
      переділення кожні 210,000 блоків, результатом буде 1 переділення.</p>
    <p>Максимальне число переділень є 64, так що код видасть нульову винагороду
      (не враховуючи комісійних), якщо число переділень перевищить 64. Далі,
      функція використовує оператор бінарного правого зсуву, щоб поділити
      винагороду (nSubsidy) на два для кожного раунду переділення. В випадку
      блоку 277,316, це буде правий зсув винагороди в 5 мільйонів сатоші (один
      раз), що дасть 2,5 мільйони сатоші, або 25 біткоінів. Оператор бінарного
      правого зсуву, бо він більш ефективний, ніж ділення на основі множення.
      Щоб уникнути потенційного багу, операція зсуву пропускається після 63
      переділень, та субсидія встановлюється в 0. Нарешті, коінбейс винагорода
      (nSubsidy) додається до комісійних за транзакції (nFees), та повертається
      сума.&nbsp;</p>
    <p>Якщо майнинговий вузол Джинга записує транзакцію коінбейсу, що зупиняє
      Джинга від "винагоди" себе в 100 або 1000 біткоінів? Відповідь в тому, що
      невірна винагорода призведе до того, що блок вважатиметься невалідним
      усіма іншими, та втрати електричної енергії Джинга, витраченої на
      обчислення доказу виконаної роботи. Джинг зможе витратити винагорооду
      тільки в випадку, коли блок буде сприйнятий всіма і кожним.</p>
    <h3>Структура коінбейс транзакції</h3>
    <p> З ціма розрахунками, вузол Джинга конструює коінбейс транзакцію, щоб
      сплатити собі 25.09094928 біткоінів. Як ви бачили в Прикладі 10-4,
      коінбейс транзакція має особливий формат. Замість того, щоб вхід
      транзакції вказував на витрату попереднього UTXO, це є входом “коінбейс”.
      Ми перевірили входи транзакції в Таблиці 6-2. Давайте порівняємо звичайний
      вхід транзакції з входом транзакції коінбейс. Таблиця 10-1 показує
      структуру звичайної транзакції, тоді як Таблиця 10-2 показує структуру
      входу транзакції коінбейс.&nbsp;</p>
    <p> Таблиця 10-1. Структура "нормального" входу транзакції</p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td>Розмір</td>
          <td>Поле</td>
          <td>Опис</td>
        </tr>
        <tr>
          <td>32 байти</td>
          <td>Хеш транзакції</td>
          <td>Вказівник на транзакцію, що містить UTXO, яке витрачається</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>Індекс виходу</td>
          <td>Числовий індекс UTXO, що витрачається, починаючи з 0</td>
        </tr>
        <tr>
          <td>1-9 байт(VarInt) </td>
          <td>Розмір розблокуючого скрипта</td>
          <td>Довжина відмикаючого скрипта в байтах</td>
        </tr>
        <tr>
          <td>змінний</td>
          <td>Розблокуючий скрипт</td>
          <td>Скрипт, що задовільняє умовам замикаючого скрипта UTXO</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>Послідовний номер</td>
          <td>Наразі відключена можливість Tx-заміни, встановлено в 0xFFFFFFFF</td>
        </tr>
      </tbody>
    </table>
    <p><br>
      Таблиця 10-2. Структура входу транзакції коінбейс </p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td>Розмір<br>
          </td>
          <td>Поле<br>
          </td>
          <td>Опис<br>
          </td>
        </tr>
        <tr>
          <td>32 байти<br>
          </td>
          <td>Хеш транзакції<br>
          </td>
          <td>Всі біти нульові, посилання на транзакцію відсутнє<br>
          </td>
        </tr>
        <tr>
          <td>4 байти<br>
          </td>
          <td>Індекс виходу<br>
          </td>
          <td>Всі біти одиниці: 0xFFFFFFFF </td>
        </tr>
        <tr>
          <td>1-9 байт(VarInt) </td>
          <td>Розмір даних коінбейс<br>
          </td>
          <td>Довжина даних коінбейс, від 2 до 100 байт<br>
          </td>
        </tr>
        <tr>
          <td>змінний<br>
          </td>
          <td>Дані коінбейс<br>
          </td>
          <td>Довільні дані, що використовуються як додатковий довісок та теги
            майнингу. В блоках версії v2 має починатись з висоти блока</td>
        </tr>
        <tr>
          <td>4 байти<br>
          </td>
          <td>Послідовний номер<br>
          </td>
          <td>Встановлено в 0xFFFFFFFF</td>
        </tr>
      </tbody>
    </table>
    <p><br>
      В транзакції коінбейс, перші два поля встановлені в значення, що не
      представляють посилання на UTXO. Замість “хеша транзакції” перше поле
      заповнене 32 байтами нулів. “Вихідний індекс” заповнений 4 байтами одиниць
      0xFF (255 в десятичній системі). “Розблокуючий скрипт” (scriptSig)
      замінений на дані коінбейс, поле даних для майнерів, як ви побачите далі.</p>
    <h3> Дані коінбейс</h3>
    <p> Транзакції коінбейс не мають поля розблокуючого скрипта (scriptSig).
      Замість цього це поле замінене на дані коінбейс, що має бути від 2 до 100
      байтів. За винятком перших декількох байтів, залишок даних коінбейс може
      використовуватись майнерами як вони цього побажають. Це довільні дані.</p>
    <p> В блоці творення, наприклад, Satoshi Nakamoto додав текст “The Times
      03/Jan/2009 Chancellor on brink of second bailout for banks” в дані
      коінбейс, використавши це як доказ дати, та надіслення повідомлення.
      Наразі майнери використовують дані коінбейс для включення додаткового
      значення довіску, та рядка, що ідентифікує майнинговий пул. </p>
    <p> Перші декілька байтів коінбес були довільними свого часу, але це вже не
      так. Згідно BIP-34, блоки версії 2 (блоки з полемверсії в значенні 2)
      мають містити індекс висоти блоку, в вигляді операції скрипта “push” на
      початку поля коінбейс.</p>
    <p> В блоці 277,316 ми бачимо, що коінбейс (дивіться Приклад 10-4), що є в
      розблокуючому скрипті, або полі scriptSig входу транзакції, містить
      шістнадцятиричне значення 03443b0403858402062f503253482f. Давайте
      розкодуємо це значення. Перший байт, 03, інструктує скриптову машину
      заштовхати наступні три байти в стек скрипта (дивіться Таблицю B-1).
      Наступні три байти, 0x443b04, є висотою блока, закодованого в форматі
      little-endian (зворотньому, найменьш значущий байт перший). Обертаючи
      порядок байтів в результаті дає 0x043b44, що в десятичному вигляді є
      277,316. Наступні декілька цифр (0385840206) використовуються як
      додатковий довісок (дивіться “Рішення додаткового довіску”), або випадкове
      значення, що використовується для пошуку підходящого рішення підтвердження
      виконаної роботи.</p>
    <p> Заключна частина даних коінбейсу (2f503253482f) є ASCII-кодованим рядком
      /P2SH/, що вказує, що майнінговий вузол, що змайнав цей блок, підтримує
      покращення P2SH .визначене в BIP-16. Всутп до можливостей P2SH потребує
      сигналювання майнерами про підтримку або BIP-16, або BIP-17. Це
      підтвердження реалізації BIP-16 надійшло через включення /P2SH/ в їх дані
      коінбейс. Підтвердження реалізації BIP-17 P2SH буде виглядати як рядок
      p2sh/CHV в їх даних коінбейсу. BIP-16 бвв обраний як переможець, та багато
      майнерів продовжують включати рядок /P2SH/ в сій коінбейс, щоб вказати
      свою підтримку цієї можливості.<br>
    </p>
    <p>Приклад 10-6 використовує libbitcoin, введену в “Альтернативні клієнти,
      бібліотеки та тулкіти”, щоб виділити дані коінбейс з блоку творення,
      відобразивши повідомлення Satoshi. Зауважте, що бібліотека libbitcoin
      містить статичну копію блоку творення, так що приклад може отримати блок
      напряму з бібліотеки.</p>
    <p> Приклад 10-6. Отримання даних коінбейс з блоку творення<br>
    </p>
    <pre>/* Відображуємо повідомлення Satoshi з блоку творення. */<br>
      #include &lt;iostream&gt;<br>
      #include &lt;bitcoin/bitcoin.hpp&gt;<br>
      int main()<br>
      {<br>
      // Створюємо блок творення.<br>
      bc::chain::block block = bc::chain::block::genesis_mainnet();<br>
      // Блок творення містить єдину транзакцію коінбейс.<br>
      assert(block.transactions().size() == 1);<br>
      // Отримуємо першу транзакцію в блоці (коінбейс).<br>
      const bc::chain::transaction&amp; coinbase_tx = block.transactions()[0];<br>
      // Транзакція коінбейс має один вхід.<br>
      assert(coinbase_tx.inputs().size() == 1);<br>
      const bc::chain::input&amp; coinbase_input = coinbase_tx.inputs()[0];<br>
      // Конвертуємо вхідний скрипт на сирий формат.<br>
      const auto prefix = false;<br>
      const bc::data_chunk&amp; raw_message =
          coinbase_input.script().to_data(prefix);<br>
      // Конвертуємо на std::string.<br>
      std::string message(raw_message.begin(), raw_message.end());<br>
      // Відображуємо повідомлення з блоку творення.<br>
      std::cout &lt;&lt; message &lt;&lt; std::endl;<br>
      return 0;<br>
      }</pre>
    <p> Ми компілюємо код за допомогою компілятора GNU C++, та виконуємо
      отриману програму, як показано в Прикладі 10-7.<br>
    </p>
    <p>Приклад 10-7. Компіляція та виконання коду приклада satoshi-words</p>
    <pre>  </pre>
    <pre>$ # Compile the code<br>
      $ g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs
      libbitcoin)<br>
      $ # Run the executable<br>
      $ ./satoshi-words<br>
      ^D��&lt;GS&gt;^A^DEThe Times 03/Jan/2009 Chancellor on brink of second
      bailout for banks</pre>
    <h3> Конструювання заголовку блоку</h3>
    <p> To construct the block header, the mining node needs to fill in six
      fields, as listed in Table 10-3.<br>
    </p>
    <p>Table 10-3. The structure of the block header</p>
    <table style="width: 100%;" border="0">
      <tbody>
        <tr>
          <td>Розмір<br>
          </td>
          <td>Поле<br>
          </td>
          <td>Опис<br>
          </td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>версія</td>
          <td>Номер версії для слідкування за оновленнями</td>
        </tr>
        <tr>
          <td>32 байти</td>
          <td>хеш попереднього блоку</td>
          <td>Посилання на хеш попереднього (батьківського) блоку</td>
        </tr>
        <tr>
          <td>32 байти</td>
          <td>мерклівській корінь</td>
          <td>Хеш мерклівського дерева транзакцій в цьому блоці</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>відтиск часу</td>
          <td>Приблизний час створення (секунди епохи Юнікс)</td>
        </tr>
        <tr>
          <td>4 байти</td>
          <td>ціль</td>
          <td>Ціль алгоритму доказу виконанохї роботи для цього блока</td>
        </tr>
        <tr>
          <td>4 байти </td>
          <td>довісок</td>
          <td>Безглуздий лічильник, що використовується для підрахунку хеша</td>
        </tr>
      </tbody>
    </table>
    <p>На той час, коли було змайнано блок 277,316, номер версії, що описував
      структуру блока, була 2, що закодоване в форматі little-endian в 4 байтах
      виглядає так: 0x02000000.<br>
    </p>
    <p>Далі, майнання блоку потребує додавання "Хеш попереднього блоку" (також
      відомий як pre vhash). Це хеш заголовку блоку 277,315, попереднього блоку,
      отриманого з мережі, що вузол Джинга прийняв та обрав як батьківській для
      блока-кандидата блока 277,316. Заголовок блоку для блоку 277,315 такий:</p>
    <pre>      0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</pre>
    <p> Обираючи певний батьківській блок, на який вказує хеш попереднього блоку
      в блоці-кандидаті, Джинг докладає свою обчислювальну потужність до
      розширення ланцюга, що завершується на певний блок. Загалом, це те, як
      Джинг "голосує" своєю обчислювальною потужністю за валідний ланцюжок з
      найдовшою складністю. <br>
    </p>
    <p>Наступний крок є підсумувати всі транзакції в мерклівське дерево, щоб
      додати мерклівський корінь до заголовку блока. Транзакція коінбейса
      вставляється першою транзакцією в блоці. Після неї додані ще інші 418
      транзакцій, що разом складає 419 транзакцій в блоці. Як ми бачили в
      дискусії щодо мерклівських дерев, має бути парне число листів в дереві,
      так що остання транзакція дублюється, створюючі 420 вузлів, кожен з яких
      містить хеш однієї транзакції. Хеші транзакцій комбінуються попарно,
      створюючи нові рівні дерева, доки всі транзакції не складуються в один
      вузол в "корені" дерева. Корінь мерклівського дерева підсумовує всі
      транзакції в єдине 32-байтне значення, що ви можете бачити як “merkle
      root” в Прикладі 10-3, та ми повторимо його тут:</p>
    <pre>      c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e
      </pre>
    <p>Майнаючий вузол Джинг потім додасть 4-байтний відтиск часу, закодований в
      вигляді "епохи" Юнікс, що базується на числі секунд, що пройшли після 1
      січня 1970 року, 0 годин за UTC/GMT. Час 1388185914 відповідає 27 грудня
      2013, 23:11:54 за UTC/GMT. <br>
    </p>
    <p>Потім вузол Джинга заповнює ціль, що визначає потрібний доказ виконаної
      роботи Proof-of-Work, щоб зробити цей блок валідним. Ціль зберігається в
      блоці як метрика “цільові біти”, що є кодування цілі з мантисою та
      експонентою. Кодування має 1-байтну експоненту, за якою слідує 3-байтна
      мантиса (коефіціент). Наприклад, в блоці 277,316, цільові біти є значення
      0x1903a30c. Перша частина, 0x19, є шістнацятерична експонента, та далі іде
      коефіціент, 0x03a30c. Концепція цілі пояснюється в “Зміна цілі та
      налаштування складності” далі, та представлення “цільових бітів”
      пояснюється в “Представлення цілі”. </p>
    <p>Завершуюче поле є нонс, або довісок, що ініціалізується нулем. Маючи всі
      ці поля заповненими, заголовок блоку тепер завершений, та можна
      розпочинати процес майнінгу. Тепер ціль знайти значення для довіску, що
      дасть хеш заголовку блока, меньший ніж ціль. Майнаючий вузол бепер має
      перевірити мільярди або трильйони значень довіска, перед тим, як буде
      знайдений довісок, що задовільнить вимогам.</p>
    <h3>Майнинг блоку</h3>
    <p> Тепер, коли блок-кандидат був побудований вузлом Джинга, настає час для
      обладнання Джинга "змайнати" блок, щоб знайти рішення алгоритма, що робить
      блок валідним. На протязі цієї книги ми вивчили щодо криптографічних хеш
      функцій, що використовуються в різних аспектах системи біткоінів. Хеш
      функція SHA256 є та сама функція, що використовується в процесі майнингу.
      В простіших термінах, майнинг є процес хешування заголовку блоку раз за
      разом, змінюючи один параметр, доки отриманий хеш не співпаде з визначеною
      ціллю. Хеш буде продакувати результат, що не може бути визначений
      заздалегідь, так само, як не може бути створений шаблон, що утворить
      бажане хеш значення. Ця властивість хеш функції означає, що єдиний спосіб
      спродукувати хеш результат, що співпадає з заданою ціллю, є тільки
      продувати раз за разом, випадково модифікуючи вхід, доки бажаний результат
      хешу не трапиться випадково.&nbsp;</p>
    <h3> Алгоритм доказу виконаної роботи</h3>
    <p> Алгоритм хешу приймає дані довільної довжини на вході, та продукує
      детермінистьский результат&nbsp; фіксованої довжини, як відтиск вхідних
      даних. Для кожного певного входу резльтуючий хеш буде завжди той самий, та
      може бути просто обчислений та перевірений будь-ким, хто реалізує той
      самий хеш алгоритм. Ключова характеристика криптографічного хеш алгоритму
      полягає в обчислювальній неможливості знайти два різні входи, що
      спродукують той самий відтиск (ситуація, відома як колізія). На відміну,
      також віртуально неможливо обрати такий вхід, щоб отримати бажаний
      відтиск, інакше, ніж спробувати випадкові входи. </p>
    <p>Алгоритм SHA256 завжди продукує 256 біт довжиною на виході, безвідностно
      від довжини входу. В Прикладі 10-8 ми будемо використовувати інтерпретатор
      Python для обчислення хешу SHA256 від фрази “I am Satoshi Nakamoto.”<br>
    </p>
    <p>Приклад 10-8. Приклад SHA256</p>
    <pre>$ python</pre>
    <pre>      Python 2.7.1</pre>
    <pre>      &gt;&gt;&gt; import hashlib</pre>
    <pre>      &gt;&gt;&gt; print hashlib.sha256("I am Satoshi Nakamoto").hexdigest()</pre>
    <pre>      5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e</pre>
    <p> Приклад 10-8 показує результат обчислення хешу "I am Satoshi Nakamoto":</p>
    <pre>      5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e.</pre>
    <p> Це 256-бібтне число є хешем або дайджестом від фрази, та залежить від
      кожної частини фрази. Додаючи одну літеру, знак пунктуації, або любі інші
      символи, буде продукувати інший хеш. Тепер, якщо ми змінимо фразу, нам
      треба очікувати повністю інший хеш. Давайте спробуємо це, через додавання
      числа в кінець фрази, за допомогою простого скрипта на Python в Прикладі
      10-9.<br>
    </p>
    <p>Приклад 10-9. Скрипт SHA256 для генерації багатьох хешів, через ітерацію
      довіску<br>
    </p>
    <pre># приклад ітерації довіску на вході хеш алгоритму<br>
      import hashlib<br>
      text = "I am Satoshi Nakamoto"<br>
      # ітеруємо від 0 до 19<br>
      for nonce in xrange(20):<br>
      # додаємо довісок до кінця рядка<br>
      input = text + str(nonce)<br>
      # обчислення SHA-256 для входу (текст+довісок)<br>
      hash = hashlib.sha256(input).hexdigest()<br>
      # друкуємо результат<br>
      print input, '=&gt;', hash<br>
      </pre>
    <p>Виконання цього коду продукує хеші для декількох фраз, що додає різни
      числа в кінець текста. Через збільшення числа ми отримуємо різні хеші, як
      показано в Прикладі 10-10.<br>
    </p>
    <p>Приклад 10-10. Вихід SHA256 скрипта для генерації різноманітних хешей
      через ітерацію довіска<br>
    </p>
    <pre>$ python hash_example.py<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto0 =&gt; a80a81401765c8eddee25df36728d732...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto1 =&gt; f7bc9a6304a4647bb41241a677b5345f...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto2 =&gt; ea758a8134b115298a1583ffb80ae629...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto3 =&gt; bfa9779618ff072c903d773de30c99bd...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto4 =&gt; bce8564de9a83c18c31944a66bde992f...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto5 =&gt; eb362c3cf3479be0a97a20163589038e...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto6 =&gt; 4a2fd48e3be420d0d28e202360cfbaba...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto7 =&gt; 790b5a1349a5f2b909bf74d0d166b17a...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto8 =&gt; 702c45e5b15aa54b625d68dd947f1597...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto9 =&gt; 7007cf7dd40f5e933cd89fff5b791ff0...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto10 =&gt; c2f38c81992f4614206a21537bd634a...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto11 =&gt; 7045da6ed8a914690f087690e1e8d66...<br>
      I&nbsp; am&nbsp; Satoshi&nbsp; Nakamoto12 =&gt; 60f01db30c1a0d4cbce2b4b22e88b9b...<br>
      ...</pre>
    <p> Кожна фраза продукує повністю інших результат хешування. Вони виглядають
      повністю довільними, але ви можете відтворити точно такий результат на
      любому комп'ютері, за допомогою Python, та побачити ті самі хеші. Число,
      використане як змінна в такому сценарії, називається безглуздим довіском,
      або нонсом. нонс використовується для зміни виводу криптографічної
      функції, в нашому випадку змінювати відтиск SHA256 для ключової фрази. <br>
    </p>
    <p>Щоб зробити змагання з цього алгоритму, давайте встановимо ціль: знайти
      першу фразу, що продукує шістнадцятиричний хеш, що починається з нуля. На
      щастя, це не складно! Приклад 10-10 показує, що фраза “I am Satoshi
      Nakamoto13” продукує хеш:</p>
    <pre>0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5</pre>
    <p>Він задовільняє нашому критерію. Щоб знайти його займає 13 спроб. В
      термінах вірогідності, якщо вивід функції хешування ріно розподілене, ми
      маємо знаходити результат з 0 в якості шістнадцятеричного префіксу кожні
      16 хешів (один з 16-ти шістнадцятеричних цифр, від 0 до F). В числових
      термінах це означає пошук значення хешу, меньшого ніж <br>
      0x1000000000000000000000000000000000000000000000000000000000000000. Ми
      назваємо цей відлік приначенням, та ціль полягає в пошуку хешу, що в
      числовому сенсі менший, ніж призначення. Якщо ми зменшимо ціль, тоді
      рішення пошуку хешу, меншого ніж ціль, стає більш та більш складною. </p>
    <p>Щоб отримати просту аналогію, уявіть гру, де гравці раз за разом
      викидають пару кісток, намагаючись викинути найменьшу кількість, що меньша
      за вказаний рубіж. В мершому раунді ціль є 12. Якщо ви не викидуєте дві
      шістірки, ви виграєте. В наступному раунді цілью є 11. Гравці мають
      викинути 10 або менше, щоб перемогти - знову неважка ціль. Тепер, декілька
      раундів пізніше, ціль зменшилась до 5. Тепер більше ніж половина кидків
      буде перевершувати ціль, і, таким чином, не виграє. Тепер для перемоги
      витрачається експоненціальна кількість кидків, з тим, як ціль зменшується.
      З часом, коли ціль стає 2 (мінімальна з можливих), тільки один кидок з
      кожних 36, або 2% з них, буде продукувати переможний результат.<br>
    </p>
    <p>З точки зору спостерігача, який знає, що ціллю гри є 2 якщо дехто буде
      успішним, зробивши переможний кидок, він буде вважати, що той зробив в
      середньому 36 кидків. Іншими словами, дехто може очікувати кількість
      роботи, що потрібна для отримання успіху від складності, що закладена в
      цілі. Коли алгоритм бізується на детерміністській функції, як SHA256,
      самий вхід складає доказ, що було виконано певний обсяг роботи, щоб
      спродукувати результат щодо цілі. Таким чином ми кажемо про доказ
      виконаної роботи.<br>
    </p>
    <p>Навіть якщо б кожна спроба продукувала довільний результат, вірогідність
      від можливих виходів могла б бути обчисленою заздалегідь. Таким чином,
      вихід від очікуваної складності задовільняє підтвердженню вказаної
      кількості виконаної роботи.<br>
    </p>
    <p>В Прикладі 10-10 виграшний "довісок" є 13, та цей результат може бути
      підтвердженний будь-ким, незалежно. Будь-хто може додати суфікс в вигляді
      числа 13 до фрази “I am Satoshi Nakamoto”, та обчислити хеш, та
      перевірити, що він менший за ціль. Вдалий результат також є доказом
      виконанної роботи, Proof-of-Work, оскільки він свідчить, що ми виконали
      роботу щодо пошуку цього довіску. Доки він має тільки одне обчислення
      хешу, це займе лише 13 обчислень хешу для пошуку працюючого довіску. Якщо
      ми збільшимо складність, та зменшимо ціль, це займе більше обчислень хешу
      для пошуку відповідного довіску, але тільки один хеш має бути
      веріфікований кожним. Більше того, знаючи ціль, будь-хто може оцінити
      складність, використовуючи статистику, і, таким чином, знати, скільки
      роботи було потрібне для пошуку цього довіску. <br>
    </p>
    <p>Алгоритм Proof-of-Work має продукувати хеш, що меньший за ціль. Більша
      ціль означає меншу складність для пошуку хешу, що меньший цілі. нижча ціль
      означає, що буде більш складно знайти хеш, менший за ціль. Ціль ті
      складність пов'язані взаємно обратньо. Перевірка виконаної роботи в
      біткоін дуже подібна назмагання в Прикладі 10-10. Майнер збирає
      блок-кандидат, заповнений транзакціями. Далі майнер обчислює хеш заголовку
      блоку, та дивиться, чи він менший за встановлену ціль. Якщо хеш не меньший
      за ціль, майнер буде змінювати довісок (звичайно просто збільшуючи його на
      одщин), та пробуваит знову. За заданої складності в мережі біткоін,
      майнери мають перевірити квадрільйони разів, перед тим, як знайти
      довісок-нонс, що призведе до достатньо малого хешу заголовку блоку. </p>
    <p> Дуже спрощений алгоритм Proof-of-Work, реалізований в Python, наданий в
      Прикладі 10-11.<br>
    </p>
    <p>Приклад 10-11. Спрощена реалізація Proof-of-Work</p>
    <pre>      #!/usr/bin/env python<br>
      # приклад алгоритму proof-of-work<br>
      import hashlib<br>
      import time<br>
      max_nonce = 2 ** 32 # 4 billion<br><br>
      def proof_of_work(header, difficulty_bits):<br>
            target = 2 ** (256-difficulty_bits) # обчислення цілі складності

	    for nonce in xrange(max_nonce):<br>
      		hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest()<br>
      	        if long(hash_result, 16) &lt; target: # перевірка, ци це валідний результат, що меньше цілі

      		    print "Success with nonce %d" % nonce<br>
	            print "Hash is %s" % hash_result<br>
          	    return (hash_result,nonce)<br>
     	    print "Failed after %d (max_nonce) tries" % nonce<br>
      	    return nonce<br>
      if __name__ == '__main__':<br>
	nonce = 0<br>
      	hash_result = ''<br>
        for difficulty_bits in xrange(32): # складність від 0 до 31 біт

              difficulty = 2 ** difficulty_bits<br>
              print "\nDifficulty: %ld (%d bits)" % (difficulty, difficulty_bits)<br>
      	      print "Starting search..."<br>
              start_time = time.time() # поточний час

              # створюємо умовний блок, що включає хеш з попереднього блоку<br>
              new_block = 'test block with transactions' + hash_result<br>
              # find a valid nonce for the new block<br>
             (hash_result, nonce) = proof_of_work(new_block, difficulty_bits)<br>
             end_time = time.time() # обчислюємо час калькуляції

             elapsed_time = end_time - start_time<br>
      	     print "Elapsed Time: %.4f seconds" % elapsed_time<br>
             if elapsed_time &gt; 0:<br>
     		  hash_power = float(long(nonce)/elapsed_time)  # estimate the hashes per second

                  print "Hashing Power: %ld hashes per second" % hash_power<br>
      </pre>
    <p>Виконуючи цей код, ви можете встановити бажану складність (в бітах,
      скільки передніх бітів має бути нулями), та побачити, скільки це забирає в
      вашого комп'ютера, щоб обчислити це: </p>
    <p>Приклад 10-12.Виконання прикладу Proof-of-Work для різних складностей</p>
    <pre>$ python proof-of-work-example.py*</pre>
    <pre>      Difficulty: 1 (0 bits)<br>
      [...]<br>
      Difficulty: 8 (3 bits)<br>
      Starting search...<br>
      Success with nonce 9<br>
      Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1<br>
      Elapsed Time: 0.0004 seconds<br>
      Hashing Power: 25065 hashes per second<br>
      Difficulty: 16 (4 bits)<br>
      Starting search...<br>
      Success with nonce 25<br>
      Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148<br>
      Elapsed Time: 0.0005 seconds<br>
      Hashing Power: 52507 hashes per second<br>
      Difficulty: 32 (5 bits)<br>
      Starting search...<br>
      Success with nonce 36<br>
      Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903<br>
      Elapsed Time: 0.0006 seconds<br>
      Hashing Power: 58164 hashes per second<br>
      [...]
      <br>
      Difficulty: 4194304 (22 bits)<br>
      Starting search...<br>
      Success with nonce 1759164<br>
      Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3<br>
      Elapsed Time: 13.3201 seconds<br>
      Hashing Power: 132068 hashes per second<br>
      Difficulty: 8388608 (23 bits)<br>
      Starting search...<br>
      Success with nonce 14214729<br>
      Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3<br>
      Elapsed Time: 110.1507 seconds<br>
      Hashing Power: 129048 hashes per second<br>
      Difficulty: 16777216 (24 bits)<br>
      Starting search...<br>
      Success with nonce 24586379<br>
      Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95<br>
      Elapsed Time: 195.2991 seconds<br>
      Hashing Power: 125890 hashes per second<br>
      [...]<br>
      Difficulty: 67108864 (26 bits)<br>
      Starting search...<br>
      Success with nonce 84561291<br>
      Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a<br>
      Elapsed Time: 665.0949 seconds<br>
      Hashing Power: 127141 hashes per second<br>
      </pre>
    <p>Як ви можете бачити, збільшення складності на 1 біт призводить до
      подвоєння в часі, що потрібен для пошуку рішення. Якщо ви подумаєте про
      цілий простір 256-бітних чисел, кожного разу, коли ви обмежуєте один біт
      до нуля, ви зменшуєте простір пошуку навпіл. В Прикладі 10-12 потрібно 84
      мільйони хеш спроб для пошуку довіска, що продукує хеш з 26 першими бітами
      нулів. Навіть на швидкості більще ніж 120 000 хешів на секунду, все ще
      треба 10 хвилин на лептопі для пошуку цього рішення.<br>
    </p>
    <p>На час написання мережа намагається знайти блок, хеш заголовка якого
      менший ніж:</p>
    <pre>      0000000000000000029AB9000000000000000000000000000000000000000000</pre>
    <p> Як ви можете бачити, є багато нулів на початку цілі, що означає наш
      диапазон хешів став значно менший, так що знайти валідний хеш стає значно
      складнішим. Для мережі це вимагає в середньому більше ніж 1,8 септа-хешей
      (тисяч мільярдів мільярдів хешей) на секунду, щоб знайти наступний блок.
      Це виглядає як неможливе завдання, але на щастя мережа дає 3 екза-хешів на
      секунду (EH/sec) обчислювальної потужності, що здатні знаходити блок в
      середньому з 10 хвилин.<br>
    </p>
    <h3> Представлення цілі</h3>
    <p> В Прикладі 10-3, ми бачили, що блок містить ціль в нотації, названою
      “цільові біти”, або просто “біти”, що для блока 277 316 має значення
      0x1903a30c. Ця нотація виражає ціль доказу виконанної роботи в форматі
      коефіціент/експонента, де перші дві шістнадцятирічні цифри є експонентою,
      та наступні шість цифер є коефіцієнтом. Таким чином в цьому блоці
      експонента є 0x19, та коефіціент 0x03a30c.<br>
    </p>
    <p>Формула для обчислення цільової складності з цього представлення
      наступна:<br>
    </p>
    <pre>target = coefficient * 2^(8 * (exponent – 3))</pre>
    <p> Використовуючи цю формулу, та бітами складності 0x1903a30c, ми
      отримуємо:</p>
    <pre>      target = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^</pre>
    <pre>      =&gt; target = 0x03a30c * 2^(0x08 * 0x16)^</pre>
    <pre>      =&gt; target = 0x03a30c * 2^0xB0^</pre>
    <p> або в десятичній формі:</p>
    <pre>      =&gt; target = 238,348 * 2^176^</pre>
    <pre>      =&gt; target =</pre>
    <pre>22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</pre>
    <p> перемикаючись знову до шістнадцятирічної форми:</p>
    <pre>      =&gt; target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</pre>
    <p> Це означає, що валідний блок для висоти 277 316 є такий, у якого хеш
      заголовка менший за ціль. В бінарноми вигляді це число повинно мати більше
      ніж 60 перших нульових бітів. З цім рівнем складності поодинокий майнер,
      що обробляє 1 триліон хешів на секунду (1 терахеш на секунду, або 1
      TH/sec), повинен знаходити рішення в середньому для одного блоку з 8496,
      або раз на 59 днів.</p>
    <h3> Зміна цілі та підлаштування складності</h3>
    <p> Як ми побачили, ціль визначає складність, і, таким чином, впливає на те,
      як довго треба шукати рішення для алгоритма доказу виконаної роботи. Це
      приводить до очевидного питання: чому треба підлаштовувати складність, хто
      її підлаштовує, та яким чином?</p>
    <p>Блоки біткоін генеруються в середньому кожні 10 хвилин. Це пульс
      біткоіну, що фіксує частоту випуску валюти, а також швидкість закріплення
      транзакцій. Цей час має залишатись сталим, не тільки протягом короткого
      терміну, але також на періоді в декілька десятиріч. Очікується, що з часом
      потужність комп'ютерів буде зростати швидкими темпами. Щоб підтримувати
      час генерації блока в 10 хвилин, складність майнінгу має налаштовуватись,
      щоб приймати до уваги ці зміни. Фактично, ціль доказу виконаної роботи є
      динамічним параметром, що періодично підлаштовується, щоб відповідати
      10-хвилинному виробництву блоків. Просто кажучи, ціль встановлюється таким
      чином, щоб нагальна обчислювальна потужність призводила до 10-хвилинного
      інтервалу блоків.&nbsp;</p>
    <p> Тоді як робиться таке підлаштування в повнісью децентралізованій мережі?
      Зміна цілі виконується автоматично, та незалежно на кожному вузлі. Кожні
      2016 блоків всі вузли змінюють ціль для доказу виконаної роботи. Рівняння
      для зміни цілі обчислює час, за який обчислені останні 2016 блоків, та
      порівнює це з очікуваним часом в 20160 хвилин (2016 разів по бажаному
      10-хвилинному інтервалу). Обчислюється відношення між дійсним проміжком
      часу, та бажаним, та робиться відповідне корегування цілі (вниз або
      догори). Просто кажучи, якщо мережа знаходить блоки швидше ніж кожні 10
      хвилин, складність зростає (ціль зменшується). Якщо знаходження блоків
      повільніше, ніж очікувалось, складність зменьшується (ціль зростає).<br>
    </p>
    <p>Рівняння може бути підсумоване таким чином:<br>
    </p>
    <p>Нова Ціль = Стара Ціль * (Дійсний час обчислення останніх 2016 блоків /
      20160 хвилин)<br>
    </p>
    <p>Приклад 10-13 показує код, що використовується в клієнті Bitcoin Core.<br>
    </p>
    <p>Приклад 10-13. Зміна цілі для доказу виконаної роботи:
      CalculateNextWorkRequired() в pow.cpp</p>
    <pre>      // Обмежуємо крок підлаштування<br>
      int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;<br>
      LogPrintf(" nActualTimespan = %d before bounds\n", nActualTimespan);<br>
      if (nActualTimespan &lt; params.nPowTargetTimespan/4)<br>
      		nActualTimespan = params.nPowTargetTimespan/4;<br>
      if (nActualTimespan &gt; params.nPowTargetTimespan*4)<br>
      		nActualTimespan = params.nPowTargetTimespan*4;<br>
      // Зміна цілі<br>
      const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);<br>
      arith_uint256 bnNew;<br>
      arith_uint256 bnOld;<br>
      bnNew.SetCompact(pindexLast-&gt;nBits);<br>
      bnOld = bnNew;<br>
      bnNew *= nActualTimespan;<br>
      bnNew /= params.nPowTargetTimespan;<br>
      if (bnNew &gt; bnPowLimit)<br>
      		bnNew = bnPowLimit;<br>
      </pre>
    <p>Хоча калібровка цілі відбувається кожні 2016 блоків, завдяки окремій
      помилці в оригінальному клієнті Bitcoin Core, розрахунки базуються на
      загальному часі попередніх 2015 блоків (не 2016, як це має бути), що
      призводить до похибки зміни цілі на 0.05%. Параметри Interval (2016
      блоків), та TargetTimespan (два тижні як 1209600 секунд), визначені в
      chainparams.cpp.<br>
    </p>
    <p>Щоб запобігти надмірно волатильній складності (<em>тобто, швидким
        перепадам, прим. перекл.</em>), підлаштування має не перевищувати
      коефіціент чотири (4) за цикл. Якщо запитане підлаштування більше ніж в
      чотири рази, воне буде обмежене коефіціентом чотири, і не більше. Кожне
      наступне підлаштування буде досягнуте через наступний період зміни цілі,
      та дисбаланс буде зберігатись на протязі наступних 2016 блоків. Таким
      чином, довготривалі невідповідності між потужністю хешування, та
      складності, може зайняти декілька циклів в 2016 блоків, доки знову не буде
      досягнутий баланс. </p>
    <p>Складність майнингу блоку біткоіну є приблизно 10 хвилин обробки для
      всієї мережі, базуючись на часі, що зайняв майнинг попередніх 2016 блоків,
      що підлаштовується кожні 2016 блоків. Це досягається через зниження або
      піднесення цілі.</p>
    <p> Зауважте, що ціль незалежна від числа транзакцій, або вартості
      транзакцій. Це означає, що кількість потужності хешування, і, таким чином,
      витрат на електро енергію, витрачених на унебезпечення біткоінів, також
      повністю незалежні від числа транзакцій. Біткоін може маштабуватись,
      досягати більшого поширення, та залишатись безпечним, без жодного
      збільшення потужності хешування від сьогоднішнього рівня. Збільшення
      хешингової потужності представляє ринкові сили, по мірі того, як нові
      майнери виходять на ринок, щоб позмагатися за винагороду. Доки існує
      досить хешингової потужності, що контролюється часно граючими за
      винагороду майнерами, цього буде достатньо для атак типу "захвату", і,
      таким чином, досить для безпеки біткоіну.&nbsp;</p>
    <p>Складність майнингу близько пов'язана з вартістю електрики та обмінного
      курсу біткоіна в термінах валюти, що використовує цю електричну енергію.
      Високопотужні системи майнингу намагаються бути такими ефективними, як це
      можливо, з сучасним поколінням виробництва кремнію, перетворюючи електрику
      в обчислення хешів, з найбільшою можливою потужністю. Первинний вплив не
      ринок майнингу є ціна однієї кіловат-години електрики в біткоіні, оскільки
      це визначає прибутковість майнингу, і, таким чином, стимулів для входу або
      виходу з ринку майнінгу. </p>
    <h3> Успішний майнинг блоку</h3>
    <p> Як ми бачили раніше, вузол Джинга побудував блок-кандидат, та підготував
      його для майнингу. Джинг має декілька апаратних стоєк для майнингу,
      насичений застосування-специфічними інтегрованими пристроями, де сотні та
      тисячі інтегрованих пристроїв виконуть алгоритм SHA256 паралельно з
      неймовірною швидкістю. Багато з ціх спеціалізованих машин під'єднані до
      свого майнингового вузла через USB або локальну мережу. Далі, майнинговий
      вузол, що виконується на десктопі Джинга, передає заголовок блоку до свого
      майнингового устаткування, що починає тестування трильйони довісків. Майже
      за 11 хвилин після початку майнингу блоку 277316, одна з апаратних
      майнингових машин знаходить рішення, та надсилає його назад, до
      майнингового вузла. Тоді, вставлене в заголовок блоку, довісок 924,591,752
      продукує хеш блоку:</p>
    <pre>      0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4</pre>
    <p> і це є менше за ціль:</p>
    <pre>      0000000000000003A30C00000000000000000000000000000000000000000000</pre>
    <p> Безвідкладно майнинговий вузол Джинга передає цей блок всім відомим йому
      сторонам. Вони приймають, перевіряють, та після цього просувають цей блок
      далі. З часом, коли цей блок заповнює всю мережу, кожний вузол додає його
      до власної копії блокчейну, розширюючи його до нової висоти в 277 316
      блоків. По мірі того, як майнаючі блоки отримують та підтверджують новий
      блок, вони припиняють власні спроби знайти блок на тій же висоті, та
      безпосередньо починають обчислювати наступний блок в ланцюгові,
      використовуючи блок Джинга як "батьківській". Через будівницьтво на цьому
      новому блоці від Джинга, інші майнери, насправді, “голосують” власною
      потужністю майнинга, та схвалюють блок Джинга, та весь ланцюг, що він
      подовжує. В наступному розділі ми поглянемо на процес, що використовує
      кожний вузол для валідації блоку, та вибору найдовшого ланцюга, створюючи
      консенсус, що формує децентралізований блокчейн.</p>
    <h3> Валідація нового блоку</h3>
    <p>Третій крок в механізму консенсусу біткоіну є незалежна валідація кожного
      нового блоку кожним вузлом мережі. По мірі того, як новий вирішений блок
      просувається по мережі, кожний вузол виконує серію перевірок, щоб
      валідутувати його, перед тим, як просувати його відомим сторонам. Це надає
      переконання, що тільки валідні блоки курсують мережою. Незалежна валідація
      також гарантує, що майнери, які діють чесно, отримують свої біткоіни в
      блокчейні, і так отримують винагороду. Tі майнери, що діють безчесно,
      будуть мати свої блоки відхиленими, та не тільки втратять винагороду, але
      і також втратять вартість своїз спроб знайти рішення доказу виконаної
      роботи, таким чином втративши вартість електроенергії без компенсації.</p>
    <p> When a node receives a new block, it will validate the block by checking
      it against a<br>
      long list of criteria that must all be met; otherwise, the block is
      rejected. These criteria<br>
      can be seen in the Bitcoin Core client in the functions CheckBlock and
      CheckBlock<br>
      Header and include:<br>
      • The block data structure is syntactically valid<br>
      • The block header hash is less than the target (enforces the
      Proof-of-Work)<br>
      • The block timestamp is less than two hours in the future (allowing for
      time<br>
      errors)<br>
      • The block size is within acceptable limits<br>
      • The first transaction (and only the first) is a coinbase transaction<br>
      • All transactions within the block are valid using the transaction
      checklist dis‐<br>
      cussed in “Independent Verification of Transactions” on page 218<br>
    </p>
    <p>The independent validation of each new block by every node on the network
      ensures<br>
      that the miners cannot cheat. In previous sections we saw how miners get
      to write a<br>
      transaction that awards them the new bitcoin created within the block and
      claim the<br>
      transaction fees. Why don’t miners write themselves a transaction for a
      thousand bit‐<br>
      coin instead of the correct reward? Because every node validates blocks
      according to<br>
      the same rules. An invalid coinbase transaction would make the entire
      block invalid,<br>
      which would result in the block being rejected and, therefore, that
      transaction would<br>
      never become part of the ledger. The miners have to construct a perfect
      block, based<br>
      on the shared rules that all nodes follow, and mine it with a correct
      solution to the<br>
      Proof-of-Work. To do so, they expend a lot of electricity in mining, and
      if they cheat,<br>
      all the electricity and effort is wasted. This is why independent
      validation is a key<br>
      component of decentralized consensus.</p>
    <h3> Assembling and Selecting Chains of Blocks</h3>
    <p> The final step in bitcoin’s decentralized consensus mechanism is the
      assembly of<br>
      blocks into chains and the selection of the chain with the most
      Proof-of-Work. Once<br>
      a node has validated a new block, it will then attempt to assemble a chain
      by connect‐<br>
      ing the block to the existing blockchain.<br>
      Nodes maintain three sets of blocks: those connected to the main
      blockchain, those<br>
      that form branches off the main blockchain (secondary chains), and
      finally, blocks<br>
      that do not have a known parent in the known chains (orphans). Invalid
      blocks are<br>
      rejected as soon as any one of the validation criteria fails and are
      therefore not<br>
      included in any chain.</p>
    <p> The “main chain” at any time is whichever valid chain of blocks has the
      most cumula‐<br>
      tive Proof-of-Work associated with it. Under most circumstances this is
      also the chain<br>
      with the most blocks in it, unless there are two equal-length chains and
      one has more<br>
      Proof-of-Work. The main chain will also have branches with blocks that are
      “siblings”<br>
      to the blocks on the main chain. These blocks are valid but not part of
      the main<br>
      chain. They are kept for future reference, in case one of those chains is
      extended to<br>
      exceed the main chain in work. In the next section (“Blockchain Forks” on
      page 240),<br>
      we will see how secondary chains occur as a result of an almost
      simultaneous mining<br>
      of blocks at the same height.</p>
    <p> When a new block is received, a node will try to slot it into the
      existing blockchain.<br>
      The node will look at the block’s “previous block hash” field, which is
      the reference to<br>
      the block’s parent. Then, the node will attempt to find that parent in the
      existing<br>
      blockchain. Most of the time, the parent will be the “tip” of the main
      chain, meaning<br>
      this new block extends the main chain. For example, the new block 277,316
      has a ref‐<br>
      erence to the hash of its parent block 277,315. Most nodes that receive
      277,316 will<br>
      already have block 277,315 as the tip of their main chain and will
      therefore link the<br>
      new block and extend that chain.</p>
    <p> Sometimes, as we will see in “Blockchain Forks” on page 240, the new
      block extends a<br>
      chain that is not the main chain. In that case, the node will attach the
      new block to<br>
      the secondary chain it extends and then compare the work of the secondary
      chain to<br>
      the main chain. If the secondary chain has more cumulative work than the
https://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8main<br>
      chain, the node will reconverge on the secondary chain, meaning it will
      select the sec‐<br>
      ondary chain as its new main chain, making the old main chain a secondary
      chain. If<br>
      the node is a miner, it will now construct a block extending this new,
      longer, chain.<br>
      If a valid block is received and no parent is found in the existing
      chains, that block is<br>
      considered an “orphan.” Orphan blocks are saved in the orphan block pool
      where<br>
      they will stay until their parent is received. Once the parent is received
      and linked<br>
      into the existing chains, the orphan can be pulled out of the orphan pool
      and linked<br>
      to the parent, making it part of a chain. Orphan blocks usually occur when
      two<br>
      blocks that were mined within a short time of each other are received in
      reverse order<br>
      (child before parent).</p>
    <p> By selecting the greatest-cumulative-work valid chain, all nodes
      eventually achieve<br>
      network-wide consensus. Temporary discrepancies between chains are
      resolved even‐<br>
      tually as more work is added, extending one of the possible chains. Mining
      nodes<br>
      “vote” with their mining power by choosing which chain to extend by mining
      the<br>
      next block. When they mine a new block and extend the chain, the new block
      itself<br>
      represents their vote.<br>
      In the next section we will look at how discrepancies between competing
      chains<br>
      (forks) are resolved by the independent selection of the
      greatest-cumulative-work<br>
      chain.</p>
    <h3> Blockchain Forks</h3>
    <p> Because the blockchain is a decentralized data structure, different
      copies of it are not<br>
      always consistent. Blocks might arrive at different nodes at different
      times, causing<br>
      the nodes to have different perspectives of the blockchain. To resolve
      this, each node<br>
      always selects and attempts to extend the chain of blocks that represents
      the most<br>
      Proof-of-Work, also known as the longest chain or greatest cumulative work
      chain.<br>
      By summing the work recorded in each block in a chain, a node can
      calculhttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8ate
      the<br>
      total amount of work that has been expended to create that chain. As long
      as all nodes<br>
      select the greatest-cumulative-work chain, the global bitcoin network
      eventually con‐<br>
      verges to a consistent state. Forks occur as temporary inconsistencies
      between ver‐<br>
      sions of the blockchain, which are resolved by eventual reconvergence as
      more blocks<br>
      are added to one of the forks.<br>
    </p>
    <p> The blockchain forks described in this section occur naturally as a<br>
      result of transmission delays in the global network. We will also<br>
      look at deliberately induced forks later in this chapter.<br>
      In the next few diagrams, we follow the progress of a “fork” event across
      the network.<br>
      The diagram is a simplified representation of the bitcoin network. For
      illustration<br>
      purposes, different blocks are shown as different shapes (star, triangle,
      upside-down<br>
      triangle, rhombus), spreading across the network. Each node in the network
      is repre‐<br>
      sented as a circle.</p>
    <p> Each node has its own perspective of the global blockchain. As each node
      receives<br>
      blocks from its neighbors, it updates its own copy of the blockchain,
      selecting the<br>
      greatest-cumulative-work chain. For illustration purposes, each node
      contains a<br>
      shape that represents the block that it believes is currently the tip of
      the main chain.<br>
      So, if you see a star shape in the node, that means that the star block is
      the tip of the<br>
      main chain, as far as that node is concerned.<br>
      In the first diagram (Малюнок&nbsp; 10-2), the network has a unified
      perspective of the block‐<br>
      chain, with the star block as the tip of the main chain.<br>
    </p>
    <p>Малюнок&nbsp; 10-2. Before the fork—all nodes have the same perspective<br>
      <br>
      A “fork” occurs whenever there are two candidate blocks competing to form
      the<br>
      longest blockchain. This occurs under normal conditions whenever two
      miners solve<br>
      the Proof-of-Work algorithm within a short period of time from each other.
      As both<br>
      miners discover a solution for their respective candidate blocks, they
      immediately<br>
      broadcast their own “winning” block to their immediate neighbors who begin
      propa‐<br>
      gating the block across the network. Each node that receives a valid block
      will incor‐<br>
      porate it into its blockchain, extending the blockchain by one block. If
      that node later<br>
      sees another candidate block extending the same parent, it connects the
      second can‐<br>
      didate on a secondary chain. As a result, some nodes will “see” one
      candidate block<br>
      first, while other nodes will see the other candidate block and two
      competing versions<br>
      of the blockchain will emerge.</p>
    <p> In Малюнок&nbsp; 10-3, we see two miners (Node X and Node Y) who mine
      two different<br>
      blocks almost simultaneously. Both of these blocks are children of the
      star block, and<br>
      extend the chain by building on top of the star block. To help us track
      it, one is visual‐<br>
      ized as a triangle block originating from Node X, and the other is shown
      as an upside-<br>
      down triangle block originating from Node Y.<br>
    </p>
    <p>Малюнок&nbsp; 10-3. Visualization of a blockchain fork event: two blocks
      found simultaneously<br>
      <br>
      Let’s assume, for example, that a miner Node X finds a Proof-of-Work
      solution for a<br>
      block “triangle” that extends the blockchain, building on top of the
      parent block<br>
      “star.” Almost simultaneously, the miner Node Y who was also extending the
      chain<br>
      from block “star” finds a solution for block “upside-down triangle,” his
      candidate<br>
      block. Now, there are two possible blocks; one we call “triangle,”
      originating in Node<br>
      X; and one we call “upside-down triangle,” originating in Node Y. Both
      blocks are<br>
      valid, both blocks contain a valid solution to the Proof-of-Work, and both
blohttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8cks<br>
      extend the same parent (block “star”). Both blocks likely contain most of
      the same<br>
      transactions, with only perhaps a few differences in the order of
      transactions.<br>
      As the two blocks propagate, some nodes receive block “triangle” first and
      some<br>
      receive block “upside-down triangle” first. As shown in Малюнок&nbsp;
      10-4, the network<br>
      splits into two different perspectives of the blockchain; one side topped
      with a trian‐<br>
      gle block, the other with the upside-down-triangle block.<br>
    </p>
    <p>Малюнок&nbsp; 10-4. Visualization of a blockchain fork event: two blocks
      propagate, splitting the<br>
      network<br>
    </p>
    <p>In the diagram, a randomly chosen “Node X” received the triangle block
      first and<br>
      extended the star chain with it. Node X selected the chain with “triangle”
      block as the<br>
      main chain. Later, Node X also received the “upside-down triangle” block.
      Since it<br>
      was received second, it is assumed to have “lost” the race. Yet, the
      “upside-down triangle” block is not discarded. It is linked to the “star”
      block parent and forms a secondary chain. While Node X assumes it has
      correctly selected the winning chain, it<br>
      keeps the “losing” chain so that it has the information needed to
      reconverge if the<br>
      “losing” chain ends up
“winning.”https://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8</p>
    <p> On the other side of the network, Node Y constructs a blockchain based
      on its own<br>
      perspective of the sequence of events. It received “upside-down triangle”
      first and<br>
      elected that chain as the “winner.” When it later received “triangle”
      block, it connec‐<br>
      ted it to the “star” block parent as a secondary chain.</p>
    <p> Neither side is “correct,” or “incorrect.” Both are valid perspectives
      of the blockchain.<br>
      Only in hindsight will one prevail, based on how these two competing
      chains are<br>
      extended by additional work.</p>
    <p> Mining nodes whose perspective resembles Node X will immediately begin
      mining a<br>
      candidate block that extends the chain with “triangle” as its tip. By
      linking “triangle”<br>
      as the parent of their candidate block, they are voting with their hashing
      power. Their<br>
      vote supports the chain that they have elected as the main chain.</p>
    <p> Any mining node whose perspective resembles Node Y will start building a
      candidate<br>
      node with “upside-down triangle” as its parent, extending the chain that
      they believe<br>
      is the main chain. And so, the race begins again.</p>
    <p> Forks are almost always resolved within one block. While part of the
      network’s hash‐<br>
      ing power is dedicated to building on top of “triangle” as the parent,
      another part of<br>
      the hashing power is focused on building on top of “upside-down triangle.”
      Even if<br>
      the hashing power is almost evenly split, it is likely that one set of
      miners will find a<br>
      solution and propagate it before the other set of miners have found any
      solutions.<br>
      Let’s say, for example, that the miners building on top of “triangle” find
      a new block<br>
      “rhombus” that extends the chain (e.g., star-triangle-rhombus). They
      immediately<br>
      propagate this new block and the entire network sees it as a valid
      solution as shown<br>
      in Малюнок&nbsp; 10-5.</p>
    <p> All nodes that had chosen “triangle” as the winner in the previous round
      will simply<br>
      extend the chain one more block. The nodes that chose “upside-down
      triangle” as the<br>
      winner, however, will now see two chains: star-triangle-rhombus and
      star-upside-<br>
      down-triangle. The chain star-triangle-rhombus is now longer (more
      cumulative<br>
      work) than the other chain. As a result, those nodes will set the chain
      star-triangle-<br>
      rhombus as the main chain and change the star-upside-down-triangle chain
      to a sec‐<br>
      ondary chain, as shown in Малюнок&nbsp; 10-6. This is a chain
      reconvergence, because those<br>
      nodes are forced to revise their view of the blockchain to incorporate the
      new evi‐<br>
      dence of a longer chain. Any miners working on extending the chain
      star-upside-<br>
      down-triangle will now stop that work because their candidate block is an
      “orphan,”<br>
      as its parent “upside-down-triangle” is no longer on the longest chain.
      The transac‐<br>
      tions within “upside-down-triangle” are re-inserted in the mempool for
      inclusion in the next block, because the block they were in is no longer
      in the main chain. The entire network reconverges on a single blockchain
      star-triangle-rhombus, with<br>
      “rhombus” as the last block in the chain. All miners immediately start
      working on<br>
      candidate blocks that reference “rhombus” as their parent to extend the
      star-triangle-<br>
      rhombus chain.<br>
    </p>
    <p>Малюнок&nbsp; 10-5. Visualization of a blockchain fork event: a new block
      extends one fork,<br>
      reconverging the network<br>
      <br>
      Малюнок&nbsp; 10-6. Visualization of a blockchain fork event: the network
      reconverges on a new<br>
      longest chain<br>
    </p>
    <p>It is theoretically possible for a fork to extend to two blocks, if two
      blocks are found<br>
      almost simultaneously by miners on opposite “sides” of a previous fork.
      However, the<br>
      chance of that happening is very low. Whereas a one-block fork might occur
      every<br>
      day, a two-block fork occurs at most once every few weeks.<br>
    </p>
    <p>Bitcoin’s block interval of 10 minutes is a design compromise between
      fast confirma‐<br>
      tion times (settlement of transactions) and the probability of a fork. A
      faster block<br>
      time would make transactions clear faster but lead to more frequent
      blockchain forks,<br>
      whereas a slower block time would decrease the number of forks but make
      settlement<br>
      slower.</p>
    <h3> Mining and the Hashing Race</h3>
    <p> Bitcoin mining is an extremely competitive industry. The hashing power
      has<br>
      increased exponentially every year of bitcoin’s existence. Some years the
      growth has<br>
      reflected a complete change of technology, such as in 2010 and 2011 when
      many min‐<br>
      ers switched from using CPU mining to GPU mining and field programmable
      gate<br>
      array (FPGA) mining. In 2013 the introduction of ASIC mining lead to
      another giant<br>
      leap in mining power, by placing the SHA256 function directly on silicon
      chips speci‐<br>
      alized for the purpose of mining. The first such chips could deliver more
      mining<br>
      power in a single box than the entire bitcoin network in 2010.<br>
    </p>
    <p>The following list shows the total hashing power of the bitcoin network,
      over the first<br>
      eight years of operation:<br>
    </p>
    <p>2009<br>
      0.5 MH/sec–8 MH/sec (16× growth)<br>
      2010<br>
      8 MH/sec–116 GH/sec (14,500× growth)<br>
      2011<br>
      16 GH/sec–9 TH/sec (562× growth)<br>
      2012<br>
      9 TH/sec–23 TH/sec (2.5× growth)<br>
      2013<br>
      23 TH/sec–10 PH/sec (450× growth)<br>
      2014<br>
      10 PH/sec–300 PH/sec (3000× growth)<br>
      2015<br>
      300 PH/sec-800 PH/sec (266× growth)<br>
      2016<br>
      800 PH/sec-2.5 EH/sec (312× growth))<br>
    </p>
    <p>In the chart in Малюнок&nbsp; 10-7, we can see that bitcoin network’s
      hashing power increased<br>
      over the past two years. As you can see, the competition between miners
      and the growth of bitcoin has resulted in an exponential increase in the
      hashing power (total<br>
      hashes per second across the network).<br>
    </p>
    <p>Малюнок&nbsp; 10-7. Total hashing power, terahashes per second (TH/sec)<br>
    </p>
    <p>As the amount of hashing power applied to mining bitcoin has exploded,
      the diffi‐<br>
      culty has risen to match it. The difficulty metric in the chart shown in
      Малюнок&nbsp; 10-8 is<br>
      measured as a ratio of current difficulty over minimum difficulty (the
      difficulty of the<br>
      first block).<br>
    </p>
    <p>Малюнок&nbsp; 10-8. Bitcoin’s mining difficulty metric<br>
      <br>
      In the last two years, the ASIC mining chips have become increasingly
      denser,<br>
      approaching the cutting edge of silicon fabrication with a feature size
      (resolution) of<br>
      16 nanometers (nm). Currently, ASIC manufacturers are aiming to overtake
      general-<br>
      purpose CPU chip manufacturers, designing chips with a feature size of 14
      nm,<br>
      because the profitability of mining is driving this industry even faster
      than general<br>
      computing. There are no more giant leaps left in bitcoin mining, because
      the industry<br>
      has reached the forefront of Moore’s Law, which stipulates that computing
      density<br>
      will double approximately every 18 months. Still, the mining power of the
      network<br>
      continues to advance at an exponential pace as the race for higher density
      chips is<br>
      matched with a race for higher density data centers where thousands of
      these chips<br>
      can be deployed. It’s no longer about how much mining can be done with one
      chip,<br>
      but how many chips can be squeezed into a building, while still
      dissipating the heat<br>
      and providing adequate power.</p>
    <h3> The Extra Nonce Solution</h3>
    <p> Since 2012, bitcoin mining has evolved to resolve a fundamental
      limitation in the<br>
      structure of the block header. In the early days of bitcoin, a miner could
      find a block<br>
      by iterating through the nonce until the resulting hash was below the
      target. As diffi‐<br>
      culty increased, miners often cycled through all 4 billion values of the
      nonce without<br>
      finding a block. However, this was easily resolved by updating the block
      timestamp to<br>
      account for the elapsed time. Because the timestamp is part of the header,
      the change<br>
      would allow miners to iterate through the values of the nonce again with
      different<br>
      results. Once mining hardware exceeded 4 GH/sec, however, this approach
      became<br>
      increasingly difficult because the nonce values were exhausted in less
      than a second.<br>
      As ASIC mining equipment started pushing and then exceeding the TH/sec
      hash<br>
      rate, the mining software needed more space for nonce values in order to
      find valid<br>
      blocks. The timestamp could be stretched a bit, but moving it too far into
      the future<br>
      would cause the block to become invalid. A new source of “change” was
      needed in the<br>
      block header. The solution was to use the coinbase transaction as a source
      of extra<br>
      nonce values. Because the coinbase script can store between 2 and 100
      bytes of data,<br>
      miners started using that space as extra nonce space, allowing them to
      explore a<br>
      much larger range of block header values to find valid blocks. The
      coinbase transac‐<br>
      tion is included in the merkle tree, which means that any change in the
      coinbase<br>
      script causes the merkle root to change. Eight bytes of extra nonce, plus
      the 4 bytes of<br>
      “standard” nonce allow miners to explore a total 296 (8 followed by 28
      zeros) possibili‐<br>
      ties per second without having to modify the timestamp. If, in the future,
      miners<br>
      could run through all these possibilities, they could then modify the
      timestamp.<br>
      There is also more space in the coinbase script for future expansion of
      the extra<br>
      nonce space.<br>
      <br>
      Successful blocks pay the reward to a pool bitcoin address, rather than
      individual<br>
      miners. The pool server will periodically make payments to the miners’
      bitcoin<br>
      addresses, once their share of the rewards has reached a certain
      threshold. Typically,<br>
      the pool server charges a percentage fee of the rewards for providing the
      pool-mining<br>
      service.</p>
    <p> Miners participating in a pool split the work of searching for a
      solution to a candidate<br>
      block, earning “shares” for their mining contribution. The mining pool
      sets a higher<br>
      target (lower difficulty) for earning a share, typically more than 1,000
      times easier<br>
      than the bitcoin network’s target. When someone in the pool successfully
      mines a<br>
      block, the reward is earned by the pool and then shared with all miners in
      proportion<br>
      to the number of shares they contributed to the effort.</p>
    <p> Pools are open to any miner, big or small, professional or amateur. A
      pool will there‐<br>
      fore have some participants with a single small mining machine, and others
      with a<br>
      garage full of high-end mining hardware. Some will be mining with a few
      tens of a<br>
      kilowatt of electricity, others will be running a data center consuming a
      megawatt of<br>
      power. How does a mining pool measure the individual contributions, so as
      to fairly<br>
      distribute the rewards, without the possibility of cheating? The answer is
      to use bit‐<br>
      coin’s Proof-of-Work algorithm to measure each pool miner’s contribution,
      but set at<br>
      a lower difficulty so that even the smallest pool miners win a share
      frequently enough<br>
      to make it worthwhile to contribute to the pool. By setting a lower
      difficulty for earn‐<br>
      ing shares, the pool measures the amount of work done by each miner. Each
      time a<br>
      pool miner finds a block header hash that is less than the pool target,
      she proves she<br>
      has done the hashing work to find that result. More importantly, the work
      to find<br>
      shares contributes, in a statistically measurable way, to the overall
      effort to find a hash<br>
      lower than the bitcoin network’s target. Thousands of miners trying to
      find low-value<br>
      hashes will eventually find one low enough to satisfy the bitcoin network
      target.<br>
      Let’s return to the analogy of a dice game. If the dice players are
      throwing dice with a<br>
      goal of throwing less than four (the overall network difficulty), a pool
      would set an<br>
      easier target, counting how many times the pool players managed to throw
      less than<br>
      eight. When pool players throw less than eight (the pool share target),
      they earn<br>
      shares, but they don’t win the game because they don’t achieve the game
      target (less<br>
      than four). The pool players will achieve the easier pool target much more
      often,<br>
      earning them shares very regularly, even when they don’t achieve the
      harder target of<br>
      winning the game. Every now and then, one of the pool players will throw
      ahttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8
      com‐<br>
      bined dice throw of less than four and the pool wins. Then, the earnings
      can be dis‐<br>
      tributed to the pool players based on the shares they earned. Even though
      the target<br>
      of eight-or-less wasn’t winning, it was a fair way to measure dice throws
      for the play‐<br>
      ers, and it occasionally produces a less-than-four throw.</p>
    <p> Similarly, a mining pool will set a (higher and easier) pool target that
      will ensure that<br>
      an individual pool miner can find block header hashes that are less than
      the pool tarold blocks practically immutable. Consensus attacks also do
      not affect the security of the private keys and signing algorithm (ECDSA).
      A consensus attack cannot steal bit‐<br>
      coin, spend bitcoin without signatures, redirect bitcoin, or otherwise
      change past<br>
      transactions or ownership records. Consensus attacks can only affect the
      most recent<br>
      blocks and cause denial-of-service disruptions on the creation of future
      blocks.<br>
      One attack scenario against the consensus mechanism is called the “51%
      attack.” In<br>
      this scenario a group of miners, controlling a majority (51%) of the total
      network’s<br>
      hashing power, collude to attack bitcoin. With the ability to mine the
      majorihttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8ty
      of the<br>
      blocks, the attacking miners can cause deliberate “forks” in the
      blockchain and<br>
      double-spend transactions or execute denial-of-service attacks against
      spechttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8ific
      trans‐<br>
      actions or addresses. A fork/double-spend attack is where the attacker
      causes previ‐<br>
      ously confirmed blocks to be invalidated by forking below them and
re-convhttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8erging<br>
      on an alternate chain. With sufficient power, an attacker can invalidate
      six or more<br>
      blocks in a row, causing transactions that were considered immutable (six
chttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8onfirma‐<br>
      tions) to be invalidated. Note that a double-spend can only be done on the
      attacker’s<br>
      own transactions, for which the attacker can produce a valid signature.
Dohttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8uble-<br>
      spending one’s own transactions is profitable if by invalidating a
      transaction the<br>
      attacker can get an irreversible exchange payment or product without
      paying for it.<br>
      Let’s examine a practical example of a 51% attack. In the first chapter,
      we looked at a<br>
      transaction between Alice and Bob for a cup of coffee. Bob, the cafe
      owner, is willing<br>
      to accept payment for cups of coffee without waiting for confirmation
      (minihttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8https://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8ng
      in a<br>
      block), because the risk of a double-spend on a cup of coffee is low in
      comparison to<br>
      the convenience of rapid customer service. This is similar to the practice
      of coffee<br>
      shops that accept credit card payments without a signature for amounts
      below $25,<br>
      because the risk of a credit-card chargeback is low while the cost of
      delayinhttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8g
      the<br>
      transaction to obtain a signature is comparatively larger. In contrast,
      selling a more<br>
      expensive item for bitcoin runs the risk of a double-spend attack, where
      the buyer<br>
      broadcasts a competing transaction that spends the same inputs (UTXO) and
      cancels<br>
      the payment to the merchant. A double-spend attack can happen in two ways:
      either<br>
      before a transaction is confirmed, or if the attacker takes advantage of a
      blockchain<br>
      fork to undo several blocks. A 51% attack allows attackers to double-spend
      their own<br>
      transactions in the new chain, thus undoing the corresponding transaction
      in the old<br>
      chain.</p>
    <p> In our example, malicious attacker Mallory goes to Carol’s gallery and
      purchases a<br>
      beautiful triptych painting depicting Satoshi Nakamoto as Prometheus.
      Carol sells<br>
      “The Great Fire” paintings for $250,000 in bitcoin to Mallory. Instead of
      waiting for<br>
      six or more confirmations on the transaction, Carol wraps and hands the
      paintings to<br>
      Mallory after only one confirmation. Mallory works with an accomplice,
      Paul, who<br>
      operates a large mining pool, and the accomplice launches a 51% attack as
      soon as<br>
      Mallory’s transaction is included in a block. Paul directs the mining pool
      to remine<br>
      the same block height as the block containing Mallory’s transaction,
      replacing Mallory’s payment to Carol with a transaction that double-spends
      the same input as Mallory’s payment. The double-spend transaction consumes
      the same UTXO and pays it<br>
      back to Mallory’s wallet, instead of paying it to Carol, essentially
      allowing Mallory to<br>
      keep the bitcoin. Paul then directs the mining pool to mine an additional
      block, so as<br>
      to make the chain containing the double-spend transaction longer than the
      original<br>
      chain (causing a fork below the block containing Mallory’s transaction).
      When the<br>
      blockchain fork resolves in favor of the new (longer) chain, the
      double-spent transac‐<br>
      tion replaces the original payment to Carol. Carol is now missing the
      three paintings<br>
      and also has no bitcoin payment. Throughout all this activity, Paul’s
      mining pool par‐<br>
      ticipants might remain blissfully unaware of the double-spend attempt,
      because they<br>
      mine with automated miners and cannot monitor every transaction or block.<br>
      To protect against this kind of attack, a merchant selling large-value
      items must wait<br>
      at least six confirmations before giving the product to the buyer.
      Alternatively, the<br>
      merchant should use an escrow multisignature account, again waiting for
      several<br>
      confirmations after the escrow account is funded. The more confirmations
      elapse, the<br>
      harder it becomes to invalidate a transaction with a 51% attack. For
      high-value items,<br>
      payment by bitcoin will still be convenient and efficient even if the
      buyer has to wait<br>
      24 hours for delivery, which would correspond to approximately 144
confirmhttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8ations.<br>
      In addition to a double-spend attack, the other scenario for a consensus
      attack is to<br>
      deny service to specific bitcoin participants (specific bitcoin
      addresses). An attacker<br>
      with a majority of the mining power can simply ignore specific
      transactions. If they<br>
      are included in a block mined by another miner, the attacker can
      deliberately fork<br>
      and remine that block, again excluding the specific transactions. This
      type of attack<br>
      can result in a sustained denial-of-service against a specific address or
      set of addresses<br>
      for as long as the attacker controls the majority of the mining power.<br>
      Despite its name, the 51% attack scenario doesn’t actually require 51% of
      the hashing<br>
      power. In fact, such an attack can be attempted with a smaller percentage
      of the hash‐<br>
      ing power. The 51% threshold is simply the level at which such an attack
      is almost<br>
      guaranteed to succeed. A consensus attack is essentially a tug-of-war for
      the next<br>
      block and the “stronger” group is more likely to win. With less hashing
      power, the<br>
      probability of success is reduced, because other miners control the
      generation of<br>
      some blocks with their “honest” mining power. One way to look at it is
      that
      thhttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8https://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8e
      more<br>
      hashing power an attacker has, the longer the fork he can deliberately
      create, the<br>
      more blocks in the recent past he can invalidate, or the more blocks in
      the future he<br>
      can control. Security research groups have used statistical modeling to
      claim that var‐<br>
      ious types of consensus attacks are possible with as little as 30% of the
      hashing power.<br>
      The massive increase of total hashing power has arguably made bitcoin
      impervious to<br>
      attacks by a single miner. There is no possible way for a solo miner to
      control more<br>
      than a small percentage of the total mining power. However, the
      centralization of<br>
      control caused by mining pools has introduced the risk of for-profit
      attacks by a mining pool operator. The pool operator in a managed pool
      controls the construction of candidate blocks and also controls which
      transactions are included. This gives the<br>
      pool operator the power to exclude transactions or introduce double-spend
      transac‐<br>
      tions. If such abuse of power is done in a limited and subtle way, a pool
      operator<br>
      could conceivably profit from a consensus attack without being noticed.<br>
      Not all attackers will be motivated by profit, however. One potential
      attack
      schttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8enario
      is<br>
      where an attacker intends to disrupt the bitcoin network without the
      possibility of<br>
      profiting from such disruption. A malicious attack aimed at crippling
      bitcoin would<br>
      require enormous investment and covert planning, but could conceivably be<br>
      launched by a well-funded, most likely state-sponsored, attacker.
      Alternatively, a well-<br>
      funded attacker could attack bitcoin’s consensus by simultaneously
      amassing mining<br>
      hardware, compromising pool operators, and attacking other pools with
denihttps://www.google.com.ua/search?q=%D0%B7%D0%B4%D1%84%D0%BD&amp;oq=%D0%B7%D0%B4%D1%84%D0%BD&amp;aqs=chrome..69i57j0l5.1633j0j7&amp;sourceid=chrome&amp;ie=UTF-8al-of-<br>
      service. All of these scenarios are theoretically possible, but
      increasingly impractical<br>
      as the bitcoin network’s overall hashing power continues to grow
      exponentially.<br>
      Undoubtedly, a serious consensus attack would erode confidence in bitcoin
      in the<br>
      short term, possibly causing a significant price decline. However, the
      bitcoin network<br>
      and software are constantly evolving, so consensus attacks would be met
      with imme‐<br>
      diate countermeasures by the bitcoin community, making bitcoin hardier,
      stealthier,<br>
      and more robust than ever.</p>
    <h3> Changing the Consensus Rules</h3>
    <p> The rules of consensus determine the validity of transactions and
      blocks. These rules<br>
      are the basis for collaboration between all bitcoin nodes and are
      responsible for the<br>
      convergence of all local perspectives into a single consistent blockchain
      across the<br>
      entire network.<br>
      While the consensus rules are invariable in the short term and must be
      consistent<br>
      across all nodes, they are not invariable in the long term. In order to
      evolve and<br>
      develop the bitcoin system, the rules have to change from time to time to
      accommo‐<br>
      date new features, improvements, or bug fixes. Unlike traditional software
      develop‐<br>
      ment, however, upgrades to a consensus system are much more difficult and
      require<br>
      coordination between all the participants.<br>
      Hard Forks<br>
      In “Blockchain Forks” on page 240 we looked at how the bitcoin network may
      briefly<br>
      diverge, with two parts of the network following two different branches of
      the block‐<br>
      chain for a short time. We saw how this process occurs naturally, as part
      of the nor‐<br>
      mal operation of the network and how the network reconverges on a common<br>
      blockchain after one or more blocks are mined.<br>
    </p>
    <p>There is another scenario in which the network may diverge into following
      two<br>
      chains: a change in the consensus rules. This type of fork is called a
      hard fork, because<br>
      after the fork the network does not reconverge onto a single chain.
      Instead, the two<br>
      chains evolve independently. Hard forks occur when part of the network is
      operating<br>
      under a different set of consensus rules than the rest of the network.
      This may occur<br>
      because of a bug or because of a deliberate change in the implementation
      of the con‐<br>
      sensus rules.</p>
    <p> Hard forks can be used to change the rules of consensus, but they
      require coordina‐<br>
      tion between all participants in the system. Any nodes that do not upgrade
      to the new<br>
      consensus rules are unable to participate in the consensus mechanism and
      are forced<br>
      onto a separate chain at the moment of the hard fork. Thus, a change
      introduced by a<br>
      hard fork can be thought of as not “forward compatible,” in that
      nonupgraded sys‐<br>
      tems can no longer process the new consensus rules.<br>
      Let’s examine the mechanics of a hard fork with a specific example.<br>
      Малюнок&nbsp; 10-9 shows a blockchain with two forks. At block height 4, a
      one-block fork<br>
      occurs. This is the type of spontaneous fork we saw in “Blockchain Forks”
      on page<br>
      240. With the mining of block 5, the network reconverges on one chain and
      the fork<br>
      is resolved.</p>
    <p> Малюнок&nbsp; 10-9. A blockchain with forks<br>
    </p>
    <p>Later, however, at block height 6, a hard fork occurs. Let’s assume that
      a new imple‐<br>
      mentation of the client is released with a change in the consensus rules.
      Starting on<br>
      block height 7, miners running this new implementation will accept a new
      type of<br>
      digital signature, let’s call it a “Smores” signature, that is not ECDSA
      based. Immedi‐<br>
      ately after, a node running the new implementation creates a transaction
      that contains<br>
      a Smores signature and a miner with the updated software mines block 7b
      containing<br>
      this transaction.<br>
      Any node or miner that has not upgraded the software to validate Smores
      signatures<br>
      is now unable to process block 7b. From their perspective, both the
      transaction that<br>
      contained a Smores signature and block 7b that contained that transaction
      are inva‐<br>
      lid, because they are evaluating them based upon the old consensus rules.
      These<br>
      nodes will reject the transaction and the block and will not propagate
      them. Any min‐<br>
      ers that are using the old rules will not accept block 7b and will
      continue to mine a candidate block whose parent is block 6. In fact,
      miners using the old rules may not even receive block 7b if all the nodes
      they are connected to are also obeying the old<br>
      rules and therefore not propagating the block. Eventually, they will be
      able to mine<br>
      block 7a, which is valid under the old rules and does not contain any
      transactions<br>
      with Smores signatures.<br>
      The two chains continue to diverge from this point. Miners on the “b”
      chain will con‐<br>
      tinue to accept and mine transactions containing Smores signatures, while
      miners on<br>
      the “a” chain will continue to ignore these transactions. Even if block 8b
      does not con‐<br>
      tain any Smores-signed transactions, the miners on the “a” chain cannot
      process it. To<br>
      them it appears to be an orphan block, as its parent “7b” is not
      recognized as a valid<br>
      block.</p>
    <h3> Hard Forks: Software, Network, Mining, and Chain</h3>
    <p> For software developers, the term “fork” has another meaning, adding
      confusion to<br>
      the term “hard fork.” In open source software, a fork occurs when a group
      of develop‐<br>
      ers choose to follow a different software roadmap and start a competing
      implementa‐<br>
      tion of an open source project. We’ve already discussed two circumstances
      that will<br>
      lead to a hard fork: a bug in the consensus rules and a deliberate
      modification of the<br>
      consensus rules. In the case of a deliberate change to the consensus
      rules, a software<br>
      fork precedes the hard fork. However, for this type of hard fork to occur,
      a new soft‐<br>
      ware implementation of the consensus rules must be developed, adopted, and<br>
      launched.<br>
      Examples of software forks that have attempted to change consensus rules
      include<br>
      Bitcoin XT, Bitcoin Classic, and most recently Bitcoin Unlimited. However,
      none of<br>
      these software forks have resulted in a hard fork. While a software fork
      is a necessary<br>
      precondition, it is not in itself sufficient for a hard fork to occur. For
      a hard fork to<br>
      occur, the competing implementation must be adopted and the new rules
      activated,<br>
      by miners, wallets, and intermediary nodes. Conversely, there are numerous
      alterna‐<br>
      tive implementations of Bitcoin Core, and even software forks, that do not
      change the<br>
      consensus rules and barring a bug, can coexist on the network and
      interoperate<br>
      without causing a hard fork.<br>
      Consensus rules may differ in obvious and explicit ways, in the validation
      of transac‐<br>
      tions or blocks. The rules may also differ in more subtle ways, in the
      implementation<br>
      of the consensus rules as they apply to bitcoin scripts or cryptographic
      primitives<br>
      such as digital signatures. Finally, the consensus rules may differ in
      unanticipated<br>
      ways because of implicit consensus constraints imposed by system
      limitations or<br>
      implementation details. An example of the latter was seen in the
      unanticipated hard<br>
      fork during the upgrade of Bitcoin Core 0.7 to 0.8, which was caused by a
      limitation<br>
      in the Berkley DB implementation used to store blocks.</p>
    <p> Conceptually, we can think of a hard fork as developing in four stages:
      a software<br>
      fork, a network fork, a mining fork, and a chain fork.<br>
      The process begins when an alternative implementation of the client, with
      modified<br>
      consensus rules, is created by developers.<br>
      When this forked implementation is deployed in the network, a certain
      percentage of<br>
      miners, wallet users, and intermediate nodes may adopt and run this
      implementation.<br>
      A resulting fork will depend upon whether the new consensus rules apply to
      blocks,<br>
      transactions, or some other aspect of the system. If the new consensus
      rules pertain to<br>
      transactions, then a wallet creating a transaction under the new rules may
      precipitate<br>
      a network fork, followed by a hard fork when the transaction is mined into
      a block. If<br>
      the new rules pertain to blocks, then the hard fork process will begin
      when a block is<br>
      mined under the new rules.<br>
      First, the network will fork. Nodes based on the original implementation
      of the con‐<br>
      sensus rules will reject any transactions and blocks that are created
      under the new<br>
      rules. Furthermore, the nodes following the original consensus rules will
      temporarily<br>
      ban and disconnect from any nodes that are sending them these invalid
      transactions<br>
      and blocks. As a result, the network will partition into two: old nodes
      will only<br>
      remain connected to old nodes and new nodes will only be connected to new
      nodes.<br>
      A single transaction or block based on the new rules will ripple through
      the network<br>
      and result in the partition into two networks.<br>
      Once a miner using the new rules mines a block, the mining power and chain
      will<br>
      also fork. New miners will mine on top of the new block, while old miners
      will mine a<br>
      separate chain based on the old rules. The partitioned network will make
      it so that the<br>
      miners operating on separate consensus rules won’t likely receive each
      other’s blocks,<br>
      as they are connected to two separate networks.</p>
    <h3> Diverging Miners and Difficulty</h3>
    <p> As miners diverge into mining two different chains, the hashing power is
      split<br>
      between the chains. The mining power can be split in any proportion
      between the<br>
      two chains. The new rules may only be followed by a minority, or by the
      vast majority<br>
      of the mining power.</p>
    <p> Let’s assume, for example, an 80%–20% split, with the majority of the
      mining power<br>
      using the new consensus rules. Let’s also assume that the fork occurs
      immediately<br>
      after a retargeting period.<br>
      The two chains would each inherit the difficulty from the retargeting
      period. The new<br>
      consensus rules would have 80% of the previously available mining power
      committed<br>
      to them. From the perspective of this chain, the mining power has suddenly
      declined<br>
      by 20% vis-a-vis the previous period. Blocks will be found on average
      every 12<br>
      minutes, representing the 20% decline in mining power available to extend
      this chain.<br>
    </p>
    <p>This rate of block issuance will continue (barring any changes in hashing
      power) until<br>
      2016 blocks are mined, which will take approximately 24,192 minutes (at 12
      minutes<br>
      per block), or 16.8 days. After 16.8 days, a retarget will occur and the
      difficulty will<br>
      adjust (reduced by 20%) to produce 10-minute blocks again, based on the
      reduced<br>
      amount of hashing power in this chain.<br>
      The minority chain, mining under the old rules with only 20% of the
      hashing power,<br>
      will face a much more difficult task. On this chain, blocks will now be
      mined every 50<br>
      minutes on average. The difficulty will not be adjusted for 2016 blocks,
      which will<br>
      take 100,800 minutes, or approximately 10 weeks to mine. Assuming a fixed
      capacity<br>
      per block, this will also result in a reduction of transaction capacity by
      a factor of 5, as<br>
      there are fewer blocks per hour available to record transactions.</p>
    <h3> Contentious Hard Forks</h3>
    <p> This is the dawn of consensus software development. Just as open source
      develop‐<br>
      ment changed both the methods and products of software and created new
      method‐<br>
      ologies, new tools, and new communities in its wake, consensus software<br>
      development also represents a new frontier in computer science. Out of the
      debates,<br>
      experiments, and tribulations of the bitcoin development roadmap, we will
      see new<br>
      development tools, practices, methodologies, and communities emerge.<br>
      Hard forks are seen as risky because they force a minority to either
      upgrade or<br>
      remain on a minority chain. The risk of splitting the entire system into
      two compet‐<br>
      ing systems is seen by many as an unacceptable risk. As a result, many
      developers are<br>
      reluctant to use the hard fork mechanism to implement upgrades to the
      consensus<br>
      rules, unless there is near-unanimous support from the entire network. Any
      hard fork<br>
      proposals that do not have near-unanimous support are considered too
      “contentious”<br>
      to attempt without risking a partition of the system.<br>
      The issue of hard forks is highly controversial in the bitcoin development
      commu‐<br>
      nity, especially as it relates to any proposed changes to the consensus
      rules controlling<br>
      the maximum block size limit. Some developers are opposed to any form of
      hard<br>
      fork, seeing it as too risky. Others see the mechanism of hard fork as an
      essential tool<br>
      for upgrading the consensus rules in a way that avoids “technical debt”
      and provides a<br>
      clean break with the past. Finally, some developers see hard forks as a
      mechanism<br>
      that should be used rarely, with a lot of advance planning and only under
      near-<br>
      unanimous consensus.<br>
      Already we have seen the emergence of new methodologies to address the
      risks of<br>
      hard forks. In the next section, we will look at soft forks, and the
      BIP-34 and BIP-9<br>
      methods for signaling and activation of consensus modifications.<br>
    </p>
    <h3> Soft Forks</h3>
    <p> Not all consensus rule changes cause a hard fork. Only consensus changes
      that are<br>
      forward-incompatible cause a fork. If the change is implemented in such a
      way that<br>
      an unmodified client still sees the transaction or block as valid under
      the previous<br>
      rules, the change can happen without a fork.</p>
    <p> The term soft fork was introduced to distinguish this upgrade method
      from a “hard<br>
      fork.” In practice, a soft fork is not a fork at all. A soft fork is a
      forward-compatible<br>
      change to the consensus rules that allows unupgraded clients to continue
      to operate<br>
      in consensus with the new rules.</p>
    <p> One aspect of soft forks that is not immediately obvious is that soft
      fork upgrades can<br>
      only be used to constrain the consensus rules, not to expand them. In
      order to be for‐<br>
      ward compatible, transactions and blocks created under the new rules must
      be valid<br>
      under the old rules too, but not vice versa. The new rules can only limit
      what is valid;<br>
      otherwise, they will trigger a hard fork when rejected under the old
      rules.<br>
      Soft forks can be implemented in a number of ways—the term does not define
      a sin‐<br>
      gle method, rather a set of methods that all have one thing in common:
      they don’t<br>
      require all nodes to upgrade or force nonupgraded nodes out of consensus.</p>
    <h3> Soft forks redefining NOP opcodes</h3>
    <p> A number of soft forks have been implemented in bitcoin, based on the
      re-<br>
      interpretation of NOP opcodes. Bitcoin Script had ten opcodes reserved for
      future<br>
      use, NOP1 through NOP10. Under the consensus rules, the presence of these<br>
      opcodes in a script is interpreted as a null-potent operator, meaning they
      have no<br>
      effect. Execution continues after the NOP opcode as if it wasn’t there.<br>
      A soft fork therefore can modify the semantics of a NOP code to give it
      new meaning.<br>
      For example, BIP-65 (CHECKLOCKTIMEVERIFY) reinterpreted the NOP2 opcode.
      Clients<br>
      implementing BIP-65 interpret NOP2 as OP_CHECKLOCKTIMEVERIFY and impose an<br>
      absolute locktime consensus rule on UTXO that contain this opcode in their
      locking<br>
      scripts. This change is a soft fork because a transaction that is valid
      under BIP-65 is<br>
      also valid on any client that is not implementing (ignorant of) BIP-65. To
      the old cli‐<br>
      ents, the script contains an NOP code, which is ignored.</p>
    <h3> Other ways to soft fork upgrade</h3>
    <p> The reinterpretation of NOP opcodes was both planned for and an obvious
      mecha‐<br>
      nism for consensus upgrades. Recently, however, another soft fork
      mechanism was<br>
      introduced that does not rely on NOP opcodes for a very specific type of
      consensus<br>
      change. This is examined in more detail in Appendix D. Segwit is an
      architectural<br>
      change to the structure of a transaction, which moves the unlocking script
      (witness)<br>
      from inside the transaction to an external data structure (segregating
      it). Segwit was initially envisioned as a hard fork upgrade, as it
      modified a fundamental structure<br>
      (transaction). In November 2015, a developer working on Bitcoin Core
      proposed a<br>
      mechanism by which segwit could be introduced as a soft fork. The
      mechanism used<br>
      for this is a modification of the locking script of UTXO created under
      segwit rules,<br>
      such that unmodified clients see the locking script as redeemable with any
      unlocking<br>
      script whatsoever. As a result, segwit can be introduced without requiring
      every node<br>
      to upgrade or split from the chain: a soft fork.<br>
      It is likely that there are other, yet to be discovered, mechanisms by
      which upgrades<br>
      can be made in a forward-compatible way as a soft fork.<br>
      Criticisms of Soft Forks<br>
      Soft forks based on the NOP opcodes are relatively uncontroversial. The
      NOP<br>
      opcodes were placed in Bitcoin Script with the explicit goal of allowing
      non-<br>
      disruptive upgrades.<br>
      However, many developers are concerned that other methods of soft fork
      upgrades<br>
      make unacceptable tradeoffs. Common criticisms of soft fork changes
      include:<br>
      Technical debt<br>
      Because soft forks are more technically complex than a hard fork upgrade,
      they<br>
      introduce technical debt, a term that refers to increasing the future cost
      of code<br>
      maintenance because of design tradeoffs made in the past. Code complexity
      in<br>
      turn increases the likelihood of bugs and security vulnerabilities.</p>
    <h3> Validation relaxation</h3>
    <p> Unmodified clients see transactions as valid, without evaluating the
      modified<br>
      consensus rules. In effect, the unmodified clients are not validating
      using the full<br>
      range of consensus rules, as they are blind to the new rules. This applies
      to NOP-<br>
      based upgrades, as well as other soft fork upgrades.<br>
      Irreversible upgrades<br>
      Because soft forks create transactions with additional consensus
      constraints, they<br>
      become irreversible upgrades in practice. If a soft fork upgrade were to
      be<br>
      reversed after being activated, any transactions created under the new
      rules could<br>
      result in a loss of funds under the old rules. For example, if a CLTV
      transaction is<br>
      evaluated under the old rules, there is no timelock constraint and it can
      be spent<br>
      whenever. Therefore, critics contend that a failed soft fork that had to
      be reversed<br>
      because of a bug would almost certainly lead to loss of funds.<br>
      Soft Fork Signaling with Block Version<br>
      Since soft forks allow unmodified clients to continue to operate within
      consensus, the<br>
      mechanism for “activating” a soft fork is through miners signaling
      readiness: a majority of miners must agree that they are ready and willing
      to enforce the new consensus<br>
      rules. To coordinate their actions, there is a signaling mechanism that
      allows them to<br>
      show their support for a consensus rule change. This mechanism was
      introduced<br>
      with the activation of BIP-34 in March 2013 and replaced by the activation
      of BIP-9<br>
      in July 2016.</p>
    <h3> BIP-34 Signaling and Activation</h3>
    <p> The first implementation, in BIP-34, used the block version field to
      allow miners to<br>
      signal readiness for a specific consensus rule change. Prior to BIP-34,
      the block ver‐<br>
      sion was set to “1” by convention not enforced by consensus.<br>
      BIP-34 defined a consensus rule change that required the coinbase field
      (input) of the<br>
      coinbase transaction to contain the block height. Prior to BIP-34, the
      coinbase could<br>
      contain any arbitrary data the miners chose to include. After activation
      of BIP-34,<br>
      valid blocks had to contain a specific block-height at the beginning of
      the coinbase<br>
      and be identified with a version number greater than or equal to “2.”<br>
      To signal the change and activation of BIP-34, miners set the block
      version to “2,”<br>
      instead of “1.” This did not immediately make version “1” blocks invalid.
      Once activa‐<br>
      ted, version “1” blocks would become invalid and all version “2” blocks
      would be<br>
      required to contain the block height in the coinbase to be valid.<br>
      BIP-34 defined a two-step activation mechanism, based on a rolling window
      of 1000<br>
      blocks. A miner would signal his or her individual readiness for BIP-34 by
      construct‐<br>
      ing blocks with “2” as the version number. Strictly speaking, these blocks
      did not yet<br>
      have to comply with the new consensus rule of including the block-height
      in the<br>
      coinbase transaction because the consensus rule had not yet been
      activated. The con‐<br>
      sensus rules activated in two steps:<br>
      • If 75% (750 of the most recent 1000 blocks) are marked with version “2,”
      then<br>
      version “2” blocks must contain block height in the coinbase transaction
      or they<br>
      are rejected as invalid. Version “1” blocks are still accepted by the
      network and<br>
      do not need to contain block-height. The old and new consensus rules
      coexist<br>
      during this period.<br>
      • When 95% (950 of the most recent 1000 blocks) are version “2,” version
      “1”<br>
      blocks are no longer considered valid. Version “2” blocks are valid only
      if they<br>
      contain the block-height in the coinbase (as per the previous threshold).
      There‐<br>
      after, all blocks must comply with the new consensus rules, and all valid
      blocks<br>
      must contain block-height in the coinbase transaction.<br>
      After successful signaling and activation under the BIP-34 rules, this
      mechanism was<br>
      used twice more to activate soft forks:<br>
      <br>
      • BIP-66 Strict DER Encoding of Signatures was activated by BIP-34 style
      signaling<br>
      with a block version “3” and invalidating version “2” blocks.<br>
      • BIP-65 CHECKLOCKTIMEVERIFY was activated by BIP-34 style signaling with
      a<br>
      block version “4” and invalidating version “3” blocks.<br>
      After the activation of BIP-65, the signaling and activation mechanism of
      BIP-34 was<br>
      retired and replaced with the BIP-9 signaling mechanism described next.<br>
      The standard is defined in BIP-34 (Block v2, Height in Coinbase).<br>
      BIP-9 Signaling and Activation<br>
      The mechanism used by BIP-34, BIP-66, and BIP-65 was successful in
      activating three<br>
      soft forks. However, it was replaced because it had several limitations:<br>
      • By using the integer value of the block version, only one soft fork
      could be activa‐<br>
      ted at a time, so it required coordination between soft fork proposals and
      agree‐<br>
      ment on their prioritization and sequencing.<br>
      • Furthermore, because the block version was incremented, the mechanism
      didn’t<br>
      offer a straightforward way to reject a change and then propose a
      different one. If<br>
      old clients were still running, they could mistake signaling for a new
      change as<br>
      signaling for the previously rejected change.<br>
      • Each new change irrevocably reduced the available block versions for
      future<br>
      changes.<br>
      BIP-9 was proposed to overcome these challenges and improve the rate and
      ease of<br>
      implementing future changes.<br>
      BIP-9 interprets the block version as a bit field instead of an integer.
      Because the<br>
      block version was originally used as an integer, versions 1 through 4,
      only 29 bits<br>
      remain available to be used as a bit field. This leaves 29 bits that can
      be used to inde‐<br>
      pendently and simultaneously signal readiness on 29 different proposals.<br>
      BIP-9 also sets a maximum time for signaling and activation. This way
      miners don’t<br>
      need to signal forever. If a proposal is not activated within the TIMEOUT
      period<br>
      (defined in the proposal), the proposal is considered rejected. The
      proposal may be<br>
      resubmitted for signaling with a different bit, renewing the activation
      period.<br>
      Furthermore, after the TIMEOUT has passed and a feature has been activated
      or rejec‐<br>
      ted, the signaling bit can be reused for another feature without
      confusion. Therefore,<br>
      up to 29 changes can be signaled in parallel and after TIMEOUT the bits
      can be “recy‐<br>
      cled” to propose new changes.<br>
      <br>
      stable state of this system with only a few changes possible if there is
      strong consen‐<br>
      sus by a very large majority. The 95% threshold for soft forks is
      reflective of this real‐<br>
      ity.<br>
      It is important to recognize that there is no perfect solution for
      consensus develop‐<br>
      ment. Both hard forks and soft forks involve tradeoffs. For some types of
      changes,<br>
      soft forks may be a better choice; for others, hard forks may be a better
      choice. There<br>
      is no perfect choice; both carry risks. The one constant characteristic of
      consensus<br>
      software development is that change is difficult and consensus forces
      compromise.<br>
      Some see this as a weakness of consensus systems. In time, you may come to
      see it as<br>
      I do, as the system’s greatest strength.<br>
      <br>
      without vulnerabilities should be vulnerable only to a compromise of the
      bitcoin con‐<br>
      sensus mechanism, meaning that its root of trust is based on the strongest
      part of the<br>
      bitcoin security architecture.<br>
      The numerous examples of hacked bitcoin exchanges serve to underscore this
      point<br>
      because their security architecture and design fails even under the most
      casual scru‐<br>
      tiny. These centralized implementations had invested trust explicitly in
      numerous<br>
      components outside the bitcoin blockchain, such as hot wallets,
      centralized ledger<br>
      databases, vulnerable encryption keys, and similar schemes.<br>
      User Security Best Practices<br>
      Humans have used physical security controls for thousands of years. By
      comparison,<br>
      our experience with digital security is less than 50 years old. Modern
      general-purpose<br>
      operating systems are not very secure and not particularly suited to
      storing digital<br>
      money. Our computers are constantly exposed to external threats via
      always-on inter‐<br>
      net connections. They run thousands of software components from hundreds
      of<br>
      authors, often with unconstrained access to the user’s files. A single
      piece of rogue<br>
      software, among the many thousands installed on your computer, can
      compromise<br>
      your keyboard and files, stealing any bitcoin stored in wallet
      applications. The level of<br>
      computer maintenance required to keep a computer virus-free and
      trojan-free is<br>
      beyond the skill level of all but a tiny minority of computer users.<br>
      Despite decades of research and advancements in information security,
      digital assets<br>
      are still woefully vulnerable to a determined adversary. Even the most
      highly pro‐<br>
      tected and restricted systems, in financial services companies,
      intelligence agencies,<br>
      and defense contractors, are frequently breached. Bitcoin creates digital
      assets that<br>
      have intrinsic value and can be stolen and diverted to new owners
      instantly and irrev‐<br>
      ocably. This creates a massive incentive for hackers. Until now, hackers
      had to convert<br>
      identity information or account tokens—such as credit cards and bank
      accounts—<br>
      into value after compromising them. Despite the difficulty of fencing and
      laundering<br>
      financial information, we have seen ever-escalating thefts. Bitcoin
      escalates this prob‐<br>
      lem because it doesn’t need to be fenced or laundered; it is intrinsic
      value within a<br>
      digital asset.<br>
      Fortunately, bitcoin also creates the incentives to improve computer
      security.<br>
      Whereas previously the risk of computer compromise was vague and indirect,
      bitcoin<br>
      makes these risks clear and obvious. Holding bitcoin on a computer serves
      to focus<br>
      the user’s mind on the need for improved computer security. As a direct
      result of the<br>
      proliferation and increased adoption of bitcoin and other digital
      currencies, we have<br>
      seen an escalation in both hacking techniques and security solutions. In
      simple terms,<br>
      hackers now have a very juicy target and users have a clear incentive to
      defend them‐<br>
      selves.<br>
    </p>
    <p>CHAPTER 12<br>
      Applications<br>
      Let’s now build on our understanding of bitcoin by looking at it as an
      application plat‐<br>
      form. Nowadays, many people use the term “blockchain” to refer to any
      application<br>
      platform that shares the design principles of bitcoin. The term is often
      misused and<br>
      applied to many things that fail to deliver the primary features that
      bitcoin’s block‐<br>
      chain delivers.<br>
      In this chapter we will look at the features offered by the bitcoin
      blockchain, as an<br>
      application platform. We will consider the application building
      primitives, which<br>
      form the building blocks of any blockchain application. We will look at
      several impor‐<br>
      tant applications that use these primitives, such as colored coins,
      payment (state)<br>
      channels, and routed payment channels (Lightning Network).<br>
      Introduction<br>
      The bitcoin system was designed as a decentralized currency and payment
      system.<br>
      However, most of its functionality is derived from much lower-level
      constructs that<br>
      can be used for much broader applications. Bitcoin wasn’t built with
      components<br>
      such as accounts, users, balances, and payments. Instead, it uses a
      transactional<br>
      scripting language with low-level cryptographic functions, as we saw in
      Chapter 6.<br>
      Just like the higher-level concepts of accounts, balances, and payments
      can be derived<br>
      from these basic primitives, so can many other complex applications. Thus,
      the bit‐<br>
      coin blockchain can become an application platform offering trust services
      to appli‐<br>
      cations, such as smart contracts, far surpassing the original purpose of
      digital<br>
      currency and payments.<br>
      275<br>
      Predictable Issuance<br>
      Less than 21 million bitcoin will be issued, at a predictable rate.<br>
      The list of building blocks is not complete and more are added with each
      new feature<br>
      introduced into bitcoin.<br>
      Applications from Building Blocks<br>
      The building blocks offered by bitcoin are elements of a trust platform
      that can be<br>
      used to compose applications. Here are some examples of applications that
      exist<br>
      today and the building blocks they use:<br>
      Proof-of-Existence (Digital Notary)<br>
      Immutability + Timestamp + Durability. A digital fingerprint can be
      committed<br>
      with a transaction to the blockchain, proving that a document existed
      (Time‐<br>
      stamp) at the time it was recorded. The fingerprint cannot be modified
      ex-post-<br>
      facto (Immutability) and the proof will be stored permanently
      (Durability).<br>
      Kickstarter (Lighthouse)<br>
      Consistency + Atomicity + Integrity. If you sign one input and the output
      (Integ‐<br>
      rity) of a fundraiser transaction, others can contribute to the fundraiser
      but it<br>
      cannot be spent (Atomicity) until the goal (output value) is funded
      (Consis‐<br>
      tency).<br>
      Payment Channels<br>
      Quorum of Control + Timelock + No Double Spend + Nonexpiration + Censor‐<br>
      ship Resistance + Authorization. A multisig 2-of-2 (Quorum) with a
      timelock<br>
      (Timelock) used as the “settlement” transaction of a payment channel can
      be held<br>
      (Nonexpiration) and spent whenever (Censorship Resistance) by either party<br>
      (Authorization). The two parties can then create commitment transactions
      that<br>
      double-spend (No Double-Spend) the settlement on a shorter timelock (Time‐<br>
      lock).<br>
      Colored Coins<br>
      The first blockchain application we will discuss is colored coins.<br>
      Colored coins refers to a set of similar technologies that use bitcoin
      transactions to<br>
      record the creation, ownership, and transfer of extrinsic assets other
      than bitcoin. By<br>
      “extrinsic” we mean assets that are not stored directly on the bitcoin
      blockchain, as<br>
      opposed to bitcoin itself, which is an asset intrinsic to the blockchain.<br>
      Colored coins are used to track digital assets as well as physical assets
      held by third<br>
      parties and traded through colored coins certificates of ownership.
      Digital asset col‐<br>
      ored coins can represent intangible assets such as a stock certificate,
      license, virtual<br>
      278<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      property (game items), or most any form of licensed intellectual property
      (trade‐<br>
      marks, copyrights, etc.). Tangible asset colored coins can represent
      certificates of<br>
      ownership of commodities (gold, silver, oil), land title, automobiles,
      boats, aircraft,<br>
      etc.<br>
      The term derives from the idea of “coloring” or marking a nominal amount
      of bit‐<br>
      coin, for example, a single satoshi, to represent something other than the
      bitcoin<br>
      value itself. As an analogy, consider stamping a $1 note with a message
      saying, “this is<br>
      a stock certificate of ACME” or “this note can be redeemed for 1 oz of
      silver” and<br>
      then trading the $1 note as a certificate of ownership of this other
      asset. The first<br>
      implementation of colored coins, named Enhanced Padded-Order-Based
      Coloring or<br>
      EPOBC, assigned extrinsic assets to a 1-satoshi output. In this way, it
      was a true “col‐<br>
      ored coin,” as each asset was added as an attribute (color) of a single
      satoshi.<br>
      More recent implementations of colored coins use the OP_RETURN script
      opcode to<br>
      store metadata in a transaction, in conjunction with external data stores
      that associate<br>
      the metadata to specific assets.<br>
      The two most prominent implementations of colored coins today are Open
      Assets and<br>
      Colored Coins by Colu. These two systems use different approaches to
      colored coins<br>
      and are not compatible. Colored coins created in one system cannot be seen
      or used<br>
      in the other system.<br>
      Using Colored Coins<br>
      Colored coins are created, transferred, and generally viewed in special
      wallets that<br>
      can interpret the colored coins protocol metadata attached to bitcoin
      transactions.<br>
      Special care must be taken to avoid using a colored-coin–related key in a
      regular bit‐<br>
      coin wallet, as the regular wallet may destroy the metadata. Similarly,
      colored coins<br>
      should not be sent to addresses managed by regular wallets, but only to
      addresses that<br>
      are managed by wallets that are colored-coin-aware. Both Colu and Open
      Assets sys‐<br>
      tems use special colored-coin addresses to mitigate this risk and to
      ensure that col‐<br>
      ored coins are not sent to unaware wallets.<br>
      Colored coins are also not visible to most general-purpose blockchain
      explorers.<br>
      Instead, you must use a colored-coins explorer to interpret the metadata
      of a colored<br>
      coins transaction.<br>
      An Open Assets-compatible wallet application and blockchain explorer can
      be found<br>
      at coinprism.<br>
      A Colu Colored Coins-compatible wallet application and blockchain explorer
      can be<br>
      found at Blockchain Explorer.<br>
      A Copay wallet plug-in can be found at Colored Coins Copay Addon.<br>
      Colored Coins<br>
      &nbsp;|<br>
      &nbsp;279<br>
      Issuing Colored Coins<br>
      Each of the colored coins implementations has a different way of creating
      colored<br>
      coins, but they all provide similar functionality. The process of creating
      a colored<br>
      coin asset is called issuance. An initial transaction, the issuance
      transaction registers<br>
      the asset on the bitcoin blockchain and creates an asset ID that is used
      to reference<br>
      the asset. Once issued, assets can be transferred between addresses using
      transfer<br>
      transactions.<br>
      Assets issued as colored coins can have multiple properties. They can be
      divisible or<br>
      indivisible, meaning that the amount of asset in a transfer can be an
      integer (e.g., 5) or<br>
      have decimal subdivision (e.g., 4.321). Assets can also have fixed
      issuance, meaning a<br>
      certain amount are issued only once, or can be reissued, meaning that new
      units of<br>
      the asset can be issued by the original issuer after the initial issuance.<br>
      Finally, some colored coins enable dividends, allowing the distribution of
      bitcoin pay‐<br>
      ments to the owners of a colored coin asset in proportion to their
      ownership.<br>
      Colored Coins Transactions<br>
      The metadata that gives meaning to a colored coin transaction is usually
      stored in<br>
      one of the outputs using the OP_RETURN opcode. Different colored coins
      protocols use<br>
      different encodings for the content of the OP_RETURN data. The output
      containing the<br>
      OP_RETURN is called the marker output.<br>
      The order of the outputs and position of the marker output may have
      special mean‐<br>
      ing in the colored coins protocol. In Open Assets, for example, any
      outputs before the<br>
      marker output represent asset issuance. Any outputs after the marker
      represent asset<br>
      transfer. The marker output assigns specific values and colors to the
      other outputs by<br>
      referencing their order in the transaction.<br>
      In Colored Coins (Colu), by comparison, the marker output encodes an
      opcode that<br>
      determines how the metadata is interpreted. Opcodes 0x01 through 0x0F
      indicate an<br>
      issuance transaction. An issuance opcode is usually followed by an asset
      ID or other<br>
      identifier that can be used to retrieve the asset information from an
      external source<br>
      (e.g., bittorrent). Opcodes 0x10 through 0x1F represent a transfer
      transaction. Trans‐<br>
      fer transaction metadata contain simple scripts that transfer specific
      amounts of<br>
      assets from inputs to outputs, by reference to their index. Ordering of
      inputs and out‐<br>
      puts is therefore important in the interpretation of the script.<br>
      If the metadata is too long to fit in OP_RETURN, the colored coins
      protocol may use<br>
      other “tricks” to store metadata in a transaction. Examples include
      putting metadata<br>
      in a redeem script, followed by OP_DROP opcodes to ensure the script
      ignores the<br>
      metadata. Another mechanism used is a 1-of-N multisig script where only
      the first<br>
      280<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      public key is a real public key that can spend the output and subsequent
      “keys” are<br>
      replaced by encoded metadata.<br>
      In order to correctly interpret the metadata in a colored coins
      transaction you must<br>
      use a compatible wallet or block explorer. Otherwise, the transaction
      looks like a<br>
      “normal” bitcoin transaction with an OP_RETURN output.<br>
      As an example, I created and issued a MasterBTC asset using colored coins.
      The Mas‐<br>
      terBTC asset represents a voucher for a free copy of this book. These
      vouchers can be<br>
      transferred, traded, and redeemed using a colored coins-compatible wallet.<br>
      For this particular example, I used the wallet and explorer at
      https://coinprism.info,<br>
      which uses the Open Assets colored coins protocol.<br>
      Малюнок&nbsp; 12-1 shows the issuance transaction using the Coinprism
      block explorer:<br>
      https://www.coinprism.info/tx/<br>
      10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec)<br>
      Малюнок&nbsp; 12-1. The issuance transaction as viewed on coinprism.info<br>
      As you can see, coinprism shows the issuance of 20 units of “Free copy of
      Mastering<br>
      Bitcoin,” the MasterBTC asset, to a special colored coin address:<br>
      akTnsDt5uzpioRST76VFRQM8q8sBFnQiwcx<br>
      Any funds or colored assets sent to this address will be lost forever.<br>
      Do not send value to this example address!<br>
      Colored Coins<br>
      &nbsp;|<br>
      &nbsp;281<br>
      The transaction ID of the issuance transaction is a “normal” bitcoin
      transaction ID.<br>
      Малюнок&nbsp; 12-2 shows that same transaction in a block explorer that
      doesn’t decode col‐<br>
      ored coins. We’ll use blockchain.info:<br>
      https://blockchain.info/tx/<br>
      10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec<br>
      Малюнок&nbsp; 12-2. The issuance transaction on a block explorer that
      doesn’t decode colored<br>
      coins<br>
      As you can see, blockchain.info doesn’t recognize this as a colored coins
      transaction.<br>
      In fact, it marks the second output with “Unable to decode output address”
      in red let‐<br>
      ters.<br>
      If you select “Show scripts &amp; coinbase” on that screen, you can see
      more detail about<br>
      the transaction (Малюнок&nbsp; 12-3).<br>
      Малюнок&nbsp; 12-3. The scripts in the issuance transaction<br>
      Once again, blockchain.info doesn’t understand the second output. It marks
      it with<br>
      “Strange” in red letters. However, we can see that some of the metadata in
      the marker<br>
      output is human-readable:<br>
      OP_RETURN
      4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559<br>
      (decoded) "OA____u=https://cpr.sm/FoykwrH6UY<br>
      Let’s retrieve the transaction using bitcoin-cli:<br>
      $ bitcoin-cli decoderawtransaction `bitcoin-cli getrawtransaction<br>
      10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec`<br>
      Stripping out the rest of the transaction, the second output looks like
      this:<br>
      282<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      {<br>
      "value": 0.00000000,<br>
      "n": 1,<br>
      "scriptPubKey": "OP_RETURN<br>
      4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559"<br>
      }<br>
      The prefix 4F41 represents the letters “OA”, which stands for “Open
      Assets” and helps<br>
      us identify that what follows is metadata defined by the Open Assets
      protocol. The<br>
      ASCII-encoded string that follows is a link to an asset definition:<br>
      u=https://cpr.sm/FoykwrH6UY<br>
      If we retrieve this URL, we get a JSON-encoded asset definition, as shown
      here:<br>
      {<br>
      "asset_ids": [<br>
      "AcuRVsoa81hoLHmVTNXrRD8KpTqUXeqwgH"<br>
      ],<br>
      "contract_url": null,<br>
      "name_short": "MasterBTC",<br>
      "name": "Free copy of \"Mastering Bitcoin\"",<br>
      "issuer": "Andreas M. Antonopoulos",<br>
      "description": "This token is redeemable for a free copy of the book
      \"Master<br>
      ing Bitcoin\"",<br>
      "description_mime": "text/x-markdown; charset=UTF-8",<br>
      "type": "Other",<br>
      "divisibility": 0,<br>
      "link_to_website": false,<br>
      "icon_url": null,<br>
      "image_url": null,<br>
      "version": "1.0"<br>
      }<br>
      Counterparty<br>
      Counterparty is a protocol layer built on top of bitcoin. The Counterparty
      protocol,<br>
      similar to colored coins, offers the ability to create and trade virtual
      assets and tokens.<br>
      In addition, Counterparty offers a decentralized exchange for assets.
      Counterparty is<br>
      also implementing smart contracts, based on the Ethereum Virtual Machine
      (EVM).<br>
      Like the colored coins protocols, Counterparty embeds metadata in bitcoin
      transac‐<br>
      tions, using the OP_RETURN opcode or 1-of-N multisignature addresses that
      encode<br>
      metadata in the place of public keys. Using these mechanisms, Counterparty
      imple‐<br>
      ments a protocol layer encoded in bitcoin transactions. The additional
      protocol layer<br>
      can be interpreted by applications that are Counterparty-aware, such as
      wallets and<br>
      blockchain explorers, or any application built using the Counterparty
      libraries.<br>
      Counterparty<br>
      &nbsp;|<br>
      &nbsp;283<br>
      Counterparty can be used as a platform for other applications and
      services, in turn.<br>
      For example, Tokenly is a platform built on top of Counterparty that
      allows content<br>
      creators, artists, and companies to issue tokens that express digital
      ownership and can<br>
      be used to rent, access, trade, or shop for content, products, and
      services. Other appli‐<br>
      cations leveraging Counterparty include games (Spells of Genesis) and grid
      comput‐<br>
      ing projects (Folding Coin).<br>
      More details about Counterparty can be found at https://counterparty.io.
      The open<br>
      source project can be found at https://github.com/CounterpartyXCP.<br>
      Payment Channels and State Channels<br>
      Payment channels are a trustless mechanism for exchanging bitcoin
      transactions<br>
      between two parties, outside of the bitcoin blockchain. These
      transactions, which<br>
      would be valid if settled on the bitcoin blockchain, are held off-chain
      instead, acting<br>
      as promissory notes for eventual batch settlement. Because the
      transactions are not<br>
      settled, they can be exchanged without the usual settlement latency,
      allowing<br>
      extremely high transaction throughput, low (submillisecond) latency, and
      fine<br>
      (satoshi-level) granularity.<br>
      Actually, the term channel is a metaphor. State channels are virtual
      constructs repre‐<br>
      sented by the exchange of state between two parties, outside of the
      blockchain. There<br>
      are no “channels” per se and the underlying data transport mechanism is
      not the<br>
      channel. We use the term channel to represent the relationship and shared
      state<br>
      between two parties, outside of the blockchain.<br>
      To further explain this concept, think of a TCP stream. From the
      perspective of<br>
      higher-level protocols it is a “socket” connecting two applications across
      the internet.<br>
      But if you look at the network traffic, a TCP stream is just a virtual
      channel over IP<br>
      packets. Each endpoint of the TCP stream sequences and assembles IP
      packets to cre‐<br>
      ate the illusion of a stream of bytes. Underneath, it’s all disconnected
      packets. Simi‐<br>
      larly, a payment channel is just a series of transactions. If properly
      sequenced and<br>
      connected, they create redeemable obligations that you can trust even
      though you<br>
      don’t trust the other side of the channel.<br>
      In this section we will look at various forms of payment channels. First,
      we will exam‐<br>
      ine the mechanisms used to construct a one-way (unidirectional) payment
      channel<br>
      for a metered micropayment service, such as streaming video. Then, we will
      expand<br>
      on this mechanism and introduce bidirectional payment channels. Finally,
      we will<br>
      look at how bidirectional channels can be connected end-to-end to form
      multihop<br>
      channels in a routed network, first proposed under the name Lightning
      Network.<br>
      Payment channels are part of the broader concept of a state channel, which
      represents<br>
      an off-chain alteration of state, secured by eventual settlement in a
      blockchain. A pay‐<br>
      284<br>
      &nbsp;| Chapter 12: Blockchain Applications<br>
      ment channel is a state channel where the state being altered is the
      balance of a virtual<br>
      currency.<br>
      State Channels—Basic Concepts and Terminology<br>
      A state channel is established between two parties, through a transaction
      that locks a<br>
      shared state on the blockchain. This is called the funding transaction or
      anchor trans‐<br>
      action. This single transaction must be transmitted to the network and
      mined to<br>
      establish the channel. In the example of a payment channel, the locked
      state is the<br>
      initial balance (in currency) of the channel.<br>
      The two parties then exchange signed transactions, called commitment
      transactions,<br>
      that alter the initial state. These transactions are valid transactions in
      that they could<br>
      be submitted for settlement by either party, but instead are held
      off-chain by each<br>
      party pending the channel closure. State updates can be created as fast as
      each party<br>
      can create, sign, and transmit a transaction to the other party. In
      practice this means<br>
      that thousands of transactions per second can be exchanged.<br>
      When exchanging commitment transactions the two parties also invalidate
      the previ‐<br>
      ous states, so that the most up-to-date commitment transaction is always
      the only one<br>
      that can be redeemed. This prevents either party from cheating by
      unilaterally closing<br>
      the channel with an expired prior state that is more favorable to them
      than the cur‐<br>
      rent state. We will examine the various mechanisms that can be used to
      invalidate<br>
      prior state in the rest of this chapter.<br>
      Finally, the channel can be closed either cooperatively, by submitting a
      final settle‐<br>
      ment transaction to the blockchain, or unilaterally, by either party
      submitting the last<br>
      commitment transaction to the blockchain. A unilateral close option is
      needed in<br>
      case one of the parties unexpectedly disconnects. The settlement
      transaction repre‐<br>
      sents the final state of the channel and is settled on the blockchain.<br>
      In the entire lifetime of the channel, only two transactions need to be
      submitted for<br>
      mining on the blockchain: the funding and settlement transactions. In
      between these<br>
      two states, the two parties can exchange any number of commitment
      transactions<br>
      that are never seen by anyone else, nor submitted to the blockchain.<br>
      Малюнок&nbsp; 12-4 illustrates a payment channel between Bob and Alice,
      showing the fund‐<br>
      ing, commitment, and settlement transactions.<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;285<br>
      Малюнок&nbsp; 12-4. A payment channel between Bob and Alice, showing the
      funding, commit‐<br>
      ment, and settlement transactions<br>
      Simple Payment Channel Example<br>
      To explain state channels, we have to start with a very simple example. We
      demon‐<br>
      strate a one-way channel, meaning that value is flowing in one direction
      only. We will<br>
      also start with the naive assumption that no one is trying to cheat, to
      keep things sim‐<br>
      ple. Once we have the basic channel idea explained, we will then look at
      what it takes<br>
      to make it trustless so that neither party can cheat, even if they are
      trying to.<br>
      286<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      For this example we will assume two participants: Emma and Fabian. Fabian
      offers a<br>
      video streaming service that is billed by the second using a micropayment
      channel.<br>
      Fabian charges 0.01 millibit (0.00001 BTC) per second of video, equivalent
      to 36 mil‐<br>
      libits (0.036 BTC) per hour of video. Emma is a user who purchases this
      streaming<br>
      video service from Fabian. Малюнок&nbsp; 12-5 shows Emma buying the video
      streaming ser‐<br>
      vice from Fabian using a payment channel.<br>
      Малюнок&nbsp; 12-5. Emma purchases streaming video from Fabian with a
      payment channel,<br>
      paying for each second of video<br>
      In this example, Fabian and Emma are using special software that handles
      both the<br>
      payment channel and the video streaming. Emma is running the software in
      her<br>
      browser, Fabian is running it on a server. The software includes basic
      bitcoin wallet<br>
      functionality and can create and sign bitcoin transactions. Both the
      concept and the<br>
      term “payment channel” are completely hidden from the users. What they see
      is video<br>
      that is paid for by the second.<br>
      To set up the payment channel, Emma and Fabian establish a 2-of-2
      multisignature<br>
      address, with each of them holding one of the keys. From Emma’s
      perspective, the<br>
      software in her browser presents a QR code with a P2SH address (starting
      with “3”),<br>
      and asks her to submit a “deposit” for up to 1 hour of video. The address
      is then fun‐<br>
      ded by Emma. Emma’s transaction, paying to the multisignature address, is
      the fund‐<br>
      ing or anchor transaction for the payment channel.<br>
      For this example, let’s say that Emma funds the channel with 36 millibits
      (0.036 BTC).<br>
      This will allow Emma to consume up to 1 hour of streaming video. The
      funding<br>
      transaction in this case sets the maximum amount that can be transmitted
      in this<br>
      channel, setting the channel capacity.<br>
      The funding transaction consumes one or more inputs from Emma’s wallet,
      sourcing<br>
      the funds. It creates one output with a value of 36 millibits paid to the
      multisignature<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;287<br>
      2-of-2 address controlled jointly between Emma and Fabian. It may have
      additional<br>
      outputs for change back to Emma’s wallet.<br>
      Once the funding transaction is confirmed, Emma can start streaming video.
      Emma’s<br>
      software creates and signs a commitment transaction that changes the
      channel bal‐<br>
      ance to credit 0.01 millibit to Fabian’s address and refund 35.99
      millibits back to<br>
      Emma. The transaction signed by Emma consumes the 36 millibits output
      created by<br>
      the funding transaction and creates two outputs: one for her refund, the
      other for<br>
      Fabian’s payment. The transaction is only partially signed—it requires two
      signatures<br>
      (2-of-2), but only has Emma’s signature. When Fabian’s server receives
      this transac‐<br>
      tion, it adds the second signature (for the 2-of-2 input) and returns it
      to Emma<br>
      together with 1 second worth of video. Now both parties have a fully
      signed commit‐<br>
      ment transaction that either can redeem, representing the correct
      up-to-date balance<br>
      of the channel. Neither party broadcasts this transaction to the network.<br>
      In the next round, Emma’s software creates and signs another commitment
      transac‐<br>
      tion (commitment #2) that consumes the same 2-of-2 output from the funding
      trans‐<br>
      action. The second commitment transaction allocates one output of 0.2
      millibits to<br>
      Fabian’s address and one output of 35.98 millibits back to Emma’s address.
      This new<br>
      transaction is payment for two cumulative seconds of video. Fabian’s
      software signs<br>
      and returns the second commitment transaction, together with the another
      second of<br>
      video.<br>
      In this way, Emma’s software continues to send commitment transactions to
      Fabian’s<br>
      server in exchange for streaming video. The balance of the channel
      gradually accu‐<br>
      mulates in favor of Fabian, as Emma consumes more seconds of video. Let’s
      say<br>
      Emma watches 600 seconds (10 minutes) of video, creating and signing 600
      commit‐<br>
      ment transactions. The last commitment transaction (#600) will have two
      outputs,<br>
      splitting the balance of the channel, 6 millibits to Fabian and 30
      millibits to Emma.<br>
      Finally, Emma clicks “Stop” to stop streaming video. Either Fabian or Emma
      can now<br>
      transmit the final state transaction for settlement. This last transaction
      is the settle‐<br>
      ment transaction and pays Fabian for all the video Emma consumed,
      refunding the<br>
      remainder of the funding transaction to Emma.<br>
      Малюнок&nbsp; 12-6 shows the channel between Emma and Fabian and the
      commitment<br>
      transactions that update the balance of the channel.<br>
      In the end, only two transactions are recorded on the blockchain: the
      funding trans‐<br>
      action that established the channel and a settlement transaction that
      allocated the<br>
      final balance correctly between the two participants.<br>
      288<br>
      &nbsp;| Chapter 12: Blockchain Applications<br>
      Малюнок&nbsp; 12-6. Emma’s payment channel with Fabian, showing the
      commitment transac‐<br>
      tions that update the balance of the channel<br>
      Making Trustless Channels<br>
      The channel we just described works, but only if both parties cooperate,
      without any<br>
      failures or attempts to cheat. Let’s look at some of the scenarios that
      break this chan‐<br>
      nel and see what is needed to fix those:<br>
      • Once the funding transaction happens, Emma needs Fabian’s signature to
      get any<br>
      money back. If Fabian disappears, Emma’s funds are locked in a 2-of-2 and
      effec‐<br>
      tively lost. This channel, as constructed, leads to a loss of funds if one
      of the par‐<br>
      ties disconnects before there is at least one commitment transaction
      signed by<br>
      both parties.<br>
      • While the channel is running, Emma can take any of the commitment
      transac‐<br>
      tions Fabian has countersigned and transmit one to the blockchain. Why pay
      for<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;289<br>
      600 seconds of video, if she can transmit commitment transaction #1 and
      only<br>
      pay for 1 second of video? The channel fails because Emma can cheat by
      broad‐<br>
      casting a prior commitment that is in her favor.<br>
      Both of these problems can be solved with timelocks—let’s look at how we
      could use<br>
      transaction-level timelocks (nLocktime).<br>
      Emma cannot risk funding a 2-of-2 multisig unless she has a guaranteed
      refund. To<br>
      solve this problem, Emma constructs the funding and refund transaction at
      the same<br>
      time. She signs the funding transaction but doesn’t transmit it to anyone.
      Emma<br>
      transmits only the refund transaction to Fabian and obtains his signature.<br>
      The refund transaction acts as the first commitment transaction and its
      timelock<br>
      establishes the upper bound for the channel’s life. In this case, Emma
      could set the<br>
      nLocktime to 30 days or 4320 blocks into the future. All subsequent
      commitment<br>
      transactions must have a shorter timelock, so that they can be redeemed
      before the<br>
      refund transaction.<br>
      Now that Emma has a fully signed refund transaction, she can confidently
      transmit<br>
      the signed funding transaction knowing that she can eventually, after the
      timelock<br>
      expires, redeem the refund transaction even if Fabian disappears.<br>
      Every commitment transaction the parties exchange during the life of the
      channel<br>
      will be timelocked into the future. But the delay will be slightly shorter
      for each com‐<br>
      mitment so the most recent commitment can be redeemed before the prior
      commit‐<br>
      ment it invalidates. Because of the nLockTime, neither party can
      successfully<br>
      propagate any of the commitment transactions until their timelock expires.
      If all goes<br>
      well, they will cooperate and close the channel gracefully with a
      settlement transac‐<br>
      tion, making it unnecessary to transmit an intermediate commitment
      transaction. If<br>
      not, the most recent commitment transaction can be propagated to settle
      the account<br>
      and invalidate all prior commitment transactions.<br>
      For example, if commitment transaction #1 is timelocked to 4320 blocks in
      the<br>
      future, then commitment transaction #2 is timelocked to 4319 blocks in the
      future.<br>
      Commitment transaction #600 can be spent 600 blocks before commitment
      transac‐<br>
      tion #1 becomes valid.<br>
      Малюнок&nbsp; 12-7 shows each commitment transaction setting a shorter
      timelock, allowing<br>
      it to be spent before the previous commitments become valid.<br>
      290<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      Малюнок&nbsp; 12-7. Each commitment sets a shorter timelock, allowing it
      to be spent before the<br>
      previous commitments become valid<br>
      Each subsequent commitment transaction must have a shorter timelock so
      that it<br>
      may be broadcast before its predecessors and before the refund
      transaction. The abil‐<br>
      ity to broadcast a commitment earlier ensures it will be able to spend the
      funding<br>
      output and preclude any other commitment transaction from being redeemed
      by<br>
      spending the output. The guarantees offered by the bitcoin blockchain,
      preventing<br>
      double-spends and enforcing timelocks, effectively allow each commitment
      transac‐<br>
      tion to invalidate its predecessors.<br>
      State channels use timelocks to enforce smart contracts across a time
      dimension. In<br>
      this example we saw how the time dimension guarantees that the most recent
      com‐<br>
      mitment transaction becomes valid before any earlier commitments. Thus,
      the most<br>
      recent commitment transaction can be transmitted, spending the inputs and
      invalid‐<br>
      ating prior commitment transactions. The enforcement of smart contracts
      with abso‐<br>
      lute timelocks protects against cheating by one of the parties. This
      implementation<br>
      needs nothing more than absolute transaction-level timelocks (nLocktime).
      Next, we<br>
      will see how script-level timelocks, CHECKLOCKTIMEVERIFY and
      CHECKSEQUENCEVER<br>
      IFY, can be used to construct more flexible, useful, and sophisticated
      state channels.<br>
      The first form of unidirectional payment channel was demonstrated as a
      prototype<br>
      video streaming application in 2015 by an Argentinian team of developers.
      You can<br>
      still see it at streamium.io.<br>
      Timelocks are not the only way to invalidate prior commitment
      transactions. In the<br>
      next sections we will see how a revocation key can be used to achieve the
      same result.<br>
      Timelocks are effective but they have two distinct disadvantages. By
      establishing a<br>
      maximum timelock when the channel is first opened, they limit the lifetime
      of the<br>
      channel. Worse, they force channel implementations to strike a balance
      between<br>
      allowing long-lived channels and forcing one of the participants to wait a
      very long<br>
      time for a refund in case of premature closure. For example, if you allow
      the channel<br>
      to remain open for 30 days, by setting the refund timelock to 30 days, if
      one of the<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;291<br>
      parties disappears immediately the other party must wait 30 days for a
      refund. The<br>
      more distant the endpoint, the more distant the refund.<br>
      The second problem is that since each subsequent commitment transaction
      must<br>
      decrement the timelock, there is an explicit limit on the number of
      commitment<br>
      transactions that can be exchanged between the parties. For example, a
      30-day chan‐<br>
      nel, setting a timelock of 4320 blocks into the future, can only
      accommodate 4320<br>
      intermediate commitment transactions before it must be closed. There is a
      danger in<br>
      setting the timelock commitment transaction interval at 1 block. By
      setting the time‐<br>
      lock interval between commitment transactions to 1 block, a developer is
      creating a<br>
      very high burden for the channel participants who have to be vigilant,
      remain online<br>
      and watching, and be ready to transmit the right commitment transaction at
      anytime.<br>
      Now that we understand how timelocks can be used to invalidate prior
      commitments,<br>
      we can see the difference between closing the channel cooperatively and
      closing it<br>
      unilaterally by broadcasting a commitment transaction. All commitment
      transactions<br>
      are timelocked, therefore broadcasting a commitment transaction will
      always involve<br>
      waiting until the timelock has expired. But if the two parties agree on
      what the final<br>
      balance is and know they both hold commitment transactions that will
      eventually<br>
      make that balance a reality, they can construct a settlement transaction
      without a<br>
      timelock representing that same balance. In a cooperative close, either
      party takes the<br>
      most recent commitment transaction and builds a settlement transaction
      that is iden‐<br>
      tical in every way except that it omits the timelock. Both parties can
      sign this settle‐<br>
      ment transaction knowing there is no way to cheat and get a more favorable
      balance.<br>
      By cooperatively signing and transmitting the settlement transaction they
      can close<br>
      the channel and redeem their balance immediately. Worst case, one of the
      parties can<br>
      be petty, refuse to cooperate, and force the other party to do a
      unilateral close with<br>
      the most recent commitment transaction. But if they do that, they have to
      wait for<br>
      their funds too.<br>
      Asymmetric Revocable Commitments<br>
      A better way to handle the prior commitment states is to explicitly revoke
      them.<br>
      However, this is not easy to achieve. A key characteristic of bitcoin is
      that once a<br>
      transaction is valid, it remains valid and does not expire. The only way
      to cancel a<br>
      transaction is by double-spending its inputs with another transaction
      before it is<br>
      mined. That’s why we used timelocks in the simple payment channel example
      above<br>
      to ensure that more recent commitments could be spent before older
      commitments<br>
      were valid. However, sequencing commitments in time creates a number of
      con‐<br>
      straints that make payment channels difficult to use.<br>
      Even though a transaction cannot be canceled, it can be constructed in
      such a way as<br>
      to make it undesirable to use. The way we do that is by giving each party
      a revocation<br>
      key that can be used to punish the other party if they try to cheat. This
      mechanism for<br>
      292<br>
      &nbsp;| Chapter 12: Blockchain Applications<br>
      revoking prior commitment transactions was first proposed as part of the
      Lightning<br>
      Network.<br>
      To explain revocation keys, we will construct a more complex payment
      channel<br>
      between two exchanges run by Hitesh and Irene. Hitesh and Irene run
      bitcoin<br>
      exchanges in India and the USA, respectively. Customers of Hitesh’s Indian
      exchange<br>
      often send payments to customers of Irene’s USA exchange and vice versa.
      Currently,<br>
      these transactions occur on the bitcoin blockchain, but this means paying
      fees and<br>
      waiting several blocks for confirmations. Setting up a payment channel
      between the<br>
      exchanges will significantly reduce the cost and accelerate the
      transaction flow.<br>
      Hitesh and Irene start the channel by collaboratively constructing a
      funding transac‐<br>
      tion, each funding the channel with 5 bitcoin. The initial balance is 5
      bitcoin for<br>
      Hitesh and 5 bitcoin for Irene. The funding transaction locks the channel
      state in a 2-<br>
      of-2 multisig, just like in the example of a simple channel.<br>
      The funding transaction may have one or more inputs from Hitesh (adding up
      to 5<br>
      bitcoin or more), and one or more inputs from Irene (adding up to 5
      bitcoin or<br>
      more). The inputs have to slightly exceed the channel capacity in order to
      cover the<br>
      transaction fees. The transaction has one output that locks the 10 total
      bitcoin to a 2-<br>
      of-2 multisig address controlled by both Hitesh and Irene. The funding
      transaction<br>
      may also have one or more outputs returning change to Hitesh and Irene if
      their<br>
      inputs exceeded their intended channel contribution. This is a single
      transaction with<br>
      inputs offered and signed by two parties. It has to be constructed in
      collaboration and<br>
      signed by each party before it is transmitted.<br>
      Now, instead of creating a single commitment transaction that both parties
      sign,<br>
      Hitesh and Irene create two different commitment transactions that are
      asymmetric.<br>
      Hitesh has a commitment transaction with two outputs. The first output
      pays Irene<br>
      the 5 bitcoin she is owed immediately. The second output pays Hitesh the 5
      bitcoin he<br>
      is owed, but only after a timelock of 1000 blocks. The transaction outputs
      look like<br>
      this:<br>
      Input: 2-of-2 funding output, signed by Irene<br>
      Output 0 &lt;5 bitcoin&gt;:<br>
      &lt;Irene's Public Key&gt; CHECKSIG<br>
      Output 1:<br>
      &lt;1000 blocks&gt;<br>
      CHECKSEQUENCEVERIFY<br>
      DROP<br>
      &lt;Hitesh's Public Key&gt; CHECKSIG<br>
      Irene has a different commitment transaction with two outputs. The first
      output pays<br>
      Hitesh the 5 bitcoin he is owed immediately. The second output pays Irene
      the 5 bit‐<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;293<br>
      coin she is owed but only after a timelock of 1000 blocks. The commitment
      transac‐<br>
      tion Irene holds (signed by Hitesh) looks like this:<br>
      Input: 2-of-2 funding output, signed by Hitesh<br>
      Output 0 &lt;5 bitcoin&gt;:<br>
      &lt;Hitesh's Public Key&gt; CHECKSIG<br>
      Output 1:<br>
      &lt;1000 blocks&gt;<br>
      CHECKSEQUENCEVERIFY<br>
      DROP<br>
      &lt;Irene's Public Key&gt; CHECKSIG<br>
      This way, each party has a commitment transaction, spending the 2-of-2
      funding out‐<br>
      put. This input is signed by the other party. At any time the party
      holding the transac‐<br>
      tion can also sign (completing the 2-of-2) and broadcast. However, if they
      broadcast<br>
      the commitment transaction, it pays the other party immediately whereas
      they have<br>
      to wait for a short timelock to expire. By imposing a delay on the
      redemption of one<br>
      of the outputs, we put each party at a slight disadvantage when they
      choose to unilat‐<br>
      erally broadcast a commitment transaction. But a time delay alone isn’t
      enough to<br>
      encourage fair conduct.<br>
      Малюнок&nbsp; 12-8 shows two asymmetric commitment transactions, where the
      output pay‐<br>
      ing the holder of the commitment is delayed.<br>
      Малюнок&nbsp; 12-8. Two asymmetric commitment transactions with delayed
      payment for the<br>
      party holding the transaction<br>
      Now we introduce the final element of this scheme: a revocation key that
      allows a<br>
      wronged party to punish a cheater by taking the entire balance of the
      channel.<br>
      294<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      Each of the commitment transactions has a “delayed” output. The redemption
      script<br>
      for that output allows one party to redeem it after 1000 blocks or the
      other party to<br>
      redeem it if they have a revocation key. So when Hitesh creates a
      commitment trans‐<br>
      action for Irene to sign, he makes the second output payable to himself
      after 1000<br>
      blocks, or to whoever can present a revocation key. Hitesh constructs this
      transaction<br>
      and creates a revocation key that he keeps secret. He will only reveal it
      to Irene when<br>
      he is ready to move to a new channel state and wants to revoke this
      commitment. The<br>
      second output’s script looks like this:<br>
      Output 0 &lt;5 bitcoin&gt;:<br>
      &lt;Irene's Public Key&gt; CHECKSIG<br>
      Output 1 &lt;5 bitcoin&gt;:<br>
      IF<br>
      # Revocation penalty output<br>
      &lt;Revocation Public Key&gt;<br>
      ELSE<br>
      &lt;1000 blocks&gt;<br>
      CHECKSEQUENCEVERIFY<br>
      DROP<br>
      &lt;Hitesh's Public Key&gt;<br>
      ENDIF<br>
      CHECKSIG<br>
      Irene can confidently sign this transaction, since if transmitted it will
      immediately<br>
      pay her what she is owed. Hitesh holds the transaction, but knows that if
      he transmits<br>
      it in a unilateral channel closing, he will have to wait 1000 blocks to
      get paid.<br>
      When the channel is advanced to the next state, Hitesh has to revoke this
      commit‐<br>
      ment transaction before Irene agrees to sign the next commitment
      transaction. To do<br>
      that, all he has to do is send the revocation key to Irene. Once Irene has
      the revocation<br>
      key for this commitment, she can sign the next commitment with confidence.
      She<br>
      knows that if Hitesh tries to cheat by publishing the prior commitment,
      she can use<br>
      the revocation key to redeem Hitesh’s delayed output. If Hitesh cheats,
      Irene gets<br>
      BOTH outputs.<br>
      The revocation protocol is bilateral, meaning that in each round, as the
      channel state<br>
      is advanced, the two parties exchange new commitments, exchange revocation
      keys<br>
      for the previous commitment, and sign each other’s commitment
      transactions. As<br>
      they accept a new state, they make the prior state impossible to use, by
      giving each<br>
      other the necessary revocation keys to punish any cheating.<br>
      Let’s look at an example of how it works. One of Irene’s customers wants
      to send 2<br>
      bitcoin to one of Hitesh’s customers. To transmit 2 bitcoin across the
      channel, Hitesh<br>
      and Irene must advance the channel state to reflect the new balance. They
      will com‐<br>
      mit to a new state (state number 2) where the channel’s 10 bitcoin are
      split, 7 bitcoin<br>
      to Hitesh and 3 bitcoin to Irene. To advance the state of the channel,
      they will each<br>
      create new commitment transactions reflecting the new channel balance.<br>
      Payment Channels and State Channels<br>
      &nbsp;|<br>
      &nbsp;295<br>
      As before, these commitment transactions are asymmetric so that the
      commitment<br>
      transaction each party holds forces them to wait if they redeem it.
      Crucially, before<br>
      signing new commitment transactions, they must first exchange revocation
      keys to<br>
      invalidate the prior commitment. In this particular case, Hitesh’s
      interests are aligned<br>
      with the real state of the channel and therefore he has no reason to
      broadcast a prior<br>
      state. However, for Irene, state number 1 leaves her with a higher balance
      than state 2.<br>
      When Irene gives Hitesh the revocation key for her prior commitment
      transaction<br>
      (state number 1) she is effectively revoking her ability to profit from
      regressing the<br>
      channel to a prior state because with the revocation key, Hitesh can
      redeem both out‐<br>
      puts of the prior commitment transaction without delay. Meaning if Irene
      broadcasts<br>
      the prior state, Hitesh can exercise his right to take all of the outputs.<br>
      Importantly, the revocation doesn’t happen automatically. While Hitesh has
      the abil‐<br>
      ity to punish Irene for cheating, he has to watch the blockchain
      diligently for signs of<br>
      cheating. If he sees a prior commitment transaction broadcast, he has 1000
      blocks to<br>
      take action and use the revocation key to thwart Irene’s cheating and
      punish her by<br>
      taking the entire balance, all 10 bitcoin.<br>
      Asymmetric revocable commitments with relative time locks (CSV) are a much
      better<br>
      way to implement payment channels and a very significant innovation in
      this tech‐<br>
      nology. With this construct, the channel can remain open indefinitely and
      can have<br>
      billions of intermediate commitment transactions. In prototype
      implementations of<br>
      Lightning Network, the commitment state is identified by a 48-bit index,
      allowing<br>
      more than 281 trillion (2.8 x 1014) state transitions in any single
      channel!<br>
      Hash Time Lock Contracts (HTLC)<br>
      Payment channels can be further extended with a special type of smart
      contract that<br>
      allows the participants to commit funds to a redeemable secret, with an
      expiration<br>
      time. This feature is called a Hash Time Lock Contract, or HTLC, and is
      used in both<br>
      bidirectional and routed payment channels.<br>
      Let’s first explain the “hash” part of the HTLC. To create an HTLC, the
      intended<br>
      recipient of the payment will first create a secret R. They then calculate
      the hash of<br>
      this secret H:<br>
      H = Hash(R)<br>
      This produces a hash H that can be included in an output’s locking script.
      Whoever<br>
      knows the secret can use it to redeem the output. The secret R is also
      referred to as a<br>
      preimage to the hash function. The preimage is just the data that is used
      as input to a<br>
      hash function.<br>
      The second part of an HTLC is the “time lock” component. If the secret is
      not<br>
      revealed, the payer of the HTLC can get a “refund” after some time. This
      is achieved<br>
      with an absolute time lock using CHECKLOCKTIMEVERIFY.<br>
      296<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      The script implementing an HTLC might look like this:<br>
      IF<br>
      # Payment if you have the secret R<br>
      HASH160 &lt;H&gt; EQUALVERIFY<br>
      ELSE<br>
      # Refund after timeout.<br>
      &lt;locktime&gt; CHECKLOCKTIMEVERIFY DROP<br>
      &lt;Payee Pubic Key&gt; CHECKSIG<br>
      ENDIF<br>
      Anyone who knows the secret R, which when hashed equals to H, can redeem
      this out‐<br>
      put by exercising the first clause of the IF flow.<br>
      If the secret is not revealed and the HTLC claimed, after a certain number
      of blocks<br>
      the payee can claim a refund using the second clause in the IF flow.<br>
      This is a basic implementation of an HTLC. This type of HTLC can be
      redeemed by<br>
      anyone who has the secret R. An HTLC can take many different forms with
      slight var‐<br>
      iations to the script. For example, adding a CHECKSIG operator and a
      public key in the<br>
      first clause restricts redemption of the hash to a named recipient, who
      must also<br>
      know the secret R.<br>
      Routed Payment Channels (Lightning Network)<br>
      The Lightning Network is a proposed routed network of bidirectional
      payment chan‐<br>
      nels connected end-to-end. A network like this can allow any participant
      to route a<br>
      payment from channel to channel without trusting any of the
      intermediaries. The<br>
      Lightning Network was first described by Joseph Poon and Thadeus Dryja in
      Febru‐<br>
      ary 2015, building on the concept of payment channels as proposed and
      elaborated<br>
      upon by many others.<br>
      “Lightning Network” refers to a specific design for a routed payment
      channel net‐<br>
      work, which has now been implemented by at least five different open
      source teams.<br>
      The independent implementations are coordinated by a set of
      interoperability stand‐<br>
      ards described in the Basics of Lightning Technology (BOLT) paper.<br>
      Prototype implementations of the Lightning Network have been released by
      several<br>
      teams. For now, these implementations can only be run on testnet because
      they use<br>
      segwit, which is not activated on the main bitcoin blockchain (mainnet).<br>
      The Lightning Network is one possible way of implementing routed payment
      chan‐<br>
      nels. There are several other designs that aim to achieve similar goals,
      such as Tee‐<br>
      chan and Tumblebit.<br>
      Routed Payment Channels (Lightning Network)<br>
      &nbsp;|<br>
      &nbsp;297<br>
      Basic Lightning Network Example<br>
      Let’s see how this works.<br>
      In this example, we have five participants: Alice, Bob, Carol, Diana, and
      Eric. These<br>
      five participants have opened payment channels with each other, in pairs.
      Alice has a<br>
      payment channel with Bob. Bob is connected to Carol, Carol to Diana, and
      Diana to<br>
      Eric. For simplicity let’s assume each channel is funded with 2 bitcoin by
      each partici‐<br>
      pant, for a total capacity of 4 bitcoin in each channel.<br>
      Малюнок&nbsp; 12-9 shows five participants in a Lightning Network,
      connected by bidirec‐<br>
      tional payment channels that can be linked to make a payment from Alice to
      Eric<br>
      (“Routed Payment Channels (Lightning Network)” on page 297).<br>
      Малюнок&nbsp; 12-9. A series of bidirectional payment channels linked to
      form a Lightning Net‐<br>
      work that can route a payment from Alice to Eric<br>
      Alice wants to pay Eric 1 bitcoin. However, Alice is not connected to Eric
      by a pay‐<br>
      ment channel. Creating a payment channel requires a funding transaction,
      which<br>
      must be committed to the bitcoin blockchain. Alice does not want to open a
      new pay‐<br>
      ment channel and commit more of her funds. Is there a way to pay Eric,
      indirectly?<br>
      Малюнок&nbsp; 12-10 shows the step-by-step process of routing a payment
      from Alice to Eric,<br>
      through a series of HTLC commitments on the payment channels connecting
      the<br>
      participants.<br>
      298<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      Малюнок&nbsp; 12-10. Step-by-step payment routing through a Lightning
      Network<br>
      Alice is running a Lightning Network (LN) node that is keeping track of
      her payment<br>
      channel to Bob and has the ability to discover routes between payment
      channels. Ali‐<br>
      ce’s LN node also has the ability to connect over the internet to Eric’s
      LN node. Eric’s<br>
      LN node creates a secret R using a random number generator. Eric’s node
      does not<br>
      reveal this secret to anyone. Instead, Eric’s node calculates a hash H of
      the secret R and<br>
      transmits this hash to Alice’s node (see Малюнок&nbsp; 12-10 step 1).<br>
      Now Alice’s LN node constructs a route between Alice’s LN node and Eric’s
      LN node.<br>
      The routing algorithm used will be examined in more detail later, but for
      now let’s<br>
      assume that Alice’s node can find an efficient route.<br>
      Alice’s node then constructs an HTLC, payable to the hash H, with a
      10-block refund<br>
      timeout (current block + 10), for an amount of 1.003 bitcoin (see
      Малюнок&nbsp; 12-10 step<br>
      2). The extra 0.003 will be used to compensate the intermediate nodes for
      their partic‐<br>
      ipation in this payment route. Alice offers this HTLC to Bob, deducting
      1.003 bitcoin<br>
      from her channel balance with Bob and committing it to the HTLC. The HTLC
      has<br>
      the following meaning: “Alice is committing 1.003 of her channel balance
      to be paid to<br>
      Bob if Bob knows the secret, or refunded back to Alice’s balance if 10
      blocks elapse.” The<br>
      channel balance between Alice and Bob is now expressed by commitment
      transac‐<br>
      tions with three outputs: 2 bitcoin balance to Bob, 0.997 bitcoin balance
      to Alice,<br>
      Routed Payment Channels (Lightning Network)<br>
      &nbsp;|<br>
      &nbsp;299<br>
      1.003 bitcoin committed in Alice’s HTLC. Alice’s balance is reduced by the
      amount<br>
      committed to the HTLC.<br>
      Bob now has a commitment that if he is able to get the secret R within the
      next 10<br>
      blocks, he can claim the 1.003 locked by Alice. With this commitment in
      hand, Bob’s<br>
      node constructs an HTLC on his payment channel with Carol. Bob’s HTLC
      commits<br>
      1.002 bitcoin to hash H for 9 blocks, which Carol can redeem if she has
      secret R (see<br>
      Малюнок&nbsp; 12-10 step 3). Bob knows that if Carol can claim his HTLC,
      she has to produce<br>
      R. If Bob has R in nine blocks, he can use it to claim Alice’s HTLC to
      him. He also<br>
      makes 0.001 bitcoin for committing his channel balance for nine blocks. If
      Carol is<br>
      unable to claim his HTLC and he is unable to claim Alice’s HTLC,
      everything reverts<br>
      back to the prior channel balances and no one is at a loss. The channel
      balance<br>
      between Bob and Carol is now: 2 to Carol, 0.998 to Bob, 1.002 committed by
      Bob to<br>
      the HTLC.<br>
      Carol now has a commitment that if she gets R within the next nine blocks,
      she can<br>
      claim 1.002 bitcoin locked by Bob. Now she can make an HTLC commitment on
      her<br>
      channel with Diana. She commits an HTLC of 1.001 bitcoin to hash H, for
      eight<br>
      blocks, which Diana can redeem if she has secret R (see Малюнок&nbsp;
      12-10 step 4). From<br>
      Carol’s perspective, if this works she is 0.001 bitcoin better off and if
      it doesn’t she<br>
      loses nothing. Her HTLC to Diana is only viable if R is revealed, at which
      point she<br>
      can claim the HTLC from Bob. The channel balance between Carol and Diana
      is<br>
      now: 2 to Diana, 0.999 to Carol, 1.001 committed by Carol to the HTLC.<br>
      Finally, Diana can offer an HTLC to Eric, committing 1 bitcoin for seven
      blocks to<br>
      hash H (see Малюнок&nbsp; 12-10 step 5). The channel balance between Diana
      and Eric is now:<br>
      2 to Eric, 1 to Diana, 1 committed by Diana to the HTLC.<br>
      However, at this hop in the route, Eric has secret R. He can therefore
      claim the HTLC<br>
      offered by Diana. He sends R to Diana and claims the 1 bitcoin, adding it
      to his chan‐<br>
      nel balance (see Малюнок&nbsp; 12-10 step 6). The channel balance is now:
      1 to Diana, 3 to<br>
      Eric.<br>
      Now, Diana has secret R. Therefore, she can now claim the HTLC from Carol.
      Diana<br>
      transmits R to Carol and adds the 1.001 bitcoin to her channel balance
      (see<br>
      Малюнок&nbsp; 12-10 step 7). Now the channel balance between Carol and
      Diana is: 0.999 to<br>
      Carol, 3.001 to Diana. Diana has “earned” 0.001 for participating in this
      payment<br>
      route.<br>
      Flowing back through the route, the secret R allows each participant to
      claim the out‐<br>
      standing HTLCs. Carol claims 1.002 from Bob, setting the balance on their
      channel<br>
      to: 0.998 to Bob, 3.002 to Carol (see Малюнок&nbsp; 12-10 step 8).
      Finally, Bob claims the<br>
      HTLC from Alice (see Малюнок&nbsp; 12-10 step 9). Their channel balance is
      updated as:<br>
      0.997 to Alice, 3.003 to Bob.<br>
      300<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      Alice has paid Eric 1 bitcoin without opening a channel to Eric. None of
      the inter‐<br>
      mediate parties in the payment route had to trust each other. For the
      short-term com‐<br>
      mitment of their funds in the channel they are able to earn a small fee,
      with the only<br>
      risk being a small delay in refund if the channel was closed or the routed
      payment<br>
      failed.<br>
      Lightning Network Transport and Routing<br>
      All communications between LN nodes are encrypted point-to-point. In
      addition,<br>
      nodes have a long-term public key that they use as an identifier and to
      authenticate<br>
      each other.<br>
      Whenever a node wishes to send a payment to another node, it must first
      construct a<br>
      path through the network by connecting payment channels with sufficient
      capacity.<br>
      Nodes advertise routing information, including what channels they have
      open, how<br>
      much capacity each channel has, and what fees they charge to route
      payments. The<br>
      routing information can be shared in a variety of ways and different
      routing protocols<br>
      are likely to emerge as Lightning Network technology advances. Some
      Lightning Net‐<br>
      work implementations use the IRC protocol as a convenient mechanism for
      nodes to<br>
      announce routing information. Another implementation of route discovery
      uses a<br>
      P2P model where nodes propagate channel announcements to their peers, in a<br>
      “flooding” model, similar to how bitcoin propagates transactions. Future
      plans<br>
      include a proposal called Flare, which is a hybrid routing model with
      local node<br>
      “neighborhoods” and longer-range beacon nodes.<br>
      In our previous example, Alice’s node uses one of these route discovery
      mechanisms<br>
      to find one or more paths connecting her node to Eric’s node. Once Alice’s
      node has<br>
      constructed a path, she will initialize that path through the network, by
      propagating a<br>
      series of encrypted and nested instructions to connect each of the
      adjacent payment<br>
      channels.<br>
      Importantly, this path is only known to Alice’s node. All other
      participants in the pay‐<br>
      ment route see only the adjacent nodes. From Carol’s perspective, this
      looks like a<br>
      payment from Bob to Diana. Carol does not know that Bob is actually
      relaying a pay‐<br>
      ment from Alice. She also doesn’t know that Diana will be relaying a
      payment to Eric.<br>
      This is a critical feature of the Lightning Network, because it ensures
      privacy of pay‐<br>
      ments and makes it very difficult to apply surveillance, censorship, or
      blacklists. But<br>
      how does Alice establish this payment path, without revealing anything to
      the inter‐<br>
      mediary nodes?<br>
      The Lightning Network implements an onion-routed protocol based on a
      scheme<br>
      called Sphinx. This routing protocol ensures that a payment sender can
      construct and<br>
      communicate a path through the Lightning Network such that:<br>
      Routed Payment Channels (Lightning Network)<br>
      &nbsp;|<br>
      &nbsp;301<br>
      • Intermediate nodes can verify and decrypt their portion of route
      information<br>
      and find the next hop.<br>
      • Other than the previous and next hops, they cannot learn about any other
      nodes<br>
      that are part of the path.<br>
      • They cannot identify the length of the payment path, or their own
      position in<br>
      that path.<br>
      • Each part of the path is encrypted in such a way that a network-level
      attacker<br>
      cannot associate the packets from different parts of the path to each
      other.<br>
      • Unlike Tor (an onion-routed anonymization protocol on the internet),
      there are<br>
      no “exit nodes” that can be placed under surveillance. The payments do not
      need<br>
      to be transmitted to the bitcoin blockchain; the nodes just update channel
      balan‐<br>
      ces.<br>
      Using this onion-routed protocol, Alice wraps each element of the path in
      a layer of<br>
      encryption, starting with the end and working backward. She encrypts a
      message to<br>
      Eric with Eric’s public key. This message is wrapped in a message
      encrypted to Diana,<br>
      identifying Eric as the next recipient. The message to Diana is wrapped in
      a message<br>
      encrypted to Carol’s public key and identifying Diana as the next
      recipient. The mes‐<br>
      sage to Carol is encrypted to Bob’s key. Thus, Alice has constructed this
      encrypted<br>
      multilayer “onion” of messages. She sends this to Bob, who can only
      decrypt and<br>
      unwrap the outer layer. Inside, Bob finds a message addressed to Carol
      that he can<br>
      forward to Carol but cannot decipher himself. Following the path, the
      messages get<br>
      forwarded, decrypted, forwarded, etc., all the way to Eric. Each
      participant knows<br>
      only the previous and next node in each hop.<br>
      Each element of the path contains information on the HTLC that must be
      extended<br>
      to the next hop, the amount that is being sent, the fee to include, and
      the CLTV lock‐<br>
      time (in blocks) expiration of the HTLC. As the route information
      propagates, the<br>
      nodes make HTLC commitments forward to the next hop.<br>
      At this point, you might be wondering how it is possible that the nodes do
      not know<br>
      the length of the path and their position in that path. After all, they
      receive a message<br>
      and forward it to the next hop. Doesn’t it get shorter, allowing them to
      deduce the<br>
      path size and their position? To prevent this, the path is always fixed at
      20 hops and<br>
      padded with random data. Each node sees the next hop and a fixed-length
      encrypted<br>
      message to forward. Only the final recipient sees that there is no next
      hop. To every‐<br>
      one else it seems as if there are always 20 more hops to go.<br>
      302<br>
      &nbsp;|<br>
      &nbsp;Chapter 12: Blockchain Applications<br>
      Lightning Network Benefits<br>
      A Lightning Network is a second-layer routing technology. It can be
      applied to any<br>
      blockchain that supports some basic capabilities, such as multisignature
      transactions,<br>
      timelocks, and basic smart contracts.<br>
      If a Lightning Network is layered on top of the bitcoin network, the
      bitcoin network<br>
      can gain a significant increase in capacity, privacy, granularity, and
      speed, without<br>
      sacrificing the principles of trustless operation without intermediaries:<br>
      Privacy<br>
      Lightning Network payments are much more private than payments on the bit‐<br>
      coin blockchain, as they are not public. While participants in a route can
      see pay‐<br>
      ments propagated across their channels, they do not know the sender or<br>
      recipient.<br>
      Fungibility<br>
      A Lightning Network makes it much more difficult to apply surveillance and<br>
      blacklists on bitcoin, increasing the fungibility of the currency.<br>
      Speed<br>
      Bitcoin transactions using Lightning Network are settled in milliseconds,
      rather<br>
      than minutes, as HTLCs are cleared without committing transactions to a
      block.<br>
      Granularity<br>
      A Lightning Network can enable payments at least as small as the bitcoin
      “dust”<br>
      limit, perhaps even smaller. Some proposals allow for subsatoshi
      increments.<br>
      Capacity<br>
      A Lightning Network increases the capacity of the bitcoin system by
      several<br>
      orders of magnitude. There is no practical upper bound to the number of
      pay‐<br>
      ments per second that can be routed over a Lightning Network, as it
      depends<br>
      only on the capacity and speed of each node.<br>
      Trustless Operation<br>
      A Lightning Network uses bitcoin transactions between nodes that operate
      as<br>
      peers without trusting each other. Thus, a Lightning Network preserves the
      prin‐<br>
      ciples of the bitcoin system, while expanding its operating parameters
      signifi‐<br>
      cantly.<br>
      Of course, as mentioned previously, the Lightning Network protocol is not
      the only<br>
      way to implement routed payment channels. Other proposed systems include
      Tum‐<br>
      blebit and Teechan. At this time, however, the Lightning Network has
      already been<br>
      deployed on testnet. Several different teams have developed competing
      implementa‐<br>
      tions of LN and are working toward a common interoperability standard
      (called<br>
      Routed Payment Channels (Lightning Network)<br>
      &nbsp;|<br>
      &nbsp;303<br>
      BOLT). It is likely that Lightning Network will be the first routed
      payment channel<br>
      network to be deployed in production.<br>
      Conclusion<br>
      We have examined just a few of the emerging applications that can be built
      using the<br>
      bitcoin blockchain as a trust platform. These applications expand the
      scope of bitcoin<br>
      beyond payments and beyond financial instruments, to encompass many other
      appli‐<br>
      cations where trust is critical. By decentralizing the basis of trust, the
      bitcoin block‐<br>
      chain is a platform that will spawn many revolutionary applications in a
      wide variety<br>
      of industries.<br>
      304<br>
      &nbsp;| Chapter 12: Blockchain Applications<br>
      APPENDIX A<br>
      The Bitcoin Whitepaper by Satoshi<br>
      Nakamoto<br>
      This is the original whitepaper, reproduced in its entirety exactly as<br>
      it was published by Satoshi Nakamoto in October 2008.<br>
      Bitcoin - A Peer-to-Peer Electronic Cash System<br>
      Satoshi Nakamoto<br>
      satoshin@gmx.com<br>
      www.bitcoin.org<br>
      Abstract. A purely peer-to-peer version of electronic cash would allow
      online pay‐<br>
      ments to be sent directly from one party to another without going through
      a financial<br>
      institution. Digital signatures provide part of the solution, but the main
      benefits are<br>
      lost if a trusted third party is still required to prevent
      double-spending. We propose a<br>
      solution to the double-spending problem using a peer-to-peer network. The
      network<br>
      timestamps transactions by hashing them into an ongoing chain of
      hash-based proof-<br>
      of-work, forming a record that cannot be changed without redoing the
      proof-of-<br>
      work. The longest chain not only serves as proof of the sequence of events
      witnessed,<br>
      but proof that it came from the largest pool of CPU power. As long as a
      majority of<br>
      CPU power is controlled by nodes that are not cooperating to attack the
      network,<br>
      they’ll generate the longest chain and outpace attackers. The network
      itself requires<br>
      minimal structure. Messages are broadcast on a best effort basis, and
      nodes can leave<br>
      and rejoin the network at will, accepting the longest proof-of-work chain
      as proof of<br>
      what happened while they were gone.<br>
      305<br>
      Introduction<br>
      Commerce on the Internet has come to rely almost exclusively on financial
      institu‐<br>
      tions serving as trusted third parties to process electronic payments.
      While the sys‐<br>
      tem works well enough for most transactions, it still suffers from the
      inherent<br>
      weaknesses of the trust based model. Completely non-reversible
      transactions are not<br>
      really possible, since financial institutions cannot avoid mediating
      disputes. The cost<br>
      of mediation increases transaction costs, limiting the minimum practical
      transaction<br>
      size and cutting off the possibility for small casual transactions, and
      there is a broader<br>
      cost in the loss of ability to make non-reversible payments for
      nonreversible services.<br>
      With the possibility of reversal, the need for trust spreads. Merchants
      must be wary of<br>
      their customers, hassling them for more information than they would
      otherwise<br>
      need. A certain percentage of fraud is accepted as unavoidable. These
      costs and pay‐<br>
      ment uncertainties can be avoided in person by using physical currency,
      but no<br>
      mechanism exists to make payments over a communications channel without a
      trus‐<br>
      ted party.<br>
      What is needed is an electronic payment system based on cryptographic
      proof<br>
      instead of trust, allowing any two willing parties to transact directly
      with each other<br>
      without the need for a trusted third party. Transactions that are
      computationally<br>
      impractical to reverse would protect sellers from fraud, and routine
      escrow mecha‐<br>
      nisms could easily be implemented to protect buyers. In this paper, we
      propose a sol‐<br>
      ution to the double-spending problem using a peer-to-peer distributed
      timestamp<br>
      server to generate computational proof of the chronological order of
      transactions.<br>
      The system is secure as long as honest nodes collectively control more CPU
      power<br>
      than any cooperating group of attacker nodes.<br>
      Transactions<br>
      We define an electronic coin as a chain of digital signatures. Each owner
      transfers the<br>
      coin to the next by digitally signing a hash of the previous transaction
      and the public<br>
      key of the next owner and adding these to the end of the coin. A payee can
      verify the<br>
      signatures to verify the chain of ownership.<br>
      306<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      The problem of course is the payee can’t verify that one of the owners did
      not double-<br>
      spend the coin. A common solution is to introduce a trusted central
      authority, or<br>
      mint, that checks every transaction for double spending. After each
      transaction, the<br>
      coin must be returned to the mint to issue a new coin, and only coins
      issued directly<br>
      from the mint are trusted not to be double-spent. The problem with this
      solution is<br>
      that the fate of the entire money system depends on the company running
      the mint,<br>
      with every transaction having to go through them, just like a bank.<br>
      We need a way for the payee to know that the previous owners did not sign
      any ear‐<br>
      lier transactions. For our purposes, the earliest transaction is the one
      that counts, so<br>
      we don’t care about later attempts to double-spend. The only way to
      confirm the<br>
      absence of a transaction is to be aware of all transactions. In the mint
      based model,<br>
      the mint was aware of all transactions and decided which arrived first. To
      accomplish<br>
      this without a trusted party, transactions must be publicly announced [1],
      and we<br>
      need a system for participants to agree on a single history of the order
      in which they<br>
      were received. The payee needs proof that at the time of each transaction,
      the major‐<br>
      ity of nodes agreed it was the first received.<br>
      Timestamp Server<br>
      The solution we propose begins with a timestamp server. A timestamp server
      works<br>
      by taking a hash of a block of items to be timestamped and widely
      publishing the<br>
      hash, such as in a newspaper or Usenet post [2-5]. The timestamp proves
      that the<br>
      data must have existed at the time, obviously, in order to get into the
      hash. Each time‐<br>
      stamp includes the previous timestamp in its hash, forming a chain, with
      each addi‐<br>
      tional timestamp reinforcing the ones before it.<br>
      The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      &nbsp;|<br>
      &nbsp;307<br>
      Proof-of-Work<br>
      To implement a distributed timestamp server on a peer-to-peer basis, we
      will need to<br>
      use a proof-of-work system similar to Adam Back’s Hashcash [6], rather
      than news‐<br>
      paper or Usenet posts. The proof-of-work involves scanning for a value
      that when<br>
      hashed, such as with SHA-256, the hash begins with a number of zero bits.
      The aver‐<br>
      age work required is exponential in the number of zero bits required and
      can be veri‐<br>
      fied by executing a single hash. For our timestamp network, we implement
      the proof-<br>
      of-work by incrementing a nonce in the block until a value is found that
      gives the<br>
      block’s hash the required zero bits. Once the CPU effort has been expended
      to make it<br>
      satisfy the proof-of-work, the block cannot be changed without redoing the
      work. As<br>
      later blocks are chained after it, the work to change the block would
      include redoing<br>
      all the blocks after it.<br>
      The proof-of-work also solves the problem of determining representation in
      majority<br>
      decision making. If the majority were based on one-IP-address-one-vote, it
      could be<br>
      subverted by anyone able to allocate many IPs. Proof-of-work is
      essentially one-CPU-<br>
      one-vote. The majority decision is represented by the longest chain, which
      has the<br>
      greatest proof-of-work effort invested in it. If a majority of CPU power
      is controlled<br>
      by honest nodes, the honest chain will grow the fastest and outpace any
      competing<br>
      chains. To modify a past block, an attacker would have to redo the
      proof-of-work of<br>
      the block and all blocks after it and then catch up with and surpass the
      work of the<br>
      honest nodes. We will show later that the probability of a slower attacker
      catching up<br>
      diminishes exponentially as subsequent blocks are added.<br>
      To compensate for increasing hardware speed and varying interest in
      running nodes<br>
      over time, the proof-of-work difficulty is determined by a moving average
      targeting<br>
      an average number of blocks per hour. If they’re generated too fast, the
      difficulty<br>
      increases.<br>
      308<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      Network<br>
      The steps to run the network are as follows:<br>
      1. New transactions are broadcast to all nodes.<br>
      2. Each node collects new transactions into a block.<br>
      3. Each node works on finding a difficult proof-of-work for its block.<br>
      4. When a node finds a proof-of-work, it broadcasts the block to all
      nodes.<br>
      5. Nodes accept the block only if all transactions in it are valid and not
      already<br>
      spent.<br>
      6. Nodes express their acceptance of the block by working on creating the
      next<br>
      block in the chain, using the hash of the accepted block as the previous
      hash.<br>
      Nodes always consider the longest chain to be the correct one and will
      keep working<br>
      on extending it. If two nodes broadcast different versions of the next
      block simultane‐<br>
      ously, some nodes may receive one or the other first. In that case, they
      work on the<br>
      first one they received, but save the other branch in case it becomes
      longer. The tie<br>
      will be broken when the next proof-of-work is found and one branch becomes<br>
      longer; the nodes that were working on the other branch will then switch
      to the<br>
      longer one.<br>
      New transaction broadcasts do not necessarily need to reach all nodes. As
      long as<br>
      they reach many nodes, they will get into a block before long. Block
      broadcasts are<br>
      also tolerant of dropped messages. If a node does not receive a block, it
      will request it<br>
      when it receives the next block and realizes it missed one.<br>
      Incentive<br>
      By convention, the first transaction in a block is a special transaction
      that starts a new<br>
      coin owned by the creator of the block. This adds an incentive for nodes
      to support<br>
      the network, and provides a way to initially distribute coins into
      circulation, since<br>
      there is no central authority to issue them. The steady addition of a
      constant of<br>
      amount of new coins is analogous to gold miners expending resources to add
      gold to<br>
      circulation. In our case, it is CPU time and electricity that is expended.<br>
      The incentive can also be funded with transaction fees. If the output
      value of a trans‐<br>
      action is less than its input value, the difference is a transaction fee
      that is added to<br>
      the incentive value of the block containing the transaction. Once a
      predetermined<br>
      number of coins have entered circulation, the incentive can transition
      entirely to<br>
      transaction fees and be completely inflation free.<br>
      The incentive may help encourage nodes to stay honest. If a greedy
      attacker is able to<br>
      assemble more CPU power than all the honest nodes, he would have to choose<br>
      The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      &nbsp;|<br>
      &nbsp;309<br>
      between using it to defraud people by stealing back his payments, or using
      it to gener‐<br>
      ate new coins. He ought to find it more profitable to play by the rules,
      such rules that<br>
      favour him with more new coins than everyone else combined, than to
      undermine<br>
      the system and the validity of his own wealth.<br>
      Reclaiming Disk Space<br>
      Once the latest transaction in a coin is buried under enough blocks, the
      spent trans‐<br>
      actions before it can be discarded to save disk space. To facilitate this
      without break‐<br>
      ing the block’s hash, transactions are hashed in a Merkle Tree [7] [2]
      [5], with only the<br>
      root included in the block’s hash. Old blocks can then be compacted by
      stubbing off<br>
      branches of the tree. The interior hashes do not need to be stored.<br>
      A block header with no transactions would be about 80 bytes. If we suppose
      blocks<br>
      are generated every 10 minutes, 80 bytes * 6 * 24 * 365 == 4.2MB per year.
      With<br>
      computer systems typically selling with 2GB of RAM as of 2008, and Moore’s
      Law<br>
      predicting current growth of 1.2GB per year, storage should not be a
      problem even if<br>
      the block headers must be kept in memory.<br>
      Simplified Payment Verification<br>
      It is possible to verify payments without running a full network node. A
      user only<br>
      needs to keep a copy of the block headers of the longest proof-of-work
      chain, which<br>
      he can get by querying network nodes until he’s convinced he has the
      longest chain,<br>
      and obtain the Merkle branch linking the transaction to the block it’s
      timestamped in.<br>
      He can’t check the transaction for himself, but by linking it to a place
      in the chain, he<br>
      can see that a network node has accepted it, and blocks added after it
      further confirm<br>
      the network has accepted it.<br>
      310<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      As such, the verification is reliable as long as honest nodes control the
      network, but is<br>
      more vulnerable if the network is overpowered by an attacker. While
      network nodes<br>
      can verify transactions for themselves, the simplified method can be
      fooled by an<br>
      attacker’s fabricated transactions for as long as the attacker can
      continue to over‐<br>
      power the network. One strategy to protect against this would be to accept
      alerts<br>
      from network nodes when they detect an invalid block, prompting the user’s
      software<br>
      to download the full block and alerted transactions to confirm the
      inconsistency.<br>
      Businesses that receive frequent payments will probably still want to run
      their own<br>
      nodes for more independent security and quicker verification.<br>
      Combining and Splitting Value<br>
      Although it would be possible to handle coins individually, it would be
      unwieldy to<br>
      make a separate transaction for every cent in a transfer. To allow value
      to be split and<br>
      combined, transactions contain multiple inputs and outputs. Normally there
      will be<br>
      either a single input from a larger previous transaction or multiple
      inputs combining<br>
      smaller amounts, and at most two outputs: one for the payment, and one
      returning<br>
      the change, if any, back to the sender.<br>
      It should be noted that fan-out, where a transaction depends on several
      transactions,<br>
      and those transactions depend on many more, is not a problem here. There
      is never<br>
      the need to extract a complete standalone copy of a transaction’s history.<br>
      The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      &nbsp;|<br>
      &nbsp;311<br>
      Privacy<br>
      The traditional banking model achieves a level of privacy by limiting
      access to infor‐<br>
      mation to the parties involved and the trusted third party. The necessity
      to announce<br>
      all transactions publicly precludes this method, but privacy can still be
      maintained by<br>
      breaking the flow of information in another place: by keeping public keys
      anony‐<br>
      mous. The public can see that someone is sending an amount to someone
      else, but<br>
      without information linking the transaction to anyone. This is similar to
      the level of<br>
      information released by stock exchanges, where the time and size of
      individual<br>
      trades, the “tape”, is made public, but without telling who the parties
      were.<br>
      As an additional firewall, a new key pair should be used for each
      transaction to keep<br>
      them from being linked to a common owner. Some linking is still
      unavoidable with<br>
      multi-input transactions, which necessarily reveal that their inputs were
      owned by the<br>
      same owner. The risk is that if the owner of a key is revealed, linking
      could reveal<br>
      other transactions that belonged to the same owner.<br>
      Calculations<br>
      We consider the scenario of an attacker trying to generate an alternate
      chain faster<br>
      than the honest chain. Even if this is accomplished, it does not throw the
      system open<br>
      to arbitrary changes, such as creating value out of thin air or taking
      money that never<br>
      belonged to the attacker. Nodes are not going to accept an invalid
      transaction as pay‐<br>
      ment, and honest nodes will never accept a block containing them. An
      attacker can<br>
      only try to change one of his own transactions to take back money he
      recently spent.<br>
      The race between the honest chain and an attacker chain can be
      characterized as a<br>
      Binomial Random Walk. The success event is the honest chain being extended
      by one<br>
      block, increasing its lead by +1, and the failure event is the attacker’s
      chain being<br>
      extended by one block, reducing the gap by -1.<br>
      The probability of an attacker catching up from a given deficit is
      analogous to a<br>
      Gambler’s Ruin problem. Suppose a gambler with unlimited credit starts at
      a deficit<br>
      and plays potentially an infinite number of trials to try to reach
      breakeven. We can<br>
      312<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      calculate the probability he ever reaches breakeven, or that an attacker
      ever catches<br>
      up with the honest chain, as follows [8]:<br>
      p == probability an honest node finds the next block<br>
      q == probability the attacker finds the next block<br>
      qz == probability the attacker will ever catch up from z blocks behind<br>
      Given our assumption that p &gt; q, the probability drops exponentially as
      the number<br>
      of blocks the attacker has to catch up with increases. With the odds
      against him, if he<br>
      doesn’t make a lucky lunge forward early on, his chances become
      vanishingly small as<br>
      he falls further behind.<br>
      We now consider how long the recipient of a new transaction needs to wait
      before<br>
      being sufficiently certain the sender can’t change the transaction. We
      assume the<br>
      sender is an attacker who wants to make the recipient believe he paid him
      for a while,<br>
      then switch it to pay back to himself after some time has passed. The
      receiver will be<br>
      alerted when that happens, but the sender hopes it will be too late.<br>
      The receiver generates a new key pair and gives the public key to the
      sender shortly<br>
      before signing. This prevents the sender from preparing a chain of blocks
      ahead of<br>
      time by working on it continuously until he is lucky enough to get far
      enough ahead,<br>
      then executing the transaction at that moment. Once the transaction is
      sent, the dis‐<br>
      honest sender starts working in secret on a parallel chain containing an
      alternate ver‐<br>
      sion of his transaction.<br>
      The recipient waits until the transaction has been added to a block and z
      blocks have<br>
      been linked after it. He doesn’t know the exact amount of progress the
      attacker has<br>
      made, but assuming the honest blocks took the average expected time per
      block, the<br>
      attacker’s potential progress will be a Poisson distribution with expected
      value:<br>
      To get the probability the attacker could still catch up now, we multiply
      the Poisson<br>
      density for each amount of progress he could have made by the probability
      he could<br>
      catch up from that point:<br>
      The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      &nbsp;|<br>
      &nbsp;313<br>
      Rearranging to avoid summing the infinite tail of the distribution...<br>
      Converting to C code...<br>
      #include &lt;math.h&gt;<br>
      double AttackerSuccessProbability(double q, int z)<br>
      {<br>
      double p == 1.0 - q;<br>
      double lambda == z * (q / p);<br>
      double sum == 1.0;<br>
      int i, k;<br>
      for (k == 0; k &lt;== z; k++)<br>
      {<br>
      double poisson == exp(-lambda);<br>
      for (i == 1; i &lt;== k; i++)<br>
      poisson *== lambda / i;<br>
      sum -== poisson * (1 - pow(q / p, z - k));<br>
      }<br>
      return sum;<br>
      }<br>
      Running some results, we can see the probability drop off exponentially
      with z.<br>
      q=0.1<br>
      z=0 P=1.0000000<br>
      z=1 P=0.2045873<br>
      z=2 P=0.0509779<br>
      z=3 P=0.0131722<br>
      z=4 P=0.0034552<br>
      z=5 P=0.0009137<br>
      z=6 P=0.0002428<br>
      z=7 P=0.0000647<br>
      z=8 P=0.0000173<br>
      z=9 P=0.0000046<br>
      z=10 P=0.0000012<br>
      q=0.3<br>
      z=0 P=1.0000000<br>
      z=5 P=0.1773523<br>
      z=10 P=0.0416605<br>
      z=15 P=0.0101008<br>
      z=20 P=0.0024804<br>
      z=25 P=0.0006132<br>
      314<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      z=30<br>
      z=35<br>
      z=40<br>
      z=45<br>
      z=50<br>
      P=0.0001522<br>
      P=0.0000379<br>
      P=0.0000095<br>
      P=0.0000024<br>
      P=0.0000006<br>
      Solving for P less than 0.1%...<br>
      P &lt; 0.001<br>
      q=0.10 z=5<br>
      q=0.15 z=8<br>
      q=0.20 z=11<br>
      q=0.25 z=15<br>
      q=0.30 z=24<br>
      q=0.35 z=41<br>
      q=0.40 z=89<br>
      q=0.45 z=340<br>
      Conclusion<br>
      We have proposed a system for electronic transactions without relying on
      trust. We<br>
      started with the usual framework of coins made from digital signatures,
      which pro‐<br>
      vides strong control of ownership, but is incomplete without a way to
      prevent double-<br>
      spending. To solve this, we proposed a peer-to-peer network using
      proof-of-work to<br>
      record a public history of transactions that quickly becomes
      computationally imprac‐<br>
      tical for an attacker to change if honest nodes control a majority of CPU
      power. The<br>
      network is robust in its unstructured simplicity. Nodes work all at once
      with little<br>
      coordination. They do not need to be identified, since messages are not
      routed to any<br>
      particular place and only need to be delivered on a best effort basis.
      Nodes can leave<br>
      and rejoin the network at will, accepting the proof-of-work chain as proof
      of what<br>
      happened while they were gone. They vote with their CPU power, expressing
      their<br>
      acceptance of valid blocks by working on extending them and rejecting
      invalid blocks<br>
      by refusing to work on them. Any needed rules and incentives can be
      enforced with<br>
      this consensus mechanism.<br>
      References<br>
      [1] W. Dai, “b-money,” http://www.weidai.com/bmoney.txt, 1998.<br>
      [2] H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure
      timestamping ser‐<br>
      vice with minimal trust requirements,” In 20th Symposium on Information
      Theory in<br>
      the Benelux, May 1999.<br>
      [3] S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” In
      Journal of<br>
      Cryptology, vol 3, no 2, pages 99-111, 1991.<br>
      The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      &nbsp;|<br>
      &nbsp;315<br>
      [4] D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and
      reliability of dig‐<br>
      ital time-stamping,” In Sequences II: Methods in Communication, Security
      and Com‐<br>
      puter Science, pages 329-334, 1993.<br>
      [5] S. Haber, W.S. Stornetta, “Secure names for bit-strings,” In
      Proceedings of the 4th<br>
      ACM Conference on Computer and Communications Security, pages 28-35, April<br>
      1997.<br>
      [6] A. Back, “Hashcash - a denial of service counter-measure,”
      http://www.hash‐<br>
      cash.org/papers/hashcash.pdf, 2002.<br>
      [7] R.C. Merkle, “Protocols for public key cryptosystems,” In Proc. 1980
      Symposium<br>
      on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.<br>
      [8] W. Feller, “An introduction to probability theory and its
      applications,” 1957.<br>
      License<br>
      This whitepaper was published in October 2008 by Satoshi Nakamoto. It was
      later<br>
      (2009) added as supporting documentation to the bitcoin software and
      carries the<br>
      same MIT license. It has been reproduced in this book, without
      modification other<br>
      than formatting, under the terms of the MIT license:<br>
      The MIT License (MIT) Copyright (c) 2008 Satoshi Nakamoto<br>
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this<br>
      software and associated documentation files (the “Software”), to deal in
      the Software<br>
      without restriction, including without limitation the rights to use, copy,
      modify,<br>
      merge, publish, distribute, sublicense, and/or sell copies of the
      Software, and to per‐<br>
      mit persons to whom the Software is furnished to do so, subject to the
      following con‐<br>
      ditions:<br>
      The above copyright notice and this permission notice shall be included in
      all copies<br>
      or substantial portions of the Software.<br>
      THE SOFTWARE IS PROVIDED “AS IS,” WITHOUT WARRANTY OF ANY KIND,<br>
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRAN‐<br>
      TIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND<br>
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT<br>
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,<br>
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br>
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE<br>
      OR OTHER DEALINGS IN THE SOFTWARE.<br>
      316<br>
      &nbsp;|<br>
      &nbsp;Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto<br>
      APPENDIX B<br>
      Transaction Script Language Operators,<br>
      Constants, and Symbols<br>
      Tables and descriptions sourced from https://en.bitcoin.it/wiki/<br>
      Script.<br>
      Table B-1 shows operators for pushing values onto the stack.<br>
      Table B-1. Push value onto stack<br>
      Symbol<br>
      &nbsp;Value (hex)<br>
      &nbsp;Description<br>
      OP_0 or OP_FALSE 0x00<br>
      &nbsp;An empty array is pushed onto the stack<br>
      1-75<br>
      &nbsp;0x01-0x4b<br>
      &nbsp;Push the next N bytes onto the stack, where N is 1 to 75 bytes<br>
      OP_PUSHDATA1<br>
      &nbsp;0x4c<br>
      &nbsp;The next script byte contains N, push the following N bytes onto the
      stack<br>
      OP_PUSHDATA2<br>
      &nbsp;0x4d<br>
      &nbsp;The next two script bytes contain N, push the following N bytes onto
      the stack<br>
      OP_PUSHDATA4<br>
      &nbsp;0x4e<br>
      &nbsp;The next four script bytes contain N, push the following N bytes
      onto the stack<br>
      OP_1NEGATE<br>
      &nbsp;0x4f<br>
      &nbsp;Push the value “–1” onto the stack<br>
      OP_RESERVED<br>
      &nbsp;0x50<br>
      &nbsp;Halt - Invalid transaction unless found in an unexecuted OP_IF
      clause<br>
      OP_1 or OP_TRUE<br>
      &nbsp;0x51<br>
      &nbsp;Push the value “1” onto the stack<br>
      OP_2 to OP_16<br>
      &nbsp;0x52 to 0x60 For OP_N, push the value “N” onto the stack, e.g., OP_2
      pushes “2”<br>
      317<br>
      Table B-2 shows conditional flow control operators.<br>
      Table B-2. Conditional flow control<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_NOP<br>
      &nbsp;0x61<br>
      &nbsp;Do nothing<br>
      OP_VER<br>
      &nbsp;0x62<br>
      &nbsp;Halt—Invalid transaction unless found in an unexecuted OP_IF clause<br>
      OP_IF<br>
      &nbsp;0x63<br>
      &nbsp;Execute the statements following if top of stack is not 0<br>
      OP_NOTIF<br>
      &nbsp;0x64<br>
      &nbsp;Execute the statements following if top of stack is 0<br>
      OP_VERIF<br>
      &nbsp;0x65<br>
      &nbsp;Halt—Invalid transaction<br>
      OP_VERNOTIF 0x66<br>
      &nbsp;Halt—Invalid transaction<br>
      OP_ELSE<br>
      &nbsp;0x67<br>
      &nbsp;Execute only if the previous statements were not executed<br>
      OP_ENDIF<br>
      &nbsp;0x68<br>
      &nbsp;End the OP_IF, OP_NOTIF, OP_ELSE block<br>
      OP_VERIFY<br>
      &nbsp;0x69<br>
      &nbsp;Check the top of the stack, halt and invalidate transaction if not
      TRUE<br>
      OP_RETURN<br>
      &nbsp;0x6a<br>
      &nbsp;Halt and invalidate transaction<br>
      Table B-3 shows operators used for timelocks.<br>
      Table B-3. Timelock operations<br>
      Symbol<br>
      OP_CHECKLOCKTIMEVERIFY<br>
      (previously OP_NOP2)<br>
      OP_CHECKSEQUENCEVERIFY<br>
      (previously OP_NOP3)<br>
      Value<br>
      (hex)<br>
      0xb1<br>
      0xb2<br>
      Description<br>
      Marks transaction as invalid if the top stack item is greater than the
      transaction’s<br>
      nLockTime field, otherwise script evaluation continues as though an OP_NOP
      was<br>
      executed. Transaction is also invalid if 1. the stack is empty; or 2. the
      top stack<br>
      item is negative; or 3. the top stack item is greater than or equal to
      500000000<br>
      while the transaction’s nLockTime field is less than 500000000, or vice
      versa; or 4.<br>
      the input’s nSequence field is equal to 0xffffffff. The precise semantics
      are<br>
      described in BIP-65<br>
      Marks transaction as invalid if the relative lock time of the input
      (enforced by BIP<br>
      0068 with nSequence) is not equal to or longer than the value of the top
      stack<br>
      item. The precise semantics are described in BIP-112<br>
      Table B-4 shows operators used to manipulate the stack.<br>
      Table B-4. Stack operations<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_TOALTSTACK<br>
      &nbsp;0x6b<br>
      &nbsp;Pop top item from stack and push to alternative stack<br>
      OP_FROMALTSTACK 0x6c<br>
      &nbsp;Pop top item from alternative stack and push to stack<br>
      OP_2DROP<br>
      &nbsp;0x6d<br>
      &nbsp;Pop top two stack items<br>
      OP_2DUP<br>
      &nbsp;0x6e<br>
      &nbsp;Duplicate top two stack items<br>
      OP_3DUP<br>
      &nbsp;0x6f<br>
      &nbsp;Duplicate top three stack items<br>
      OP_2OVER<br>
      &nbsp;0x70<br>
      &nbsp;Copy the third and fourth items in the stack to the top<br>
      318<br>
      &nbsp;|<br>
      &nbsp;Appendix B: Transaction Script Language Operators, Constants, and
      Symbols<br>
      Symbol<br>
      OP_2ROT<br>
      OP_2SWAP<br>
      OP_IFDUP<br>
      OP_DEPTH<br>
      OP_DROP<br>
      OP_DUP<br>
      OP_NIP<br>
      OP_OVER<br>
      OP_PICK<br>
      OP_ROLL<br>
      OP_ROT<br>
      OP_SWAP<br>
      OP_TUCK<br>
      Value0x71<br>
      0x72<br>
      0x73<br>
      0x74<br>
      0x75<br>
      0x76<br>
      0x77<br>
      0x78<br>
      0x79<br>
      0x7a<br>
      0x7b<br>
      0x7c<br>
      0x7d<br>
      (hex)Description<br>
      Move the fifth and sixth items in the stack to the top<br>
      Swap the two top pairs of items in the stack<br>
      Duplicate the top item in the stack if it is not 0<br>
      Count the items on the stack and push the resulting count<br>
      Pop the top item in the stack<br>
      Duplicate the top item in the stack<br>
      Pop the second item in the stack<br>
      Copy the second item in the stack and push it onto the top<br>
      Pop value N from top, then copy the Nth item to the top of the stack<br>
      Pop value N from top, then move the Nth item to the top of the stack<br>
      Rotate the top three items in the stack<br>
      Swap the top three items in the stack<br>
      Copy the top item and insert it between the top and second item.<br>
      Table B-5 shows string operators.<br>
      Table B-5. String splice operations<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_CAT<br>
      &nbsp;0x7e<br>
      &nbsp;Disabled (concatenates top two items)<br>
      OP_SUBSTR 0x7f<br>
      &nbsp;Disabled (returns substring)<br>
      OP_LEFT<br>
      &nbsp;0x80<br>
      &nbsp;Disabled (returns left substring)<br>
      OP_RIGHT<br>
      &nbsp;0x81<br>
      &nbsp;Disabled (returns right substring)<br>
      OP_SIZE<br>
      &nbsp;0x82<br>
      &nbsp;Calculate string length of top item and push the result<br>
      Table B-6 shows binary arithmetic and boolean logic operators.<br>
      Table B-6. Binary arithmetic and conditionals<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_INVERT<br>
      &nbsp;0x83<br>
      &nbsp;Disabled (Flip the bits of the top item)<br>
      OP_AND<br>
      &nbsp;0x84<br>
      &nbsp;Disabled (Boolean AND of two top items)<br>
      OP_OR<br>
      &nbsp;0x85<br>
      &nbsp;Disabled (Boolean OR of two top items)<br>
      OP_XOR<br>
      &nbsp;0x86<br>
      &nbsp;Disabled (Boolean XOR of two top items)<br>
      OP_EQUAL<br>
      &nbsp;0x87<br>
      &nbsp;Push TRUE (1) if top two items are exactly equal, push FALSE (0)
      otherwise<br>
      OP_EQUALVERIFY 0x88<br>
      &nbsp;Same as OP_EQUAL, but run OP_VERIFY after to halt if not TRUE<br>
      OP_RESERVED1<br>
      &nbsp;0x89<br>
      &nbsp;Halt - Invalid transaction unless found in an unexecuted OP_IF
      clause<br>
      OP_RESERVED2<br>
      &nbsp;0x8a<br>
      &nbsp;Halt - Invalid transaction unless found in an unexecuted OP_IF
      clause<br>
      Transaction Script Language Operators, Constants, and Symbols<br>
      &nbsp;|<br>
      &nbsp;319<br>
      Table B-7 shows numeric (arithmetic)Table B-7. Numeric operators<br>
      Symbol<br>
      OP_1ADD<br>
      OP_1SUB<br>
      OP_2MUL<br>
      OP_2DIV<br>
      OP_NEGATE<br>
      OP_ABS<br>
      OP_NOT<br>
      OP_0NOTEQUAL<br>
      OP_ADD<br>
      OP_SUB<br>
      OP_MUL<br>
      OP_DIV<br>
      OP_MOD<br>
      OP_LSHIFT<br>
      OP_RSHIFT<br>
      OP_BOOLAND<br>
      OP_BOOLOR<br>
      OP_NUMEQUAL<br>
      OP_NUMEQUALVERIFY<br>
      OP_NUMNOTEQUAL<br>
      OP_LESSTHAN<br>
      OP_GREATERTHAN<br>
      OP_LESSTHANOREQUAL<br>
      OP_GREATERTHANOREQUALOP_MIN<br>
      OP_MAX<br>
      OP_WITHIN<br>
      Value<br>
      (hex)<br>
      0x8b<br>
      0x8c<br>
      0x8d<br>
      0x8e<br>
      0x8f<br>
      0x90<br>
      0x91<br>
      0x92<br>
      0x93<br>
      0x94<br>
      0x95<br>
      0x96<br>
      0x97<br>
      0x98<br>
      0x99<br>
      0x9a<br>
      0x9b<br>
      0x9c<br>
      0x9d<br>
      0x9e<br>
      0x9f<br>
      0xa0<br>
      0xa1<br>
      0xa2<br>
      0xa3<br>
      0xa4<br>
      0xa5<br>
      operators.<br>
      Description<br>
      Add 1 to the top item<br>
      Subtract 1 from the top item<br>
      Disabled (multiply top item by 2)<br>
      Disabled (divide top item by 2)<br>
      Flip the sign of top item<br>
      Change the sign of the top item to positive<br>
      If top item is 0 or 1 Boolean flip it, otherwise return 0<br>
      If top item is 0 return 0, otherwise return 1<br>
      Pop top two items, add them and push result<br>
      Pop top two items, subtract first from second, push result<br>
      Disabled (multiply top two items)<br>
      Disabled (divide second item by first item)<br>
      Disabled (remainder divide second item by first item)<br>
      Disabled (shift second item left by first item number of bits)<br>
      Disabled (shift second item right by first item number of bits)<br>
      Boolean AND of top two items<br>
      Boolean OR of top two items<br>
      Return TRUE if top two items are equal numbers<br>
      Same as NUMEQUAL, then OP_VERIFY to halt if not TRUE<br>
      Return TRUE if top two items are not equal numbers<br>
      Return TRUE if second item is less than top item<br>
      Return TRUE if second item is greater than top item<br>
      Return TRUE if second item is less than or equal to top item<br>
      Return TRUE if second item is great than or equal to top item<br>
      Return the smaller of the two top items<br>
      Return the larger of the two top items<br>
      Return TRUE if the third item is between the second item (or equal) and
      first item<br>
      320<br>
      &nbsp;|<br>
      &nbsp;Appendix B: Transaction Script Language Operators, Constants, and
      Symbols<br>
      Table B-8 shows cryptographic function operators.<br>
      Table B-8. Cryptographic and hashing operations<br>
      Symbol<br>
      &nbsp;Value<br>
      &nbsp;Description<br>
      (hex)<br>
      OP_RIPEMD160<br>
      &nbsp;0xa6<br>
      &nbsp;Return RIPEMD160 hash of top item<br>
      OP_SHA1<br>
      &nbsp;0xa7<br>
      &nbsp;Return SHA1 hash of top item<br>
      OP_SHA256<br>
      &nbsp;0xa8<br>
      &nbsp;Return SHA256 hash of top item<br>
      OP_HASH160<br>
      &nbsp;0xa9<br>
      &nbsp;Return RIPEMD160(SHA256(x)) hash of top item<br>
      OP_HASH256<br>
      &nbsp;0xaa<br>
      &nbsp;Return SHA256(SHA256(x)) hash of top item<br>
      OP_CODESEPARATOR<br>
      &nbsp;0xab<br>
      &nbsp;Mark the beginning of signature-checked data<br>
      OP_CHECKSIG<br>
      &nbsp;0xac<br>
      &nbsp;Pop a public key and signature and validate the signature for the
      transaction’s<br>
      hashed data, return TRUE if matching<br>
      OP_CHECKSIGVERIFY<br>
      &nbsp;0xad<br>
      &nbsp;Same as CHECKSIG, then OP_VERIFY to halt if not TRUE<br>
      OP_CHECKMULTISIG<br>
      &nbsp;0xae<br>
      &nbsp;Run CHECKSIG for each pair of signature and public key provided. All
      must match.<br>
      Bug in implementation pops an extra value, prefix with OP_NOP as
      workaround<br>
      OP_CHECKMULTISIGVERIFY 0xaf<br>
      &nbsp;Same as CHECKMULTISIG, then OP_VERIFY to halt if not TRUE<br>
      Table B-9 shows nonoperator symbols.<br>
      Table B-9. Nonoperators<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_NOP1-OP_NOP10 0xb0-0xb9 Does nothing, ignored<br>
      Table B-10 shows operator codes reserved for use by the internal script
      parser.<br>
      Table B-10. Reserved OP codes for internal use by the parser<br>
      Symbol<br>
      &nbsp;Value (hex) Description<br>
      OP_SMALLDATA<br>
      &nbsp;0xf9<br>
      &nbsp;Represents small data field<br>
      OP_SMALLINTEGER<br>
      &nbsp;0xfa<br>
      &nbsp;Represents small integer data field<br>
      OP_PUBKEYS<br>
      &nbsp;0xfb<br>
      &nbsp;Represents public key fields<br>
      OP_PUBKEYHASH<br>
      &nbsp;0xfd<br>
      &nbsp;Represents a public key hash field<br>
      OP_PUBKEY<br>
      &nbsp;0xfe<br>
      &nbsp;Represents a public key field<br>
      OP_INVALIDOPCODE 0xff<br>
      &nbsp;Represents any OP code not currently assigned<br>
      Transaction Script Language Operators, Constants, and Symbols<br>
      &nbsp;|<br>
      &nbsp;321<br>
      APPENDIX C<br>
      Bitcoin Improvement Proposals<br>
      Bitcoin Improvement Proposals are design documents providing information
      to the<br>
      bitcoin community, or for describing a new feature for bitcoin or its
      processes or<br>
      environment.<br>
      As per BIP-01 BIP Purpose and Guidelines, there are three kinds of BIPs:<br>
      Standard BIP<br>
      Describes any change that affects most or all bitcoin implementations,
      such as a<br>
      change to the network protocol, a change in block or transaction validity
      rules, or<br>
      any change or addition that affects the interoperability of applications
      using bit‐<br>
      coin.<br>
      Informational BIP<br>
      Describes a bitcoin design issue, or provides general guidelines or
      information to<br>
      the bitcoin community, but does not propose a new feature. Informational
      BIPs<br>
      do not necessarily represent a bitcoin community consensus or
      recommendation,<br>
      so users and implementors may ignore informational BIPs or follow their
      advice.<br>
      Process BIP<br>
      Describes a bitcoin process, or proposes a change to (or an event in) a
      process.<br>
      Process BIPs are like standard BIPs but apply to areas other than the
      bitcoin pro‐<br>
      tocol itself. They might propose an implementation, but not to bitcoin’s
      codebase;<br>
      they often require community consensus; and unlike informational BIPs,
      they are<br>
      more than recommendations, and users are typically not free to ignore
      them.<br>
      Examples include procedures, guidelines, changes to the decision-making
      pro‐<br>
      cess, and changes to the tools or environment used in bitcoin development.
      Any<br>
      meta-BIP is also considered a process BIP.<br>
      323<br>
      BIPs are recorded in a versioned repository on GitHub:
      https://github.com/bitcoin/<br>
      bips. Table C-1 shows a snapshot of the BIPs in April 2017. Consult the
      authoritative<br>
      repository for up-to-date information on existing BIPs and their contents.<br>
      Table C-1. Snapshot of BIPs<br>
      BIP#<br>
      &nbsp;Title<br>
      BIP-1<br>
      &nbsp;BIP Purpose and Guidelines<br>
      BIP-2<br>
      &nbsp;BIP process, revised<br>
      BIP-8<br>
      &nbsp;Version bits with guaranteed lock-in<br>
      BIP-9<br>
      &nbsp;Version bits with timeout and delay<br>
      BIP-10<br>
      BIP-11<br>
      BIP-12<br>
      BIP-13<br>
      BIP-14<br>
      Multi-Sig Transaction Distribution<br>
      M-of-N Standard Transactions<br>
      OP_EVAL<br>
      Address Format for pay-to-script-hash<br>
      Protocol Version and User Agent<br>
      BIP-15<br>
      BIP-16<br>
      BIP-17<br>
      BIP-18<br>
      BIP-19<br>
      BIP-20<br>
      BIP-21<br>
      Aliases<br>
      Pay to Script Hash<br>
      OP_CHECKHASHVERIFY (CHV)<br>
      hashScriptCheck<br>
      M-of-N Standard Transactions (Low SigOp)<br>
      URI Scheme<br>
      URI Scheme<br>
      BIP-22<br>
      BIP-23<br>
      BIP-30<br>
      BIP-31<br>
      BIP-32<br>
      BIP-33<br>
      BIP-34<br>
      BIP-35<br>
      BIP-36<br>
      BIP-37<br>
      BIP-38<br>
      getblocktemplate - Fundamentals<br>
      getblocktemplate - Pooled Mining<br>
      Duplicate transactions<br>
      Pong message<br>
      Hierarchical Deterministic Wallets<br>
      Stratized Nodes<br>
      Block v2, Height in Coinbase<br>
      mempool message<br>
      Custom Services<br>
      Connection Bloom filtering<br>
      Passphrase-protected private key<br>
      BIP-39<br>
      &nbsp;Mnemonic code for generating deterministic keys<br>
      Owner<br>
      &nbsp;Type<br>
      &nbsp;Status<br>
      Amir Taaki<br>
      &nbsp;Process<br>
      &nbsp;Replaced<br>
      Luke Dashjr<br>
      &nbsp;Process<br>
      &nbsp;Active<br>
      Shaolin Fry<br>
      &nbsp;Informational Draft<br>
      Pieter Wuille, Peter Todd,<br>
      &nbsp;Informational Final<br>
      Greg Maxwell, Rusty<br>
      Russell<br>
      Alan Reiner<br>
      &nbsp;Informational Withdrawn<br>
      Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Withdrawn<br>
      Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Amir Taaki, Patrick<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Strateman<br>
      Amir Taaki<br>
      &nbsp;Standard<br>
      &nbsp;Deferred<br>
      Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Withdrawn<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Proposed<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Replaced<br>
      Nils Schneider, Matt<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Corallo<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Luke Dashjr<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Pieter Wuille<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Mike Hearn<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Pieter Wuille<br>
      &nbsp;Informational Final<br>
      Amir Taaki<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Jeff Garzik<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Stefan Thomas<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      Mike Hearn, Matt Corallo<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Mike Caldwell, Aaron<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      Voisine<br>
      Marek Palatinus, Pavol<br>
      &nbsp;Standard<br>
      &nbsp;Proposed<br>
      Rusnak, Aaron Voisine,<br>
      Sean Bowe<br>
      324<br>
      &nbsp;|<br>
      &nbsp;Appendix C: Bitcoin Improvement Proposals<br>
      BIP#<br>
      &nbsp;Title<br>
      &nbsp;Owner<br>
      &nbsp;Type<br>
      &nbsp;Status<br>
      BIP-40<br>
      &nbsp;Stratum wire protocol<br>
      &nbsp;Marek Palatinus<br>
      &nbsp;Standard<br>
      &nbsp;BIP number<br>
      allocated<br>
      BIP-41<br>
      &nbsp;Stratum mining protocol<br>
      &nbsp;Marek Palatinus<br>
      &nbsp;Standard<br>
      &nbsp;BIP number<br>
      allocated<br>
      BIP-42<br>
      &nbsp;A finite monetary supply for Bitcoin<br>
      &nbsp;Pieter Wuille<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      BIP-43<br>
      &nbsp;Purpose Field for Deterministic Wallets<br>
      &nbsp;Marek Palatinus, Pavol<br>
      &nbsp;Informational Draft<br>
      Rusnak<br>
      BIP-44<br>
      &nbsp;Multi-Account Hierarchy for Deterministic Wallets<br>
      &nbsp;Marek Palatinus, Pavol<br>
      &nbsp;Standard<br>
      &nbsp;Proposed<br>
      Rusnak<br>
      BIP-45<br>
      &nbsp;Structure for Deterministic P2SH Multisignature<br>
      &nbsp;Manuel Araoz, Ryan X.<br>
      &nbsp;Standard<br>
      &nbsp;Proposed<br>
      Wallets<br>
      &nbsp;Charles, Matias Alejo Garcia<br>
      BIP-47<br>
      &nbsp;Reusable Payment Codes for Hierarchical<br>
      &nbsp;Justus Ranvier<br>
      &nbsp;Informational Draft<br>
      Deterministic Wallets<br>
      BIP-49<br>
      &nbsp;Derivation scheme for P2WPKH-nested-in-P2SH<br>
      &nbsp;Daniel Weigl<br>
      &nbsp;Informational Draft<br>
      based accounts<br>
      BIP-50<br>
      &nbsp;March 2013 Chain Fork Post-Mortem<br>
      &nbsp;Gavin Andresen<br>
      &nbsp;Informational Final<br>
      BIP-60<br>
      &nbsp;Fixed Length “version” Message (Relay-Transactions Amir Taaki<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      Field)<br>
      BIP-61<br>
      &nbsp;Reject P2P message<br>
      &nbsp;Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      BIP-62<br>
      &nbsp;Dealing with malleability<br>
      &nbsp;Pieter Wuille<br>
      &nbsp;Standard<br>
      &nbsp;Withdrawn<br>
      BIP-63<br>
      &nbsp;Stealth Addresses<br>
      &nbsp;Peter Todd<br>
      &nbsp;Standard<br>
      &nbsp;BIP number<br>
      allocated<br>
      BIP-64<br>
      &nbsp;getutxo message<br>
      &nbsp;Mike Hearn<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      BIP-65<br>
      &nbsp;OP_CHECKLOCKTIMEVERIFY<br>
      &nbsp;Peter Todd<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      BIP-66<br>
      &nbsp;Strict DER signatures<br>
      &nbsp;Pieter Wuille<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      BIP-67<br>
      &nbsp;Deterministic Pay-to-script-hash multi-signature<br>
      &nbsp;Thomas Kerin, Jean-Pierre<br>
      &nbsp;Standard<br>
      &nbsp;Proposed<br>
      addresses through public key sorting<br>
      &nbsp;Rupp, Ruben de Vries<br>
      BIP-68<br>
      &nbsp;Relative lock-time using consensus-enforced<br>
      &nbsp;Mark Friedenbach, BtcDrak, Standard<br>
      &nbsp;Final<br>
      sequence numbers<br>
      &nbsp;Nicolas Dorier,<br>
      kinoshitajona<br>
      BIP-69<br>
      &nbsp;Lexicographical Indexing of Transaction Inputs and<br>
      &nbsp;Kristov Atlas<br>
      &nbsp;Informational Proposed<br>
      Outputs<br>
      BIP-70<br>
      &nbsp;Payment Protocol<br>
      &nbsp;Gavin Andresen, Mike<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      Hearn<br>
      BIP-71<br>
      &nbsp;Payment Protocol MIME types<br>
      &nbsp;Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      BIP-72<br>
      &nbsp;bitcoin: uri extensions for Payment Protocol<br>
      &nbsp;Gavin Andresen<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      BIP-73<br>
      &nbsp;Use “Accept” header for response type negotiation<br>
      &nbsp;Stephen Pair<br>
      &nbsp;Standard<br>
      &nbsp;Final<br>
      with Payment Request URLs<br>
      BIP-74<br>
      &nbsp;Allow zero value OP_RETURN in Payment Protocol<br>
      &nbsp;Toby Padilla<br>
      &nbsp;Standard<br>
      &nbsp;Draft<br>
      BIP-75<br>
      &nbsp;Out of Band Address Exchange using Payment<br>
      &nbsp;Justin Newton, Matt David, Standard<br>
      &nbsp;Draft<br>
      Protocol Encryption<br>
      &nbsp;Aaron Voisine, James<br>
      MacWhyte<br>
      Bitcoin Improvement Proposals<br>
      &nbsp;|<br>
      &nbsp;325<br>
      BIP#<br>
      BIP-80<br>
      BIP-81<br>
      BIP-83<br>
      BIP-90<br>
      BIP-99<br>
BIP-101BIP-102BIP-103BIP-104BIP-105BIP-106BIP-107BIP-109BIP-111BIP-112Title<br>
      Hierarchy for Non-Colored Voting Pool DeterministicMultisig Wallets<br>
      Hierarchy for Colored Voting Pool Deterministic<br>
      Multisig Wallets<br>
      Dynamic Hierarchical Deterministic Key Trees<br>
      Buried Deployments<br>
      Motivation and deployment of consensus rule<br>
      changes ([soft/hard]forks)<br>
      Increase maximum block size<br>
      Block size increase to 2MB<br>
      Block size following technological growth<br>
      Block75 - Max block size like difficulty<br>
      Consensus based block size retargeting algorithm<br>
      Dynamically Controlled Bitcoin Block Size Max Cap<br>
      Dynamic limit on the block size<br>
      Two million byte size limit with sigop and sighash<br>
      limits<br>
      NODE_BLOOM service bit<br>
      CHECKSEQUENCEVERIFY<br>
      BIP-113BIP-114BIP-120BIP-121BIP-122BIP-123BIP-124Median time-past as
      endpoint for lock-time<br>
      calculations<br>
      Merkelized Abstract Syntax Tree<br>
      Proof of Payment<br>
      Proof of Payment URI scheme<br>
      URI scheme for Blockchain references / exploration<br>
      BIP Classification<br>
      Hierarchical Deterministic Script Templates<br>
      BIP-125 Opt-in Full Replace-by-Fee Signaling<br>
      BIP-126BIP-130BIP-131BIP-132BIP-133BIP-134BIP-140Best Practices for
      Heterogeneous Input Script<br>
      Transactions<br>
      sendheaders message<br>
      “Coalescing Transaction” Specification (wildcard<br>
      inputs)<br>
      Committee-based BIP Acceptance Process<br>
      feefilter message<br>
      Flexible Transactions<br>
      Normalized TXID<br>
      Owner<br>
      Justus Ranvier, Jimmy<br>
      Song<br>
      Justus Ranvier, Jimmy<br>
      Song<br>
      Eric Lombrozo<br>
      Suhas Daftuar<br>
      Jorge Timón<br>
      Gavin Andresen<br>
      Jeff Garzik<br>
      Pieter Wuille<br>
      t.khan<br>
      BtcDrak<br>
      Upal Chakraborty<br>
      Washington Y. Sanchez<br>
      Gavin Andresen<br>
      Matt Corallo, Peter Todd<br>
      BtcDrak, Mark Friedenbach,Eric Lombrozo<br>
      Thomas Kerin, Mark<br>
      Friedenbach<br>
      Johnson Lau<br>
      Kalle Rosenbaum<br>
      Kalle Rosenbaum<br>
      Marco Pontello<br>
      Eric Lombrozo<br>
      Eric Lombrozo, William<br>
      Swanson<br>
      David A. Harding, Peter<br>
      Todd<br>
      Kristov Atlas<br>
      Suhas Daftuar<br>
      Chris Priest<br>
      Andy Chase<br>
      Alex Morcos<br>
      Tom Zander<br>
      Christian Decker<br>
      Type<br>
      InformationalStatus<br>
      Deferred<br>
      Informational Deferred<br>
      Standard<br>
      InformationalInformationalDraft<br>
      Draft<br>
      Draft<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Withdrawn<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Rejected<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Process<br>
      InformationalStandard<br>
      InformationalStandard<br>
      Standard<br>
      Process<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Proposed<br>
      Final<br>
      Final<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Active<br>
      Draft<br>
      Proposed<br>
      Draft<br>
      Proposed<br>
      Draft<br>
      Withdrawn<br>
      Draft<br>
      Draft<br>
      Draft<br>
      326<br>
      &nbsp;|<br>
      &nbsp;Appendix C: Bitcoin Improvement Proposals<br>
      BIP#<br>
      BIP-141Title<br>
      Segregated Witness (Consensus layer)<br>
      BIP-142BIP-143BIP-144Address Format for Segregated Witness<br>
      Transaction Signature Verification for Version 0<br>
      Witness Program<br>
      Segregated Witness (Peer Services)<br>
      BIP-145BIP-146BIP-147BIP-148BIP-150BIP-151BIP-152BIP-171BIP-180BIP-199getblocktemplate
      Updates for Segregated Witness<br>
      Dealing with signature encoding malleability<br>
      Dealing with dummy stack element malleability<br>
      Mandatory activation of segwit deployment<br>
      Peer Authentication<br>
      Peer-to-Peer Communication Encryption<br>
      Compact Block Relay<br>
      Currency/exchange rate information API<br>
      Block size/weight fraud proof<br>
      Hashed Time-Locked Contract transactions<br>
      Owner<br>
      Eric Lombrozo, Johnson<br>
      Lau, Pieter Wuille<br>
      Johnson Lau<br>
      Johnson Lau, Pieter Wuille<br>
      Type<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Eric Lombrozo, Pieter<br>
      Wuille<br>
      Luke Dashjr<br>
      Johnson Lau, Pieter Wuille<br>
      Johnson Lau<br>
      Shaolin Fry<br>
      Jonas Schnelli<br>
      Jonas Schnelli<br>
      Matt Corallo<br>
      Luke Dashjr<br>
      Luke Dashjr<br>
      Sean Bowe, Daira<br>
      Hopwood<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Standard<br>
      Status<br>
      Draft<br>
      Deferred<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Draft<br>
      Bitcoin Improvement Proposals<br>
      &nbsp;|<br>
      &nbsp;327<br>
      SegregatedAPPENDIX D<br>
      Witness<br>
      Segregated Witness (segwit) is an upgrade to the bitcoin consensus rules
      and network<br>
      protocol, proposed and implemented as a BIP-9 soft-fork that is currently
      (mid-2017)<br>
      pending activation.<br>
      In cryptography, the term “witness” is used to describe a solution to a
      cryptographic<br>
      puzzle. In bitcoin terms, the witness satisfies a cryptographic condition
      placed on a<br>
      unspent transaction output (UTXO).<br>
      In the context of bitcoin, a digital signature is one type of witness, but
      a witness is<br>
      more broadly any solution that can satisfy the conditions imposed on an
      UTXO and<br>
      unlock that UTXO for spending. The term “witness” is a more general term
      for an<br>
      “unlocking script” or “scriptSig.”<br>
      Before segwit’s introduction, every input in a transaction was followed by
      the witness<br>
      data that unlocked it. The witness data was embedded in the transaction as
      part of<br>
      each input. The term segregated witness, or segwit for short, simply means
      separating<br>
      the signature or unlocking script of a specific output. Think “separate
      scriptSig,” or<br>
      “separate signature” in the simplest form.<br>
      Segregated Witness therefore is an architectural change to bitcoin that
      aims to move<br>
      the witness data from the scriptSig (unlocking script) field of a
      transaction into a<br>
      separate witness data structure that accompanies a transaction. Clients
      may request<br>
      transaction data with or without the accompanying witness data.<br>
      In this section we will look at some of the benefits of Segregated
      Witness, describe the<br>
      mechanism used to deploy and implement this architecture change, and
      demonstrate<br>
      the use of Segregated Witness in transactions and addresses.<br>
      329<br>
      Segregated Witness is defined by the following BIPs:<br>
      BIP-141<br>
      The main definition of Segregated Witness.<br>
      BIP-143<br>
      Transaction Signature Verification for Version 0 Witness Program<br>
      BIP-144<br>
      Peer Services—New network messages and serialization formats<br>
      BIP-145<br>
      getblocktemplate Updates for Segregated Witness (for mining)<br>
      Why Segregated Witness?<br>
      Segregated Witness is an architectural change that has several effects on
      the scalabil‐<br>
      ity, security, economic incentives, and performance of bitcoin:<br>
      Transaction Malleability<br>
      By moving the witness outside the transaction, the transaction hash used
      as an<br>
      identifier no longer includes the witness data. Since the witness data is
      the only<br>
      part of the transaction that can be modified by a third party (see
      “Transaction<br>
      identifiers” on page 338), removing it also removes the opportunity for
      transac‐<br>
      tion malleability attacks. With Segregated Witness, transaction hashes
      become<br>
      immutable by anyone other than the creator of the transaction, which
      greatly<br>
      improves the implementation of many other protocols that rely on advanced
      bit‐<br>
      coin transaction construction, such as payment channels, chained
      transactions,<br>
      and lightning networks.<br>
      Script Versioning<br>
      With the introduction of Segregated Witness scripts, every locking script
      is pre‐<br>
      ceded by a script version number, similar to how transactions and blocks
      have<br>
      version numbers. The addition of a script version number allows the
      scripting<br>
      language to be upgraded in a backward-compatible way (i.e., using soft
      fork<br>
      upgrades) to introduce new script operands, syntax, or semantics. The
      ability to<br>
      upgrade the scripting language in a nondisruptive way will greatly
      accelerate the<br>
      rate of innovation in bitcoin.<br>
      Network and Storage Scaling<br>
      The witness data is often a big contributor to the total size of a
      transaction. More<br>
      complex scripts such as those used for multisig or payment channels are
      very<br>
      large. In some cases these scripts account for the majority (more than
      75%) of the<br>
      data in a transaction. By moving the witness data outside the transaction,
      Segre‐<br>
      gated Witness improves bitcoin’s scalability. Nodes can prune the witness
      data<br>
      after validating the signatures, or ignore it altogether when doing
      simplified pay‐<br>
      330<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      ment verification. The witness data doesn’t need to be transmitted to all
      nodes<br>
      and does not need to be stored on disk by all nodes.<br>
      Signature Verification Optimization<br>
      Segregated Witness upgrades the signature functions (CHECKSIG,
      CHECKMULTISIG,<br>
      etc.) to reduce the algorithm’s computational complexity. Before segwit,
      the algo‐<br>
      rithm used to produce a signature required a number of hash operations
      that was<br>
      proportional to the size of the transaction. Data-hashing computations
      increased<br>
      in O(n2) with respect to the number of signature operations, introducing a
      sub‐<br>
      stantial computational burden on all nodes verifying the signature. With
      segwit,<br>
      the algorithm is changed to reduce the complexity to O(n).<br>
      Offline Signing Improvement<br>
      Segregated Witness signatures incorporate the value (amount) referenced by
      each<br>
      input in the hash that is signed. Previously, an offline signing device,
      such as a<br>
      hardware wallet, would have to verify the amount of each input before
      signing a<br>
      transaction. This was usually accomplished by streaming a large amount of
      data<br>
      about the previous transactions referenced as inputs. Since the amount is
      now<br>
      part of the commitment hash that is signed, an offline device does not
      need the<br>
      previous transactions. If the amounts do not match (are misrepresented by
      a<br>
      compromised online system), the signature will be invalid.<br>
      How Segregated Witness Works<br>
      At first glance, Segregated Witness appears to be a change to how
      transactions are<br>
      constructed and therefore a transaction-level feature, but it is not. In
      fact, Segregated<br>
      Witness is also a change to how individual UTXO are spent and therefore is
      a per-<br>
      output feature.<br>
      A transaction can spend Segregated Witness outputs or traditional
      (inline-witness)<br>
      outputs or both. Therefore, it does not make much sense to refer to a
      transaction as a<br>
      “Segregated Witness transaction.” Rather we should refer to specific
      transaction<br>
      inputs as “Segregated Witness inputs.”<br>
      When a transaction spends an UTXO, it must provide a witness. In a
      traditional<br>
      UTXO, the locking script requires that witness data be provided inline in
      the input<br>
      part of the transaction that spends the UTXO. A Segregated Witness UTXO,
      however,<br>
      specifies a locking script that can be satisfied with witness data outside
      of the input<br>
      (segregated).<br>
      Soft Fork (Backward Compatibility)<br>
      Segregated Witness is a significant change to the way outputs and
      transactions are<br>
      architected. Such a change would normally require a simultaneous change in
      every<br>
      bitcoin node and wallet to change the consensus rules—what is known as a
      hard fork.<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;331<br>
      Instead, segregated witness is introduced with a much less disruptive
      change, which is<br>
      backward compatible, known as a soft fork. This type of upgrade allows
      nonupgraded<br>
      software to ignore the changes and continue to operate without any
      disruption.<br>
      Segregated Witness outputs are constructed so that older systems that are
      not segwit-<br>
      aware can still validate them. To an old wallet or node, a Segregated
      Witness output<br>
      looks like an output that anyone can spend. Such outputs can be spent with
      an empty<br>
      signature, therefore the fact that there is no signature inside the
      transaction (it is seg‐<br>
      regated) does not invalidate the transaction. Newer wallets and mining
      nodes, how‐<br>
      ever, see the Segregated Witness output and expect to find a valid witness
      for it in the<br>
      transaction’s witness data.<br>
      Segregated Witness Output and Transaction Examples<br>
      Let’s look at some of our example transactions and see how they would
      change with<br>
      Segregated Witness. We’ll first look at how a Pay-to-Public-Key-Hash
      (P2PKH) pay‐<br>
      ment is transformed with the Segregated Witness program. Then, we’ll look
      at the<br>
      Segregated Witness equivalent for Pay-to-Script-Hash (P2SH) scripts.
      Finally, we’ll<br>
      look at how both of the preceding Segregated Witness programs can be
      embedded<br>
      inside a P2SH script.<br>
      Pay-to-Witness-Public-Key-Hash (P2WPKH)<br>
      In “Buying a Cup of Coffee” on page 16, Alice created a transaction to pay
      Bob for a<br>
      cup of coffee. That transaction created a P2PKH output with a value of
      0.015 BTC<br>
      that was spendable by Bob. The output’s script looks like this:<br>
      DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG<br>
      With Segregated Witness, Alice would create a
      Pay-to-Witness-Public-Key-Hash<br>
      (P2WPKH) script, which looks like this:<br>
      0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7<br>
      As you can see, a Segregated Witness output’s locking script is much
      simpler than a<br>
      traditional output. It consists of two values that are pushed on to the
      script evaluation<br>
      stack. To an old (nonsegwit-aware) bitcoin client, the two pushes would
      look like an<br>
      output that anyone can spend and does not require a signature (or rather,
      can be<br>
      spent with an empty signature). To a newer, segwit-aware client, the first
      number (0)<br>
      is interpreted as a version number (the witness version) and the second
      part (20 bytes)<br>
      is the equivalent of a locking script known as a witness program. The
      20-byte witness<br>
      program is simply the hash of the public key, as in a P2PKH script<br>
      Now, let’s look at the corresponding transaction that Bob uses to spend
      this output.<br>
      For the original script (nonsegwit), Bob’s transaction would have to
      include a signa‐<br>
      ture within the transaction input:<br>
      332<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      [...]<br>
      “Vin” : [<br>
      "txid":
      "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",<br>
      "vout": 0,<br>
      "scriptSig": “&lt;Bob’s scriptSig&gt;”,<br>
      ]<br>
      [...]<br>
      However, to spend the Segregated Witness output, the transaction has no
      signature<br>
      on that input. Instead, Bob’s transaction has an empty scriptSig and
      includes a Seg‐<br>
      regated Witness, outside the transaction itself:<br>
      [...]<br>
      “Vin” : [<br>
      "txid":
      "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",<br>
      "vout": 0,<br>
      "scriptSig": “”,<br>
      ]<br>
      [...]<br>
      “witness”: “&lt;Bob’s witness data&gt;”<br>
      [...]<br>
      Wallet construction of P2WPKH<br>
      It is extremely important to note that P2WPKH should only be created by
      the payee<br>
      (recipient) and not converted by the sender from a known public key, P2PKH
      script,<br>
      or address. The sender has no way of knowing if the recipient’s wallet has
      the ability<br>
      to construct segwit transactions and spend P2WPKH outputs.<br>
      Additionally, P2WPKH outputs must be constructed from the hash of a
      compressed<br>
      public key. Uncompressed public keys are nonstandard in segwit and may be
      explic‐<br>
      itly disabled by a future soft fork. If the hash used in the P2WPKH came
      from an<br>
      uncompressed public key, it may be unspendable and you may lose funds.
      P2WPKH<br>
      outputs should be created by the payee’s wallet by deriving a compressed
      public key<br>
      from their private key.<br>
      P2WPKH should be constructed by the payee (recipient) by con‐<br>
      verting a compressed public key to a P2WPKH hash. You should<br>
      never transform a P2PKH script, bitcoin address, or uncompressed<br>
      public key to a P2WPKH witness script.<br>
      Pay-to-Witness-Script-Hash (P2WSH)<br>
      The second type of witness program corresponds to a Pay-to-Script-Hash
      (P2SH)<br>
      script. We saw this type of script in “Pay-to-Script-Hash (P2SH)” on page
      151. In that<br>
      example, P2SH was used by Mohammed’s company to express a multisignature<br>
      script. Payments to Mohammed’s company were encoded with a locking script
      like<br>
      this:<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;333<br>
      HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL<br>
      This P2SH script references the hash of a redeem script that defines a
      2-of-3 multi‐<br>
      signature requirement to spend funds. To spend this output, Mohammed’s
      company<br>
      would present the redeem script (whose hash matches the script hash in the
      P2SH<br>
      output) and the signatures necessary to satisfy that redeem script, all
      inside the trans‐<br>
      action input:<br>
      [...]<br>
      “Vin” : [<br>
      "txid": "abcdef12345...",<br>
      "vout": 0,<br>
      "scriptSig": “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5
      CHECKMULTI-<br>
      SIG&gt;”,<br>
      ]<br>
      Now, let’s look at how this entire example would be upgraded to segwit. If
      Moham‐<br>
      med’s customers were using a segwit-compatible wallet, they would make a
      payment,<br>
      creating a Pay-to-Witness-Script-Hash (P2WSH) output that would look like
      this:<br>
      0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73<br>
      Again, as with the example of P2WPKH, you can see that the Segregated
      Witness<br>
      equivalent script is a lot simpler and omits the various script operands
      that you see in<br>
      P2SH scripts. Instead, the Segregated Witness program consists of two
      values pushed<br>
      to the stack: a witness version (0) and the 32-byte SHA256 hash of the
      redeem script.<br>
      While P2SH uses the 20-byte RIPEMD160(SHA256(script)) hash,<br>
      the P2WSH witness program uses a 32-byte SHA256(script) hash.<br>
      This difference in the selection of the hashing algorithm is deliber‐<br>
      ate and is used to differentiate between the two types of witness<br>
      programs (P2WPKH and P2WSH) by the length of the hash and to<br>
      provide stronger security to P2WSH (128 bits versus 80 bits of<br>
      P2SH).<br>
      Mohammed’s company can spend outputs the P2WSH output by presenting the
      cor‐<br>
      rect redeem script and sufficient signatures to satisfy it. Both the
      redeem script and<br>
      the signatures would be segregated outside the spending transaction as
      part of the<br>
      witness data. Within the transaction input, Mohammed’s wallet would put an
      empty<br>
      scriptSig:<br>
      [...]<br>
      “Vin” : [<br>
      "txid": "abcdef12345...",<br>
      "vout": 0,<br>
      "scriptSig": “”,<br>
      ]<br>
      [...]<br>
      334<br>
      &nbsp;| Appendix D: Segregated Witness<br>
      “witness”: “&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5
      CHECKMULTISIG&gt;”<br>
      [...]<br>
      Differentiating between P2WPKH and P2WSH<br>
      In the previous two sections, we demonstrated two types of witness
      programs: “Pay-<br>
      to-Witness-Public-Key-Hash (P2WPKH)” on page 332 and
      “Pay-to-Witness-Script-<br>
      Hash (P2WSH)” on page 333. Both types of witness programs consist of a
      single byte<br>
      version number followed by a longer hash. They look very similar, but are
      interpreted<br>
      very differently: one is interpreted as a public key hash, which is
      satisfied by a signa‐<br>
      ture and the other as a script hash, which is satisfied by a redeem
      script. The critical<br>
      difference between them is the length of the hash:<br>
      • The public key hash in P2WPKH is 20 bytes<br>
      • The script hash in P2WSH is 32 bytes<br>
      This is the one difference that allows a wallet to differentiate between
      the two types of<br>
      witness programs. By looking at the length of the hash, a wallet can
      determine what<br>
      type of witness program it is, P2WPKH or P2WSH.<br>
      Upgrading to Segregated Witness<br>
      As we can see from the previous examples, upgrading to Segregated Witness
      is a two-<br>
      step process. First, wallets must create special segwit type outputs.
      Then, these out‐<br>
      puts can be spent by wallets that know how to construct Segregated Witness<br>
      transactions. In the examples, Alice’s wallet was segwit-aware and able to
      create spe‐<br>
      cial outputs with Segregated Witness scripts. Bob’s wallet is also
      segwit-aware and<br>
      able to spend those outputs. What may not be obvious from the example is
      that in<br>
      practice, Alice’s wallet needs to know that Bob uses a segwit-aware wallet
      and can<br>
      spend these outputs. Otherwise, if Bob’s wallet is not upgraded and Alice
      tries to<br>
      make segwit payments to Bob, Bob’s wallet will not be able to detect these
      payments.<br>
      For P2WPKH and P2WSH payment types, both the sender and the<br>
      recipient wallets need to be upgraded to be able to use segwit. Fur‐<br>
      thermore, the sender’s wallet needs to know that the recipient’s wal‐<br>
      let is segwit-aware.<br>
      Segregated Witness will not be implemented simultaneously across the
      entire net‐<br>
      work. Rather, Segregated Witness is implemented as a backward-compatible
      upgrade,<br>
      where old and new clients can coexist. Wallet developers will
      independently upgrade<br>
      wallet software to add segwit capabilities. The P2WPKH and P2WSH payment
      types<br>
      are used when both sender and recipient are segwit-aware. The traditional
      P2PKH<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;335<br>
      and P2SH will continue to work for nonupgraded wallets. That leaves two
      important<br>
      scenarios, which are addressed in the next section:<br>
      • Ability of a sender’s wallet that is not segwit-aware to make a payment
      to a recipi‐<br>
      ent’s wallet that can process segwit transactions<br>
      • Ability of a sender’s wallet that is segwit-aware to recognize and
      distinguish<br>
      between recipients that are segwit-aware and ones that are not, by their
      addresses<br>
      Embedding Segregated Witness inside P2SH<br>
      Let’s assume, for example, that Alice’s wallet is not upgraded to segwit,
      but Bob’s wal‐<br>
      let is upgraded and can handle segwit transactions. Alice and Bob can use
      “old” non-<br>
      segwit transactions. But Bob would likely want to use segwit to reduce
      transaction<br>
      fees, taking advantage of the discount that applies to witness data.<br>
      In this case Bob’s wallet can construct a P2SH address that contains a
      segwit script<br>
      inside it. Alice’s wallet sees this as a “normal” P2SH address and can
      make payments<br>
      to it without any knowledge of segwit. Bob’s wallet can then spend this
      payment with<br>
      a segwit transaction, taking full advantage of segwit and reducing
      transaction fees.<br>
      Both forms of witness scripts, P2WPKH and P2WSH, can be embedded in a P2SH<br>
      address. The first is noted as P2SH(P2WPKH) and the second is noted as<br>
      P2SH(P2WSH).<br>
      Pay-to-Witness-Public-Key-Hash inside Pay-to-Script-Hash<br>
      The first form of witness script we will examine is P2SH(P2WPKH). This is
      a Pay-to-<br>
      Witness-Public-Key-Hash witness program, embedded inside a
      Pay-to-Script-Hash<br>
      script, so that it can be used by a wallet that is not aware of segwit.<br>
      Bob’s wallet constructs a P2WPKH witness program with Bob’s public key.
      This wit‐<br>
      ness program is then hashed and the resulting hash is encoded as a P2SH
      script. The<br>
      P2SH script is converted to a bitcoin address, one that starts with a “3,”
      as we saw in<br>
      the “Pay-to-Script-Hash (P2SH)” on page 151 section.<br>
      Bob’s wallet starts with the P2WPKH witness program we saw earlier:<br>
      0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7<br>
      The P2WPKH witness program consists of the witness version and Bob’s
      20-byte<br>
      public key hash.<br>
      Bob’s wallet then hashes the preceding witness program, first with SHA256,
      then with<br>
      RIPEMD160, producing another 20-byte hash:<br>
      3e0547268b3b19288b3adef9719ec8659f4b2b0b<br>
      336<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      The hash of the witness program is then embedded in a P2SH script:<br>
      HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL<br>
      Finally, the P2SH script is converted to a P2SH bitcoin address:<br>
      37Lx99uaGn5avKBxiW26HjedQE3LrDCZru<br>
      Now, Bob can display this address for customers to pay for their coffee.
      Alice’s wallet<br>
      can make a payment to 37Lx99uaGn5avKBxiW26HjedQE3LrDCZru, just as it would
      to<br>
      any other bitcoin address. Even though Alice’s wallet has no support for
      segwit, the<br>
      payment it creates can be spent by Bob with a segwit transaction.<br>
      Pay-to-Witness-Script-Hash inside Pay-to-Script-Hash<br>
      Similarly, a P2WSH witness program for a multisig script or other
      complicated script<br>
      can be embedded inside a P2SH script and address, making it possible for
      any wallet<br>
      to make payments that are segwit compatible.<br>
      As we saw in “Pay-to-Witness-Script-Hash (P2WSH)” on page 333, Mohammed’s<br>
      company is using Segregated Witness payments to multisignature scripts. To
      make it<br>
      possible for any client to pay his company, regardless of whether their
      wallets are<br>
      upgraded for segwit, Mohammed’s wallet can embed the P2WSH witness program<br>
      inside a P2SH script.<br>
      First, Mohammed’s wallet creates the P2WSH witness program that
      corresponds to<br>
      the multisignature script, hashed with SHA256:<br>
      0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73<br>
      Then, the witness program itself is hashed with SHA256 and RIPEMD160,
      producing<br>
      a new 20-byte hash, as used in traditional P2SH:<br>
      86762607e8fe87c0c37740cddee880988b9455b2<br>
      Next, Mohammed’s wallet puts the hash into a P2SH script:<br>
      HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL<br>
      Finally, the wallet constructs a bitcoin address from this script:<br>
      3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG<br>
      Now, Mohammed’s clients can make payments to this address without any need
      to<br>
      support segwit. Mohammed’s company can then construct segwit transactions
      to<br>
      spend these payments, taking advantage of segwit features including lower
      transac‐<br>
      tion fees.<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;337<br>
      Segregated Witness addresses<br>
      After segwit is deployed on the bitcoin network, it will take some time
      until wallets<br>
      are upgraded. It is quite likely therefore that segwit will mostly be used
      embedded in<br>
      P2SH, as we saw in the previous section, at least for several months.<br>
      Eventually, however, almost all wallets will be able to support segwit
      payments. At<br>
      that time it will no longer be necessary to embed segwit in P2SH. It is
      therefore likely<br>
      that a new form of bitcoin address will be created, one that indicates the
      recipient is<br>
      segwit-aware and that directly encodes a witness program. There have been
      a number<br>
      of proposals for a Segregated Witness address scheme, but none have been
      actively<br>
      pursued.<br>
      Transaction identifiers<br>
      One of the greatest benefits of Segregated Witness is that it eliminates
      third-party<br>
      transaction malleability.<br>
      Before segwit, transactions could have their signatures subtly modified by
      third par‐<br>
      ties, changing their transaction ID (hash) without changing any
      fundamental proper‐<br>
      ties (inputs, outputs, amounts). This created opportunities for
      denial-of-service<br>
      attacks as well as attacks against poorly written wallet software that
      assumed uncon‐<br>
      firmed transaction hashes were immutable.<br>
      With the introduction of Segregated Witness, transactions have two
      identifiers, txid<br>
      and wtxid. The traditional transaction ID txid is the double-SHA256 hash
      of the<br>
      serialized transaction, without the witness data. A transaction wtxid is
      the double-<br>
      SHA256 hash of the new serialization format of the transaction with
      witness data.<br>
      The traditional txid is calculated in exactly the same way as with a
      nonsegwit trans‐<br>
      action. However, since the segwit transaction has empty scriptSigs in
      every input,<br>
      there is no part of the transaction that can be modified by a third party.
      Therefore, in<br>
      a segwit transaction, the txid is immutable by a third party, even when
      the transac‐<br>
      tion is unconfirmed.<br>
      The wtxid is like an “extended” ID, in that the hash also incorporates the
      witness<br>
      data. If a transaction is transmitted without witness data, then the wtxid
      and txid are<br>
      identical. Note than since the wtxid includes witness data (signatures)
      and since wit‐<br>
      ness data may be malleable, the wtxid should be considered malleable until
      the trans‐<br>
      action is confirmed. Only the txid of a segwit transaction can be
      considered<br>
      immutable by third parties and only if all the inputs of the transaction
      are segwit<br>
      inputs.<br>
      338<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      Segregated Witness transactions have two IDs: txid and wtxid.<br>
      The txid is the hash of the transaction without the witness data<br>
      and the wtxid is the hash inclusive of witness data. The txid of a<br>
      transaction where all inputs are segwit inputs is not susceptible to<br>
      third-party transaction malleability.<br>
      Segregated Witness’ New Signing Algorithm<br>
      Segregated Witness modifies the semantics of the four signature
      verification func‐<br>
      tions (CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, and CHECKMULTISIGVERIFY),<br>
      changing the way a transaction commitment hash is calculated.<br>
      Signatures in bitcoin transactions are applied on a commitment hash, which
      is calcu‐<br>
      lated from the transaction data, locking specific parts of the data
      indicating the sign‐<br>
      er’s commitment to those values. For example, in a simple SIGHASH_ALL type<br>
      signature, the commitment hash includes all inputs and outputs.<br>
      Unfortunately, the way the commitment hash was calculated introduced the
      possibil‐<br>
      ity that a node verifying the signature can be forced to perform a
      significant number<br>
      of hash computations. Specifically, the hash operations increase in O(n 2)
      with respect<br>
      to the number of signature operations in the transaction. An attacker
      could therefore<br>
      create a transaction with a very large number of signature operations,
      causing the<br>
      entire bitcoin network to have to perform hundreds or thousands of hash
      operations<br>
      to verify the transaction.<br>
      Segwit represented an opportunity to address this problem by changing the
      way the<br>
      commitment hash is calculated. For segwit version 0 witness programs,
      signature ver‐<br>
      ification occurs using an improved commitment hash algorithm as specified
      in<br>
      BIP-143.<br>
      The new algorithm achieves two important goals. Firstly, the number of
      hash opera‐<br>
      tions increases by a much more gradual O(n) to the number of signature
      operations,<br>
      reducing the opportunity to create denial-of-service attacks with overly
      complex<br>
      transactions. Secondly, the commitment hash now also includes the value
      (amounts)<br>
      of each input as part of the commitment. This means that a signer can
      commit to a<br>
      specific input value without needing to “fetch” and check the previous
      transaction<br>
      referenced by the input. In the case of offline devices, such as hardware
      wallets, this<br>
      greatly simplifies the communication between the host and the hardware
      wallet,<br>
      removing the need to stream previous transactions for validation. A
      hardware wallet<br>
      can accept the input value “as stated” by an untrusted host. Since the
      signature is<br>
      invalid if that input value is not correct, the hardware wallet doesn’t
      need to validate<br>
      the value before signing the input.<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;339<br>
      Economic Incentives for Segregated Witness<br>
      Bitcoin mining nodes and full nodes incur costs for the resources used to
      support the<br>
      bitcoin network and the blockchain. As the volume of bitcoin transactions
      increases,<br>
      so does the cost of resources (CPU, network bandwidth, disk space,
      memory). Miners<br>
      are compensated for these costs through fees that are proportional to the
      size (in<br>
      bytes) of each transaction. Nonmining full nodes are not compensated, so
      they incur<br>
      these costs because they have a need to run an authoritative fully
      validating full-index<br>
      node, perhaps because they use the node to operate a bitcoin business.<br>
      Without transaction fees, the growth in bitcoin data would arguably
      increase dramat‐<br>
      ically. Fees are intended to align the needs of bitcoin users with the
      burden their<br>
      transactions impose on the network, through a market-based price discovery
      mecha‐<br>
      nism.<br>
      The calculation of fees based on transaction size treats all the data in
      the transaction<br>
      as equal in cost. But from the perspective of full nodes and miners, some
      parts of a<br>
      transaction carry much higher costs. Every transaction added to the
      bitcoin network<br>
      affects the consumption of four resources on nodes:<br>
      Disk Space<br>
      Every transaction is stored in the blockchain, adding to the total size of
      the<br>
      blockchain. The blockchain is stored on disk, but the storage can be
      optimized by<br>
      “pruning” older transactions.<br>
      CPU<br>
      Every transaction must be validated, which requires CPU time.<br>
      Bandwidth<br>
      Every transaction is transmitted (through flood propagation) across the
      network<br>
      at least once. Without any optimization in the block propagation protocol,
      trans‐<br>
      actions are transmitted again as part of a block, doubling the impact on
      network<br>
      capacity.<br>
      Memory<br>
      Nodes that validate transactions keep the UTXO index or the entire UTXO
      set in<br>
      memory to speed up validation. Because memory is at least one order of
      magni‐<br>
      tude more expensive than disk, growth of the UTXO set contributes
      dispropor‐<br>
      tionately to the cost of running a node.<br>
      As you can see from the list, not every part of a transaction has an equal
      impact on<br>
      the cost of running a node or on the ability of bitcoin to scale to
      support more trans‐<br>
      actions. The most expensive part of a transaction are the newly created
      outputs, as<br>
      they are added to the in-memory UTXO set. By comparison, signatures (aka
      witness<br>
      data) add the least burden to the network and the cost of running a node,
      because<br>
      witness data are only validated once and then never used again.
      Furthermore, imme‐<br>
      340<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      diately after receiving a new transaction and validating witness data,
      nodes can dis‐<br>
      card that witness data. If fees are calculated on transaction size,
      without<br>
      discriminating between these two types of data, then the market incentives
      of fees are<br>
      not aligned with the actual costs imposed by a transaction. In fact, the
      current fee<br>
      structure actually encourages the opposite behavior, because witness data
      is the larg‐<br>
      est part of a transaction.<br>
      The incentives created by fees matter because they affect the behavior of
      wallets. All<br>
      wallets must implement some strategy for assembling transactions that
      takes into<br>
      consideration a number of factors, such as privacy (reducing address
      reuse), frag‐<br>
      mentation (making lots of loose change), and fees. If the fees are
      overwhelmingly<br>
      motivating wallets to use as few inputs as possible in transactions, this
      can lead to<br>
      UTXO picking and change address strategies that inadvertently bloat the
      UTXO set.<br>
      Transactions consume UTXO in their inputs and create new UTXO with their
      out‐<br>
      puts. A transaction, therefore, that has more inputs than outputs will
      result in a<br>
      decrease in the UTXO set, whereas a transaction that has more outputs than
      inputs<br>
      will result in an increase in the UTXO set. Let’s consider the difference
      between inputs<br>
      and outputs and call that the “Net-new-UTXO.” That’s an important metric,
      as it tells<br>
      us what impact a transaction will have on the most expensive network-wide
      resource,<br>
      the in-memory UTXO set. A transaction with positive Net-new-UTXO adds to
      that<br>
      burden. A transaction with a negative Net-new-UTXO reduces the burden. We
      would<br>
      therefore want to encourage transactions that are either negative
      Net-new-UTXO or<br>
      neutral with zero Net-new-UTXO.<br>
      Let’s look at an example of what incentives are created by the transaction
      fee calcula‐<br>
      tion, with and without Segregated Witness. We will look at two different
      transactions.<br>
      Transaction A is a 3-input, 2-output transaction, which has a Net-new-UTXO
      metric<br>
      of –1, meaning it consumes one more UTXO than it creates, reducing the
      UTXO set<br>
      by one. Transaction B is a 2-input, 3-output transaction, which has a
      Net-new-UTXO<br>
      metric of 1, meaning it adds one UTXO to the UTXO set, imposing additional
      cost<br>
      on the entire bitcoin network. Both transactions use multisignature
      (2-of-3) scripts to<br>
      demonstrate how complex scripts increase the impact of segregated witness
      on fees.<br>
      Let’s assume a transaction fee of 30 satoshi per byte and a 75% fee
      discount on witness<br>
      data:<br>
      Without Segregated Witness<br>
      Transaction A fee: 25,710 satoshi<br>
      Transaction B fee: 18,990 satoshi<br>
      With Segregated Witness<br>
      Transaction A fee: 8,130 satoshi<br>
      Transaction B fee: 12,045 satoshi<br>
      Segregated Witness<br>
      &nbsp;|<br>
      &nbsp;341<br>
      Both transactions are less expensive when segregated witness is
      implemented. But<br>
      comparing the costs between the two transactions, we see that before
      Segregated Wit‐<br>
      ness, the fee is higher for the transaction that has a negative
      Net-new-UTXO. After<br>
      Segregated Witness, the transaction fees align with the incentive to
      minimize new<br>
      UTXO creation by not inadvertently penalizing transactions with many
      inputs.<br>
      Segregated Witness therefore has two main effects on the fees paid by
      bitcoin users.<br>
      Firstly, segwit reduces the overall cost of transactions by discounting
      witness data and<br>
      increasing the capacity of the bitcoin blockchain. Secondly, segwit’s
      discount on wit‐<br>
      ness data corrects a misalignment of incentives that may have
      inadvertently created<br>
      more bloat in the UTXO set.<br>
      342<br>
      &nbsp;|<br>
      &nbsp;Appendix D: Segregated Witness<br>
      APPENDIX E<br>
      Bitcore<br>
      Bitcore is a suite of tools provided by BitPay. Its goal is to provide
      easy-to-use tools<br>
      for Bitcoin developers. Almost all of Bitcore’s code is written in
      JavaScript. There are<br>
      some modules written specifically for NodeJS. Finally, the “node” module
      of Bitcore<br>
      includes Bitcoin Core’s C++ code. Please see https://bitcore.io for more
      information.<br>
      Bitcore’s Feature List<br>
      • Bitcoin full node (bitcore-node)<br>
      • Block explorer (insight)<br>
      • Block, transaction, and wallet utilities (bitcore-lib)<br>
      • Communicating directly with Bitcoin’s P2P network (bitcore-p2p)<br>
      • Seed entropy mnemonic generation (bitcore-mnemonic)<br>
      • Payment protocol (bitcore-payment-protocol)<br>
      • Message verification and signing (bitcore-message)<br>
      • Elliptic curve Integrated Encryption Scheme (bitcore-ecies)<br>
      • Wallet service (bitcore-wallet-service)<br>
      • Wallet client (bitcore-wallet-client)<br>
      • Playground (bitcore-playground)<br>
      • Integrating services directly with Bitcoin Core (bitcore-node)<br>
      343<br>
      Bitcore Library Examples<br>
      Prerequisities<br>
      • NodeJS &gt;= 4.x or use our hosted online playground<br>
      If using NodeJS and the node REPL:<br>
      $ npm install -g bitcore-lib bitcore-p2p<br>
      $ NODE_PATH=$(npm list -g | head -1)/node_modules node<br>
      Wallet Examples using bitcore-lib<br>
      Creating a new bitcoin address with associated private key:<br>
      &gt; bitcore = require('bitcore-lib')<br>
      &gt; privateKey = new bitcore.PrivateKey()<br>
      &gt; address = privateKey.toAddress().toString()<br>
      Creating a hierarchical deterministic private key and address:<br>
      &gt; hdPrivateKey = bitcore.HDPrivateKey()<br>
      &gt; hdPublicKey = bitcore.HDPublicKey(hdPrivateKey)<br>
      &gt; hdAddress = new bitcore.Address(hdPublicKey.publicKey).toString()<br>
      Creating and signing a transaction from a UTXO:<br>
      &gt; utxo = {<br>
      txId: transaction id containing an unspent output,<br>
      outputIndex: output indexi e.g. 0,<br>
      address: addressOfUtxo,<br>
      script: bitcore.Script.buildPublicKeyHashOut(addressOfUtxo).toString(),<br>
      satoshis: amount sent to the address<br>
      }<br>
      &gt; fee = 3000 //set appropriately for conditions on the network<br>
      &gt; tx = new bitcore.Transaction()<br>
      .from(utxo)<br>
      .to(address, 35000)<br>
      .fee(fee)<br>
      .enableRBF()<br>
      .sign(privateKeyOfUtxo)<br>
      Replace the last transaction in the mempool (replace-by-fee):<br>
      &gt; rbfTx = new Transaction()<br>
      .from(utxo)<br>
      .to(address, 35000)<br>
      .fee(fee*2)<br>
      .enableRBF()<br>
      .sign(privateKeyOfUtxo);<br>
      &gt; tx.serialize();<br>
      &gt; rbfTx.serialize();<br>
      344<br>
      &nbsp;|<br>
      &nbsp;Appendix E: Bitcore<br>
      Broadcasting a transaction to the Bitcoin network (note: broadcast valid
      transactions<br>
      only; refer to https://bitnodes.21.co/nodes for peer hosts):<br>
      1. Copy the code below into a file called broadcast.js.<br>
      2. The tx and rbfTx variables are the output of tx.serialize() and
      rbfTx.serial<br>
      ize(), respectively.<br>
      3. In order to replace-by-fee, the peer must support bitcoind option
      mempoolre<br>
      place and have it set to 1.<br>
      4. Run the file node broadcast.js:<br>
      var p2p = require('bitcore-p2p');<br>
      var bitcore = require('bitcore-lib');<br>
      var tx = new bitcore.Transaction('output from serialize function');<br>
      var rbfTx = new bitcore.Transaction('output from serialize function');<br>
      var host = 'ip address'; //use valid peer listening on tcp 8333<br>
      var peer = new p2p.Peer({host: host});<br>
      var messages = new p2p.Messages();<br>
      peer.on('ready', function() {<br>
      var txs = [messages.Transaction(tx), messages.Transaction(rbfTx)];<br>
      var index = 0;<br>
      var interval = setInterval(function() {<br>
      peer.sendMessage(txs[index++]);<br>
      console.log('tx: ' + index + ' sent');<br>
      if (index === txs.length) {<br>
      clearInterval(interval);<br>
      console.log('disconnecting from peer: ' + host);<br>
      peer.disconnect();<br>
      }<br>
      }, 2000);<br>
      });<br>
      peer.connect();<br>
      Bitcore<br>
      &nbsp;|<br>
      &nbsp;345<br>
      APPENDIX F<br>
      pycoin, ku, and tx<br>
      The Python library pycoin, originally written and maintained by Richard
      Kiss, is a<br>
      Python-based library that supports manipulation of bitcoin keys and
      transactions,<br>
      even supporting the scripting language enough to properly deal with
      nonstandard<br>
      transactions.<br>
      The pycoin library supports both Python 2 (2.7.x) and Python 3 (after 3.3)
      and comes<br>
      with some handy command-line utilities, ku and tx.<br>
      Key Utility (KU)<br>
      The command-line utility ku (“key utility”) is a Swiss Army knife for
      manipulating<br>
      keys. It supports BIP-32 keys, WIF, and addresses (bitcoin and alt coins).
      Following<br>
      are some examples.<br>
      Create a BIP-32 key using the default entropy sources of GPG and
      /dev/random:<br>
      $ ku create<br>
      input<br>
      &nbsp;: create<br>
      network<br>
      &nbsp;: Bitcoin<br>
      wallet key<br>
      &nbsp;: xprv9s21ZrQH143K3LU5ctPZTBnb9kTjA5Su9DcWHvXJe-<br>
      miJBsY7VqXUG7hipgdWaU<br>
      m2nhnzdvxJf5KJo9vjP2nABX65c5sFsWsV8oXcbpehtJi<br>
      public version : xpub661MyMwAqRbcFpYYiuvZpKjKhnJD-<br>
      ZYAkWSY76JvvD7FH4fsG3Nqiov2CfxzxY8<br>
      DGcpfT56AMFeo8M8KPkFMfLUtvwjwb6WPv8rY65L2q8Hz<br>
      tree depth<br>
      &nbsp;: 0<br>
      fingerprint<br>
      &nbsp;: 9d9c6092<br>
      parent f'print : 00000000<br>
      child index<br>
      &nbsp;: 0<br>
      chain code<br>
      &nbsp;:<br>
      80574fb260edaa4905bc86c9a47d30c697c50047ed466c0d4a5167f6821e8f3c<br>
      347<br>
      private key<br>
      &nbsp;: yes<br>
      secret exponent :<br>
112471538590155650688604752840386134637231974546906847202389294096567806844862<br>
      hex<br>
      &nbsp;:<br>
      f8a8a28b28a916e1043cc0aca52033a18a13cab1638d544006469bc171fddfbe<br>
      wif<br>
      &nbsp;: L5Z54xi6qJusQT42JHA44mfPVZGjyb4XBRWfxAzUWwRiGx1kV4sP<br>
      uncompressed<br>
      &nbsp;: 5KhoEavGNNH4GHKoy2Ptu4KfdNp4r56L5B5un8FP6RZnbsz5Nmb<br>
      public pair x<br>
      &nbsp;:<br>
76460638240546478364843397478278468101877117767873462127021560368290114016034<br>
      public pair y<br>
      &nbsp;:<br>
59807879657469774102040120298272207730921291736633247737077406753676825777701<br>
      x as hex<br>
      &nbsp;:<br>
      a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322<br>
      y as hex<br>
      &nbsp;:<br>
      843a0f6ed9c0eb1962c74533795406914fe3f1957c5238951f4fe245a4fcd625<br>
      y parity<br>
      &nbsp;: odd<br>
      key pair as sec :<br>
      03a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322<br>
      uncompressed<br>
      &nbsp;:<br>
      04a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322<br>
      843a0f6ed9c0eb1962c74533795406914fe3f1957c5238951f4fe245a4fcd625<br>
      hash160<br>
      &nbsp;: 9d9c609247174ae323acfc96c852753fe3c8819d<br>
      uncompressed<br>
      &nbsp;: 8870d869800c9b91ce1eb460f4c60540f87c15d7<br>
      Bitcoin address : 1FNNRQ5fSv1wBi5gyfVBs2rkNheMGt86sp<br>
      uncompressed<br>
      &nbsp;: 1DSS5isnH4FsVaLVjeVXewVSpfqktdiQAM<br>
      Create a BIP-32 key from a passphrase:<br>
      The passphrase in this example is way too easy to guess.<br>
      $ ku P:foo<br>
      input<br>
      &nbsp;: P:foo<br>
      network<br>
      &nbsp;: Bitcoin<br>
      wallet key<br>
      &nbsp;:<br>
      xprv9s21ZrQH143K31AgNK5pyVvW23gHnkBq2wh5aEk6g1s496M8ZMjxncCKZKgb5j<br>
      ZoY5eSJMJ2Vbyvi2hbmQnCuHBujZ2WXGTux1X2k9Krdtq<br>
      public version :
      xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWo-<br>
      QayvtS<br>
      VYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy<br>
      tree depth<br>
      &nbsp;: 0<br>
      fingerprint<br>
      &nbsp;: 5d353a2e<br>
      parent f'print : 00000000<br>
      child index<br>
      &nbsp;: 0<br>
      chain code<br>
      &nbsp;:<br>
      5eeb1023fd6dd1ae52a005ce0e73420821e1d90e08be980a85e9111fd7646bbc<br>
      private key<br>
      &nbsp;: yes<br>
      348<br>
      &nbsp;|<br>
      &nbsp;Appendix F: pycoin, ku, and tx<br>
      secret exponent :<br>
65825730547097305716057160437970790220123864299761908948746835886007793998275<br>
      hex<br>
      &nbsp;:<br>
      91880b0e3017ba586b735fe7d04f1790f3c46b818a2151fb2def5f14dd2fd9c3<br>
      wif<br>
      &nbsp;: L26c3H6jEPVSqAr1usXUp9qtQJw6NHgApq6Ls4ncyqtsvcq2MwKH<br>
      uncompressed<br>
      &nbsp;: 5JvNzA5vXDoKYJdw8SwwLHxUxaWvn9mDea6k1vRPCX7KLUVWa7W<br>
      public pair x<br>
      &nbsp;:<br>
81821982719381104061777349269130419024493616650993589394553404347774393168191<br>
      public pair y<br>
      &nbsp;:<br>
58994218069605424278320703250689780154785099509277691723126325051200459038290<br>
      x as hex<br>
      &nbsp;:<br>
      b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f<br>
      y as hex<br>
      &nbsp;:<br>
      826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52<br>
      y parity<br>
      &nbsp;: even<br>
      key pair as sec :<br>
      02b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f<br>
      uncompressed<br>
      &nbsp;:<br>
      04b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f<br>
      826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52<br>
      hash160<br>
      &nbsp;: 5d353a2ecdb262477172852d57a3f11de0c19286<br>
      uncompressed<br>
      &nbsp;: e5bd3a7e6cb62b4c820e51200fb1c148d79e67da<br>
      Bitcoin address : 19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii<br>
      uncompressed<br>
      &nbsp;: 1MwkRkogzBRMehBntgcq2aJhXCXStJTXHT<br>
      Get info as JSON:<br>
      $ ku P:foo -P -j<br>
      {<br>
      "y_parity": "even",<br>
      "public_pair_y_hex":<br>
      "826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52",<br>
      "private_key": "no",<br>
      "parent_fingerprint": "00000000",<br>
      "tree_depth": "0",<br>
      "network": "Bitcoin",<br>
      "btc_address_uncompressed": "1MwkRkogzBRMehBntgcq2aJhXCXStJTXHT",<br>
      "key_pair_as_sec_uncompressed":<br>
"04b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f826d8b4d3010a<br>
      ea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52",<br>
      "public_pair_x_hex":<br>
      "b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f",<br>
      "wallet_key":
      "xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWo<br>
      QayvtSVYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy",<br>
      "chain_code":<br>
      "5eeb1023fd6dd1ae52a005ce0e73420821e1d90e08be980a85e9111fd7646bbc",<br>
      "child_index": "0",<br>
      "hash160_uncompressed": "e5bd3a7e6cb62b4c820e51200fb1c148d79e67da",<br>
      "btc_address": "19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii",<br>
      "fingerprint": "5d353a2e",<br>
      "hash160": "5d353a2ecdb262477172852d57a3f11de0c19286",<br>
      pycoin, ku, and tx<br>
      &nbsp;|<br>
      &nbsp;349<br>
      "input": "P:foo",<br>
      "public_pair_x":<br>
"81821982719381104061777349269130419024493616650993589394553404347774393168191",<br>
      "public_pair_y":<br>
"58994218069605424278320703250689780154785099509277691723126325051200459038290",<br>
      "key_pair_as_sec":<br>
      "02b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f"<br>
      }<br>
      Public BIP32 key:<br>
      $ ku -w -P P:foo<br>
      xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWoQayvtS-<br>
      VYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy<br>
      Generate a subkey:<br>
      $ ku -w -s3/2 P:foo<br>
      xprv9wTErTSkjVyJa1v4cUTFMFkWMe5eu8ErbQcs9xajn-<br>
      sUzCBT7ykHAwdrxvG3g3f6BFk7ms5hHBvmbdutNmyg6iogWKxx6mefEw4M8EroLgKj<br>
      Hardened subkey:<br>
      $ ku -w -s3/2H P:foo<br>
      xprv9wTErTSu5AWGk-<br>
DeUPmqBcbZWX1xq85ZNX9iQRQW9DXwygFp7iRGJo79dsVctcsCHsnZ3XU3DhsuaGZbDh8iDkBN45k67U<br>
      KsJUXM1JfRCdn1<br>
      WIF:<br>
      $ ku -W P:foo<br>
      L26c3H6jEPVSqAr1usXUp9qtQJw6NHgApq6Ls4ncyqtsvcq2MwKH<br>
      Address:<br>
      $ ku -a P:foo<br>
      19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii<br>
      Generate a bunch of subkeys:<br>
      $ ku P:foo -s 0/0-5 -w<br>
      xprv9xWkBDfyBXmZjBG9EiXBpy67KK72fphUp9utJokEBFtjsjiuKUUDF5V3TU8U8cDzytqYn-<br>
      Sekc8bYuJS8G3bhXxKWB89Ggn2dzLcoJsuEdRK<br>
      xprv9xWkBDfyBXmZnzKf3bAGifK593gT7WJZPnYAmvc77gUQ-<br>
      Vej5QHckc5Adtwxa28ACmANi9XhCrRvtFqQcUxt8rUgFz3souMiDdWxJDZnQxzx<br>
xprv9xWkBDfyBXmZqdXA8y4SWqfBdy71gSW9sjx9JpCiJEiBwSMQyRxan6srXUPBtj3PTxQFkZJAi-<br>
      woUpmvtrxKZu4zfsnr3pqyy2vthpkwuoVq<br>
      xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuq-<br>
      xYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p<br>
xprv9xWkBDfyBXmZv2q3N66hhZ8DAcEnQDnXML1J62krJAcf7Xb1HJwuW2VMJQrCofY2jtFXdiEY8UsR<br>
      NJfqK6DAdyZXoMvtaLHyWQx3FS4A9zw<br>
      xprv9xWkBDfyBXmZw4jEYXU-<br>
HYc9fT25k9irP87n2RqfJ5bqbjKdT84Mm7Wtc2xmzFuKg7iYf7XFHKkSsaYKWKJbR54bnyAD9GzjUY-<br>
      bAYTtN4ruo<br>
      350<br>
      &nbsp;|<br>
      &nbsp;Appendix F: pycoin, ku, and tx<br>
      Generate the corresponding addresses:<br>
      $ ku P:foo -s 0/0-5 -a<br>
      1MrjE78H1R1rqdFrmkjdHnPUdLCJALbv3x<br>
      1AnYyVEcuqeoVzH96zj1eYKwoWfwte2pxu<br>
      1GXr1kZfxE1FcK6ZRD5sqqqs5YfvuzA1Lb<br>
      116AXZc4bDVQrqmcinzu4aaPdrYqvuiBEK<br>
      1Cz2rTLjRM6pMnxPNrRKp9ZSvRtj5dDUML<br>
      1WstdwPnU6HEUPme1DQayN9nm6j7nDVEM<br>
      Generate the corresponding WIFs:<br>
      $ ku P:foo -s 0/0-5 -W<br>
      L5a4iE5k9gcJKGqX3FWmxzBYQc29PvZ6pgBaePLVqT5YByEnBomx<br>
      Kyjgne6GZwPGB6G6kJEhoPbmyjMP7D5d3zRbHVjwcq4iQXD9QqKQ<br>
      L4B3ygQxK6zH2NQGxLDee2H9v4Lvwg14cLJW7QwWPzCtKHdWMaQz<br>
      L2L2PZdorybUqkPjrmhem4Ax5EJvP7ijmxbNoQKnmTDMrqemY8UF<br>
      L2oD6vA4TUyqPF8QG4vhUFSgwCyuuvFZ3v8SKHYFDwkbM765Nrfd<br>
      KzChTbc3kZFxUSJ3Kt54cxsogeFAD9CCM4zGB22si8nfKcThQn8C<br>
      Check that it works by choosing a BIP32 string (the one corresponding to
      subkey<br>
      0/3):<br>
      $ ku -W
      xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuq-<br>
      xYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p<br>
      L2L2PZdorybUqkPjrmhem4Ax5EJvP7ijmxbNoQKnmTDMrqemY8UF<br>
      $ ku -a
      xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuq-<br>
      xYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p<br>
      116AXZc4bDVQrqmcinzu4aaPdrYqvuiBEK<br>
      Yep, looks familiar.<br>
      From secret exponent:<br>
      $ ku 1 наput<br>
      &nbsp;: 1<br>
      network<br>
      &nbsp;: Bitcoin<br>
      secret exponent : 1<br>
      hex<br>
      &nbsp;: 1<br>
      wif<br>
      &nbsp;: KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgd9M7rFU73sVHnoWn<br>
      uncompressed<br>
      &nbsp;: 5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAnchuDf<br>
      public pair x<br>
      &nbsp;:<br>
55066263022277343669578718895168534326250603453777594175500187360389116729240<br>
      public pair y<br>
      &nbsp;:<br>
32670510020758816978083085130507043184471273380659243275938904335757337482424<br>
      x as hex<br>
      &nbsp;:<br>
      79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      y as hex<br>
      &nbsp;:<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      y parity<br>
      &nbsp;: even<br>
      key pair as sec :<br>
      0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      uncompressed<br>
      &nbsp;:<br>
      pycoin, ku, and tx<br>
      &nbsp;|<br>
      &nbsp;351<br>
      0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      hash160<br>
      &nbsp;: 751e76e8199196d454941c45d1b3a323f1433bd6<br>
      uncompressed<br>
      &nbsp;: 91b24bf9f5288532960ac687abb035127b1d28a5<br>
      Bitcoin address : 1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH<br>
      uncompressed<br>
      &nbsp;: 1EHNa6Q4Jz2uvNExL497mE43ikXhwF6kZm<br>
      Litecoin version:<br>
      $ ku -nL 1 наput<br>
      &nbsp;: 1<br>
      network<br>
      &nbsp;: Litecoin<br>
      secret exponent : 1<br>
      hex<br>
      &nbsp;: 1<br>
      wif<br>
      &nbsp;: T33ydQRKp4FCW5LCLLUB7deioUMoveiwekdwUwyfRDeGZm76aUjV<br>
      uncompressed<br>
      &nbsp;: 6u823ozcyt2rjPH8Z2ErsSXJB5PPQwK7VVTwwN4mxLBFrao69XQ<br>
      public pair x<br>
      &nbsp;:<br>
55066263022277343669578718895168534326250603453777594175500187360389116729240<br>
      public pair y<br>
      &nbsp;:<br>
32670510020758816978083085130507043184471273380659243275938904335757337482424<br>
      x as hex<br>
      &nbsp;:<br>
      79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      y as hex<br>
      &nbsp;:<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      y parity<br>
      &nbsp;: even<br>
      key pair as sec :<br>
      0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      uncompressed<br>
      &nbsp;:<br>
      0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      hash160<br>
      &nbsp;: 751e76e8199196d454941c45d1b3a323f1433bd6<br>
      uncompressed<br>
      &nbsp;: 91b24bf9f5288532960ac687abb035127b1d28a5<br>
      Litecoin address : LVuDpNCSSj6pQ7t9Pv6d6sUkLKoqDEVUnJ<br>
      uncompressed<br>
      &nbsp;: LYWKqJhtPeGyBAw7WC8R3F7ovxtzAiubdM<br>
      Dogecoin WIF:<br>
      $ ku -nD -W 1<br>
      QNcdLVw8fHkixm6NNyN6nVwxKek4u7qrioRbQmjxac5TVoTtZuot<br>
      From public pair (on Testnet):<br>
      $ ku -nT<br>
55066263022277343669578718895168534326250603453777594175500187360389116729240,ev<br>
      en<br>
      input<br>
      &nbsp;:<br>
      550662630222773436695787188951685343262506034537775941755001873603<br>
      89116729240,even<br>
      network<br>
      &nbsp;: Bitcoin testnet<br>
      public pair x<br>
      &nbsp;:<br>
      352<br>
      &nbsp;| Appendix F: pycoin, ku, and tx<br>
55066263022277343669578718895168534326250603453777594175500187360389116729240<br>
      public pair y<br>
      &nbsp;:<br>
32670510020758816978083085130507043184471273380659243275938904335757337482424<br>
      x as hex<br>
      &nbsp;:<br>
      79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      y as hex<br>
      &nbsp;:<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      y parity<br>
      &nbsp;: even<br>
      key pair as sec<br>
      &nbsp;:<br>
      0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      uncompressed<br>
      &nbsp;:<br>
      0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798<br>
      483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8<br>
      hash160<br>
      &nbsp;: 751e76e8199196d454941c45d1b3a323f1433bd6<br>
      uncompressed<br>
      &nbsp;: 91b24bf9f5288532960ac687abb035127b1d28a5<br>
      Bitcoin testnet address : mrCDrCybB6J1vRfbwM5hemdJz73FwDBC8r<br>
      uncompressed<br>
      &nbsp;: mtoKs9V381UAhUia3d7Vb9GNak8Qvmcsme<br>
      From hash160:<br>
      $ ku 751e76e8199196d454941c45d1b3a323f1433bd6<br>
      input<br>
      &nbsp;:<br>
      &nbsp;751e76e8199196d454941c45d1b3a323f1433bd6<br>
      network<br>
      &nbsp;:<br>
      &nbsp;Bitcoin<br>
      hash160<br>
      &nbsp;:<br>
      &nbsp;751e76e8199196d454941c45d1b3a323f1433bd6<br>
      Bitcoin address<br>
      &nbsp;:<br>
      &nbsp;1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH<br>
      As a Dogecoin address:<br>
      $ ku -nD 751e76e8199196d454941c45d1b3a323f1433bd6<br>
      input<br>
      &nbsp;:<br>
      &nbsp;751e76e8199196d454941c45d1b3a323f1433bd6<br>
      network<br>
      &nbsp;:<br>
      &nbsp;Dogecoin<br>
      hash160<br>
      &nbsp;:<br>
      &nbsp;751e76e8199196d454941c45d1b3a323f1433bd6<br>
      Dogecoin address<br>
      &nbsp;:<br>
      &nbsp;DFpN6QqFfUm3gKNaxN6tNcab1FArL9cZLE<br>
      Transaction Utility (TX)<br>
      The command-line utility tx will display transactions in human-readable
      form, fetch<br>
      base transactions from pycoin’s transaction cache or from web services
      (block‐<br>
      chain.info, blockcypher.com, blockr.io and chain.so are currently
      supported), merge<br>
      transactions, add or delete inputs or outputs, and sign transactions.<br>
      Following are some examples.<br>
      View the famous “pizza” transaction:<br>
      $ tx 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a<br>
      warning: consider setting environment variable
      PYCOIN_CACHE_DIR=~/.pycoin_cache<br>
      to cache transactions fetched via web services<br>
      warning: no service providers found for get_tx; consider setting
      environment<br>
      variable PYCOIN_BTC_PROVIDERS<br>
      pycoin, ku, and tx<br>
      &nbsp;|<br>
      &nbsp;353<br>
      usage: tx [-h] [-t TRANSACTION_VERSION] [-l LOCK_TIME] [-n NETWORK] [-a]<br>
      [-i address] [-f path-to-private-keys] [-g GPG_ARGUMENT]<br>
      [--remove-tx-in tx_in_index_to_delete]<br>
      [--remove-tx-out tx_out_index_to_delete] [-F transaction-fee] [-u]<br>
      [-b BITCOIND_URL] [-o path-to-output-file]<br>
      argument [argument ...]<br>
      tx: error: can't find Tx with id<br>
      49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a<br>
      Oops! We don’t have web services set up. Let’s do that now:<br>
      $ PYCOIN_CACHE_DIR=~/.pycoin_cache<br>
      $ PYCOIN_BTC_PROVIDERS="block.io blockchain.info blockexplorer.com"<br>
      $ export PYCOIN_CACHE_DIR PYCOIN_BTC_PROVIDERS<br>
      It’s not done automatically so a command-line tool won’t leak potentially
      private<br>
      information about what transactions you’re interested in to a third-party
      website. If<br>
      you don’t care, you could put these lines into your .profile.<br>
      Let’s try again:<br>
      $ tx 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a<br>
      Version: 1 tx hash<br>
      49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a 159 bytes<br>
      TxIn count: 1; TxOut count: 1<br>
      Lock time: 0 (valid anytime)<br>
      Input:<br>
      0:<br>
      &nbsp;(unknown) from<br>
      1e133f7de73ac7d074e2746a3d6717dfc99ecaa8e9f9fade2cb8b0b20a5e0441:0<br>
      Output:<br>
      0: 1CZDM6oTttND6WPdt3D6bydo7DYKzd9Qik receives 10000000.00000 mBTC<br>
      Total output 10000000.00000 mBTC<br>
      including unspents in hex dump since transaction not fully signed<br>
      010000000141045e0ab2b0b82cde-<br>
faf9e9a8ca9ec9df17673d6a74e274d0c73ae77d3f131e000000004a493046022100a7f26eda8749<br>
31999c90f87f01ff1ffc76bcd058fe16137e0e63fdb6a35c2d78022100a61e9199238eb73f07c8f2<br>
09504c84b80f03e30ed8169edd44f80ed17ddf451901ffffffff010010a5d4e80000001976a9147e<br>
      c1003336542cae8bded8909cdd6b5e48ba0ab688ac00000000<br>
      ** can't validate transaction as source transactions missing<br>
      The final line appears because to validate the transactions’ signatures,
      you technically<br>
      need the source transactions. So let’s add -a to augment the transactions
      with source<br>
      information:<br>
      $ tx -a 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a<br>
      warning: transaction fees recommendations casually calculated and
      estimates may<br>
      be incorrect<br>
      warning: transaction fee lower than (casually calculated) expected value
      of 0.1<br>
      mBTC, transaction might not propogate<br>
      Version: 1 tx hash<br>
      49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a 159 bytes<br>
      TxIn count: 1; TxOut count: 1<br>
      354<br>
      &nbsp;|<br>
      &nbsp;Appendix F: pycoin, ku, and tx<br>
      Lock time: 0 (valid anytime)<br>
      Input:<br>
      0: 17WFx2GQZUmh6Up2NDNCEDk3deYomdNCfk from<br>
      1e133f7de73ac7d074e2746a3d6717dfc99ecaa8e9f9fade2cb8b0b20a5e0441:0<br>
      10000000.00000 mBTC sig ok<br>
      Output:<br>
      0: 1CZDM6oTttND6WPdt3D6bydo7DYKzd9Qik receives 10000000.00000 mBTC<br>
      Total input 10000000.00000 mBTC<br>
      Total output 10000000.00000 mBTC<br>
      Total fees<br>
      &nbsp;0.00000 mBTC<br>
      010000000141045e0ab2b0b82cde-<br>
faf9e9a8ca9ec9df17673d6a74e274d0c73ae77d3f131e000000004a493046022100a7f26eda8749<br>
31999c90f87f01ff1ffc76bcd058fe16137e0e63fdb6a35c2d78022100a61e9199238eb73f07c8f2<br>
09504c84b80f03e30ed8169edd44f80ed17ddf451901ffffffff010010a5d4e80000001976a9147e<br>
      c1003336542cae8bded8909cdd6b5e48ba0ab688ac00000000<br>
      all incoming transaction values validated<br>
      Now, let’s look at unspent outputs for a specific address (UTXO). In block
      #1, we see a<br>
      coinbase transaction to 12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX. Let’s use<br>
      fetch_unspent to find all coins in this address:<br>
      $ fetch_unspent 12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX<br>
      a3a6f902a51a2cbebede144e48a88c05e608c2cce28024041a5b9874013a1e2a/<br>
      0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/333000<br>
      cea36d008badf5c7866894b191d3239de9582d89b6b452b596f1f1b76347f8cb/<br>
      31/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/10000<br>
      065ef6b1463f552f675622a5d1fd2c08d6324b4402049f68e767a719e2049e8d/<br>
      86/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/10000<br>
a66dddd42f9f2491d3c336ce5527d45cc5c2163aaed3158f81dc054447f447a2/0/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/10000<br>
ffd901679de65d4398de90cefe68d2c3ef073c41f7e8dbec2fb5cd75fe71dfe7/0/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/100<br>
      d658ab87cc053b8dbcfd4aa2717fd23cc3edfe90ec75351fadd6a0f7993b461d/<br>
      5/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/911<br>
      36ebe0ca3237002acb12e1474a3859bde0ac84b419ec4ae373e63363ebef731c/<br>
      1/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/100000<br>
fd87f9adebb17f4ebb1673da76ff48ad29e64b7afa02fda0f2c14e43d220fe24/0/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/1<br>
dfdf0b375a987f17056e5e919ee6eadd87dad36c09c4016d4a03cea15e5c05e3/1/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/1337<br>
cb2679bfd0a557b2dc0d8a6116822f3fcbe281ca3f3e18d3855aa7ea378fa373/0/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/1337<br>
d6be34ccf6edddc3cf69842dce99fe503bf632ba2c2adb0f95c63f6706ae0c52/1/76a914119b098<br>
      e2e980a229e139a9ed01a469e518e6f2688ac/2000000<br>
0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098/0/410496b538e85<br>
3519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141<br>
      781e62294721166bf621e73a82cbf2342c858eeac/5000000000<br>
      pycoin, ku, and tx<br>
      &nbsp;|<br>
      &nbsp;355<br>
      APPENDIX G<br>
      Bitcoin Explorer (bx) Commands<br>
      Bitcoin Explorer (bx) is a command-line tool that offers a variety of
      commands for<br>
      key management and transaction construction. It is part of the libbitcoin
      bitcoin<br>
      library.<br>
      Usage: bx COMMAND [--help]<br>
      Info: The bx commands are:<br>
      address-decode<br>
      address-embed<br>
      address-encode<br>
      address-validate<br>
      base16-decode<br>
      base16-encode<br>
      base58-decode<br>
      base58-encode<br>
      base58check-decode<br>
      base58check-encode<br>
      base64-decode<br>
      base64-encode<br>
      bitcoin160<br>
      bitcoin256<br>
      btc-to-satoshi<br>
      ec-add<br>
      ec-add-secrets<br>
      ec-multiply<br>
      ec-multiply-secrets<br>
      ec-new<br>
      ec-to-address<br>
      ec-to-public<br>
      ec-to-wif<br>
      fetch-balance<br>
      fetch-header<br>
      fetch-height<br>
      357<br>
      fetch-history<br>
      fetch-stealth<br>
      fetch-tx<br>
      fetch-tx-index<br>
      hd-new<br>
      hd-private<br>
      hd-public<br>
      hd-to-address<br>
      hd-to-ec<br>
      hd-to-public<br>
      hd-to-wif<br>
      help<br>
      input-set<br>
      input-sign<br>
      input-validate<br>
      message-sign<br>
      message-validate<br>
      mnemonic-decode<br>
      mnemonic-encode<br>
      ripemd160<br>
      satoshi-to-btc<br>
      script-decode<br>
      script-encode<br>
      script-to-address<br>
      seed<br>
      send-tx<br>
      send-tx-node<br>
      send-tx-p2p<br>
      settings<br>
      sha160<br>
      sha256<br>
      sha512<br>
      stealth-decode<br>
      stealth-encode<br>
      stealth-public<br>
      stealth-secret<br>
      stealth-shared<br>
      tx-decode<br>
      tx-encode<br>
      uri-decode<br>
      uri-encode<br>
      validate-tx<br>
      watch-address<br>
      wif-to-ec<br>
      wif-to-public<br>
      wrap-decode<br>
      wrap-encode<br>
      For more information, see the Bitcoin Explorer homepage and Bitcoin
      Explorer user<br>
      documentation.<br>
      358<br>
      &nbsp;|<br>
      &nbsp;Appendix G: Bitcoin Explorer (bx) Commands<br>
      Examples of bx Command Use<br>
      Let’s look at some examples of using Bitcoin Explorer commands to
      experiment with<br>
      keys and addresses.<br>
      Generate a random “seed” value using the seed command, which uses the
      operating<br>
      system’s random number generator. Pass the seed to the ec-new command to
      generate<br>
      a new private key. We save the standard output into the file private_key:<br>
      $ bx seed | bx ec-new &gt; private_key<br>
      $ cat private_key<br>
      73096ed11ab9f1db6135857958ece7d73ea7c30862145bcc4bbc7649075de474<br>
      Now, generate the public key from that private key using the ec-to-public
      com‐<br>
      mand. We pass the private_key file into the standard input and save the
      standard out‐<br>
      put of the command into a new file public_key:<br>
      $ bx ec-to-public &lt; private_key &gt; public_key<br>
      $ cat public_key<br>
      02fca46a6006a62dfdd2dbb2149359d0d97a04f430f12a7626dd409256c12be500<br>
      We can reformat the public_key as an address using the ec-to-address
      command.<br>
      We pass the public_key into standard input:<br>
      $ bx ec-to-address &lt; public_key<br>
      17re1S4Q8ZHyCP8Kw7xQad1Lr6XUzWUnkG<br>
      Keys generated in this manner produce a type-0 nondeterministic wallet.
      That means<br>
      that each key is generated from an independent seed. Bitcoin Explorer
      commands<br>
      can also generate keys deterministically, in accordance with BIP-32. In
      this case, a<br>
      “master” key is created from a seed and then extended deterministically to
      produce a<br>
      tree of subkeys, resulting in a type-2 deterministic wallet.<br>
      First, we use the seed and hd-new commands to generate a master key that
      will be<br>
      used as the basis to derive a hierarchy of keys:<br>
      $ bx seed &gt; seed<br>
      $ cat seed<br>
      eb68ee9f3df6bd4441a9feadec179ff1<br>
      $ bx hd-new &lt; seed &gt; master<br>
      $ cat master<br>
      xprv9s21ZrQH143K2BEhMYpNQoUvAgiEjArAVaZaCTgsaGe6LsAnwu-<br>
      beiTcDzd23mAoyizm9cApe51gNfLMkBqkYoWWMCRwzfuJk8RwF1SVEpAQ<br>
      We now use the hd-private command to generate a hardened “account” key and
      a<br>
      sequence of two private keys within the account:<br>
      $ bx hd-private --hard &lt; master &gt; account<br>
      $ cat account<br>
      xprv9vkDLt81dTKjwHB8fsVB5QK8cGnzveChzSrtCfvu3aMWvQaThp59ueu-<br>
      fuyQ8Qi3qpjk4aKsbmbfxwcgS8PYbgoR2NWHeLyvg4DhoEE68A1n<br>
      Bitcoin Explorer (bx) Commands<br>
      &nbsp;|<br>
      &nbsp;359<br>
      $ bx hd-private --index 0 &lt; account<br>
xprv9xHfb6w1vX9xgZyPNXVgAhPxSsEkeRcPHEUV5iJcVEsuUEACvR3NRY3fpGhcnBiDbvG4LgndirD-<br>
      sia1e9F3DWPkX7Tp1V1u97HKG1FJwUpU<br>
      $ bx hd-private --index 1 &lt; account<br>
xprv9xHfb6w1vX9xjc8XbN4GN86jzNAZ6xHEqYxzbLB4fzHFd6VqCLPGRZFsdjsuMVERadbgDb-<br>
      ziCRJru9n6tzEWrASVpEdrZrFidt1RDfn4yA3<br>
      Next, we use the hd-public command to generate the corresponding sequence
      of two<br>
      public keys:<br>
      $ bx hd-public --index 0 &lt; account<br>
      xpub6BH1zcTuk-<br>
tiFu43rUZ2gXqLgzu5F3tLEeTQ5t6iE3aQtM2VMTxMcyLN9fYHiGhGpQe9QQYmqL2eYPFJ3vezHz5wza<br>
      SW4FiGrseNDR4LKqTy<br>
      $ bx hd-public --index 1 &lt; account<br>
      xpub6BH1zcTuktiFx6CzhPbGjG3UYQ13WR16CmtbPiagEKpEVtpyjshWy-<br>
      MaMV1cn7nUPUkgQHPVXJVqsrA8xWbGQDhohEcDFTEYMvYzwRD7Juf8<br>
      The public keys can also be derived from their corresponding private keys
      using the<br>
      hd-to-public Команда:<br>
      $ bx hd-private --index 0 &lt; account | bx hd-to-public<br>
      xpub6BH1zcTuk-<br>
tiFu43rUZ2gXqLgzu5F3tLEeTQ5t6iE3aQtM2VMTxMcyLN9fYHiGhGpQe9QQYmqL2eYPFJ3vezHz5wza<br>
      SW4FiGrseNDR4LKqTy<br>
      $ bx hd-private --index 1 &lt; account | bx hd-to-public<br>
      xpub6BH1zcTuktiFx6CzhPbGjG3UYQ13WR16CmtbPiagEKpEVtpyjshWy-<br>
      MaMV1cn7nUPUkgQHPVXJVqsrA8xWbGQDhohEcDFTEYMvYzwRD7Juf8<br>
      We can generate a practically limitless number of keys in a deterministic
      chain, all<br>
      derived from a single seed. This technique is used in many wallet
      applications to gen‐<br>
      erate keys that can be backed up and restored with a single seed value.
      This is easier<br>
      than having to back up the wallet with all its randomly generated keys
      every time a<br>
      new key is created.<br>
      The seed can be encoded using the mnemonic-encode Команда:<br>
      $ bx hd-mnemonic &lt; seed &gt; words<br>
      adore repeat vision worst especially veil inch woman cast recall dwell
      appreci-<br>
      ate<br>
      The seed can then be decoded using the mnemonic-decode Команда:<br>
      $ bx mnemonic-decode &lt; words<br>
      eb68ee9f3df6bd4441a9feadec179ff1<br>
      Mnemonic encoding can make the seed easier to record and even remember.<br>
      360<br>
      &nbsp;|<br>
      &nbsp;Appendix G: Bitcoin Explorer (bx) Commands<br>
      Index<br>
      Symbols<br>
      $ symbol, 33<br>
      A<br>
      accounts receivable (AR), 151<br>
      acknowledgments, xviii-xxii<br>
      addresses (see also keys and addresses)<br>
      algorithms used to create, 65<br>
      Base58 and Base58check encoding, 66-70<br>
      bitcoin wallet quick start example, 9<br>
      change addresses, 20<br>
      multisig addresses, 81, 274<br>
      security of, 10<br>
      vanity addresses, 82-88<br>
      application-specific integrated circuits (ASIC),<br>
      27<br>
      asymmetric cryptography, 57<br>
      ATMs, locating, 11<br>
      attribution, xvi<br>
      authentication, 191<br>
      authentication paths, 203<br>
      autogen/configure/make system, 35<br>
      (see also Bitcoin Core)<br>
      B<br>
      balanced trees, 203<br>
      balances, 119<br>
      Base58 and Base58check encoding, 66-70<br>
      Basics of Lightning Technology (BOLT), 297<br>
      binary hash trees (see merkle trees)<br>
      bitcoin<br>
      benefits of, xiii-xiv, 11<br>
      defined, 1-2<br>
      getting started, 6-14<br>
      history of, 4<br>
      overview of, 15-30<br>
      use cases, 5-6<br>
      Bitcoin Block Explorer, 16<br>
      Bitcoin Core<br>
      alternatives to, 51-53<br>
      architecture, 32<br>
      Bitcoin Core API, 43-51<br>
      exploring and decoding transactions, 45<br>
      exploring blocks, 47<br>
      RPC commands, 43<br>
      status information, 44<br>
      using programmatic interface, 48<br>
      compiling from source code, 32-37<br>
      build configuration, 34<br>
      core executables, 37<br>
      downloading, 32<br>
      version selection, 33<br>
      reference implementation, 31<br>
      running core nodes, 38-43<br>
      configuring, 39<br>
      database options, 41<br>
      first run, 39<br>
      Bitcoin Explorer (bx) commands, 357-360<br>
      bitcoin improvement proposals<br>
      Address Format for P2SH (BIP-13), 153<br>
      Block v2, Height in Coinbase (BIP-34), 263<br>
      CHECKHASHVERIFY (BIP-17), 225<br>
      CHECKLOCKTIMEVERIFY (BIP-65), 158,<br>
      264<br>
      CHECKSEQUENCEVERIFY (BIP-112),<br>
      160<br>
      Encrypted Private Keys (BIP-38), 80, 89<br>
      361<br>
      Hierarchical Deterministic Wallets (BIP-32/<br>
      BIP-44), 31, 96<br>
      Mnemonic Code Words (BIP-39), 31, 97,<br>
      99-105<br>
      Multipurpose HD Wallet Structure<br>
      (BIP-43), 97<br>
      Pay to Script Hash (BIP-16), 81, 225<br>
      Peer Authentication (BIP-150), 191<br>
      Peer-to-Peer Communication Encryption<br>
      (BIP-151), 191<br>
      Relative lock-time using consensus-<br>
      enforced sequence numbers (BIP-68),<br>
      160<br>
      repository of, 324<br>
      snapshot of, 324-327<br>
      Strict DER signatures (BIP-66), 264<br>
      types of, 323<br>
      Version bits with timeout and delay (BIP-9),<br>
      264<br>
      bitcoin network<br>
      Bitcoin Relay Networks, 176<br>
      bloom filters, 185-190<br>
      defined, 171<br>
      encrypted connections, 191<br>
      extended network activities, 173<br>
      extended network discovery, 176-180<br>
      full nodes, 180<br>
      node types and roles, 172-173<br>
      peer-to-peer architecture, 171<br>
      SPV nodes, 183-185<br>
      syncing the blockchain, 181<br>
      transaction pools, 192<br>
      bitcoin nodes<br>
      defined, 25<br>
      full nodes, 181, 189<br>
      mining nodes, 173, 219<br>
      network discovery, 176-180<br>
      running core nodes, 38-43<br>
      SPV nodes, 183-192, 207<br>
      types and roles, 172-173<br>
      bitcoin whitepaper, 31, 305-316<br>
      BitcoinAverage, 12<br>
      bitcoinfees (third-party service), 128<br>
      Bitcore, 343-345<br>
      Bitmask Sighash Modes, 143<br>
      BitPay Insight, 16<br>
      bloat, 155<br>
      blockchain (the)<br>
      block headers, 197, 227<br>
      362<br>
      &nbsp;| Index<br>
      block identifiers, 197<br>
      block structure, 196<br>
      blockchain forks, 240-247<br>
      full blockchain nodes, 180<br>
      genesis block, 28, 180, 198, 225<br>
      linking blocks in the blockchain, 200<br>
      merkle trees, 201-207, 227<br>
      nonpayment data recording, 155<br>
      overview of, 195<br>
      overview of mining, 26-29<br>
      syncing the blockchain, 181<br>
      test blockchains, 207-211<br>
      blockchain applications<br>
      benefits of bitcoin system, 275<br>
      building blocks for (primitives), 276<br>
      colored coins, 278-283<br>
      Counterparty, 283<br>
      examples of, 278<br>
      payment (state) channels, 284-297<br>
      routed payment channels, 297-304<br>
      (see also Lightning Network)<br>
      warnings and cautions, xvi<br>
      blockchain bloat, 155<br>
      blockchain explorer sites, 15<br>
      blockchain.info, 16<br>
      BlockCypher Explorer, 16<br>
      blocks<br>
      aggregating transactions into, 220-226<br>
      assembling and selecting chains of, 239-247<br>
      block hash, 47, 195, 197<br>
      block height, 47, 195, 197<br>
      candidate blocks, 28, 220<br>
      exploring with Bitcoin Core API, 47<br>
      genesis block, 28, 180, 195, 198, 225<br>
      headers, 197, 227<br>
      linking blocks in the blockchain, 200<br>
      mining transactions in, 27<br>
      new block validation, 238<br>
      parent blocks, 195, 227<br>
      structure of, 196<br>
      bloom filters, 185-190<br>
      brainwallets, 100<br>
      build documentation, 34<br>
      (see also Bitcoin Core)<br>
      Byzantine Generals' Problem, 4<br>
      C<br>
      candidate blocks, 28, 220<br>
      central trusted authority, 4, 15, 213<br>
      chain of transactions, 19<br>
      change addresses, 20<br>
      change, making, 20, 120<br>
      charitable donations, 5, 130, 143<br>
      Check Lock Time Verify (CLTV), 158-160<br>
      CHECKHASHVERIFY (CHV), 225<br>
      CHECKMULTISIG bug workaround, 150<br>
      CHECKSEQUENCEVERIFY (CSV), 162<br>
      child key derivation (CKD), 106<br>
      clearing, 14<br>
      (see also confirmations)<br>
      clients, libraries, and toolkits, 51-53<br>
      cloning source code, 33<br>
      code examples, obtaining and using, xv-xvi, 32<br>
      Coin ATM Radar, 11<br>
      coinbase transactions, 120, 196, 221-226<br>
      coinbase data, 225<br>
      rewards and fees, 223<br>
      structure of, 224<br>
      cold storage, 7, 110, 273<br>
      (see also storage)<br>
      collisions, 228<br>
      colored coins, 278-283<br>
      comments and questions, xvii<br>
      commitment, 141<br>
      Compact Block optimization, 176<br>
      conditional clauses, 164-167<br>
      configuration options, 40<br>
      (see also Bitcoin Core)<br>
      confirmations (see also mining and consensus;<br>
      transactions)<br>
      bitcoin wallet quick start example, 14<br>
      of large-value transactions, 255<br>
      role in transactions, 28<br>
      of small-value transactions, 26<br>
      consensus (see mining and consensus)<br>
      contact information, xvii<br>
      core executables, 37<br>
      (see also Bitcoin Core)<br>
      Counterparty, 283<br>
      cryptographic puzzles, 132<br>
      cryptography (see also keys and addresses)<br>
      asymmetric, 57<br>
      defined, 55<br>
      elliptic curve cryptography, 57, 60-63<br>
      currency creation, 215<br>
      currency exchanges, 11<br>
      D<br>
      data recording (nonpayment data), 155<br>
      decentralized systems<br>
      benefits of, xiv<br>
      bitcoin as, xiii, 270<br>
      bitcoin mining and, 213<br>
      bitcoin overview, 15-30<br>
      vs. centralized, 3<br>
      consensus in, 4, 217<br>
      in nature, xiv<br>
      security of, 269<br>
      deflationary money, 216<br>
      denial-of-service attacks, 131, 254 (see also<br>
      security)<br>
      deserialization, 122<br>
      deterministic initialization, 145<br>
      deterministic wallets, 94<br>
      (see also wallets)<br>
      development environment<br>
      consensus software development, 266<br>
      setup (see Bitcoin Core)<br>
      test blockchains and, 211<br>
      digital asset executors, 274<br>
      digital asset management, 278<br>
      digital currencies<br>
      benefits of bitcoin, 11<br>
      bitcoin vs. others, xiii<br>
      cryptocurrency, 56<br>
      currency exchanges, 11<br>
      prior to bitcoin, 3<br>
      digital keys (see keys and addresses)<br>
      digital notary services, 155, 278<br>
      digital ownership, 284<br>
      digital signatures<br>
      algorithm used, 138<br>
      asymmetric cryptography and, 57<br>
      defined, 139<br>
      how they work, 139<br>
      purpose of, 55<br>
      purposes of, 139<br>
      randomness in, 145<br>
      signature hash types, 141<br>
      verifying, 141<br>
      Distinguished Encoding Rules (DER), 140<br>
      distributed computing, 4<br>
      distributed version control systems, 33<br>
      DOCPROOF prefix, 156<br>
      documentation, 34<br>
      double-spend problem, 4<br>
      Index<br>
      &nbsp;|<br>
      &nbsp;363<br>
      dumpprivkey command, 59<br>
      dynamic fees, 127<br>
      E<br>
      Electrum wallet, 100<br>
      (see also wallets)<br>
      elliptic curve cryptography, 57, 60-63<br>
      Elliptic Curve Digital Signature Algorithm<br>
      (ECDSA), 138, 143<br>
      emergent consensus, 217<br>
      encryption, 55, 191 (see also keys and<br>
      addresses)<br>
      Enhanced Padded-Order-Based Coloring<br>
      (EPOBC), 279<br>
      entropy<br>
      os.urandom (see random numbers)<br>
      random number generation, 59, 79, 145<br>
      EQUAL opcode, 166<br>
      EQUALVERIFY opcode, 166<br>
      Ethereum Virtual Machine (EVM), 283<br>
      exchange rates<br>
      determining, 11, 16<br>
      floating, 12<br>
      listing services, 11<br>
      extended keys, 108<br>
      extrinsic asset management, 278, 283<br>
      F<br>
      Falcon Relay Network, 176<br>
      Fast Internet Bitcoin Relay Engine (FIBRE), 176<br>
      fees<br>
      dynamic fees, 127<br>
      fee relay policies, 127<br>
      fee sniping, 163<br>
      mining rewards, 214<br>
      static fees, 128<br>
      transaction fees, 18, 126, 213, 223<br>
      floating exchange rate, 12<br>
      flooding technique, 25<br>
      flow control, 164-167<br>
      forks<br>
      blockchain fork events, 240-247<br>
      changing consensus rules, 256-266<br>
      contentious hard forks, 260<br>
      diverging miners and difficulty, 259<br>
      hard forks, 256<br>
      soft fork activation, 262<br>
      soft fork drawbacks, 262<br>
      soft forks, 261<br>
      364<br>
      &nbsp;| Index<br>
      software forks, 258<br>
      fractional values, 18<br>
      full indexing option, 41<br>
      full-node clients, 7, 172, 180<br>
      G<br>
      generator point, 60, 63<br>
      genesis block, 28, 180, 195, 225<br>
      getting started<br>
      acquiring bitcoin, 10<br>
      confirmations, 14<br>
      exchange rates, 11<br>
      quick start example, 8-10<br>
      sending and receiving bitcoin, 12<br>
      wallet selection, 6-8<br>
      warnings and cautions, xvi<br>
      GitHub bitcoin page, 32<br>
      guard clauses, 165<br>
      H<br>
      halvings, 223<br>
      hard forks, 260, 267<br>
      hardened derivation, 112<br>
      hardware wallets, 97, 110, 273 (see also wallets)<br>
      Hash Time Lock Contracts (HTLC), 296<br>
      headers, 197, 227<br>
      hierarchical deterministic (HD) wallets, 94, 96,<br>
      106, 113<br>
      (see also wallets)<br>
      I<br>
      IF clauses, 165<br>
      inputs (see outputs and inputs)<br>
      intended audience, xiii<br>
      issuance rate, 215<br>
      J<br>
      JBOK wallets, 94<br>
      (see also wallets)<br>
      K<br>
      key derivation methods, 94<br>
      key utility (ku), 347<br>
      key-stretching function, 101<br>
      keychains, 93<br>
      keys and addresses (see also public and private<br>
      keys)<br>
      advanced forms, 80-91<br>
      encrypted private keys, 80<br>
      paper wallets, 88<br>
      pay-to-script hash and multisig<br>
      addresses, 81<br>
      vanity addresses, 82<br>
      bitcoin addresses, 64-76<br>
      Base58 and Base58check encoding, 66<br>
      key formats, 70<br>
      implementing in Python, 76-79<br>
      overview of, 55-64<br>
      elliptic curve cryptography, 60<br>
      key pairs, 57<br>
      private and public key pairs, 57<br>
      private key generation, 58<br>
      public key calculation, 60<br>
      public key cryptography, 56<br>
      public key generation, 63<br>
      warnings and cautions, xvi<br>
      L<br>
      libraries, clients, and toolkits, 51-53<br>
      Lightning Network<br>
      basic example, 298<br>
      benefits of, 303<br>
      defined, 297<br>
      transport and routing, 301<br>
      lightweight clients, 8, 172<br>
      locking scripts, 121, 132<br>
      M<br>
      mainnet, 207<br>
      (see also blockchain (the))<br>
      malleability, 46<br>
      Median-Tme-Past, 162<br>
      memory pools (mempools), 192, 220<br>
      merkle trees, 201-207, 227<br>
      milli-bitcoin, 18<br>
      millibits, 17<br>
      mining and consensus<br>
      aggregating transactions into blocks,<br>
      220-226<br>
      assembling and selecting chains of blocks,<br>
      239-247<br>
      blockchain forks, 240<br>
      bitcoin economics and currency creation,<br>
      215<br>
      coinbase transactions, 120<br>
      consensus attacks, 253-256<br>
      consensus rules<br>
      changing, 256-262<br>
      satisfying, 2<br>
      security provided by, 26<br>
      consensus software development, 266<br>
      constructing block headers, 227<br>
      decentralized consensus, 213, 217<br>
      defined, 228<br>
      emergent consensus, 217<br>
      hashing power race, 247-253<br>
      independent transaction verification, 218<br>
      mining farms and pools, 27<br>
      mining nodes, 173, 219<br>
      mining rewards and fees, 214<br>
      mining the block, 228-238<br>
      retargeting to adjust difficulty, 235<br>
      successful completion, 237<br>
      target representation, 235<br>
      new block validation, 238<br>
      overview of, 26-29<br>
      Proof-of-Work algorithm, 4, 27, 173, 214,<br>
      220, 228-234<br>
      purpose of, 213<br>
      rewards and fees, 126, 223<br>
      security and consensus, 271<br>
      mining pools, 250-253<br>
      benefits of, 250<br>
      defined, 27<br>
      managed pools, 252<br>
      operation of, 28, 251<br>
      peer-to-peer pools (P2Pool), 252<br>
      minrelaytxfee option, 127<br>
      mnemonic code words, 94, 97, 99-105<br>
      money supply, 215<br>
      multisig addresses, 81, 274<br>
      multisignature scripts, 149, 167<br>
      N<br>
      Nakamoto, Satoshi, 4, 31, 305-316<br>
      nLocktime field, 157<br>
      nodes (see bitcoin nodes)<br>
      nonce values, 225, 249<br>
      nondeterministic wallets, 94<br>
      (see also wallets)<br>
      nonpayment data, 155<br>
      nSequence field, 160<br>
      O<br>
      off-blockchain transactions, 270<br>
      offshore contract services, 5<br>
      Index<br>
      &nbsp;|<br>
      &nbsp;365<br>
      opcodes<br>
      EQUAL, 166<br>
      EQUALVERIFY, 166<br>
      redefinition by soft forks, 261<br>
      VERIFY, 165<br>
      Open Assets, 279<br>
      open source licenses, xvi, 4, 31, 316<br>
      OpenSSL cryptographic library, 64<br>
      orphan pools, 192<br>
      outputs and inputs<br>
      basics of, 18<br>
      creating outputs, 24<br>
      defined, 21 наput components, 123<br>
      input serialization, 125<br>
      locating and tracking inputs, 22<br>
      output characteristics, 119<br>
      output parts, 121<br>
      outputs defined, 119<br>
      structure of, 122<br>
      P<br>
      paper wallets, 88-91, 273 (see also wallets)<br>
      parent blocks, 195, 227<br>
      parsing, 122<br>
      passphrases, 102, 104<br>
      passwords<br>
      core node first run, 39<br>
      creating, 39<br>
      encrypted private keys, 80<br>
      survivability and, 274<br>
      Pay-to-Public-Key-Hash (P2PKH), 131, 136<br>
      Pay-to-Script-Hash (P2SH)<br>
      addresses, 153<br>
      benefits of, 154<br>
      coinbase data, 225<br>
      import/export example, 151<br>
      multisig addresses and, 81<br>
      redeem scripts and validation, 154<br>
      payment (state) channels<br>
      asymmetric revocable commitments,<br>
      292-296<br>
      building blocks (primitives) used in, 278<br>
      concept of, 284<br>
      defined, 284<br>
      example of, 286-288<br>
      Hash Time Lock Contracts (HTLC), 296<br>
      making trustless channels, 289-292<br>
      terminology, 285<br>
      366<br>
      &nbsp;|<br>
      &nbsp;Index<br>
      payment requests, 17<br>
      PBKDF2 function, 101<br>
      peer-to-peer (P2P), 171<br>
      Peer-to-Peer authentication and encryption,<br>
      191<br>
      peer-to-peer pools (P2Pool), 252<br>
      pool operators, 252<br>
      (see also mining pools)<br>
      primitives, 276<br>
      privacy, maintaining, 11, 185-192<br>
      programmable money, 131<br>
      programmatic interface, 48-51<br>
      Proof of Existence, 156, 278<br>
      Proof-of-Work algorithm, 4, 27, 173, 214, 220,<br>
      228-234<br>
      propagation<br>
      address propagation and discovery, 178<br>
      flooding technique, 25<br>
      process of, 25<br>
      relay networks and, 176<br>
      public and private keys (see also keys and<br>
      addresses)<br>
      child key derivation (CKD), 106<br>
      compressed private keys, 75<br>
      compressed public keys, 73<br>
      encrypted private keys, 80<br>
      extended keys, 108<br>
      hardened child key derivation, 112<br>
      key pairs, 56<br>
      ephemeral, 144<br>
      private key formats, 70<br>
      public child key derivation, 109<br>
      public key formats, 72<br>
      pybitcointools, 76<br>
      pycoin library, 347<br>
      Q<br>
      QR codes<br>
      bitcoin wallet quick start example, 9<br>
      payment requests, 17<br>
      warnings and cautions, xvi, 17<br>
      R<br>
      random numbers<br>
      os.urandom (see entropy)<br>
      random number generation, 59, 79, 145<br>
      redeem scripts, 152, 154<br>
      reference implementation (see Bitcoin Core)<br>
      regtest (Regression Testing), 210<br>
      relative timelocks, 160-162<br>
      relay networks, 176<br>
      resource requirements, 38<br>
      RETURN operator, 155<br>
      risk, balancing and diversifying, 273<br>
      (see also security)<br>
      root of trust concept, 271<br>
      root seeds, 106<br>
      routed payment channels (see Lightning Net‐<br>
      work)<br>
      S<br>
      salts, 102<br>
      satoshi, xxx<br>
      Satoshi client, 31, 181<br>
      satoshis, 18, 119<br>
      scripting<br>
      complex script example, 167-169<br>
      data recording output, 155<br>
      flow control scripts, 164-167<br>
      locking scripts, 121, 132<br>
      multisignature scripts, 149-151<br>
      CHECKMULTISIG bug, 150<br>
      import/export example, 167<br>
      Pay-to-Script-Hash, 151-155<br>
      addresses, 153<br>
      benefits of, 154<br>
      import/export example, 151<br>
      redeem scripts and validation, 154<br>
      redeem scripts, 152<br>
      Script language operators, constants, and<br>
      symbols, 317-321<br>
      timelocks, 157-164<br>
      Check Lock Time Verify (CLTV), 158<br>
      defense against fee-sniping, 163<br>
      Median-Tme-Past, 162<br>
      nLocktime, 157<br>
      relative timelocks, 160<br>
      relative timelocks with CHECKSE‐<br>
      QUENCEVERIFY, 162<br>
      relative timelocks with nSequence, 160<br>
      uses for, 157<br>
      transactions and, 131-137<br>
      scriptPubKey, 121, 132<br>
      scriptSig, 132<br>
      security (see also warnings and cautions)<br>
      bitcoin addresses, 10<br>
      consensus attacks, 253-256<br>
      defense against fee-sniping, 163<br>
      denial-of-service attacks, 131, 254<br>
      locking and unlocking scripts, 136<br>
      maintaining privacy, 11, 185-192<br>
      passwords, 39, 80, 274<br>
      security principles, 269-272<br>
      user security best practices, 272-274<br>
      vanity addresses, 87<br>
      wallet selection, 6<br>
      segnet, 210<br>
      segwit (Segregated Witness), 210, 329-342<br>
      serialization<br>
      inputs, 125<br>
      outputs, 122<br>
      shell commands, 33<br>
      SIGHASH flags, 141<br>
      simple-payment-verification (SPV), 8, 29, 172,<br>
      183-185, 207<br>
      smart contracts, 283<br>
      sniping, 163<br>
      soft forks<br>
      activation, 262<br>
      defined, 261<br>
      drawbacks of, 262<br>
      redefinition of NOP codes, 261<br>
      source code, cloning, 33<br>
      (see also Bitcoin Core)<br>
      spending bitcoin (see also transactions)<br>
      bitcoin wallet quick start example, 12<br>
      defined, 19<br>
      double-spend problem, 4<br>
      simple-payment-verification (SPV), 29<br>
      stateless verification, 132<br>
      static fees, 128<br>
      storage<br>
      cold storage, 7, 110, 273<br>
      physical bitcoin storage, 273<br>
      survivability, 274<br>
      syncing, 181<br>
      T<br>
      targets, 231, 235-237<br>
      terminal applications, 33<br>
      testnet, 207-209<br>
      The Onion Routing network (Tor), 191<br>
      third-party API clients, 8, 51-53<br>
      timelocks<br>
      Check Lock Time Verify (CLTV), 158<br>
      defense against fee-sniping, 163<br>
      Median-Tme-Past, 162<br>
      Index<br>
      &nbsp;|<br>
      &nbsp;367<br>
      nLocktime, 157<br>
      relative timelocks, 160-162<br>
      uses for, 157<br>
      toolkits, libraries, and clients, 51-53<br>
      Tor network, 191<br>
      transaction IDs (txd), 46, 124<br>
      transaction IDs (txid), 189, 282, 338<br>
      transaction pools, 192, 220<br>
      transaction utility (TX), 353-355<br>
      transactions<br>
      advanced, 149-169<br>
      data recording output, 155<br>
      example, 167<br>
      flow control scripts, 164<br>
      multisignature scripts, 149, 167<br>
      Pay-to-Script-Hash, 151<br>
      timelocks, 157<br>
      aggregating into blocks, 220-226<br>
      behind the scenes details of, 118<br>
      coinbase transactions, 120, 196, 221-226<br>
      constructing, 22-26<br>
      database configuration options, 41<br>
      defined, 18, 21, 117<br>
      digital signatures and, 138-145<br>
      exploring with Bitcoin Core API, 45<br>
      higher-level abstractions, 145-148<br>
      independent verification of, 218<br>
      off blockchain, 270<br>
      orphaned, 192<br>
      outputs and inputs, 119-130<br>
      input components, 123<br>
      input serialization, 125<br>
      output characteristics, 119<br>
      output components, 121<br>
      structure of, 122<br>
      transaction fees, 126<br>
      overview of, 18-22<br>
      parsing, 122<br>
      scripts and Script language, 131-137,<br>
      317-321<br>
      valid and invalid, 134<br>
      warnings and cautions, xvi, 17<br>
      Turing incompleteness, 131<br>
      txindex option, 41<br>
      typographical conventions, xiv<br>
      U<br>
      unlocking scripts, 132<br>
      368<br>
      &nbsp;|<br>
      &nbsp;Index<br>
      unspent transaction outputs (UTXO), 119, 123,<br>
      155<br>
      use cases<br>
      buying coffee, 8-14, 16-30, 45-50, 117-126,<br>
      130, 136, 140-148, 157-160, 166, 220,<br>
      254, 332-337<br>
      charitable donations, 5, 130, 143<br>
      import/export, 6, 151-153, 167-169,<br>
      333-334, 337<br>
      mining for bitcoin, 6, 27, 219-228, 237-238<br>
      offshore contract services, 5, 30, 82<br>
      retail sales, 5, 254-255<br>
      user security best practices, 272-274<br>
      web store, 5, 98-99, 110-112<br>
      UTXO sets, 119, 123, 155<br>
      V<br>
      validation, 154, 238<br>
      vanity addresses, 82-88<br>
      VERIFY opcodes, 165<br>
      virtual asset management, 283<br>
      W<br>
      wallets<br>
      best practices for, 31, 97<br>
      constructing transactions, 22<br>
      contents of, 93<br>
      defined, 93<br>
      quick start example, 8-10<br>
      selecting, 6-8<br>
      technology of<br>
      creating HD wallets from root seed, 106<br>
      mnemonic code words, 99<br>
      seeds and mnemonic codes, 97<br>
      using extended public keys on web<br>
      stores, 110<br>
      types of<br>
      deterministic (seeded) wallets, 95<br>
      hardware wallets, 98, 273<br>
      hierarchical deterministic (HD) wallets,<br>
      96<br>
      JBOK wallets, 94<br>
      nondeterministic (random) wallets, 94<br>
      paper wallets, 88-91, 273<br>
      primary distinctions, 94<br>
      using bitcoin wallets, 98<br>
      warnings and cautions (see also security)<br>
      accidental bitcoin locking, 155<br>
      avoid sending money to addresses appear‐<br>
      ing in book, xvi, 17<br>
      change outputs, 130<br>
      core node resource requirements, 38<br>
      digital signatures, 145<br>
      password creation, 39<br>
      private key protection, 58<br>
      whitepaper, 305-316<br>
      witnesses, 55, 121, 132<br>
      Index<br>
      &nbsp;|<br>
      &nbsp;369<br>
      About the Author<br>
      Andreas M. Antonopoulos is a noted technologist and serial entrepreneur
      who has<br>
      become one of the most well-known and well-respected figures in bitcoin.
      As an<br>
      engaging public speaker, teacher, and writer, Andreas makes complex
      subjects acces‐<br>
      sible and easy to understand. As an advisor, he helps startups recognize,
      evaluate, and<br>
      navigate security and business risks.<br>
      Andreas grew up with the internet, starting his first company, an early
      BBS and<br>
      proto-ISP, as a teenager in his home in Greece. He earned degrees in
      computer sci‐<br>
      ence, data communications, and distributed systems from University College
      London<br>
      (UCL)—recently ranked among the world’s top 10 universities. After moving
      to the<br>
      United States, Andreas cofounded and managed a successful technology
      research<br>
      company, and in that role advised dozens of Fortune 500 company executives
      on net‐<br>
      working, security, data centers, and cloud computing. More than 200 of his
      articles on<br>
      security, cloud computing, and data centers have been published in print
      and syndi‐<br>
      cated worldwide. He holds two patents in networking and security.<br>
      In 1990, Andreas started teaching various IT topics in private,
      professional, and aca‐<br>
      demic environments. He honed his speaking skills in front of audiences
      ranging in<br>
      size from five executives in a boardroom to thousands of people in large
      conferences.<br>
      With more than 400 speaking engagements under his belt he is considered a
      world-<br>
      class and charismatic public speaker and teacher. In 2014, he was
      appointed as a<br>
      teaching fellow with the University of Nicosia, the first university in
      the world to offer<br>
      a masters degree in digital currency. In this role, he helped develop the
      curriculum<br>
      and cotaught the Introduction to Digital Currencies course, offered as a
      massive open<br>
      online course (MOOC) through the university.<br>
      As a bitcoin entrepreneur, Andreas has founded a number of bitcoin
      businesses and<br>
      launched several community open source projects. He serves as an advisor
      to several<br>
      bitcoin and cryptocurrency companies. He is a widely published author of
      articles<br>
      and blog posts on bitcoin, a permanent host on the popular Let’s Talk
      Bitcoin pod‐<br>
      cast, and a frequent speaker at technology and security conferences
      worldwide.<br>
      Colophon<br>
      The animal on the cover of Mastering Bitcoin is a leafcutter ant (Atta
      colombica). The<br>
      leafcutter ant (a nongeneric name) is a tropical, fungus-growing ant
      endemic to<br>
      South and Central America, Mexico, and southern United States. Aside from<br>
      humans, leafcutter ants form the largest and most complex animal societies
      on the<br>
      planet. They are named for the way they chew leaves, which serve as
      nutrition for<br>
      their fungal garden.<br>
      Winged ants, both male and female, take part in a mass exit of their nest
      known as<br>
      the revoada, or a nuptial flight. Females mate with multiple males to
      collect the 300<br>
      million sperm necessary to set up a colony. Females also store bits of the
      parental fun‐<br>
      gus garden mycelium in the infrabuccal pocket located in their oral
      cavity; they will<br>
      use this to start their own fungal gardens. Once grounded, the female
      loses its wings<br>
      and sets up an underground lair for her colony. The success rate for new
      queens is<br>
      low: 2.5% establish a long-lived colony.<br>
      Once a colony has matured, ants are divided into castes based on size,
      with each caste<br>
      performing various functions. There are usually four castes: minims, the
      smallest<br>
      workers that tend to the young and fungus gardens; minors, slightly larger
      than min‐<br>
      ima, are the first line of defense for the colony and patrol the
      surrounding terrain and<br>
      attack enemies; mediae, the general foragers that cut leaves and bring
      back leaf frag‐<br>
      ments to the nest; and majors, the largest worker ants that act as
      soldiers, defending<br>
      the nest from intruders. Recent research has shown that majors also clear
      main forag‐<br>
      ing trails and carry bulky items back to the nest.<br>
      Many of the animals on O’Reilly covers are endangered; all of them are
      important to<br>
      the world. To learn more about how you can help, go to
      animals.oreilly.com.<br>
      The cover image is from Insects Abroad. The cover fonts are URW Typewriter
      and<br>
      Guardian Sans. The text font is Adobe Minion Pro; the heading font is
      Adobe Myriad<br>
      Condensed; and the code font is Dalton Maag’s Ubuntu Mono.</p>
  </body>
</html>
