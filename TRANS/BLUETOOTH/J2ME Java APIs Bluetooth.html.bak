<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0059)http://www.oracle.com/technetwork/systems/index-155558.html -->
<html xmlns="http://www.w3.org/1999/xhtml" class="hasjs haspushstate">
  <head>
    <meta charset="UTF-8" />
    <style type="text/css">
      .grey4 {
        background-color: #E8E8E8;
      }
    </style>
  </head>
  <body class="f01 f01v0 f01bg">
    <div class="f01v0w1">
      <div id="wrapper_lnav_maincont_rcol_foot">
        <div id="Wrapper_FixedWidth_Centercontent">
          <div class="pg0 pg0v0 pg0x1v0 pg0x1">
            <div class="orcl6w2" style="text-align: center;">
              <div class="orcl6w3" style="text-align: left;">
                <div style="text-align: left;"><sub>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
                      Чеботарьов</a> - Ніжин 2015</sub></div>
                <h1 style="text-align: center;"><span style="font-family: arial,helvetica,sans-serif;">Частина</span>
                  II: Java API для Bluetooth</h1>
                <div class="contentdivider">
                  <table width="90%" cellspacing="0" cellpadding="0" border="0"
                    class="grey1" style="text-align: left; margin-left: 0px; margin-right: auto;">
                    <tbody>
                      <tr>
                        <td width="20%"><br />
                        </td>
                        <td> by <a href="http://www.oracle.com/technetwork/systems/index-155558.html#about">Qusay
                            H. Mahmoud</a>
                          <p><span class="byline"> April 2003 <br />
                            </span></p>
                          <p><br />
                          </p>
                          <p>Платформа Java 2, Micro Edition (J2ME) та
                            технологія Bluetooth є двома найбільш захопливими
                            пропозиціями в бездротовій індустрій на сьогоді.
                            J2ME, найбільш компактна з трьох платформ Java, є
                            невід’ємно портативною, оскільки вона поділяє
                            філософію Java "написати один раз, виконувати
                            кругом", і таким чином покращує продуктивність
                            розробника. Bluetooth є близько-дистанційним
                            універсальним бездотовим стандартом зв’язку для
                            електронних застосувань та мобільних пристроїв.</p>
                          <p>Уявіть, що ви можете використати ваш мобільний
                            телефон з Bluetooth для відмикання вашої маниши,
                            управляння дверями вашого гаража, та управляння
                            вашим плеєром TV, VCR, DVD, та інші споживатьські
                            застосування. Якщо ви бажаєте зробити цей тип
                            керування доступним для ваших користувачів, вам
                            треба бути в змозі писати Bluetooth застосування, що
                            підлаштовані під ці застосування, да розповсюджують
                            їх таким шляхом, що дозволяє користувачам
                            завантажувати їх, наприклад, на мобільний телефон.
                            Bluetooth та J2ME можуть робити разом для досягнення
                            цього уніфікованого бачення. Bluetooth дозволяє
                            пристроям комунікувати без дротів, J2ME дозволяє вам
                            писати власні засосування, та пошируювати їх на
                            мобільні пристрої.</p>
                          <p>Перша частина серії, "<a href="http://www.oracle.com/technetwork/systems/index-155558.html#">Getting
                              Started with Bluetooth</a>" була оглядом, що
                            присвячений основам Bluetooth, стеку протоколу
                            Bluetooth, та процедурам для встановлення Bluetooth
                            з’єднань. Ця стаття фокусується на програмуванні
                            бездротових застосувань з використанням та
                            Bluetooth  J2ME. Вона провадить короткий огляд  Java
                            API для Bluetooth Wireless Technology ( <a href="http://jcp.org/en/jsr/detail?id=82"
                              target="_blank">JSR 82</a>), та показує, як
                            використосувати цей API.</p>
                          <h3>Java API для Bluetooth Wireless Technology</h3>
                          <p>Доки обладнання Bluetooth було складним, не було
                            стандартизованого шляху розробляти Bluetooth
                            застосування - доки не з’явилось JSR 82. Це перший
                            відкритий, не-привласнений стандарт для розробки
                            Bluetooth застосувань з використанням мови
                            програмування Java. Він приховує складність
                            Bluetooth протоколу стеку за набором  Java API, що
                            дозволяє вам сфокосуватись на розробці застосування,
                            скоріше, ніж на низкорівневих деталях Bluetooth. JSR
                            82 базований на версії Bluetooth Specification 1.1.</p>
                          <p>Подібно до всіх JSR, Java API для Bluetooth був
                            розроблений через Java Community Process. Це
                            експертна група має членів, що представляють 20
                            компаній. Фінальна специфікація <a href="http://jcp.org/aboutJava/communityprocess/final/jsr082/index.html">доступна
                              для завантаження</a>.</p>
                          <p>JSR 82 складається з двох опціональних пакунків:
                            базовий Bluetooth API та Object Exchange (OBEX) API.
                            Останній є транспорт-незалежним, та може
                            використовуватись без попереднього.</p>
                          <p><span class="body"><strong>Зауваження</strong>:
                              Java API для Bluetooth не реалізує специфікацію
                              Bluetooth, але скоріше провадить набір API для
                              доступу та керування пристоєм з Bluetooth. JSR 82
                              розглядає себе в основному як провайдер Bluetooth
                              можливостей для J2ME-облаштованих пристроїв. <br />
                            </span></p>
                          <p>Java API націлений на прострої Bluetooth за
                            наступними характеристиками: </p>
                          <ul>
                            <li>мінімум 512K загальної доступної пам’яті (ROM та
                              RAM) (на додаток до потреби в пам’яті
                              застосування)</li>
                            <li>З’єднання до бездротової мережі Bluetooth </li>
                            <li>Сумісна реалізація J2ME Connected Limited Device
                              Configuration (CLDC)</li>
                          </ul>
                          <h4>Вимоги до системи Bluetooth</h4>
                          <p>Підлежна система Bluetooth, на якій будуть
                            збудовані Java API, також потребує задовільняти
                            даяким  вимогам:</p>
                          <ul>
                            <li>Підлегла система має бути "кваліфікованою"
                              згідно Bluetooth Qualification Program, щонайменше
                              для Generic Access Profile, Service Discovery
                              Application Profile та Serial Port Profile.</li>
                            <li>Система мусить підтримувати три рівня
                              комунікації або протоколів, як визначено в 1.1
                              Bluetooth Specification, та реалізація ціх API
                              мусить мати доступ до них: Service Discovery
                              Protocol (SDP), Radio Frequency Communications
                              Protocol (RFCOMM), Logical Link Control та
                              Adaptation Protocol (L2CAP).</li>
                            <li>Система мусить провадити Bluetooth Control
                              Center (BCC), панель керування, більше схоже на
                              застосування, що дозволяє користувачеві або OEM
                              для визначення специфічних значень для даяких
                              параметрів конфігурації в стеці.</li>
                          </ul>
                          <p>OBEX підтримка може бути вроваджена в підлеглій
                            системі Bluetooth або реалізацією API. Протокол OBEX
                            провадить підтримку для обміну об’єктами, та формує
                            основу для профілів Bluetooth, таких як
                            Synchronization Profile та File Transfer Profile.</p>
                          <p>Що таке BCC? </p>
                          <p>Пристрої Bluetooth, що реалізують API, можуть
                            дозволяти декільком застосуванням виконуватись
                            одночасно. BCC запобігає одному застосуванню
                            нашкодити іншому. BCC є набором можливостей, що
                            дозволяють користувачу або OEM розрішити
                            конфліктуючі запити застосувань, визначаючи
                            специфічні значення для окремих параметрів
                            конфігурації в стеці Bluetooth. Є центральний
                            менеджер налаштувань локального присторою Bluetooth.
                            BCC може бути природним застосуванням, застосуванням
                            з окремим API, або просто групою налаштувань, що
                            вказані виробником, та не можуть бути змінені
                            користувачем. Зауважте, що BCC не є класом або
                            інтерфейсом, визначеним в цій специфікації, але є
                            важливою частиною архитектури безпеки.</p>
                          <h4>Можливості JSR 82</h4>
                          <p>API призначене провадити наступні можливості:</p>
                          <ul>
                            <li>Реєстрація сервісів</li>
                            <li>Пошук пристороїв та сервісів</li>
                            <li>Встановлення RFCOMM, L2CAP та OBEX з’єднань між
                              пристроями</li>
                            <li>Використання ціх з’єднань для надсилання та
                              отримання даних (звукова комунікація не
                              підтримується)</li>
                            <li>Управління на керування з’єднаннями комунікацій</li>
                            <li>Провадження безпеки для ціх активностей</li>
                          </ul>
                          <h4>Архітектура API</h4>
                          <p>Ціллю специфікації було визначити відкрите,
                            не-привласнене стандартне API, що може
                            використовуватись на всіх J2ME-сумісних пристроях.
                            Таким чином, вона була розроблена з використанням
                            стандартного J2ME API та CLDC/MIDP's Generic
                            Connection Framework. Деякі важливі можливості:</p>
                          <ul>
                            <li>Специфікація провадить базову підтримку для
                              протоколів Bluetooth та профілей. Вона не включає
                              специфічні API для всіх Bluetooth профілів, просто
                              тому, що число профілів зростає.</li>
                            <li>Специфікація включає комінакаційні протоколи
                              OBEX, L2CAP та  RFCOMM в JSR 82 API, головним
                              чином тому, що всі поточні профілі Bluetooth
                              розроблені для використання ціх комунікаційний
                              протоколів.</li>
                            <li>Специфікація JSR 82 націлена на Generic Access
                              Profile, Service Discovery Application Profile,
                              Serial Port Profile та Generic Object Exchange
                              Profile.</li>
                            <li>Протокол Service Discovery також підтримується.
                              JSR 82 визначає реєстрацію сервісів в деталях, щоб
                              стандартизувати процес реєстрації для програміста
                              застосувань.</li>
                          </ul>
                          <p>JSR 82 потребує, щоб підлеглий стек Bluetooth для
                            реалізації JSR 82 був кваліфікований згідно Generic
                            Access Profile, Service Discovery Application
                            Profile та Serial Port Profile. Стек має також
                            провадити доступ до його Service Discovery Protocol,
                            та до рівней RFCOMM та L2CAP.</p>
                          <p>API розроблені таким чином, що розробники можуть
                            використовувати мову програмування Java для побудови
                            нових профілей Bluetooth, зверху цього API, коли
                            специфікація базового рівня не змінюється. Щоб
                            просувати цю гнучкість та розширюваність,
                            специфікація не обмежена до API, що реалізують
                            Bluetooth профілі. JSR 82 включає API для OBEX та
                            L2CAP, так що майбутні Bluetooth профілі можуть бути
                            реалізовані на Java, та це вже використовується для
                            ціх цілей. Малюнок 1 показує, де API, визначені в
                            цій специфікації, пасують до CLDC/MIDP архітектури.</p>
                          <img width="379" border="0" height="344" alt="Figure 1: High-level Architecture of J2ME CDLC/MIDP and Bluetooth"
                            src="file:///home/ac2epsilon/Dropbox/TRANS/BLUETOOTH/J2ME%20Java%20APIs%20Bluetooth_files/158407.gif" /><br />
                          <span class="rtbtitle">Малюнок 1: Високорівнева
                            архітектура J2ME CDLC/MIDP та Bluetooth<br />
                            <br />
                          </span>
                          <h4>JSR 82 є гнучким</h4>
                          <p> JSR 82 API може робити з обома, природними
                            Bluetooth стеками, та Java Bluetooth стеками. В
                            першому випадку API викликає стек безпосередньо; в
                            другому випадку API проходить через віртуальну
                            машину, що буде взаємодіяти з природним стеком. Як
                            вже вказувалось, Java розробники можуть розширити
                            свої опції, створивши нові профілі. </p>
                          <p>JSR 82 стандартизує програмний інтерфейс. Його два
                            опціональні пакунки можуть бути використані з любим
                            з профілів J2ME. Мінімальна конфігурація є CLDC.
                            Оскільки CLDC є підмножиною CDC, застосування, що
                            використовують цей API, мають також робити з CDC
                            пристроями. Якщо реалізований додатковий пакунок <a
                              href="http://www.jcp.org/en/jsr/detail?id=197" target="blank">Generic
                              Connection Framework Optional Package for J2SE
                              (JSR 197)</a>, JSR 82 API мають робити без
                            перешкод з J2SE.</p>
                          <h4>Пакунки</h4>
                          <p>Java API для Bluetooth визначають два пакунку, що
                            залежать від пакунку  CLDC <code>javax.microedition.io</code>:</p>
                          <ul>
                            <li><code>javax.bluetooth</code>: базовий Bluetooth
                              API</li>
                            <li><code>javax.obex</code>: API для протоколу
                              Object Exchange (OBEX)</li>
                          </ul>
                          <p>Знову, OBEX API визначені незалежно від
                            транспортного рівня Bluetooth та запакований окремо.
                            Кожний з перелічених вище пакунків представляє
                            окремий опціональний пакунок, що означає, що CLDC
                            реалізація може включати любий з пакунків, або обоє.
                            Очікується, що MIDP-обладнані пристрої  будуть
                            включати цю специфікацію.</p>
                          <h3>Програмування застосувань</h3>
                          <p>Анатомія застосування Blueooth має п’ять частин:
                            ініціалізація стеку, управління пристроями, пошук
                            пристроїв, пошук сервісів, та власне комунікація.</p>
                          <h4>Ініціалізація стеку</h4>
                          <p>Стек Bluetooth відповідальний за управління
                            пристроєм Bluetooth, так що вам треба ініціалізувати
                            Bluetooth стек перед тим, як ви зможете зробити
                            будь-що інше. Процес ініціалізації складається з
                            декількох кроків, чиє призначення отримати готовий
                            пристрій для бездротової комунікації. На жаль,
                            специфікація Bluetooth залишає реалізцію BCC на
                            виробників, та різні виробники виконують
                            ініціалізацію стеку по-різному. на одному пристрої
                            це може бути застосування з  GUI інтерфейсом, та на
                            іншому це может бути послідовність налагоджень, що
                            не можуть бути змінені користувачем. Як приклад,
                            рішення Atinav Java Bluetooth потребує, щоб
                            розробник ініціалізував стек послідовністю
                            налаштувань, подібно до тих з наступного фрагменту
                            коду - зауважте, що викликаються API, що не є
                            частиною JSR 82:</p>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// встановити номер порту
BCC.setPortNumber("COM1");
// встановити швидкість передачі
BCC.setBaudRate(50000);
// встановити режим з’єднання
BCC.setConnectable(true);
// встановити режим пошуку в Limited Inquiry Access Code
BCC.setDiscoverable(DiscoveryAgent.LIAC);
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                          </blockquote>
                          <h4>Управління пристороєм</h4>
                          <p>Java Bluetooth API містить класи <code>LocalDevice</code>
                            та <code>RemoteDevice</code>, що провадять
                            можливості управління пристроями, визначені в
                            Generic Access Profile. <code>LocalDevice</code>
                            залежить від класу <code>javax.bluetooth.DeviceClass</code>
                            для отримання типу пристрою та типів сервісів, що
                            вони надають. Клас <code>RemoteDevice</code>
                            представляє віддалений пристрій (пристрій в зоні
                            досяжності) та провадить методи для отримання
                            інфорації щодо пристрою, включаючи його Bluetooth
                            адресу та ім’я. Наступний фрагмент коду отримує цю
                            інформацію для локлаьного пристрою:</p>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// отримати локальний об’єкт пристрою Bluetooth
LocalDevice local = LocalDevice.getLocalDevice();
// отримати адресу Bluetooth для локального пристрою
String address = local.getBluetoothAddress();
// отримати ім’я локального пристрою Bluetooth
String name = local.getFriendlyName();
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                          </blockquote>
                          <p>Ви можете отримати ту саму інформацію для
                            віддаленого пристрою:</p>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// отримати пристрій що на іншому кінці
// з’єднання Bluetooth Serial Port Profile,
// L2CAP з’єднання, або OBEX понад RFCOMM з’єднання
RemoteDevice remote = 
    RemoteDevice.getRemoteDevice(
        javax.microedition.io.Connection c);
// отримати Bluetooth адресу віддаленого пристрою
String remoteAddress = remote.getBluetoothAddress();
// отримати ім’я віддаленого пристрою Bluetooth
String remoteName = local.getFriendlyName(true);
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                          </blockquote>
                          <p>Клас <code>RemoteDevice</code> також провадить
                            методи для аутентифікації, авторизації або
                            шифрування даних, що передаються між локальними та
                            віддаленими пристроями.</p>
                          <h4>Пошук пристроїв</h4>
                          <p>Оскільки бездротові пристрої є мобільними, вони
                            потребують механізму, що дозволяє їм шукати другі
                            пристрої та отримувати доступ до їх можливостей.
                            Базовий клас Bluetooth API <code>DiscoveryAgent</code>
                            та інтерфейс <code>DiscoveryListener</code>
                            провадять необхідні сервіси пошуку.</p>
                          <p>Пристрій Bluetooth може використовувати о’бєкт <code>DiscoveryAgent</code>
                            для отримання списку досяжних пристроїв, якщо такі
                            є, в три шляхи:</p>
                          <p>Метод <code>DiscoveryAgent.startInquiry</code>
                            переводить пристрій в режим опитування. Щоб отримати
                            вигоди від цього режиму, застосування має задати
                            слухача подій, що буде відповідати на події,
                            пов’язані з опитуванням. </p>
                          <p><code>DiscoveryListener.deviceDiscovered</code>
                            викликається кожного разу, коли опитування знаходить
                            пристрій. Коли пошук завершено або відмінено,
                            викликається <code>DiscoveryListener.inquiryCompleted</code>.</p>
                          <p>Якщо пристрій не бажає очікувати, коли пристрої
                            будуть знайдені, воно може використати метод <code>DiscoveryAgent.retrieveDevices</code>
                            для отримання існуючого списку. В залежності на
                            переданий параметр, цей метод буде повертати або
                            список пристроїв, що були знайдені в попередньому
                            пошуку, або список <em>заздалегідь відомих
                              пристроїв</em>, що були введені через Bluetooth
                            Control Center як часто уживані.</p>
                          <p>Ці три фрагменти коду демонструють різіні підходи:</p>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// отримати агент пошуку 
DiscoveryAgent agent = local.getDiscoveryAgent();
// перевести пристрій в режим опитування
boolean complete = agent.startInquiry();
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                          </blockquote>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// отримати агент пошуку 
DiscoveryAgent agent = local.getDiscoveryAgent();
// повернути масив заздалегідь відомих пристроїв
RemoteDevice[] devices = 
   agent.retrieveDevices(DiscoveryAgent.PREKNOWN);
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                          </blockquote>
                          <blockquote>
                            <table width="100%" cellspacing="0" cellpadding="10"
                              border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td>
                                    <pre>...
// отримати агент пошуку 
DiscoveryAgent agent = local.getDiscoveryAgent();
// отримати масив пристроїв, знайдених шляхом попереднього опитування
RemoteDevice[] devices =
    agent.retrieveDevices(DiscoveryAgent.CACHED);
...
</pre> </td>
                                </tr>
                              </tbody>
                            </table>
                            <br />
                            <h4>Пошук сервісів</h4>
                            <p>Коли локальний пристрій знаходить щонайменше один
                              відалений пристрій, він може почати шукати
                              доступні <em>services</em> - застосування
                              Bluetooth, що можна використати для виконання
                              корисних завдань. Оскільки пошук сервісів дуже
                              схожий на пошук пристроїв, <code>DiscoveryAgent</code>
                              також провадить методи для пошуку сервісів на
                              пристроях серверів Bluetooth, та дають змогу
                              ініціювати для пошуку сервісів на віддалених
                              пристроях, але не сервісів на локлаьному пристрої.</p>
                            <h4>Реєстрація сервісів</h4>
                            <p>Перед тим, як сервіс може бути знайдений,
                              спочатку він має бути <em>зареєстрований</em> -
                              оголошений на <em>пристрої серверу Bluetooth</em>.
                              Сервер відповідає за: </p>
                            <ul>
                              <li>Створення запису сервісу, що описує
                                запропонований сервіс</li>
                              <li>Довадання запису сервісу на сервер в Service
                                Discovery DataBase (SDDB), так що він буде
                                видимій та доступний для потенційних клієнтів</li>
                              <li>Реєстрація вимірів безпеки Bluetooth,
                                асоційованих з сервісом  (накладаються для
                                з’єднань з клієнтами)</li>
                              <li>Прийняття з’єднань від клієнтів</li>
                              <li>Оновлення запису сервісу в SDDB, коли
                                змінюютьс атрибути сервісу</li>
                              <li>Видалення або відключення запису сервісу в
                                SDDB, щоб зробити сервіс більше недоступним</li>
                            </ul>
                            <p>Наступний анотований фрагмент коду дає вам
                              приклад зусиль з реєстрації сервісу з
                              використанням Java API для Bluetooth:</p>
                            <ol>
                              <li>Щоб створити новий запис сервісу викличте <code>Connector.open</code>
                                з аргументом URL з’єднанння з сервером, та
                                перетворити результат до <code>StreamConnectionNotifier</code>,
                                що представляє сервіс:
                                <blockquote>
                                  <table width="100%" cellspacing="0" cellpadding="10"
                                    border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                    <tbody>
                                      <tr>
                                        <td>
                                          <pre>...
StreamConnectionNotifier service =
    (StreamConnectionNotifier) Connector.open("someURL");
</pre> </td>
                                      </tr>
                                    </tbody>
                                  </table>
                                  <br />
                                </blockquote>
                              </li>
                              <li>Отримати запис сервісу, створений пристроєм
                                серверу:
                                <blockquote>
                                  <table width="100%" cellspacing="0" cellpadding="10"
                                    border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                    <tbody>
                                      <tr>
                                        <td>
                                          <pre>ServiceRecord sr = local.getRecord(service);
</pre> </td>
                                      </tr>
                                    </tbody>
                                  </table>
                                  <br />
                                </blockquote>
                              </li>
                              <li>Вказує, що сервіс готовий сприймати клієнтські
                                з’єднання:
                                <blockquote>
                                  <table width="100%" cellspacing="0" cellpadding="10"
                                    border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                    <tbody>
                                      <tr>
                                        <td>
                                          <pre>StreamConnection connection =
    (StreamConnection) service.acceptAndOpen();
</pre> </td>
                                      </tr>
                                    </tbody>
                                  </table>
                                  <br />
                                </blockquote>
                                <p>Зауважте, що <code>acceptAndOpen</code>
                                  блокується до з’єднання з клієнтом.</p>
                              </li>
                              <li>Коли сервер готовий до виходу, зачиніть
                                з’єднання та видаліть серверний запис:
                                <blockquote>
                                  <table width="100%" cellspacing="0" cellpadding="10"
                                    border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                    <tbody>
                                      <tr>
                                        <td>
                                          <pre>service.close();
...
</pre> </td>
                                      </tr>
                                    </tbody>
                                  </table>
                                  <br />
                                </blockquote>
                              </li>
                            </ol>
                            <br />
                            <h4>Комунікація</h4>
                            <p>Щоб локальний пристрій виконував віддалений
                              пристрій, два пристрою мають поділяти загальний
                              протокол комунікації. Так що застосування можуть
                              мати доступ до широкої різноманітності Bluetooth
                              сервісів. Java API для Bluetooth провадять
                              механізми, що дозволяють з’єднання до любого
                              сервісу, що використовує RFCOMM, L2CAP або OBEX в
                              якості своїх протоколів. Якщо сервіс використовує
                              інший протокол (такий як TCP/IP), покладений
                              поверху одного з ціх протоколів, застосування <em>може</em>
                              мати доступ до сервісу, але тілька якщо реалізує
                              додатковий протокол в застосуванні, з
                              використанням CLDC Generic Connection Framework.</p>
                            <p>Оскільки протокол OBEX може бути використаний поверху
                              декількох різних серед передачі - дротовий,
                              інфрачервоний, Bluetooth радіо, та інших - JSR 82
                              реалізує OBEX API ( <code>javax.obex</code>)
                              незалежно від базового Bluetooth API ( <code>javax.bluetooth</code>).
OBEX
                              API є окремим опціональним пакунком, що ви можете
                              використовувати або за базовим пакунком Bluetooth
                              або незалежно.</p>
                            <p><strong>Профіль послідовного порту</strong></p>
                            <p>Протокол RFCOMM, що є надбудований поверху
                              протоколу L2CAP, емулює послідовне з’єднання
                              RS-232. Serial Port Profile (SPP) спрощує
                              комунікацію між Bluetooth пристроями, проваджуючи
                              потік-базований інтерфейс до RFCOMM протоколу.
                              Деякі можливості та обмеження, що слід враховувати:</p>
                            <ul>
                              <li>Два пристрої можуть поділяти одну RFCOMM
                                сессію одночасно.</li>
                              <li>До 60 логічних послідовних з’єднань можуть
                                бути мультиплексовані через одну сессію.</li>
                              <li>Єнидий пристрій Bluetooth може мати
                                щонайбільше 30
                                активних RFCOMM сервісів.</li>
                              <li>Пристрій може підтримувати тільки одне
                                клієнтське з’єднання з кожним окремим сервісом в
                                даний проміжок часу.</li>
                            </ul>
                            <p>Для того, щоб сервер та клієнт комунікували через
                              Serial Port Profile, кожний має виконати декілька
                              простих кроків.</p>
                            <p>Як демонструє наступний фрагмент коду, сервер
                              повинен:</p>
                            <ol>
                              <li>Побудувати URL, що вказує, як під’єднатись до
                                сервісу, та зберегти його в записі сервису</li>
                              <li>Зробити запис сервісу доступним для клієнта</li>
                              <li>Прийняти з’єднання від клієнту</li>
                              <li>Падсилати та отримувати дані від клієнта</li>
                            </ol>
                            <p>URL, розміщений в запису сервіса, може виглядати
                              на кшталт такого:</p>
                            <p><code>btspp://102030405060740A1B1C1D1E100:5</code></p>
                            <p>Цей каже, що клієнт повинен використовувати
                              Bluetooth Serial Port Profile для з’єднання з цім
                              сервісом, що ідентифікується з п’ятим каналом на
                              пристрої, адреса якого
                              102030405060740A1B1C1D1E100.</p>
                            <blockquote>
                              <table width="100%" cellspacing="0" cellpadding="10"
                                border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                <tbody>
                                  <tr>
                                    <td>
                                      <pre>...
// вважається що UID сервісу був отриманий
String serviceURL =
    "btspp://localhost:"+serviceUID.toString());
// more explicitly:
String ServiceURL =
    "btspp://localhost:10203040607040A1B1C1DE100;name=SPP 
        Server1";
try {
    // створити з’єднання з сервером
    StreamConnectionNotifier notifier =
       (StreamConnectionNotifier) Connector.open(serviceURL);
    // сприймати клієнтські з’єднання
    StreamConnection connection = notifier.acceptAndOpen();
    // приготуватись до обміну даними
    byte buffer[] = new byte[100];
    String msg = "hello there, client";
    InputStream is = connection.openInputStream();
    OutputStream os = connection.openOutputStream();
    // надіслати дані до клієнта
    os.write(msg.getBytes());
    // прочитати дані від клієнта
    is.read(buffer);
    connection.close();
} catch(IOException e) {
  e.printStackTrace();
}
...
</pre> </td>
                                  </tr>
                                </tbody>
                              </table>
                              <br />
                            </blockquote>
                            <p>З іншого кінця, як показує наступний код, для
                              встановлення RFCOMM з’єднання з сервером клієнт
                              мусить:</p>
                            <ol>
                              <li>Ініціювати пошук сервісів, щоб отримати запис
                                сервісу</li>
                              <li>Побудувати URL з’єднання з використанням сервісного
                                запису</li>
                              <li>Відкрити з’єднання з сервером</li>
                              <li>Надіслати та отримати дані з серверу</li>
                            </ol>
                            <blockquote>
                              <table width="100%" cellspacing="0" cellpadding="10"
                                border="0" class="grey4" style="text-align: left; margin-left: 0px; margin-right: auto;">
                                <tbody>
                                  <tr>
                                    <td>
                                      <pre>...
// (вважається що ми маємо запис сервісу)
// виконуємо запис для отримання URL з’єднання
String url =
    record.getConnectionURL(
        record.NOAUTHENTICATE_NOENCRYPT, false);
// відкрити з’єднання з сервером
StreamConnection connection =
    (StreamConnection) Connector.open(url);
// надіслати та отримати дані
try {
    byte buffer[] = new byte[100];
    String msg = "hello there, server";
    InputStream is = connection.openInputStream();
    OutputStream os = connection.openOutputStream();
    // надіслати дані на сервер
    os.write(msg.getBytes);
    // читати дані від сервера
    is.read(buffer);
    connection.close();
} catch(IOException e) {
  e.printStackTrace();
}
...
</pre> </td>
                                  </tr>
                                </tbody>
                              </table>
                              <br />
                            </blockquote>
                            <p>Якщо ви хочете зрозуміти, як використовувати
                              протоколи комунікації, інші ніж RFCOMM, дивіться <a
                                href="http://www.jcp.org/en/jsr/detail?id=82" target="_blank">
                                специфікацію </a><a href="http://www.jcp.org/en/jsr/detail?id=82"
                                target="_blank">JSR 82</a>.</p>
                            <h4>Набори розробки J2ME/Bluetooth</h4>
                            <p>Декілька інтегрованих оточень розробки провадять
                              API for Bluetooth. Коли обраєте IDE для розробки
                              J2ME/Bluetooth, будьте впевнені, що вона сумісна з
                              JSR 82. Якщо ви маєте доступ до Bluetooth
                              пристроїв,  я рекомендував би вам рішення Java
                              Bluetooth від <a href="http://www.atinav.com/" target="_blank">Atinav</a>.
                              Він JSR 82  сумісний та базується на повністю-Java
                              стеку, він включає KVM, та підтримує RS-232, USB,
                              PCMCIA, та інші Bluetooth пристрої.</p>
                            <p><a href="http://www.esmertec.com/" target="_blank">Esmertec</a>,
                              <a href="http://www.smartnd.com/" target="_blank">Smart
                                Network Devices</a>, та декілька інших компаній
                              надають унікальні, сумісні з JSR 82, рішення.</p>
                            <p>Базована в Ірландії <a href="http://rococosoft.com/"
                                target="_blank">Rococo Software</a> має декілька
                              продуктів  J2ME/Bluetooth, включаючи Impronto
                              Simulator, що дозволяє вам виконувати Java
                              застосування в симульованому оточенні Bluetooth,
                              де ви можете тестувати та конфігурувати
                              засосування, перед тим, як розгортати їх на
                              Bluetooth-пристрої. Все це без необхідності
                              купувати обладнання та мати Bluetooth стек! Ось як
                              це робить: коли затсосування виконує Impronto
                              Simulator, віртуальний стек Bluetooth обробляє всі
                              виклики Bluetooth, маршрутизуючи їх у віртуальний
                              стек потрібного прострою. Сервер пошуку дозволяє
                              пристроям віднаходити один одного; GUI допомагає
                              розробникам моніторити поведінку симульованих
                              пристроїв та мереж; журанал подій записує події
                              API та Bluetooth;
                              та редактор пристроїв використовується для
                              конфінурації віртуальних пристроїв. Симулятор
                              підтримує стандартні  Java API для Bluetooth. Одне
                              обмеження в тому, що він не дозволяє вам задати,
                              якій пристрій є головним, а який другорядним.
                              Figure 2 shows a screenshot:</p>
                            <table width="image_width" cellspacing="0" cellpadding="10"
                              border="0" style="text-align: left; margin-left: 0px; margin-right: auto;">
                              <tbody>
                                <tr>
                                  <td align="center"><img width="450" border="0"
                                      height="356" alt="Figure 2: Impronto Simulator"
                                      src="file:///home/ac2epsilon/Dropbox/TRANS/BLUETOOTH/J2ME%20Java%20APIs%20Bluetooth_files/157849.gif" />
                                    <br />
                                    <span class="rtbtitle">Figure 2: Impronto
                                      Simulator</span></td>
                                </tr>
                              </tbody>
                            </table>
                            <h4><strong>Підсумок</strong> </h4>
                            <p>Ця стаття презентує  tutorial on the Java APIs
                              for Bluetooth wireless technology. The sample code
                              demonstrated how easy it is to develop wireless
                              applications for Bluetooth-enabled devices. The
                              APIs enable you to exploit fully the power of the
                              Java programming language to develop wireless
                              applications in a standard way. This set of APIs
                              is a key enabler that will help software vendors
                              and developers tap the potentially huge market for
                              Bluetooth wireless technology.</p>
                            <h4>Додаткова інформація: <a href="http://www.jcp.org/en/jsr/detail?id=82"
                                target="_blank">JSR 82: Java APIs for Bluetooth
                                Wireless Technology</a> <br />
                            </h4>
                            <a id="about" name="about"></a><span class="byline">
                              <strong>Про автора:</strong> <a href="mailto:qmahmoud@javacourses.com">Qusay
                                H. Mahmoud</a> надає консультації </span><span
                              class="byline"><span class="byline">та тренінги</span>
                              щодо Java. Він опубліковав десятки статей по Java,
                              та є автором <em>Distributed Programming with
                                Java</em> (Manning Publications, 1999) та <em>Learning
                                Wireless Java</em> (O'Reilly &amp; Associates,
                              2002).</span> <strong></strong> </blockquote>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <span class="byline"></span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div onclick="showclose();" style="DISPLAY: none; Z-INDEX: 30000" id="lightbox_brightcove"
      class="lightbox_overlay">
      <!--spacer-->  </div>
    <span class="ui-helper-hidden-accessible" aria-relevant="additions" aria-live="assertive"
      role="status"></span>
  </body>
</html>
