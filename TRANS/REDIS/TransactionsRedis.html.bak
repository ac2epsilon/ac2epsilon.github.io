<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Транзакції Redis. Переклад українською - Арсеній Чеботарьов - Ніжин 2016</title>
  </head>
  <body class="topics transactions">
    <address>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <div class="site-wrapper"><br>
      <div class="site-content">
        <div class="text">
          <article id="topic">
            <aside>
              <h2>Пов’язані команди</h2>
              <ul>
                <li> <a href="/commands/discard">DISCARD</a> </li>
                <li> <a href="/commands/exec">EXEC</a> </li>
                <li> <a href="/commands/multi">MULTI</a> </li>
                <li> <a href="/commands/unwatch">UNWATCH</a> </li>
                <li> <a href="/commands/watch">WATCH</a> </li>
              </ul>
            </aside>
            <span id="transactions" class="anchor"></span>
            <h1><a href="#transactions" class="anchor-link">*</a>Транзакції</h1>
            <p><a href="/commands/multi">MULTI</a>, <a href="/commands/exec">EXEC</a>,
              <a href="/commands/discard">DISCARD</a> та <a href="/commands/watch">WATCH</a>
              є основою транзакцій в Redis. Вони дозволяють виконання групи
              команд за один крок, з двома важливими гарантіями:</p>
            <ul>
              <li>
                <p>Всі команди в транзакції послідовні, та виконуються одна за
                  однією. Ніколи не відбудеться такого, щоб запит від іншого
                  клієнта оброблявся&nbsp;<strong>в середині</strong> виконання
                  транзакції Redis. Це гарентує, що команди виконуються в одній
                  ізольованій операції.</p>
              </li>
              <li>
                <p>Або всі, або жодна команда будуть оброблені, так що
                  транзакція Redis також є атомарною. Команда <a href="/commands/exec">EXEC</a>
                  перемикає виконання всіх команд в транзакції, так що
                  користувач втратить з’єднання до серверу в контексті
                  транзакції перед викликом команди <a href="/commands/multi">MULTI</a>,
                  ніяка з операцій не буде виконана. Замість цього, якщо
                  викликана команда&nbsp;<a href="/commands/exec">EXEC</a>, всі
                  операції виконані. Коли використовуєте <a href="/topics/persistence#append-only-file">файл
                    тільки для додавання</a>, Redis впевниться, що
                  використовуєтсья єдиний системний виклик write(2) для запису
                  транзакії на диск. Однак якщо сервер Redis впаде, або буде
                  зупинений системним адміністратором у деякий жорсткий спосіб,
                  можливо, що тільки частина операцій будуть зареєстровані.
                  Redis розпізнає цю ситуацію при перезапуску, та вийде з
                  помилкою. Використання інструменту <code>redis-check-aof</code>
                  може допомогти для налаштування файлу тільки для запису, та
                  видалить часткову транзакцію, так що сервер зможе стартувати
                  знову.</p>
              </li>
            </ul>
            <p>Починаючи з версії 2.2, Redis дозволяє додаткову гарантію до
              двох, наведених вище, в формі оптимістичного блокування шляхом,
              дуже схожим до операції перевірити-та-встановити (CAS). Це
              задукоментовано&nbsp;<a href="#cas">піздніше</a> на цій сторінці.</p>
            <span id="usage" class="anchor"></span>
            <h2><a href="#usage" class="anchor-link">*</a>Використання</h2>
            Транзакція Redis починається з команди <a href="/commands/multi">MULTI</a>.
            Команда завжди відповідає <code>OK</code>. В цій точці коритсувач
            може надати декілька команд. Замість виконання ціх команд, Redis
            ставить їх в чергу. Всі ці команду виконаються, коли буде викликано
            <a href="/commands/exec">EXEC</a>.
            <p>Виклик <a href="/commands/discard">DISCARD</a>, насупротив,
              скине чергу транзакції, та вийде з транзакції.</p>
            <p>Наступний приклад збільшує ключі&nbsp;<code>foo</code> та <code>bar</code>
              автоматично.</p>
            <pre><code>&gt; MULTI
OK
&gt; INCR foo
QUEUED
&gt; INCR bar
QUEUED
&gt; EXEC
1) (integer) 1
2) (integer) 1
</code></pre>
            <p>Як можливо побачити з прикладу вище, <a href="/commands/exec">EXEC</a>
              повертає масив з відповідей, де кожний елемент є відповіддю на
              кожну окрему команду транзакції, в тому ж порядку, як ці команди
              були надані.</p>
            <p>Коли з’єднання Redis є в контектсі запиту&nbsp;<a href="/commands/multi">MULTI</a>,
              ві команди будуть повертатись з рядком&nbsp;<code>QUEUED</code>
              (що відсилаються як відповідь стану з точки&nbsp;зору протоколу
              Redis). Запитана команда є тільки запланована для виконання, коли
              буде викличено <a href="/commands/exec">EXEC</a>.</p>
            <span id="errors-inside-a-transaction" class="anchor"></span>
            <h2><a href="#errors-inside-a-transaction" class="anchor-link">*</a>Помилки
              в транзакції</h2>
            <p>На протязі транзакції можливо натрапити на два типи помилок:</p>
            <ul>
              <li>Команда може схибити при розміщенні в черзі, так що помилка
                виникне перед викликом <a href="/commands/exec">EXEC</a>.
                Наприклад, команда може бути синтаксично хибною (невірне число
                аргументів, помилкове ім’я команди, таке інше), або може
                виникнути якісь критичні умови, як нестача пам’яті (якщо сервер
                сконфігуровано мати обмеження з використанням директиви&nbsp;<code>maxmemory</code>).</li>
              <li>Команда може схибити <em>після</em> того, як буде викликаний
                <a href="/commands/exec">EXEC</a>, наприклад, оскільки ми
                виконуємо операцію з ключем з невірним значенням (як викликання
                операцій зі списками для значення рядка).</li>
            </ul>
            <p>Клієнти, які переймались першим типом помилок, що відбуваються
              раніше виклику&nbsp;<a href="/commands/exec">EXEC</a>, визначають
              це,&nbsp; перевіряючи значення запиту команди: якщо команда
              выповідає QUEUED, вона була поставлена в чергу коректно. В іншому
              випадку Redis повертає помилку. Якщо виникла помилка під час
              постановки команди в чергу, більшість клієнтів перервуть
              транзакцію, відкидаючи її.</p>
            <p>Однак, починаючи з Redis 2.6.5, сервер буде запам’ятовувати, що
              виникли помилки під час накопичення команд, та буде відмовляи в
              виконанні транзакції, повертаючи також помилку на протязі&nbsp;<a
                href="/commands/exec">EXEC</a>, та автоматично відкидаючи
              транзакцію.</p>
            <p>Поведінка до Redis 2.6.5 успішно виконувала транзакцію тільки з
              підмножиною команд, що були поміщені в черзі, в разі, коли клиєнт
              викликав <a href="/commands/exec">EXEC</a>, безвідносно до
              попередніх помилок. Нова поведінка робить значно простішим
              змішувати транзакції з конвеєром, так що повна транзакція може
              бути надіслана за раз, також отримуючи всі відповіді також разом.</p>
            <p>Помилки, що на відміну відбулись <em>після</em> <a href="/commands/exec">EXEC</a>,
              не обробляються особливим чином: всі інші команди будуть виконані,
              навіть, якщо деякі команди схиблять на протязі транзакції.</p>
            <p>Це більш прозоро на рівні протоколу. В наступному прикладі одна
              команда дає збій при виконанні, навіть коли синтаксис є вірним:</p>
            <pre><code>Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
MULTI
+OK
SET a 3
abc
+QUEUED
LPOP a
+QUEUED
EXEC
*2
+OK
-ERR Operation against a key holding the wrong kind of value
</code></pre>
            <p><a href="/commands/exec">EXEC</a> повертає відповідь з двох
              частин&nbsp;<a href="/topics/protocol#bulk-string-reply">поєднаних
                рядків</a>, де один є кодом&nbsp;<code>OK</code>, да інший
              відповідь&nbsp;<code>-ERR</code>. Завданням бібліотеки клієнта є
              знайти відповідний спосіб сповістити&nbsp; користувачеві про
              помилку.</p>
            <p>Важливо зауважити, що <strong>навіть коли команда схибить, всі
                інші команди в черзі будуть оброблені</strong> – Redis <em>не
                зупунить</em> обробку команд.</p>
            <p>Інший приклад, також з використанням протоколу&nbsp;<code>telnet</code>,
              показує як помилка синтаксису повідомляється ASAP:</p>
            <pre><code>MULTI
+OK
INCR a b c
-ERR wrong number of arguments for 'incr' command
</code></pre>
            <p>Цього разу, завдячуючі помилці синтаксису, погана команда&nbsp;<a
                href="/commands/incr">INCR</a> не буде поставлена в чергу
              взагалі.</p>
            <span id="why-redis-does-not-support-roll-backs" class="anchor"></span>
            <h2><a href="#why-redis-does-not-support-roll-backs" class="anchor-link">*</a>Чому
              Redis не підтримує відкати?</h2>
            <p>Якщо ваш досвід походить з реляційних баз даних, той факт, що
              команди Redis можуть схибити під час транзакції, та при цьому
              Redis буде виконувати решту транзації, замість того, щоб
              відкатитити її, може видатись для вас дурнею.</p>
            <p>Однак є добрі мотиви щодо цієї поведінки:</p>
            <ul>
              <li>Команди Redis можуть схибити тільки коли вони надані з
                невірним синтаксисом (та проблему не можна визначити на протязі
                накопичення команд), або застосовуються до ключів невірного
                типу: це означає, що на практиці команда зазнає поразки в
                результаті помилок програмування, та помилка з того типу, що
                скоріше всього буде визначена на етапі розробки, та не під час
                експлуатації.</li>
              <li>Redis внутрішньо спрощений та скоріший, оскільки він не
                повинен виконувати відкати.</li>
            </ul>
            <p>Аргументом за точки зору Redis є те, що навіть коли трапляються
              зачіпки, треба зазначити, що відкати жодним чином не рятують вас
              від помилок програмування. Наприклад, якщо запит збільшує ключ на
              2 замість 1, або збільшує не той ключ, механізм відкатів жодним
              чином не врятує вас. Беручи до уваги, що ніхто не врятує розроника
              від його помилок, та що тип помилок, потрібних для того, щоб
              команда Redis схибила, вірогідно не трапиться під час
              використання, так що ми обрали простіший та швидший підхід, не
              підтримуючи відкати після помилок.</p>
            <span id="discarding-the-command-queue" class="anchor"></span>
            <h2><a href="#discarding-the-command-queue" class="anchor-link">*</a>Відміна
              командної черги</h2>
            <p><a href="/commands/discard">DISCARD</a> може бути використаний
              для відміни транзакції. В цьому разі команди не будуть виконані,
              та стан з’єднання повернеться до нормального.</p>
            <pre><code>&gt; SET foo 1
OK
&gt; MULTI
OK
&gt; INCR foo
QUEUED
&gt; DISCARD
OK
&gt; GET foo
"1"
</code></pre>
            <p><a name="cas"></a></p>
            <span id="optimistic-locking-using-check-and-set" class="anchor"></span>
            <h2><a href="#optimistic-locking-using-check-and-set" class="anchor-link">*</a>Оптимістичне
              блокування з використанням перевірити-та-встановити</h2>
            <p><a href="/commands/watch">WATCH</a> використовується для
              впровадження поведінки перевірити-та-встановити (CAS) до
              транзакцій Redis.</p>
            <p><code>WATCH</code> ключі моніторяться на предмет виникнення змін.
              Якщо щонайменш один з ключів буде модифіковано пере виконанням
              команди&nbsp;<a href="/commands/exec">EXEC</a>, ціла транзакція
              буде відмінена, та <a href="/commands/exec">EXEC</a> повертає <a
                href="/topics/protocol#nil-reply">нульову відповідь</a>, щоб
              повідомити, що транзакція схибила.</p>
            <p>Наприклад, уявіть, що нам треба автоматично збільшити значення
              ключа на 1 (уявімо, що Redis не має <a href="/commands/incr">INCR</a>).</p>
            <p>Перша спроба може бути наступною:</p>
            <pre><code>val = GET mykey
val = val + 1
SET mykey $val
</code></pre>
            <p>Це буде робити надійно, тільки якщо ми маємо одного клієнта, що
              виконує дещо в окремий проміжок часу. Якщо декілька клієнтів
              спробують збільшити ключ приблизно одночасно, виникне стан гонок.
              Наприклад, клієнти А та Б прочитають значення, наприклад, 10.
              Значення буде збільшено до 11 обома клієнтами, та, нарешті,&nbsp;<a
                href="/commands/set">SET</a> встановить значення ключа. Так що
              остаточнє значення буде 11, замість 12.</p>
            <p>Завдяки <a href="/commands/watch">WATCH</a> ми в змозі
              змоделювати проблему дуже гарно:</p>
            <pre><code>WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
</code></pre>
            <p>Використовуючи код вище, якщо виникне стан гонок, та інший клієнт
              модифікує результат <code>val</code> в час між нашим викликом <a
                href="/commands/watch">WATCH</a>, та нашим викликом&nbsp;<a href="/commands/exec">EXEC</a>,
              транзакція схибить.</p>
            <p>Ми тільки маємо повторити операцію, в надії, що цього разу не
              виникне нових гонок. Ця форма блокування називається <em>оптимістичним
                блокуванням</em> та є дуже потужною формою блокування. В
              багатьох випадках, багато клієнтів будуть використовувати різні
              ключі, так що колізії маловірогідні – зазвичай немає потреби
              повторювати операцію.</p>
            <span id="a-hrefcommandswatchwatcha-explained" class="anchor"></span>
            <h2><a href="#a-hrefcommandswatchwatcha-explained" class="anchor-link">*</a><a
                href="/commands/watch">WATCH</a>: пояснення</h2>
            <p>Таким чином, що ховається за&nbsp;<a href="/commands/watch">WATCH</a>
              насправді? Це команда, що робить <a href="/commands/exec">EXEC</a>
              умовним: ми питаємо Redis виконати транзакцію тільки в випадку,
              якщо не один інший клієнт не модифікує жодний з ключів під
              наглядом <code>WATCH</code>. В іншому випадку транзакція навіть
              не розпочнеться взагалі. (Зауважте, що якщо ви застосуєте&nbsp;<a
                href="/commands/watch">WATCH</a> до тимчасового ключа, та Redis
              прострочить ключ під час нагляду, <a href="/commands/exec">EXEC</a>
              буде все одно виконуватись. <a href="http://code.google.com/p/redis/issues/detail?id=270">Більше
                про це</a>.)</p>
            <p><a href="/commands/watch">WATCH</a> може бути викликаний більше
              одного разу. Всі виклики&nbsp;<a href="/commands/watch">WATCH</a>
              набувають ефект нагляду з виклику самої команди до виклику&nbsp;<a
                href="/commands/exec">EXEC</a>. Ви можете також надіслати
              довільне число ключів до одного виклику&nbsp;<a href="/commands/watch">WATCH</a>.</p>
            <p>Коли викликається <a href="/commands/exec">EXEC</a>, всі ключі
              втрачають нагляд, незалежно, була відмінена транзакція, або ні.
              Також це відбувається, коли закривається з’єднання клієнта.&nbsp;</p>
            <p>Також можливо викликати команду&nbsp;<a href="/commands/unwatch">UNWATCH</a>
              (без аргументів), щоб скинути всі наглядувані ключі. Іноді це
              корисно, коли ми оптимістично блокуємо декілька ключів, оскільки
              нам треба виконати транзакцію, щоб змінити ці ключі, але після
              читання поточного вмісту ключів ми вирішили не продовжувати. Коли
              це трапляється, ми просто викликаємо <a href="/commands/unwatch">UNWATCH</a>,
              так що з’єднання може використовуватись і надалі для нових
              транзакцій.</p>
            <span id="using-a-hrefcommandswatchwatcha-to-implement-zpop" class="anchor"></span>
            <h3><a href="#using-a-hrefcommandswatchwatcha-to-implement-zpop" class="anchor-link">*</a>Використання
              <a href="/commands/watch">WATCH</a> для реалізації ZPOP</h3>
            <p>Гарним прикладом іллюстрації, як <a href="/commands/watch">WATCH</a>
              може бути використаний для створення нової атомарної операції, що
              інакше не підтримується Redis, є реалізація ZPOP, що є командою,
              яка висуває елемент з нижчими балами з впорядкованої множини в
              атомічний шлях. Це найпростіша реалізація:</p>
            <pre><code>WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
</code></pre>
            <p>Якщо <a href="/commands/exec">EXEC</a> схибить (тобто, поверне <a
                href="/topics/protocol#nil-reply">нульову відповідь</a>) ми
              просто повторюємо операцію.</p>
            <span id="redis-scripting-and-transactions" class="anchor"></span>
            <h2><a href="#redis-scripting-and-transactions" class="anchor-link">*</a>Redis
              скрипти та транзакції</h2>
            <p><a href="/commands/eval">Скрипти Redis</a> є транзакціями за
              визначенням, і таким чином все, що ви можете робити з транзакціями
              Redis, ви можете робити зі скриптами, та, можливо, скрипт буде
              більш простішим та швидшим.</p>
            <p>Це дублювання існує через той факт, що скрипти були введені в
              Redis 2.6, тоді як транзакції існували задовно до того. Однак ми
              навряд чи видалимо транзакції в найближчому часі, бо це виглядає
              симантично доцільним, що навіть без звертання до скриптингу Redis
              все ще є можливим уникнути умов гонок, особливо зважаючи на те, що
              складність реалізації транзакцій Redis є мінімальною.</p>
            <p>Однак не є неможливим, щоб в найближчому майбутньому ми не
              побачили, що всі користувачі використовують суцільно скрипти. Якщо
              це станеться, ми можемо занеохотити, а потім і видалити
              транзакції.</p>
          </article>
        </div>
      </div>
      <footer class="site-footer">
        <div class="container">
          <p>Цей сайт є&nbsp; <a href="https://github.com/antirez/redis-io">програмним
              забезпеченням з відкритим кодом</a>. See all <a href="/topics/sponsors">credits</a>.
          </p>
          <div class="sponsor"> Спонсовано <a href="http://www.pivotal.io/big-data/redis">
              <img alt="Redis Support" src="/images/pivotal.png" title="Redis Sponsor"
                height="25" width="99"> </a> </div>
        </div>
      </footer>
    </div>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>
    <script src="/slideout.js?1426205838"></script>
    <script src="/app.js?1426611451"></script>
    <script type="text/javascript">
lloogg_clientid = "20bb9c026e";
</script> <script type="text/javascript" src="http://demo.lloogg.com/l.js?c=20bb9c026e">
</script>
  </body>
</html>
