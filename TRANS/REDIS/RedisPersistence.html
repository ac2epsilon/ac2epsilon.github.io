<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Постійні дані в Redis. Вступ до Redis. Переклад українською - Арсеній
      Чеботарьов - Ніжин 2016</title>
  </head>
  <body class="topics persistence">
    <address>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <div class="site-wrapper">
      <header class="menu-header"></header>
      <br>
      Ця сторінка провадить технічний опис постійних даних в Redis, це
      рекомендоване до читання всіма користавачами Redis. Для ширшого огляду
      постійності Redis
      та гарантій надійності, які він провадить, ви також можете прочитати <a href="http://antirez.com/post/redis-persistence-demystified.html">Постійність
        Redis демістифікована</a>.
      <div class="site-content">
        <div class="text">
          <article id="topic"> <span id="redis-persistence" class="anchor"></span>
            <h1>Постійність Redis</h1>
            <p>Redis провадить різноманітні опції постійності:</p>
            <ul>
              <li>Постійність RDB виконує снепшоти для окрамих моментів часу
                ваших даних з вказаним інтервалом.&nbsp;</li>
              <li>Постійність AOF журналює кожну операцію запису, отриману
                сервером, що буде програватись знову при запуску сервера,
                реконструюючи оригінальний набір даних. Команди журналюються з
                використанням того ж формата, як і сам протокол Redis, в режимі
                тільки-для-додавання. Redis здатен переписати журнал в фоні,
                коли він стає дуже великим.&nbsp;</li>
              <li>Якщо ви бажаєте, ви можете відключити постійність зовсім, якщо
                ви бажаєте, щоб ваші дані існували тільки доки робить ваш
                сервер.&nbsp;</li>
              <li>Можливо скомбінувати AOF та RDB в одному екземплярі. Однак
                зауважте, що в цьому випадку, коли Redis рестартує, буде
                використовуватись файл AOF для реконструкції оригінального
                набору даних, оскільки це гарантовано більш точний набір.</li>
            </ul>
            <p>Найбільш важлива для розуміння річ - це різні компроміси між
              постійністю RDB та AOF. Давайте почнемо з RDB:</p>
            <span id="rdb-advantages" class="anchor"></span>
            <h2>Переваги RDB</h2>
            <ul>
              <li>RDB дуже компактне, одно-файлове представлення ваших
                даних&nbsp; Redis на поточний момент часу. Файли RDB ідеальні
                для резервних копій. Наприклад, ви можете архівувати ваші файли
                RDB кожну годину для 24 годин поспіль, та зберігати снепшот RDB
                кожного дня протягом 30ти днів. Це дозволяє вам легко відновити
                різні версії набору даних в випадку втрати. </li>
              <li>RDB дуже добрий для відновлення після аварії, будучи єдиним
                компактним файлом, що може бути переданий до віддалених центрів
                даних, або на Amazon S3 (можливо зашифрований).</li>
              <li>RDB максимізує продуктивність Redis, оскільки робота
                батьківського процесу Redis, що потрібна для постійності, це
                тільки відокремити дочірній процес, що виконує все інше.
                Батьківський екземпляр ніколи не буде виконувати дисковий
                ввод-вивід, або щось подібне.&nbsp;</li>
              <li>RDB дозволяє швидший рестарт великих наборів даних, порівняно
                з AOF.</li>
            </ul>
            <span id="rdb-disadvantages" class="anchor"></span>
            <h2>Недоліки RDB</h2>
            <ul>
              <li>RDB НЕ гарний, якщо вам треба мінімізувати шанси втрати даних,
                в випадку коли Redis зупинить роботу (наприклад, після перебою
                живлення). Ви можете сконфігурувати декілька <em>точок
                  збереження</em>, де продукується RDB (наприклад, після
                щонайменше п'яти хвилин та 100 записів до набору даних, але ви
                можете мати декілька точок запису). Однак ви зазвичай будете
                створювати снепшоти RDB кожні п'ять хвилин або більше, так що в
                випадку припинення роботи Redis без коректного завершення з
                любої з причин налаштуйтесь на втрату даних за останні
                хвилини.&nbsp;</li>
              <li>RDB потребує часто робити fork(), щоб зберегти дані на диск з
                використанням дочкового процесу. Fork() може поглинати час, якщо
                база даних велика, та може призвести до того, що Redis припинить
                обслуговувати клієнтів на декілька мілісекунд, або навіть на
                одну секунду, якщо набір даних дуже великий, а потужність CPU не
                така визначна. AOF також потребує fork(), але ви можете
                налаштувати, як часто ви бажаєте переписвати ваш журнал, без
                компромісу з надійністю.</li>
            </ul>
            <span id="aof-advantages" class="anchor"></span>
            <h2>Переваги AOF</h2>
            <ul>
              <li>Використання AOF Redis значно надійніше: ви можете мати різні
                політики fsync: зовсім без fsync, fsync кожну секунду, fsync
                кожний запит. З налаштуванням по замовчанню, fsync кожну
                секунду, продуктивність запису залишається чудовою (fsync
                виконується в фоновому потоці, то головний потік буде робити все
                можливе, щоб виконати записи, коли fsync не виконується), але ви
                можете втратити тільки одну секунду записів.</li>
              <li>Журнал AOF використовується тільки для додавання, так що немає
                пошуку, немає проблеми руйнування в випадку збою живлення.
                Навіть якщо журнал завершується на напів-записану команду з
                якоїсь з причин (заповнений диск або щось інше), інструмент
                redis-check-aof в змозі це просто виправити.</li>
              <li>Redis здатен автоматично переписати AOF в фоні, коли він стає
                дуже великим. Перезапис повністю безпечний, оскільки доки Redis
                продовжує додавати до старого файлу, створюєть абсолютно новий з
                мінімальним набором операцій, потрібних для відтворення
                поточного набору даних, і коли цей другий файл готовий, Redis
                замінює файл, та починає записувати в новий.&nbsp;</li>
              <li>AOF містить журнал всіх операцій, одна за одною, в простому
                для розуміння та розбору форматі. Ви можете навіть просто
                експортувати файл AOF. Наприклад, навіть якщо ви помилково
                скинули все за допомогою команди FLUSHALL, але при тому в осяжній
                перспективі ви не перезаписували файл журналу, ви все ще можете
                зберігти ваші дані, просто зупинивши сервер, видаливши останню
                команду, та рестартувавши Redis знову.</li>
            </ul>
            <span id="aof-disadvantages" class="anchor"></span>
            <h2>Недоліки AOF</h2>
            <ul>
              <li>Файли AOF звичайно більші, ніж еквівалентні файли RDB для того
                ж набору даних.</li>
              <li>AOF може біти повільнішим, ніж RDB, в залежності від політики
                fsync. Загалом, коли fsync встановлене в <em>кожу секунду</em>
                продуктивність все ще дуже велика, та коли fsync відключений,
                він буде такий самий швидкий, як RDB, навіть під величезним
                навантаженням по запису.&nbsp;</li>
              <li>В минулому ми мали досвід рідких помилок в специфічних командах
                (наприклад, була одна, що включала блокуючи команди, такі як
                BRPOPLPUSH), що призводили до того, що отриманий AOF не
                відтворював саме такий набір даних при перезавантаженні. Ця
                помилка рідка, та ми проганяємо тестову сюїту, що автоматично
                створює складні випадкові набори даних, та перезавантажує їх, щоб
                перевірити що все добре. Але цей тип помилок майже неможливий з
                постійністю RDB. Щоб прояснити це більше доступно: Redis AOF
                робить інкрементально, оновлюючи існуючий стан, як це робить
                MySQL або MongoDB, тоді як RDB робить снепшот, створюючи все з
                початку знову і знову, що концептуально більш надійно. Однак: 1)
                Треба зазначити, що кожного разу, коли AOF переписується Redis,
                він створюється з початку, починаючи з дійсних даних, що містяться
                в наборі даних, роблячи стійкість до помилок сильнішою,
                порівняно з тим, щоб весь час додавати до AOF файлу (або з тим,
                щоб перезаписувати, читаючи старий&nbsp; AOF, замість того, щоб
                читати дані з пам'яті). 2) Ми ніколи не мали жодного
                повідомлення від користувачів щодо пошкодження AOF, що було
                зафіксоване в реальному світі.</li>
            </ul>
            <span id="ok-so-what-should-i-use" class="anchor"></span>
            <h2>Гаразд, що я маю використовувати?</h2>
            <p>Головним показником того, що ви маєте використовувати обоє методи
              постійності, якщо ви бажаєте рівень безпеки даних, порівняний з тим,
              що може надати PostgreSQL.</p>
            <p>Якщо ви дуже пілкуєтесь про свої дані, але все ще можете жити з
              втратами декількох хвилин даних в разі аварії, ви можете використовувати
              один RDB.</p>
            <p>Є багато користувачів, що використоють один AOF, але ми
              відохочуємо від цього, оскільки мати час від часу снепшоти RDB є
              чудовою ідеєю для створення резервних копій, для швидших
              рестартів, та в випадку багів в механізмі AOF.</p>
            <p>Зауваження: з усіх ціх причин ми кінец кінцем прийдемо до
              уніфікації AOF та RDB в єдиній моделі постійності в майбутньому
              (це довготривалий план).</p>
            <p>Наступні розділи проіллюструють декілька деталей щодо двох
              моделей постійності.</p>
            <span id="snapshotting" class="anchor"></span>
            <h2>Снепшоти</h2>
            <p>По замовчанню Redis зберігає снепшоти даних на диск, в бінарний
              файл з назвою&nbsp;<code>dump.rdb</code>. Ви можете сконфігурувати
              Redis, щоб він зберігав набір даних кожні N, якщо щонайменьше M
              змін занесені в набір даних, або ви можете вручну викликати команди
              <a href="/commands/save">SAVE</a> або <a href="/commands/bgsave">BGSAVE</a>.</p>
            <p>Наприклад, ця конфігурація змусить Redis робить автоматичний дамп
              набору даних кожні 60 секунд, якщо змінено щонайменьше 1000 клчів:</p>
            <pre><code>save 60 1000
</code></pre>
            <p>Ця стратегія відома як <em>снепшотінг</em>.</p>
            <span id="how-it-works" class="anchor"></span>
            <h3>Як це працює</h3>
            <p>Коли Redis потребує скинути дамп на диск, відбувається наступне:</p>
            <ul>
              <li>
                <p>Redis <a href="http://linux.die.net/man/2/fork">робить
                    відгалуження</a>. Тепер ми маємо дочірній процес.</p>
              </li>
              <li>
                <p>Дочка починає записувати набір даних в тимчасовий файл RDB.</p>
              </li>
              <li>
                <p>Коли процес завершує запис нового файлу RDB, він заміщує
                  старий файл на новий.</p>
              </li>
            </ul>
            <p>Цей метод дозволяє Redis виграти від семантики
              копіюваня-по-запису.</p>
            <h2>Файл тільки для запису</h2>
            <p>Снапшотінг не є дуже надійним. Якщо ваш комп'ютер, на якому
              робить Redis, зупиняється, ваша мережа відключається або ви
              ненавмисне робите <code>kill -9</code> вашому екземпляру, останні
              дані, записані Redis, будуть втрачені. Хоча це може бути не
              великою втратою для деяких застосувань, є випадки для повної
              надійності, та в ціх випадках Redis не був прийнятною опцією.</p>
            <p><em>Файл тільки для запису </em>є альтернативною, повністю
              надійною стратегією для Redis. Вона стала доступна починаючи з
              версії 1.1.</p>
            <p>Ви можете ввімкнути AOF в вашому файлі конфігурації:</p>
            <pre><code>appendonly yes
</code></pre>
            <p>Тепер кожного разу, коли Redis отримує команду, що змінює набір
              даних (таку як <a href="/commands/set">SET</a>), він буде
              додавати її до AOF. Коли ви рестартуєте Redis, він програє AOF для
              відновлення стану.</p>
            <span id="log-rewriting" class="anchor"></span>
            <h3>Перезапис журналу</h3>
            <p>Як ви можете здогадатись, файл AOF стає все більшим та більшим,
              по мірі виконання команд запису. Наприклад, якщо ви збільшили
              лічильник 100 разів, ви закінчите тим, що один ключ в вашій базі
              даних отримає остаточне значення, але 100 записів потраплять в
              AOF. 99 з ціх записів не потрібні для відновлення поточного стану.
            </p>
            <p>Redis підтримує цікаву функцію: він в змозі перебудувати AOF в
              фоні без переривання обслуговування клієнтів. Коли ви даєте
              команду <a href="/commands/bgrewriteaof">BGREWRITEAOF</a>, Redis
              запише найкоротшу послідвність команд, потрібних для перебудови
              поточного набору даних в пам'яті. Якщо ви використовуєте AOF з
              Redis 2.2, вам треба викликати&nbsp;<a href="/commands/bgrewriteaof">BGREWRITEAOF</a>
              час від часу. Redis 2.4 в змозі перемикати перезапис журналу
              автоматично (дивіться приклад файлу конфігурації 2.4 для
              додаткової інформації).</p>
            <span id="how-durable-is-the-append-only-file" class="anchor"></span>
            <h3>Наскільки надійний файл тільки для запису?</h3>
            <p>Ви можете сконфігурувати, скільки разів Redis буде <a href="http://linux.die.net/man/2/fsync"><code>fsync</code></a>
              дані на диск. Є три опції:</p>
            <ul>
              <li>
                <p><code>fsync</code> кожного разу, коли нова команда додається
                  до AOF. Дуже-дуже повільно, дуже надійно.</p>
              </li>
              <li>
                <p><code>fsync</code> кожну секунду. Досить швидко (в 2.4
                  вірогідно так же швидко, як снепшотінг), та ви можете втратити
                  1 секунду в випадку катастрофи.&nbsp;</p>
              </li>
              <li>
                <p>Ніколи не <code>fsync</code>, просто передавати дані на
                  розсуд операційної системи. Найшвидший та найменьш надійний
                  метод.</p>
              </li>
            </ul>
            <p>Рекомендована (та по замовчанню) політика є <code>fsync</code>
              кожну секунду. Це, разом, дуже швидко та досить безпечно. Політика
              <code>always</code>
              дуже повільна на практиці (хоча вона була покращена в Redis 2.0) –
              немає шляху зробити <code>fsync</code> швидше, ніж воно є.</p>
            <span id="what-should-i-do-if-my-aof-gets-corrupted" class="anchor"></span>
            <h3>Що мені робити, якщо мій AOF пошкоджений?</h3>
            <p>Можливо, що сервер впаде під час запису файлу AOF (це все одне не
              призведе до неузгодженності), пошкоджаючи файл таким чином, що він
              більше не завантажується до Redis. Коли це відбувається, ви можете
              вирішити цю проблему, використовуючи наступну процедуру:</p>
            <ul>
              <li>
                <p>Зробіть резервну копію файшого файлу AOF.</p>
              </li>
              <li>
                <p>Полагодьте оригінальний файл використовуючи інструмент <code>redis-check-aof</code>,
                  що іде з Redis:</p>
                <p>$ redis-check-aof --fix <filename></filename></p>
              </li>
              <li>
                <p>Опціонально використовуйте <code>diff -u</code> для перевірки,
                  що змінилось між двома файлами.</p>
              </li>
              <li>
                <p>Рестартуйте сервер з полагодженим файлом.</p>
              </li>
            </ul>
            <span id="how-it-works" class="anchor"></span>
            <h3>Як це працює</h3>
            <p>Перезапис журналу використовує той же трюк копія-по-запису, що і
              снепшотінг. Ось як це працює:</p>
            <ul>
              <li>
                <p>Redis <a href="http://linux.die.net/man/2/fork">робить
                    відгалуження</a>, так що тепер ми маємо батьківський та
                  дочірній процеси.</p>
              </li>
              <li>
                <p>Дитя стартує запис в новий тимчасовий файл AOF .</p>
              </li>
              <li>
                <p>Батько акумулює всі нові зміни в буфері в пам'яті (але в той
                  же самий час він записує зміни в старий файл тільки для
                  додавання, так що коли перезапис схибить ми будемо в бебзпеці).</p>
              </li>
              <li>
                <p>Коли дитя завершить перезапис файлу, батько отрумує сигнал,
                  та додає буфер в пам'яті в кінець файлу, згенерованого дитям.</p>
              </li>
              <li>
                <p>Все! Тепер Redis автоматично переіменовує старий файл в новий,
                  та починає додавати дані в новий файл.</p>
              </li>
            </ul>
            <span id="how-i-can-switch-to-aof-if-i39m-currently-using-dumprdb-snapshots"
              class="anchor"></span>
            <h3>Як мені перейти на AOF, якщо я наразі використовую снепшоти
              dump.rdb?</h3>
            <p>Є різні процедури зробити це в Redis 2.0 та Redis 2.2, та, як ви
              здогадались, це простіше в Redis 2.2, і зовсім не потребує
              рестарту.</p>
            <p><strong>Redis &gt;= 2.2</strong></p>
            <ul>
              <li>Зробіть резервну копію вашого останнього файлу dump.rdb.</li>
              <li>Перенесіть цю копію в безпечне місце.</li>
              <li>Введіть наступні команди:</li>
              <li>redis-cli config set appendonly yes</li>
              <li>redis-cli config set save ""</li>
              <li>Переконайтесь, що маша база даних містить те ж число ключів,
                що вона і мала.</li>
              <li>Переконайтесь, що записи додаються до файлу тільки для
                додавання коректно.</li>
            </ul>
            <p>Перша команда CONFIG включає Append Only File. Щоб виконати її, <strong>Redis
                заблокуєтся</strong> щоб згенерувати первиннй дамп, потім
              відкриє файл для запису, та почне додавати всі подальші запити на
              запис.</p>
            <p>Друга команда CONFIG використовується для відключення снепшотінгу.
              Це опціонально, якщо ви бажаєте ви можете мати обоє методи постійності
              одночасно.&nbsp;</p>
            <p><strong>ВАЖЛИВО:</strong> не забувайте редагувати ваш redis.conf
              для включення AOF, інакше коли ви рестартуєте сервер зміни
              конфігурації будуть втрачені, та сервер знову стартує зі старою
              конфігурацією.</p>
            <p><strong>Redis 2.0</strong></p>
            <ul>
              <li>Зробіть резервну копію вашого останнього файлу dump.rdb.</li>
              <li>Перенесіть його в беспечне місце.</li>
              <li>Завершіть всі записи в вашу базу даних!</li>
              <li>Видайте команду redis-cli bgrewriteaof. Це створить файл
                тільки для додавання.</li>
              <li>Завершіть сервер коли Redis закінчить генерацію дампу AOF.</li>
              <li>Відредагуйте redis.conf, щоб ввімкнути постійність через файл
                для додавання.</li>
              <li>Рестартуйте сервер.</li>
              <li>Переконайтесь, що ваша база даних містить ту ж кількіть
                ключив, що і до цього.</li>
              <li>Переконайтесь, що записи додаються до файлу для додавання
                коректно. </li>
            </ul>
            <span id="interactions-between-aof-and-rdb-persistence" class="anchor"></span>
            <h2>Взаємодія між AOF та RDB</h2>
            <p>Redis &gt;= 2.4 запобігає перемиканню перезапису AOF, якщо саме
              виконується операція снепшоттінгу RDB, або включенню BGSAVE під
              час перезапису AOF. Це не дає двом фоновим процесам Redis
              виконувати важке навантаження вводу-виводу одночасно.</p>
            <p>Якщо під час виконання снепшотінгу користувач явно запросить
              перезапис журналу за допомогою команди BGREWRITEAOF, сервер
              відповідсть статусом OK, що означає, що команда запланована, та
              перезапис стартує як тільки завершиться снепшотінг.</p>
            В разі, коли обоє, постійність AOF та RDB ввімкнені, та Redis
            рестартує, файл AOF буде використовуватись для реконструкції
            оригінального набору даних, тому що він гарантовано буде більше
            повним. <span id="backing-up-redis-data" class="anchor"></span>
            <h2>Резервна копія даних Redis</h2>
            <p>Перед початком цього розділу переконайтесь, що прочитали наступне
              речення: <strong>Будьте Впевнені, Що Зробили Резервну Копію Вашої
                Бази Даних</strong>. Поломка диску, зникнення екземплярів в
              хмарах, і таке інше: відсутність резервної копії означає величений
              ризик зникнення даних в /dev/null.</p>
            <p>Redis дуже дружній до створення резервних копій, оскільки він
              може копіювати файли RDB під час виконання бази даних: RDB ніколи
              не модифікується після створення, та доки він створюється,
              використовується тимасове ім'я, та потім файл переіменовується в
              остаточному вигляді з використанням атомарного rename(2), тільки
              коли створення снепшоту завершене.</p>
            <p>Це означає, що копіювання файлу RDB є повністю безпечним під час
              виконання серверу. Ось що ми радимо:</p>
            <ul>
              <li>Створіть завдання cron на вашому сервері, що продукуватиме
                снепшоти щогодини в файл RDB в одному каталозі, та щоденний
                снепшот в іншому каталозі.&nbsp;</li>
              <li>Кожного разу, коли виконується скрипт cron, переконайтесь, що
                викликали команду <code>find</code>, та старі снепшоти будуть
                видалені: наприклад, ви можете залишити щогодинні снепшоти за
                останні 48 годин, та щоденні снепшоти за один або два місяці.
                Переконайтесь, що назвали снепшоти по датах та часу формування.</li>
              <li>Щонайменьше один раз кожного дня надійно передавайте снепшот
                RDB <em>за межі вашого центру обробки даних </em>або,
                щонайменьше, <em>за межі фізичної машини</em>, що виконує ваш
                екземпляр Redis.</li>
            </ul>
            <span id="disaster-recovery" class="anchor"></span>
            <h2>Відновлення після аварії</h2>
            <p>Відновлення після аварії в контексті Redis в основному та ж
              історія, що і резервне копіювання, плюс можливість передати ці
              резервні копії до декількох зовнішніх центрів даних. Таким чином
              дані унезбезпечуються в випадку катастрофічної події, якщо
              постраждає центральний центр даних, де виконується Redis та
              продукуються снепшоти.</p>
            <p>Оскільки багато користувачів Redis знаходяться на стартап сцені,
              та не мають багато грошей на витрати,&nbsp;ми опишемо найбільш
              цікаві технології, що не потребують великих витрат.</p>
            <ul>
              <li>Amazon S3 та інші подібні сервіси є гарним шляхом для
                монтування вашої системи захисту від аварій. Просто перенесіть
                ваші дані або щогодинний снепшот RDB до S3 в зашифровній формі.
                Ви можете зашифрувати ваші дані за допомогою <code>gpg -c</code>
                (в режимі семетричного шифрування). Переконайтесь, що зберігли
                ваш пароль в декількох надійних місцях (наприклад, надайте копію
                самим поважним людям в вашій організації). Рекомендовано
                використовувати декілька сервісів зберігання для покращенної
                безпеки даних.</li>
              <li>Перенесіть ваші снепшоти з використанням SCP (частина SSH) до
                віддалених серверів. Це дуже простий та безпечний маршрут:
                утворіть малу VPS на місці, що дуже далеко від вас, встановіть
                там ssh, згенеруйте клієнтський ключ ssh без ключового слова,
                потім додайте його до файлу authorized_keys на вашій малій VPS.
                Ви готові до передачі резервних копій а автоматичному режимі.
                Зробіть щонайменьше дві VPS
                в двох різних провайдерів для кращих результатів. </li>
            </ul>
            <p>Важливо розуміти, що ця система може легко дати збій, якщо не
              закодована відповідним чином. Щонайменьше надійно переконайтесь,
              що коли передача завершена, ви в змозі перевірити розмір файлу (що
              має співпадати з тим, що ви копіювали), та можливо дайджест SHA1,
              якщо ви використовуєте VPS.</p>
            <p>Вам також треба деяка незалежна система сповіщення, якщо передача
              свіжих резервних копій не робить з якоїсь причини.</p>
          </article>
        </div>
      </div>
    </div>
  </body>
</html>
