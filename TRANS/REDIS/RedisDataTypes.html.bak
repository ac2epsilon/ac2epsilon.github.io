<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <meta content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
    <title>Вступ до типів даних та абстракцій
              Redis. Переклад українською - Арсеній Чеботарьов - Ніжин 2016 </title>
  </head>
  <body class="topics data-types-intro">
    <div class="site-wrapper">
      <header class="menu-header"></header>
      <address>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
      <div class="site-content">
        <div class="text">
          <article id="topic"> <span id="an-introduction-to-redis-data-types-and-abstractions"
              class="anchor"></span>
            <h1><a href="#an-introduction-to-redis-data-types-and-abstractions"
                class="anchor-link">*</a>Вступ до типів даних та абстракцій
              Redis</h1>
            <p>Redis не є <em>пласким</em> сховищем ключ-значення, насправді це
              <em>сервер структур даних</em>, що підтримує різні класи значень.
              Це означає, що коли в традиційних сховищах ключ-значення ви
              асоціюєте строкові ключі зі строковими значеннями, в Redis
              значення не обмежене до простих рядків, абе може містити більш
              складні структури даних. Далі слідує перелік структур даних, що
              підтримуються Redis, що буде пояснено окремо в цьому підручнику:</p>
            <ul>
              <li>Двійниково-безпечні рядки.&nbsp;</li>
              <li>Списки: колекції строкових елементів, відсортовані згідно
                порядку додавання. Вони в основному <em>зв’язані списки</em>.</li>
              <li>Множини: набори унікальних, несортованих строкових елементів.</li>
              <li>Сортовані множини, подібні до множим, де кожний строковий
                елемент асоційований з числом з плаваючою комою, що називається
                <em>балами</em>. Ці елементи завжди ідуть відсортованими за
                своїми балами, так що на відміну від множин, можливо отримати
                диапазон елементів (наприклад, ви можете запитати: дайте мені
                вищі 10, або нижчі 10).</li>
              <li>Хеші, що є картами, що складаються з полів. асоційованих зі
                значеннями. Обоє, поле та значення є рядками. Це дуже подібно до
                хешів в Ruby або Python.</li>
              <li>Бітові масиви (або просто бітові карти): можливо, з
                використанням спеціальних команд, обробляти строкові значення як
                масиви бітів: ви можете очистити окремі біти, порахувати всі
                біти, встановлені в 1, знайти перший встановлений або
                невстановлений біт, і таке інше.</li>
              <li>Гіпержурнали: це структуру вірогіднісних даних, що
                використовуються для очікування потужності множини. Не
                лякайтесь, це простіше, ніж здається... Дивіться далі, в розділі
                HyperLogLog цього підручника.</li>
            </ul>
            <p>Не є завжди тривіальним схопити, як ці типи даних роблять, та що
              використовувати для вирішення окремої проблеми, користуючись лише
              <a href="/commands">посиланням на команди</a>, так що цей документ
              є пришвидшеним курсом по типах даних Redis, та їх найбільш
              поширених шаблонах використання.</p>
            <p>Для всіх прикладів ми будемо використовувати утіліту&nbsp;<code>redis-cli</code>,
              що є простою, але корисною утілітою командного рядка, щоб
              надсилати команди до Redis сервера.</p>
            <span id="redis-keys" class="anchor"></span>
            <h2><a href="#redis-keys" class="anchor-link">*</a>Ключі Redis</h2>
            <p>Ключі Redis є двоїчно безпечними, що означає, що ви можете
              використовувати любу двійникову послідовність в якості ключа, від
              рідка, такого як "foo", до вмісту JPEG файлу. Пустий рядок також є
              прийнятним ключем.</p>
            <p>Декілька інших правил щодо ключів:</p>
            <ul>
              <li>Дуже довгі ключі не є гарною ідеєю, наприклад, ключ з 1024
                байтів є поганою ідеєю, не тільки з боку пам’яті, але також
                оскільки пошук ключа в наборі даних може вимагати декількох
                коштовних порівнянь ключів. Навіть якщо задача полягає лише в
                пошуку на предмет існування довгого значення, рішення хешувати
                його (наприклад, за допомогою SHA1) буде кращою ідеєю, особливо
                з тбали зору пам’яті та пропускної здібності.</li>
              <li>Дуже короткі ключі часто не є гарною ідеєю. Є не багато зиску
                записувати "u1000flw" в якості ключа, замість щоб записати
                "user:1000:followers". Останнє є більш зрозумілим та додатковий
                простір є незначним у порівнянні з простором, що
                використовуєтсья об’єктом самого ключа та об’єктом значення.
                Тоді як короткі ключі вочевидь використовують меньше пам’ті,
                ваше завдання полягає в тому, щоб знайти правильний баланс.</li>
              <li>Намагайтесь притримуватись схеми. Наприклад, "object-type:id"
                є гарною ідеєю, як в "user:1000". Крапки або тире часто
                використовуються для багатослівних полів, як в
                "comment:1234:reply.to" або "comment:1234:reply-to".</li>
              <li>Максимальний розмір ключа є 512 Мб.</li>
            </ul>
            <p><a name="strings"></a></p>
            <span id="redis-strings" class="anchor"></span>
            <h2><a href="#redis-strings" class="anchor-link">*</a>Рядки Redis</h2>
            <p>Тип Redis String є найпростішим типом значення, що може бути
              асоційовано з ключем Redis. Це єдиний тип даних в Memcached, так
              що також дуже природним для новачків є його викиростання Redis.</p>
            <p>Оскільки ключі в Redis є рядками, та ми використовуємо тип рядків
              для значення, тоді ми відображуємо рядки на рядки. Строковий тип
              даних корисний в декількох випадках, як кешування фрагментів або
              сторінок HTML.</p>
            <p>Давайте пограємось трохи зі строковим типом, використовуючи&nbsp;<code>redis-cli</code>
              (всі приклади в цій книжці будуть використовувати&nbsp;<code>redis-cli</code>).</p>
            <pre><code>&gt; set mykey somevalue
OK
&gt; get mykey
"somevalue"
</code></pre>
            <p>Як ви бачите, використання команд <a href="/commands/set">SET</a>
              та <a href="/commands/get">GET</a> є шляхом для встановлення та
              отримання строкового значення. Зауважте, що <a href="/commands/set">SET</a>
              буде заміщувати любе існуюче значення, що вже зберігаєтсья в в
              ключі, в разі, якщо цей клч вже існує, навіть якщо ключ
              асоційований з не-рядковим значенням. Так що&nbsp;<a href="/commands/set">SET</a>
              виконує присвоювання.</p>
            <p>Значення можуть бути строками (включачи двійникові дані) любого
              типу, наприклад, ви можете зберігати зображення jpeg в ключі.
              Значення не може бути більшим, ніж 512 Мб.</p>
            <p>Команда <a href="/commands/set">SET</a> має цікаві опції, що
              надаються як додаткові аргументи. Наприклад, я можу попросити <a
                href="/commands/set">SET</a> дати збій, якщо ключ вже існує, або
              навпаки, команда буде успішно, тільки якщо він вже існує:</p>
            <pre><code>&gt; set mykey newval nx
(nil)
&gt; set mykey newval xx
OK
</code></pre>
            <p>Навіть якщо рядки є проcтішими значеннями в Redis, є цікаві
              операції, що ви можете виконати з ними. Наприклад, одна з них є
              атмарне збільшення:</p>
            <pre><code>&gt; set counter 100
OK
&gt; incr counter
(integer) 101
&gt; incr counter
(integer) 102
&gt; incrby counter 50
(integer) 152
</code></pre>
            <p>Команда <a href="/commands/incr">INCR</a> розбирає значення
              рядка як ціле, збільшує його на одиницю, та, нарешті, встановлює
              отримане значення як нове значення . Є інші подібні команди, такі
              як&nbsp;<a href="/commands/incrby">INCRBY</a>, <a href="/commands/decr">DECR</a>
              та <a href="/commands/decrby">DECRBY</a>. З середини це завжди
              одна й та ж команда, що діє в трохи інший спосіб.</p>
            <p>Що означає те, що команда INCR є атомарниою? Що навіть декілька
              клієнтів, що виконують INCR для одного ключа, ніколи не війдуть в
              стан гонок. Наприклад, ніколи не буде такого, що 1 читає "10",
              клієнт 2 читає "10" в той же час, обоє збільшують значення до 11,
              та встановлюють нове значення в 11. Остаточне значення завжди буде
              12 та команда читати-збільшити-зберегти буде виконуватись тоді,
              коли всі інші клієнти не виконують команду в той же час.&nbsp;</p>
            <p>Є декілька команд для операцій над рядками. Наприклад, команда <a
                href="/commands/getset">GETSET</a> встановлює ключ в нове
              значення, повертаючи старе значення як результат. Ви можете
              використовувати цю команду, наприклад, коли ви маєте систему, що
              ключ Redis з використанням <a href="/commands/incr">INCR</a>
              кожного разу, коли ваш сайт отримує нового визітера. Ви можете
              побажати збирати цю інформацію один раз на годину, без того, щоб
              втратити жодне збільшення. Ви можете зробити <a href="/commands/getset">GETSET</a>
              для ключа, надаючи йому нове значення "0" та читаючи старе
              значення.</p>
            <p>Можливість встановити або отримати значення декількох ключів в
              одній команді також корисне для зменшення затримок. З цієї причини
              існують команди <a href="/commands/mset">MSET</a> та <a href="/commands/mget">MGET</a>:</p>
            <pre><code>&gt; mset a 10 b 20 c 30
OK
&gt; mget a b c
1) "10"
2) "20"
3) "30"
</code></pre>
            <p>Коли використовується <a href="/commands/mget">MGET</a>, Redis
              повертає масив значень.</p>
            <span id="altering-and-querying-the-key-space" class="anchor"></span>
            <h2><a href="#altering-and-querying-the-key-space" class="anchor-link">*</a>Зміна
              та запити до простору ключів</h2>
            <p>Існують команди, що не визначені на окремих типах, але корисні
              для взаємодії з простором ключів, і, таким чином, використовуються
              з ключами любого типу.&nbsp;</p>
            <p>Наприклад, команда&nbsp;<a href="/commands/exists">EXISTS</a>
              повертає 1 або 0, щоб визначити, чи існує в базі даних наданий
              ключ, або ні, або команда <a href="/commands/del">DEL</a>, що
              видаляє ключ та асоційоване значення, не зважаючи на тип значення.</p>
            <pre><code>&gt; set mykey hello
OK
&gt; exists mykey
(integer) 1
&gt; del mykey
(integer) 1
&gt; exists mykey
(integer) 0
</code></pre>
            <p>З прикладу ви можете побачити, як&nbsp;<a href="/commands/del">DEL</a>
              сама по собі повертає 1 або 0, в залежності від того, чи був ключ
              видалений (якщо існував), або ні (коли не існувало ключа з таким
              ім’ям).</p>
            <p>Є багато команд, пов’язаних з простором ключів, але нижче дві
              основні, разом з командою&nbsp;<a href="/commands/type">TYPE</a>,
              яка повертає тип значення, що зберігається в окремому ключі:</p>
            <pre><code>&gt; set mykey x
OK
&gt; type mykey
string
&gt; del mykey
(integer) 1
&gt; type mykey
none
</code></pre> <span id="redis-expires-keys-with-limited-time-to-live" class="anchor"></span>
            <h2><a href="#redis-expires-keys-with-limited-time-to-live" class="anchor-link">*</a>Redis
              прострочення: ключі з лімітованим часом життя</h2>
            <p>Перед тим, як продовжувати з більш складними структурами даних,
              нам потрібно обсудити іншу можливість, що працює безвідносно до
              типу значення, та називається <strong>Redis прострочення</strong>.
              Ви можете встановити таймаут для ключа, що обмежує час життя. Коли
              час життя спливає, ключ автоматично руйнується, точно таким же
              чином, як коли користувач викликає команду&nbsp;<a href="/commands/del">DEL</a>
              для цього ключа.</p>
            <p>Швидка справка щодо прострочень Redis:</p>
            <ul>
              <li>Вони можуть бути встановлені або з використанням секунд, або з
                точністю до мілісекунд.</li>
              <li>Однак точність часу прострочення завжди одна мілісекунда.</li>
              <li>Інформація щодо прострочення реплікується та зберігається на
                диску, час віртуально проходить коли ваш Redis сервер
                залишається зупиненим (це означає, щ о Redis зберігає дату, коли
                ключ буде прострочено).</li>
            </ul>
            <p>Встановлення прострочення тривіальне:</p>
            <pre><code>&gt; set key some-value
OK
&gt; expire key 5
(integer) 1
&gt; get key (immediately)
"some-value"
&gt; get key (after some time)
(nil)
</code></pre>
            <p>Ключ зникає між двома викликами&nbsp;<a href="/commands/get">GET</a>,
              оскільки другий виклик був запізнений більше ніж на п’ять секунд.
              В прикладі вище ми використовували&nbsp;<a href="/commands/expire">EXPIRE</a>
              щоб вказати час прострочення (це може бути також використано для
              того, щоб змініти цей час, коли ключ вже мав встановлений час
              прострочення, так само як <a href="/commands/persist">PERSIST</a>
              може бути використаний щоб видалити прострочення та зробити ключ
              постійним назавжди). Однак ми можемо також створити ключі з часом
              прострочення з використанням інших команд Redis. Наприклад, з
              використанням опцій <a href="/commands/set">SET</a>:</p>
            <pre><code>&gt; set key 100 ex 10
OK
&gt; ttl key
(integer) 9
</code></pre>
            <p>Приклад вище встановлює ключ зі строковим значенням&nbsp;<code>100</code>,
              що має прострочитись за десять секунд. Піздніше команда&nbsp;<a href="/commands/ttl">TTL</a>
              викликається для того ,щоб перевірити залишок часу існування
              ключа.</p>
            <p>Щоб встановити та перевірити час життя в мілісекундах,
              звертайтесь до команд <a href="/commands/pexpire">PEXPIRE</a> та
              <a href="/commands/pttl">PTTL</a>, а також до повного списку опцій
              <a href="/commands/set">SET</a>.</p>
            <p><a name="lists"></a></p>
            <span id="redis-lists" class="anchor"></span>
            <h2><a href="#redis-lists" class="anchor-link">*</a>Списки Redis</h2>
            <p>Щоб пояснити тип даних <em>список</em> краще почати з
              невеличкого теоретичного вступу, оскільки термін <em>список</em>
              часто використовується невідповідним шляхом хлопцями від
              інформаційних технологій. Наприклад, "списки Python" не є тим, що
              підказує ім’я (з’язані списки), але скоріше масиви (насправді, той
              же тип називається масивами в&nbsp; Ruby).</p>
            <p>З дуже загальної тбали зору список є тільки послідовністю
              впорядкованих елементів: 10,20,1,2,3 є списком. Але властивості
              списку, що реалізований з використанням масиву, дуже відрізняється
              від властивостей списку, що реалізований як <strong><em>зв’язаний
                  список</em></strong>.</p>
            <p>Списки Redis реалізовані як зв’язані списки. Це означає, що
              навіть якщо ви маєте мільйони елементів в списку, операції
              додавання нового елементу в голову або в хвіст виконується за <em>постійний
                час</em>. Щвидкість додавання нового елементу за допомогою
              команди&nbsp;<a href="/commands/lpush">LPUSH</a> в голову списку з
              десятьма елементами є такою ж, як і додавання елементу в голову
              списку з десять мільйонів елементів.</p>
            <p>Яка зворотня сторона? Доступ до елементів <em>за індексом</em> є
              дуже швидким для списків, реалізованих як масиви (індексний доступ
              за сталий час), і не такий швидкий для списків, що реалізовані як
              зв’язані списки (де ця операція потребує обсягу роботи, що
              пропорційна до індексу отримуваного елементу).</p>
            <p>Списки Redis реалізовані як зв’язані списки, оскільки для системи
              бази даних є критичним можливість додавати елементи до дуже
              довгого списку в дуже швидкий спосіб. Друга сильна перевага, як ви
              побачите через мить, в тому, що списки Redis можуть бути взяті на
              сталу довжину в сталий час.</p>
            <p>Коли швидкий доступ до середини довгої колекції елементів є
              важливим, ісунє інша структура даних, що може бут використана, що
              називається сортована множина. Сортовані множини будуть розкриті
              далі в цьому підручникові.</p>
            <span id="first-steps-with-redis-lists" class="anchor"></span>
            <h2><a href="#first-steps-with-redis-lists" class="anchor-link">*</a>Перші
              кроки зі списками Redis</h2>
            <p>Команда <a href="/commands/lpush">LPUSH</a> додає новий елемент
              в список зліва (умовне позначення голови списку), тоді як команда
              <a href="/commands/rpush">RPUSH</a> додає новий елемент в список
              зправа (в хвіст). Нарешті, команда <a href="/commands/lrange">LRANGE</a>
              виділяє диапазони елементів зі списків:</p>
            <pre><code>&gt; rpush mylist A
(integer) 1
&gt; rpush mylist B
(integer) 2
&gt; lpush mylist first
(integer) 3
&gt; lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
</code></pre>
            <p>Зауважте, що <a href="/commands/lrange">LRANGE</a> приймає два
              індекси, перший та останній елементи з диапазону, що повертається.
              Обоє індекси можуть бути від’ємними, що каже Redis почати рахувати
              з кінця: таки чином -1 є останнім елементном, -2 є передостаннім
              елементом списку, і так далі.</p>
            <p>Як ви можете бачити, <a href="/commands/rpush">RPUSH</a> додає
              елементи справа списку, тоді як&nbsp;<a href="/commands/lpush">LPUSH</a>
              додає елемент зліва.</p>
            <p>Обоє команди є <em>командами змінної арності</em>, що обзначає,
              що ви можете вільно затовкувати декілька елементів в список в
              одному виклику:</p>
            <pre><code>&gt; rpush mylist 1 2 3 4 5 "foo bar"
(integer) 9
&gt; lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
4) "1"
5) "2"
6) "3"
7) "4"
8) "5"
9) "foo bar"
</code></pre>
            <p>Важливою операцією, визначеною для списків Redis є можливість <em>виштовхувати
                елементи</em>. Висування елементів є операцією обох, отримання
              елементу зі списку та видалення його зі списку, одночасно. Ви
              можете виштовхувати елементи зліва та зправа, подібно до того, як
              ви можете затовкувати елементи з обох сторін списку:</p>
            <pre><code>&gt; rpush mylist a b c
(integer) 3
&gt; rpop mylist
"c"
&gt; rpop mylist
"b"
&gt; rpop mylist
"a"
</code></pre>
            <p>Ми додали три елементи та виштовхнули три елементи. так що
              наприкінці цієї послідовності команд список пустий, так що немає
              більше елементів для виштовхування. Якщо ми спробуємо виштовхнути
              наступний елемент, то ми отримаємо такий результат:</p>
            <pre><code>&gt; rpop mylist
(nil)
</code></pre>
            <p>Redis повертає значення NULL, щоб повідомити, що більше немає
              елементів в списку.</p>
            <span id="common-use-cases-for-lists" class="anchor"></span>
            <h2><a href="#common-use-cases-for-lists" class="anchor-link">*</a>Загальні
              приклади використання списків</h2>
            <p>Списки корисні для декількох задач, та два дуже представницькі
              приклади використання є наступними:</p>
            <ul>
              <li>Запам’ятати останні оновлення, надіслані користувачами в
                соціальну мережу.</li>
              <li>Взаємодія між процесами з використанням шаблону
                споживач-продьсер, де продьюсер заштовхує елементи в список, та
                споживач (зазвичай <em>робітник</em>) споживає ці елементи та
                виконує дії. Redis має спеціальні команди, щоб зробити цей
                сценарій одночасно більш надійним та ефективним.</li>
            </ul>
            <p>Наприклад, обоє популярні бібліотеки Ruby,&nbsp; <a href="https://github.com/resque/resque">resque</a>
              та <a href="https://github.com/mperham/sidekiq">sidekiq</a>,
              внутрішньо використовують списки Redis щоб реалізувати фонові
              завдання.</p>
            <p>Популярна соціальна мережа Twitter <a href="http://www.infoq.com/presentations/Real-Time-Delivery-Twitter">утримує
                останні твіти</a>, опубліковані користувачем, в списках Redis.</p>
            <p>Щоб описати загальний пипадок використання крок за кроком, уявіть
              вашу домашню сторінку, що відображує останні світлини,
              опубліковані в соціальній мережі обміну фото, та ви&nbsp;бажаєте
              прискорити доступ.</p>
            <ul>
              <li>Кожного разу, коли користувач публікує нове фото, ви додаєте
                його ID в список за допомогою <a href="/commands/lpush">LPUSH</a>.</li>
              <li>Коли користувачі завітають на веб сторінку, ми використувуємо
                <code>LRANGE 0 9</code> щоб отримати останні десять елементів.</li>
            </ul>
            <span id="capped-lists" class="anchor"></span>
            <h2><a href="#capped-lists" class="anchor-link">*</a>Обмежені списки</h2>
            <p>В багатьох випадках ми тільки бажаємо використовувати списки для
              зберігання <em>останніх елементів</em>, чим бі вони не були:
              оновлення соціальних мереж, журнали або будь-що інше.</p>
            <p>Redis дозволяє нам використовувати списки як обмежені колекції,
              запам’ятовуючи тільки останні N елементів, та відкидаючи всі
              старіші елементи з використанням команди <a href="/commands/ltrim">LTRIM</a>.</p>
            <p>Команда <a href="/commands/ltrim">LTRIM</a> подібна до <a href="/commands/lrange">LRANGE</a>,
              але <strong>замість відображення указаного диапазону елементів</strong>
              вона встановлює цей диапазон в якості нового значення. Всі
              елементи за межами наданого диапазону видаляються.</p>
            <p>Приклад зробить це більш зрозумілим:</p>
            <pre><code>&gt; rpush mylist 1 2 3 4 5
(integer) 5
&gt; ltrim mylist 0 2
OK
&gt; lrange mylist 0 -1
1) "1"
2) "2"
3) "3"
</code></pre>
            <p>Наведена вище команда&nbsp;<a href="/commands/ltrim">LTRIM</a>
              каже Redis прийняти тільки елементи з індексами від 0 до 2, все
              інше треба відкинути. Це дозволяє дуже простий, але корисний
              шаблон: робити операцію заштовхування + відсічення списку разом,
              щоб додати новий елементи та відкинути елементи, що перевершують
              ліміт:</p>
            <pre><code>LPUSH mylist &lt;some element&gt;
LTRIM mylist 0 999
</code></pre>
            <p>Наведена вище комбінація додає новий елемент, та бере тільки 1000
              найновіших елементів в списку. За допомогою&nbsp;<a href="/commands/lrange">LRANGE</a>
              ви можете отримати доступ до верхніх елементів без жодної потреби
              запам’ятовувати старіші дані.&nbsp;</p>
            <p>Зауваження: хоча <a href="/commands/lrange">LRANGE</a> технічно
              команда&nbsp;<span class="math">O(N)</span>, доступ до малих
              диапазонів біля голови або хвоста списку є операцією зі сталим
              часом виконання.</p>
            <span id="blocking-operations-on-lists" class="anchor"></span>
            <h2><a href="#blocking-operations-on-lists" class="anchor-link">*</a>Блокування
              операцій на списках</h2>
            <p>Списки мають особливу спроможність, що робить їх підходящими для
              реализації черг, та загалом як будівельний блок для систем
              міжпроцесових комунікацій: блокуючі операції.</p>
            <p>Уявіть, що ви бажаєте заштовхнути елементи в список в одному
              процесі, та використати другий процес щоб насправді виконати
              деякий обсяг роботи з ціми елементами. Це звичана ситуація
              прод’юсер/споживач, та може бути реалізовано наступним простим
              шляхом:</p>
            <ul>
              <li>Щоб заштовхнути елементи в список прод’юсер викликає <a href="/commands/lpush">LPUSH</a>.</li>
              <li>Щоб отримати та обробити елементи зі списку споживач викликає
                <a href="/commands/rpop">RPOP</a>.</li>
            </ul>
            <p>Однак є можливість, що інколи список є пустим, та нічого
              обробляти, так що <a href="/commands/rpop">RPOP</a> повертатиме
              тільки NULL. В цьому випадку споживач примушений очікуваати деякий
              час, та знову повторювати <a href="/commands/rpop">RPOP</a>. Це
              називається <em>опросом</em>, та не є гарною ідеєю в цьому
              контексті, оскільки має декілька недоліків:</p>
            <ol>
              <li>Змушує Redis та клієнтів обробляти марні команди (всі запити,
                коли список пустий, не будуть призводити до виконання справжної
                роботи, а тільки повертати NULL).</li>
              <li>Додає затримку до обробки елементів, оскільки після того, как
                робітник отримає NULL, він очікуватиме деякий час. Щоб зробити
                затриму коротшою, нам треба очікувати менше між викликами <a href="/commands/rpop">RPOP</a>,
                що призведе до підсилення проблеми номер один, тобто збільшиться
                кількість марних викликів Redis.</li>
            </ol>
            <p>Так що Redis реалізує команди <a href="/commands/brpop">BRPOP</a>
              та <a href="/commands/blpop">BLPOP</a>, що є версіями&nbsp;<a href="/commands/rpop">RPOP</a>
              та <a href="/commands/lpop">LPOP</a>, що можуть блокуватись, якщо
              список є пустий: вони будуть повертати керування викликаючій
              стороні тільки коли новий елемент буде доданий до списку, або коли
              наступить заданий користувачем таймаут.</p>
            <p>Це приклад виклику <a href="/commands/brpop">BRPOP</a>, що ми
              можемо використати в процесі-робітникові:</p>
            <pre><code>&gt; brpop tasks 5
1) "tasks"
2) "do_something"
</code></pre>
            <p>Це означає: "очікуй, докі не з’явиться елемент в списку&nbsp;<code>tasks</code>,
              але повертайся після п’яти секунд, якщо елемент не з’явиться".</p>
            <p>Зауважте, що ви можете використати 0 як таймаут, щоб очікувати
              елемент постійно, та ви можете також вказати декілька списків, не
              тільки один, щоб чекати на декількох списках одночасно, та
              отримати повідомлення коли перший список отримає елемент.</p>
            <p>Декіка речей, що треба мати на увазі щодо <a href="/commands/brpop">BRPOP</a>:</p>
            <ol>
              <li>Клієнти обслуговуються по порядку: Перший клієнт, що
                заблокований очікуванням на списку, буде обслуговуватись першим,
                коли елемент буде заштовханий якимось іншим клієтом, і так далі.</li>
              <li>Значення, що повертається, відрізняється порівняно з&nbsp;<a href="/commands/rpop">RPOP</a>:
                воно є масивом з двох елементів, тому що&nbsp; воно також
                включає ім’я ключа, оскільки&nbsp;<a href="/commands/brpop">BRPOP</a>
                та <a href="/commands/blpop">BLPOP</a> можуть блокуватись,
                очікуючи елементів в декількох списках.</li>
              <li>Якщо очікування досягає таймауту, повертається NULL.</li>
            </ol>
            <p>Є більше речей, що вам треба знати щодо опцій блокування списків.
              Ми рекомендуємо, щоб ви почитали більше про наступне:</p>
            <ul>
              <li>Можливо побудувати безпечніші черги або ротуючі черги з
                використанням <a href="/commands/rpoplpush">RPOPLPUSH</a>.</li>
              <li>Є також блокуючий варіант команди з назвою&nbsp;<a href="/commands/brpoplpush">BRPOPLPUSH</a>.</li>
            </ul>
            <span id="automatic-creation-and-removal-of-keys" class="anchor"></span>
            <h2><a href="#automatic-creation-and-removal-of-keys" class="anchor-link">*</a>Атомарне
              створення та видалення ключів</h2>
            <p>До цього часу ми ніколи не створювали пусті списки, до того,
              як&nbsp; заштовхувати в них елементи, або видаляли пусті списки,
              коли в них вже немає елементів. Це є відповідальністю Redis,
              видаляти ключі, коли списки стають пустими, або створювати пустий
              список, якщо ключ не існує, і ми намагаємось додати елементи до
              нього, наприклад, за допомогою&nbsp;<a href="/commands/lpush">LPUSH</a>.</p>
            <p>Це не не специфічним для списків, це стосується всіх типів даних
              Redis, що складаються з декількох елементів -- множин, сортованих
              множин та хешів.</p>
            <p>В основному ми можемо підсумувати поведінку наступними трьома
              правилами:</p>
            <ol>
              <li>Коли ми додаємо елемент до агрегатного типу даних, якщо
                цільовий ключ не існує, створюється пустий агрегатний тип даних
                перед додаванням елементу.</li>
              <li>Коли ми видаляємо елементи з агрегатного типу даних, якщо
                значення остається пустим, ключ автоматично руйнується.</li>
              <li>Викликання команди тільки для читання, такої як&nbsp;<a href="/commands/llen">LLEN</a>
                (що повертає довжину списку), або команда видаляє елементи, та
                ключ при цьому пустий, завжди призводить до такого ж результату,
                якби ключ утримував пустий агрегат того типу, який очікує знайти
                команда.</li>
            </ol>
            <p>Приклади правила 1:</p>
            <pre><code>&gt; del mylist
(integer) 1
&gt; lpush mylist 1 2 3
(integer) 3
</code></pre>
            <p>Однак, ми не можемо виконати операції, коли ключ існує та містить
              значення невірного типу:</p>
            <pre><code>&gt; set foo bar
OK
&gt; lpush foo 1 2 3
(error) WRONGTYPE Operation against a key holding the wrong kind of value
&gt; type foo
string
</code></pre>
            <p>Приклад правила 2:</p>
            <pre><code>&gt; lpush mylist 1 2 3
(integer) 3
&gt; exists mylist
(integer) 1
&gt; lpop mylist
"3"
&gt; lpop mylist
"2"
&gt; lpop mylist
"1"
&gt; exists mylist
(integer) 0
</code></pre>
            <p>Ключ більше не існує, після того як всі елементи були
              виштовхнуті.</p>
            <p>Приклад правила 3:</p>
            <pre><code>&gt; del mylist
(integer) 0
&gt; llen mylist
(integer) 0
&gt; lpop mylist
(nil)
</code></pre>
            <p><a name="hashes"></a></p>
            <span id="redis-hashes" class="anchor"></span>
            <h2><a href="#redis-hashes" class="anchor-link">*</a>Redis і хеші</h2>
            <p>Хеші Redis виглядають саме так, як дехто може очікувати від
              хешів, з парами поле-значення:</p>
            <pre><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1
OK
&gt; hget user:1000 username
"antirez"
&gt; hget user:1000 birthyear
"1977"
&gt; hgetall user:1000
1) "username"
2) "antirez"
3) "birthyear"
4) "1977"
5) "verified"
6) "1"
</code></pre>
            <p>Хоча хеші є зручними для представлення <em>oб’єктів</em>,
              насправді число полів, що ви можете розмістити в хеші, не має
              практичних обмежень (крім доступної пам’яті), так що ви можете
              використовувати хеші багатьма різними шляхами в вашому
              застосуванні.</p>
            <p>Команда <a href="/commands/hmset">HMSET</a> встановлює декілька
              полів хешу, тоді як <a href="/commands/hget">HGET</a> отримує
              одно поле. <a href="/commands/hmget">HMGET</a> подібна до <a href="/commands/hget">HGET</a>,
              але повертає масив елементів:</p>
            <pre><code>&gt; hmget user:1000 username birthyear no-such-field
1) "antirez"
2) "1977"
3) (nil)
</code></pre>
            <p>Є команди, що здатні виконувати операції також і на окремих
              полях, як <a href="/commands/hincrby">HINCRBY</a>:</p>
            <pre><code>&gt; hincrby user:1000 birthyear 10
(integer) 1987
&gt; hincrby user:1000 birthyear 10
(integer) 1997
</code></pre>
            <p>Ви можете знайти <a href="http://redis.io/commands#hash">повний
                список хеш команд в документації</a>.</p>
            <p>Немає нічого дивного, що малі хеші (тобто декілька елементів з
              невеликими значеннями) кодуються особливим шляхом в пам’ті, що
              робить їх дуже ефективними відносно використання пам’яті.</p>
            <p><a name="sets"></a></p>
            <span id="redis-sets" class="anchor"></span>
            <h2><a href="#redis-sets" class="anchor-link">*</a>Множини Redis</h2>
            <p>Множини Redis є наупорядкованими колекціями рядків. Команда <a href="/commands/sadd">SADD</a>
              додає нові елементи в множину. Також можливо зробити низку інших
              операцій з множинами, як перевірити, чи даний елемент вже існує,
              виконати перетин, об’єднання або різницю між декількома множинами,
              і таке інше.</p>
            <pre><code>&gt; sadd myset 1 2 3
(integer) 3
&gt; smembers myset
1. 3
2. 1
3. 2
</code></pre>
            <p>Тут ми додаємо три елементи до моєї множини та наказуємо Redis
              повернути всі елементи. Як ви можете бачити, вони не впорядковані
              -- Redis вільно повертати елементи в любому порядку,при кожному
              виклику, оскільки немає домовленості з користувачем щодо
              впорядкування елементів.</p>
            <p>Redis має команди для перевірки на належніть до множини. Чи існує
              даний елемент?</p>
            <pre><code>&gt; sismember myset 3
(integer) 1
&gt; sismember myset 30
(integer) 0
</code></pre>
            <p>"3" є членом множити, тоді як "30" - ні.</p>
            <p>Множини гарні для вираження відносин між об’єктами. Наприклад, и
              можемо просто використати множини для реалізації помітки об’єктів.</p>
            <p>Простий шлях змоделювати цю проблему є мати множину для кожного
              об’єкту, що ми маємо помітити. Множина містить ID тегів,
              асоційованих з об’єктом.</p>
            <p>Уявіть, що ми бажаємо помітит новини. Якщо наші новини ID 1000
              помічені тегами 1, 2, 5 та 77, ми можемо мати одну множину, що
              асоціює ID наших тегів з елементом новини:</p>
            <pre><code>&gt; sadd news:1000:tags 1 2 5 77
(integer) 4
</code></pre>
            <p>Однак інколи я можу забажати мати зворотнє відношення також:
              список всіх новин, що помічені окремим тегом:</p>
            <pre><code>&gt; sadd tag:1:news 1000
(integer) 1
&gt; sadd tag:2:news 1000
(integer) 1
&gt; sadd tag:5:news 1000
(integer) 1
&gt; sadd tag:77:news 1000
(integer) 1
</code></pre>
            <p>Отримати всі теги для заданого об’єкта є тривіальним:</p>
            <pre><code>&gt; smembers news:1000:tags
1. 5
2. 1
3. 77
4. 2
</code></pre>
            <p>Зауваження: в прикладі ми очікуємо, що ви маєте іншу структуру
              даних, наприклад хеш Redis, що відображує ID тегів на їх імена.</p>
            <p>Є інші нетривіальні операції, що також просто реалізувати з
              використанням потрібних команд Redis. Наприклад, ми можемо бажати
              список всіх об’єктів з тегами 1, 2, 10, та 27 одночасно. Ми можемо
              зробити це, використовуючи команду&nbsp;<a href="/commands/sinter">SINTER</a>,
              що виконує перетин між різними множинами. Ми можемо задіяти це:</p>
            <pre><code>&gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news
... results here ...
</code></pre>
            <p>Перетин не є єдиною можливою операцією, ви можете також
              виконувати об’єднання, різницю, виділяти окремий елемент, і таке
              інше.</p>
            <p>Командою до виділення елементу є <a href="/commands/spop">SPOP</a>,
              та вона зручна для моделювання деякіх проблем. Наприклад, щоб
              реалізувати покерну гру в веб, ви можете представити її колоду
              через множину. Уявіть, що ми використувуємо односимвольні префікси
              для мастей (C)lubs, (D)iamonds, (H)earts, (S)pades:</p>
            <pre><code>&gt;  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
   S7 S8 S9 S10 SJ SQ SK
   (integer) 52
</code></pre>
            <p>Тепер ми бажаємо роздати по п’ять карт кожному гравцеві. Команда
              <a href="/commands/spop">SPOP</a> видаляє випадковий елемент,
              повертаючи його клієнту, так що це чудова операція для данного
              випадка.</p>
            <p>Однак, якщо ми викличемо її напряму для нашої колоди, в наступній
              ігрі нам буде треба знова наповнити колоду картами, що може бути
              не ідеальним. Так що для початку ми можемо зробити копію множини,
              що зберігається в ключі <code>deck</code> в ключі <code>game:1:deck</code>.</p>
            <p>Це досягаєтсья з використанням <a href="/commands/sunionstore">SUNIONSTORE</a>,
              що звичайно виконує об’єднання між декількома множинами, та
              зберігає результат в іншій множині. Однак, оскільки об’єднання
              одної множини є вона сама, колоду можно скопіювати наступним
              чином:</p>
            <pre><code>&gt; sunionstore game:1:deck deck
(integer) 52
</code></pre>
            <p>Тепер я готовий до роздачі п’ятьох карт першому гравцеві:</p>
            <pre><code>&gt; spop game:1:deck
"C6"
&gt; spop game:1:deck
"CQ"
&gt; spop game:1:deck
"D1"
&gt; spop game:1:deck
"CJ"
&gt; spop game:1:deck
"SJ"
</code></pre>
            <p>Пара валетів, не дуже...</p>
            <p>Тепер настав гарний час привести команду для множин, що повертає
              кількість елементів в множині. Це часто називається <em>потужністю
                множини</em> в контексті теорії множин, так що команда Redis
              називається&nbsp; <a href="/commands/scard">SCARD</a>.</p>
            <pre><code>&gt; scard game:1:deck
(integer) 47
</code></pre>
            <p>Математика робить: 52 - 5 = 47.</p>
            <p>Коли вам треба тільки отримати випадкові елементи без виклчення
              їх з множини, існує команда&nbsp;<a href="/commands/srandmember">SRANDMEMBER</a>,
              що підходить для цієї справи. Вона також має можливість повертати
              або повторювані, або неповторювані елементи.</p>
            <p><a name="sorted-sets"></a></p>
            <span id="redis-sorted-sets" class="anchor"></span>
            <h2><a href="#redis-sorted-sets" class="anchor-link">*</a>
              Впорядковані множини Redis</h2>
            <p>Впорядковані множини є типом даних, що подібні до міксу множин та
              хешів. Подібно множинам, впорядковані множини складаються з
              унікальних, неповторюваних елементів-рядків, так що в деяких
              сенсах впорякомана множина є також і множиною.</p>
            <p>Однак, хоча елементи в множинах не впорядковані, кожний елемент у
              впорядкованій множині асоційований зі значення з плаваючою комою,
              що називається <em>балами</em> (ось чому цей тип також подібний
              до хешу, оскільки кожний елемент відображається на значення).</p>
            <p>Більше того, елементи у впорякованій множині <em>вибираються по
                порядку</em> (так що вони не впорядковуються по запиту, поярдок
              є властивостю структури даних, що використовується для
              представлення впорядкованої множини). Вони впорядковані за
              наступним правилом:</p>
            <ul>
              <li>Якщо A та B є двома елементами з різними балами, тоді A &gt;
                B, якщо бали A &gt; балів B.</li>
              <li>Якщо A та B мають точно однакові бали, тоді A &gt; B, якщо
                рядок A лексографічно більший, ніж рядок B. Рядки A та B не
                можуть бути однаковими, оскільки впорядковані множини містять
                тільки унікальні елементи.</li>
            </ul>
            <p>Давайте розпочнемо з простого прикладу, додаючи декілька обраних
              хакерських імен у впорядковану множину елементів,&nbsp; з роком іх
              народження в якості "балів".</p>
            <pre><code>&gt; zadd hackers 1940 "Alan Kay"
(integer) 1
&gt; zadd hackers 1957 "Sophie Wilson"
(integer 1)
&gt; zadd hackers 1953 "Richard Stallman"
(integer) 1
&gt; zadd hackers 1949 "Anita Borg"
(integer) 1
&gt; zadd hackers 1965 "Yukihiro Matsumoto"
(integer) 1
&gt; zadd hackers 1914 "Hedy Lamarr"
(integer) 1
&gt; zadd hackers 1916 "Claude Shannon"
(integer) 1
&gt; zadd hackers 1969 "Linus Torvalds"
(integer) 1
&gt; zadd hackers 1912 "Alan Turing"
(integer) 1
</code></pre>
            <p>Як ви бачите,&nbsp;<a href="/commands/zadd">ZADD</a> подібна до <a
                href="/commands/sadd">SADD</a>, але приймає один додатковий
              аргумент&nbsp;(що розміщений перед елементом, що буде доданий), що
              і є балами. <a href="/commands/zadd">ZADD</a> також має змінну
              арність, так що ви вільні вказувати декілька пар бали-значення,
              навіть якщо це і не використовується в прикладі вище.</p>
            <p>З впорякованими множинами є тривіальним повернути список хакерів,
              відсортований за їх роком народження, оскільки насправді <em>вони
                вже впорядковані</em>.</p>
            <p>Зауваження з реалізації: впорядковані множини реалізовані через
              дво-стороннію структуру даних, що містить обоє, список пропусків
              та хеш таблицю, так що кожного разу, коли ми додаємо елемент,
              Redis виконує операцію <span class="math">O(log(N))</span>. Це
              добре, але коли ми запитуємо впорядковані елементи, Redis не має
              виконувати жодної роботи, оскільки елементи вже впорядковані:</p>
            <pre><code>&gt; zrange hackers 0 -1
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
6) "Richard Stallman"
7) "Sophie Wilson"
8) "Yukihiro Matsumoto"
9) "Linus Torvalds"
</code></pre>
            <p>Зауваження: 0 та -1 ознаають від інедксу 0 до останнього елементу
              (-1 робить тут так само, як і в випадку команди&nbsp;<a href="/commands/lrange">LRANGE</a>).</p>
            <p>Що, коли я бажаю впорядкувати їх зворотнім шляхом, від молодших
              до старших? Використовуйте&nbsp; <a href="/commands/zrevrange">ZREVRANGE</a>
              замість <a href="/commands/zrange">ZRANGE</a>:</p>
            <pre><code>&gt; zrevrange hackers 0 -1
1) "Linus Torvalds"
2) "Yukihiro Matsumoto"
3) "Sophie Wilson"
4) "Richard Stallman"
5) "Anita Borg"
6) "Alan Kay"
7) "Claude Shannon"
8) "Hedy Lamarr"
9) "Alan Turing"
</code></pre>
            <p>Також можливо повернути також і бали, використовуючи аргумент <code>WITHSCORES</code>:</p>
            <pre><code>&gt; zrange hackers 0 -1 withscores
1) "Alan Turing"
2) "1912"
3) "Hedy Lamarr"
4) "1914"
5) "Claude Shannon"
6) "1916"
7) "Alan Kay"
8) "1940"
9) "Anita Borg"
10) "1949"
11) "Richard Stallman"
12) "1953"
13) "Sophie Wilson"
14) "1957"
15) "Yukihiro Matsumoto"
16) "1965"
17) "Linus Torvalds"
18) "1969"
</code></pre> <span id="operating-on-ranges" class="anchor"></span>
            <h2><a href="#operating-on-ranges" class="anchor-link">*</a>Операції
              з диапазонами</h2>
            <p>Сортовані множини більш потужні, ніж ми тільки но побачили. Вони
              можуть оперувати з диапазонами. Давайте отримаємо всі особистості,
              що були народжені до 1950 включно. Для цього ми використовуємо
              команду <a href="/commands/zrangebyscore">ZRANGEBYSCORE</a>:</p>
            <pre><code>&gt; zrangebyscore hackers -inf 1950
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
</code></pre>
            <p>Ми запитуємо Redis повернути всі елементи з балами між негативною
              безкінечністю та 1950 (оба обмеження включені).</p>
            <p>Також можливо видалити диапазони елементів. Давайте видалимо всіх
              хакерів, що народились між 1940 та 1960 з впорядкованої множини:</p>
            <pre><code>&gt; zremrangebyscore hackers 1940 1960
(integer) 4
</code></pre>
            <p><a href="/commands/zremrangebyscore">ZREMRANGEBYSCORE</a>,
              можливо, не найкраще ім’я для команди, але вона може бути дуже
              корисною, та повертає число видалених елементів.</p>
            <p>Інша вкрай корисна операція, визначена для елементів впорякованих
              множин, є операція отримання місця в рейтингу. Можливо запитати,
              на якій позиції знаходиться елемент серед впорядкованої множини
              елементів.&nbsp;</p>
            <pre><code>&gt; zrank hackers "Anita Borg"
(integer) 4
</code></pre>
            <p>Команда <a href="/commands/zrevrank">ZREVRANK</a> також
              доступна, щоб повертати рейтинг, враховуючи, що елементи
              впорядковані в зворотньому порядку.&nbsp;</p>
            <span id="lexicographical-scores" class="anchor"></span>
            <h2><a href="#lexicographical-scores" class="anchor-link">*</a>Лексографічні
              бали</h2>
            <p>З останніми версіями Redis 2.8 була введена нова можливість, що
              дозволяє отримання диапазонів лексографічно, допускаючи, що
              елементи у впорядкованій множині всі вставлені з одним і тим же
              ідентичними балами (елементи порівнюються за допомогою фукнції C <code>memcmp</code>,
              так що є гарантія, що не буде порівняння, та кожний
              екземпляр&nbsp; Redis буде видавати той же результат).</p>
            <p>Головні команди для роботи з лексографічними диапазонами є <a href="/commands/zrangebylex">ZRANGEBYLEX</a>,
              <a href="/commands/zrevrangebylex">ZREVRANGEBYLEX</a>, <a href="/commands/zremrangebylex">ZREMRANGEBYLEX</a>
              та <a href="/commands/zlexcount">ZLEXCOUNT</a>.</p>
            <p>Наприклад, давайте додамо знову наш список поважних хакерів, але
              на цей раз використаємо бали рівню нулю для всіх елементів:</p>
            <pre><code>&gt; zadd hackers 0 "Alan Kay" 0 "Sophie Wilson" 0 "Richard Stallman" 0
  "Anita Borg" 0 "Yukihiro Matsumoto" 0 "Hedy Lamarr" 0 "Claude Shannon"
  0 "Linus Torvalds" 0 "Alan Turing"
</code></pre>
            <p>Завдяки правилоам впорядкованих множин, вони всі впорядковані
              лексографічно:</p>
            <pre><code>&gt; zrange hackers 0 -1
1) "Alan Kay"
2) "Alan Turing"
3) "Anita Borg"
4) "Claude Shannon"
5) "Hedy Lamarr"
6) "Linus Torvalds"
7) "Richard Stallman"
8) "Sophie Wilson"
9) "Yukihiro Matsumoto"
</code></pre>
            <p>Використовуючи <a href="/commands/zrangebylex">ZRANGEBYLEX</a>
              ми можемо запитати лексографічний диапазон:</p>
            <pre><code>&gt; zrangebylex hackers [B [P
1) "Claude Shannon"
2) "Hedy Lamarr"
3) "Linus Torvalds"
</code></pre>
            <p>Диапазони можуть бути закритими та відкритими (в залежності від
              першого символа), також рядок безмежність або мінус безмежність
              задаються відповідно з рядками&nbsp; <code>+</code> та <code>-</code>
              . Дивіться документацію для додаткової інформації.</p>
            <p>Ця можливість важлива, бо вона дозволяє використовувати
              впорядковані множини для як загальний індекс. Наприклад, якщо в
              бажаєте індексувати елементи по 128-бітному беззнаковому цілому
              аргументові, все що вам потрібно - це додати елементи в
              впорядковану множину з однаковими балами (наприклад, 0), але з
              восьмибайтним префіксом, що містить <strong>128 бітне число в
                кодуванні перший-старший (big endian</strong>). Оскільки числа
              починають зі старших розрядів, то лексографічне сортування&nbsp;
              (в порядку байтів) насправді є також і числовим сортуванням, та ви
              можете запитати диапазон в 128-бітному просторі, та отримати
              значення елементу, відкинувши префікс.</p>
            <p>Якщо ви бажаєте побачити можливість в контексті більш серьйозного
              сценарію, подивіться на приклад&nbsp; <a href="http://autocomplete.redis.io">Redis
                атводоповнення</a>.</p>
            <span id="updating-the-score-leader-boards" class="anchor"></span>
            <h2><a href="#updating-the-score-leader-boards" class="anchor-link">*</a>Оновлення
              балів: дошка змагань</h2>
            <p>Тільки в якості останнього зауваження щодо впорядкованих множин,
              перед тим, як перемикнутись на іншу тему. Впорядковані множини
              можуть оновлювати бали в будь-який час. Тільки викличте <a href="/commands/zadd">ZADD</a>
              для елеленту, що вже присутній в впорядковану множину, і це
              оновить бали (та місце) зі складністю <span class="math">O(log(N))</span>.
              Тому впорядковані множини підходять для тисяч оновлень.</p>
            <p>Завдяки цій характеристиці загальним використанням є дошки
              змагань. Типове застосування є гра Facebook, де ви комбінуєте
              можливість мати користувачів у впорядкованому по максимально
              набратих очках&nbsp; списку, плюс операція отримати-рейтинг, щоб
              показати перших N користувачів, та місце користувача на дошці
              змагань (тобто, "ваші кращі бали посіли місце #4932").</p>
            <p><a name="bitmaps"></a></p>
            <span id="bitmaps" class="anchor"></span>
            <h2><a href="#bitmaps" class="anchor-link">*</a>Бітові карти</h2>
            <p>БІтові карти насправді не є типом даних, але набором
              біт-орієнтованих операцій, визначених для типу рядків. Оскільки
              рядки двійніково безпечні об’єкти, та їх максимальний розмір є 512
              Мб, вони підходять для встановлення до 2<sup>32</sup> різних
              бітів.</p>
            <p>Бітові операції поділяются на дві групи: бітові операції сталого
              часу, такі, як встановлення біту в 1 або 0, або отримання його
              значення, та опрації над групами біт, наприклад, підрахунок числа
              встановлених біт в заданому диапазоні (підрахунок популяції).</p>
            <p>Одна з більших переваг бітових карт в тому, що вони часто надають
              екстремальну економію простору при збереженні інформації.
              Наприклад, в системі, де різні користувачі представлені&nbsp; ID
              користувачів, є можливим запам’ятати однобітову інформацію
              (наприклад, інформацію про те, чи бажає користувач отримувати
              новини на пошту) про 4 мільярда користувачів з використанням
              тільки 512 Мб пам’яті.</p>
            <p>Біти встановлюються та отримуються за допомогою команд&nbsp;<a href="/commands/setbit">SETBIT</a>
              та <a href="/commands/getbit">GETBIT</a>:</p>
            <pre><code>&gt; setbit key 10 1
(integer) 1
&gt; getbit key 10
(integer) 1
&gt; getbit key 11
(integer) 0
</code></pre>
            <p>Команда <a href="/commands/setbit">SETBIT</a> сприймає в якості
              першого параметру номер біту, та в якості другого агрументу
              значення, що треба встановити цей біт, що є 1 або 0. Команда
              автоматично збільшує рядок, якщо адреса біту за межами поточної
              довжини рядка.</p>
            <p><a href="/commands/getbit">GETBIT</a> тільки повертає значення
              біту по вказаному індексу. Біти за межами (посилання на біт, що за
              межами довжини рядка, що зберігаєтсья як ключ) завжди вважаються
              рівними нуля.</p>
            <p>Є три команди, що оперують з групами біт:</p>
            <ol>
              <li><a href="/commands/bitop">BITOP</a> виконує бітову операцію
                між різними рядками. Наданими операціями є AND, OR, XOR та NOT.</li>
              <li><a href="/commands/bitcount">BITCOUNT</a> аиконує підрахунок
                популяції, повертаючу число біт, встановлених в 1.</li>
              <li><a href="/commands/bitpos">BITPOS</a> шукає перший біт, що має
                вказане значення, 0 або 1.</li>
            </ol>
            <p>Обоє, <a href="/commands/bitpos">BITPOS</a> та <a href="/commands/bitcount">BITCOUNT</a>,
              в змозі оперувати з байтовими діапазонами рядка, замість виконання
              для всієї довжини рядка. Наступний код є тривіальним прикладом
              виклику&nbsp;<a href="/commands/bitcount">BITCOUNT</a>:</p>
            <pre><code>&gt; setbit key 0 1
(integer) 0
&gt; setbit key 100 1
(integer) 0
&gt; bitcount key
(integer) 2
</code></pre>
            <p>Загальні користувацькі випадки для бітових карт наступні:</p>
            <ul>
              <li>Аналітика реального часу всіх типів.</li>
              <li>Зберігання логічної інформації в ефективний та
                високопродуктивний спосіб, що асоційована з ID об’єктів.</li>
            </ul>
            <p>Наприклад, уявіть, що ви бажаєте знати найдовшу полосу денних
              визитів користувачів на ваш сайт. Ви починаєте рахувати дні з
              нуля, це день коли ви зробили свій сайт публічним, та встановлюєте
              біт за допомогою<a href="/commands/setbit">SETBIT</a> кожного
              разу, коли користувач відвідує ваш веб сайт. В якості індексу ви
              просто використовуєте поточний Юніск час, відраховуєте початковий
              зсув та ділите на 3600*24.</p>
            <p>Таким чином для кожного користувача ви маєте невеликий рядок, що
              містить інформацію про візити для кожного дня. За допомогою <a href="/commands/bitcount">BITCOUNT</a>
              можливо просто отримати число днів, коли окремий користувач
              відвідував веб сайт, тоді як за допомогою невеликої кількості
              викликів&nbsp;<a href="/commands/bitpos">BITPOS</a>, або просто
              витягуючи та аналізуючи бітові карти на боці клієнта можливо
              просто обчислити найдовшу полосу.</p>
            <p>Бітові карти тривіально поділити на декілька ключів, наприклад, з
              ціллю зобити шардер з набору даних, та оскільки в основному краще
              уникати роботу з гігантськими ключами. Щоб поділити бітову карту
              між декількома ключами, замість того, щоб встановлювати всі біти в
              ключі, тривіальною стртегією є зберігати тільки М біт в одному
              ключі, та отримати ім’я ключа за допомогою&nbsp;<code>bit-number/M</code>
              та N-нний&nbsp; біт в ключі адресувати за допомогою <code>bit-number
                MOD M</code>.</p>
            <p><a name="hyperloglogs"></a></p>
            <span id="hyperloglogs" class="anchor"></span>
            <h2><a href="#hyperloglogs" class="anchor-link">*</a>HyperLogLogs</h2>
            <p>HyperLogLog є вирогіднисними структурами даних, що
              використовуються для підрахунку унікальних речей (технічно це має
              назву очікуванням потужності множини). Звичано підрахунок
              унікальних елементів потребує обсігу пам’яті, пропорційного числу
              елементів, що ми будемо підраховувати, оскільки вам треба
              пам’ятати елементи, що ви вже бачили в минулому, щоб запобігти
              підрахунку їх декілька разів. Однак є набір алгоритмив, що
              обмінюють розмір на точність: в результаті ви отримуєте приблизний
              підрахунок сі стандартною помилкою, що в випадку реалізації Redis
              менша ніж 1%. Магія цього алгоритму в тому, що вам більше не треба
              використовувати обсяг пам’яті, пропорційний числу елементів, що ви
              підраховуєте, та замість цього ви використовуєте постійний обсяг
              пам’яті! 12 Кб в гіршому випадку, або значно меньше, якщо ваш
              HyperLogLog (ми просто називаємо його HLL) зустрінеться з дуже
              невеликою кількістю елементів.</p>
            <p>HLL в Redis, хоча й технічно є окремою структурою даних,
              закодовані як рядкі Redis, так що ви можете визвати <a href="/commands/get">GET</a>
              для серіалізації HLL, та <a href="/commands/set">SET</a> для
              десеріалізації його знову на сервер.</p>
            <p>Концептуально HLL API подібне до використання множин для
              виконання однакових завдань. Вам треба&nbsp; <a href="/commands/sadd">SADD</a>
              кожний піддослідний елемент в множину, та можете використовувати <a
                href="/commands/scard">SCARD</a> для перевірки числа елементів в
              множині, що будуть унікальними, тому що&nbsp;<a href="/commands/sadd">SADD</a>
              не додаватиме все існуючі елементи.</p>
            <p>Тоді як ви насправді не <em>додаєте елементи</em> в HLL,
              оскільки структура даних тільки містить стан, що не включає
              справжні елементи, API є таким самим:</p>
            <ul>
              <li>Кожного разу, коли ви бачите новий елемент, ви додаєте його до
                підрахунку за допомогою <a href="/commands/pfadd">PFADD</a>.</li>
              <li>
                <p>Кожного разу, коли ви бажаєте отримати поточну апроксімацію
                  унікальних елементів <em>доданих</em> за допомогою <a href="/commands/pfadd">PFADD</a>,
                  ви викликаєте <a href="/commands/pfcount">PFCOUNT</a>.</p>
                <pre><code>&gt; pfadd hll a b c d
(integer) 1
&gt; pfcount hll
(integer) 4
</code></pre></li>
            </ul>
            <p>Приклад використання цієї структури даних - це підрахунок
              унікальних запитів відкористувачів в пошуку кожного дня.</p>
            <p>Redis також дозволяє виконувати об’єднання HLL-ів, дивіться <a href="/commands#hyperloglog">повну
                документацію</a> для отримання додаткової інформації.</p>
            <span id="other-notable-features" class="anchor"></span>
            <h2><a href="#other-notable-features" class="anchor-link">*</a>Інші
              важливі можливості</h2>
            <p>Є інші важливі речі в Redis API, що не можуть бути досліджені в
              контексті цього документу, але варті вашої уваги:</p>
            <ul>
              <li>Можливо <a href="/commands/scan">ітерувати в просторі ключів
                  велких колекцій інкрементально</a>.</li>
              <li>Можливо виконувати <a href="/commands/eval">Lua скрипти на
                  стороні сервера</a> щоб виграти в затримках та полосі
                пропускання.</li>
              <li>Redis також є сервером публікацій та підписок <a href="/topics/pubsub">Pub-Sub</a>.</li>
            </ul>
            <span id="learn-more" class="anchor"></span>
            <h2><a href="#learn-more" class="anchor-link">*</a>Дізнайтесь більше</h2>
            <p>Цей підручник неяким шляхом не є повним та покриває тільки основи
              API. Читайне <a href="/commands">посилання на команди</a> щоб
              винайти значно більше.</p>
            <p>Спасибі за читання, та отримуйте радість від використання Redis!</p>
          </article>
        </div>
      </div>
      <footer class="site-footer">
        <div class="container">
          <p> This website is <a href="https://github.com/antirez/redis-io">open
              source software</a>. See all <a href="/topics/sponsors">credits</a>.
          </p>
          <div class="sponsor"> Sponsored by <a href="http://www.pivotal.io/big-data/redis">
              <img alt="Redis Support" src="/images/pivotal.png" title="Redis Sponsor"
                height="25" width="99"> </a> </div>
        </div>
      </footer>
    </div>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>
    <script src="/slideout.js?1426205838"></script>
    <script src="/app.js?1426611451"></script>
    <script type="text/javascript">
lloogg_clientid = "20bb9c026e";
</script> <script type="text/javascript" src="http://demo.lloogg.com/l.js?c=20bb9c026e">
</script>
  </body>
</html>
