<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Redis Lua. Переклад українською - Арсеній Чеботарьов - Ніжин 2016</title>
  </head>
  <body class="">
    <address>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <div class="site-wrapper"><br>
      <div class="article-aside">
        <aside>
          <h2>Пов'язані команди</h2>
          <ul>
            <li> <a href="file:///commands/eval"> <strong>EVAL</strong> </a>
            </li>
            <li> <a href="file:///commands/evalsha"> EVALSHA </a> </li>
            <li> <a href="file:///commands/script-exists"> SCRIPT EXISTS </a>
            </li>
            <li> <a href="file:///commands/script-flush"> SCRIPT FLUSH </a> </li>
            <li> <a href="file:///commands/script-kill"> SCRIPT KILL </a> </li>
            <li> <a href="file:///commands/script-load"> SCRIPT LOAD </a> </li>
          </ul>
        </aside>
      </div>
      <div class="site-content">
        <div class="text">
          <h1 class="command"> <span class="name">EVAL</span> <span class="arg">script</span>
            <span class="arg">numkeys</span> <span class="arg">key [key ...]</span>
            <span class="arg">arg [arg ...]</span> </h1>
          <article>
            <div class="article-main">
              <div class="metadata">
                <p><strong>Доступно починаючи з 2.6.0.</strong></p>
                <p><strong>Часова складність:</strong> Залежить від скрипту, що
                  обчислюється.</p>
              </div>
              <span id="introduction-to-eval" class="anchor"></span>
              <h2>Вступ до EVAL</h2>
              <p><a href="/commands/eval">EVAL</a> та <a href="/commands/evalsha">EVALSHA</a>
                використовуються для обчислення скриптів з використанням
                інтерпретатора Lua, вбудованого в Redis починаючи з версії
                2.6.0.</p>
              <p>Перший аргумент <a href="/commands/eval">EVAL</a> є скрипт Lua
                5.1. Скрипт не потрібен для визначення функції Lua (і він цього
                не робить). Це тільки програма Lua, що буде виконуватись в
                контексті Redis сервера.</p>
              <p>Другий аргумент <a href="/commands/eval">EVAL</a> є число
                аргументів, що слідують за скриптом (починаючи з третього
                аргументу), що представляє імена ключів Redis. Ці аргументи
                можуть бути досяжні з Lua з використанням глобальної змінної<code>
                  KEYS</code> в формі базованого на одиниці масива (<code>KEYS[1]</code>,
                <code>KEYS[2]</code>, ...).</p>
              <p>Всі додаткові аргументи не повинні представляти імена ключів та
                можуть бути доступні з Lua з використанням глобальної змінної <code>ARGV</code>,
                дуже подібно до того, що відбувається з ключами (<code>ARGV[1]</code>,
                <code>ARGV[2]</code>, ...).</p>
              <p>Наступний приклад повинен прояснити про що ідеться:</p>
              <pre><code>&gt; eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
1) "key1"
2) "key2"
3) "first"
4) "second"
</code></pre>
              <p>Зауваження: як бачите, масиви Lua повертаються як
                мультімножинній відповідді Redis, що ваша клієнтська бібліотека
                вірогідно перетворить в тип Array в вашій мові програмування.</p>
              <p>Можливо викликати команди Redis зі скрипта Lua з використанням
                двох різних фукнцій Lua:</p>
              <ul>
                <li><code>redis.call()</code></li>
                <li><code>redis.pcall()</code></li>
              </ul>
              <p><code>redis.call()</code> подібна до <code>redis.pcall()</code>,
                одна відмінність в тому, що коли виклик команди Redis призведе
                до помилки, <code>redis.call()</code> буде підіймати помилку
                Lua, що, в свою чергу змусить&nbsp;<a href="/commands/eval">EVAL</a>
                повернути помилку до викликаючої команди, тоді як <code>redis.pcall</code>
                буде перехоплювати помилку та поверне таблицю Lua, що
                представляє помилку.</p>
              <p>Аргументи функцій <code>redis.call()</code> та <code>redis.pcall()</code>
                всі аргументи гарно сформованої команди Redis:</p>
              <pre><code>&gt; eval "return redis.call('set','foo','bar')" 0
OK
</code></pre>
              <p>Скрипт вище встановлює ключ&nbsp;<code>foo</code> в рядок <code>bar</code>.
                Однак це порушує семантику команди&nbsp;<a href="/commands/eval">EVAL</a>,
                оскільки всі ключі, що використовує скрипт, мають бути передані
                з використанням масису <code>KEYS</code>:</p>
              <pre><code>&gt; eval "return redis.call('set',KEYS[1],'bar')" 1 foo
OK
</code></pre>
              <p>Всі команди Redis мусять бути проаналізовані перед виконанням,
                щоб визначити, з якіми ключами буде робити команда. Щоб це було
                так для для <a href="/commands/eval">EVAL</a>, ключі мають бути
                передані явно. Це корисно з багатьох боків, але особливо для
                того, щоб впевнитись, що Redis Cluster буде пересилати ваш запит
                на відповідний вузол кластеру.</p>
              <p>Зауважте, що це правило не примушується, щоб надати
                користувачеві можливість ввести в оману одновузлову конігурацію
                Redis, ціної написання скриптів, не сумісних з Redis Cluster.</p>
              <p>Скрипти Lua можуть повертати значення, що конвертоване з типу
                Lua до протоколу Redis з використанням правил перетворення.</p>
              <span id="conversion-between-lua-and-redis-data-types" class="anchor"></span>
              <h2>Перетворення між типами Lua та Redis</h2>
              <p>Redis повертає значення, сконвертовані в типи даних Lua, коли
                повертається з викликів команди Redis за допомогоюcall() або
                pcall(). Подібно до цього, типи даних Lua конвертуються в
                протокол Redis, коли скрипт Lua повертає значення, так що скрипт
                може контролювати, що <a href="/commands/eval">EVAL</a>
                повертає до клієнта.</p>
              <p>Це перетворення між типами даних розроблено таким чином, що
                якщо тип Redis перетворюється на тип a, та потім результат
                перетворюється знову в тип Redis, результат буде такий самий, що
                і початкове значення.</p>
              <p>Іншими словами, є перетворення один-до-одного між типами Lua та
                Redis. Наступна таблиця показує вам правила перетворення:</p>
              <p><strong>Таблиця перетворення Redis до Lua</strong>.</p>
              <ul>
                <li>integer -&gt; number</li>
                <li>bulk -&gt; string</li>
                <li>multi bulk -&gt; таблиця (може містити інші вкладені типи)</li>
                <li>status -&gt; таблиця з одним полем <code>ok</code></li>
                <li>error -&gt; таблиця з одним полем <code>err</code></li>
                <li>Nil bulk та Nil multi bulk -&gt; false</li>
              </ul>
              <p><strong>Таблиця перетворення Lua до Redis</strong>.</p>
              <ul>
                <li>number -&gt; integer (перетворюється якщо треба)</li>
                <li>string -&gt; bulk</li>
                <li>table (масив) -&gt; multi bulk (обрізане по вершому nil)</li>
                <li>table з одни полем <code>ok</code> -&gt; status</li>
                <li>table з одним полем <code>err</code> -&gt;&nbsp; error</li>
                <li>false -&gt; Nil bulk</li>
              </ul>
              <p>Є додаткові правила перетворення Lua-до-Redis, що не мають
                відповідних правил перетворення Redis до Lua:</p>
              <ul>
                <li>true -&gt; integer 1</li>
              </ul>
              <p>Також є два важливих правила, що треба занотувати:</p>
              <ul>
                <li>Lua має один числовий тип, число Lua. Немає різниці між
                  цілими та з плаваючою крапкою. Так що ми завжди конвертуємо
                  числа Lua numbers до цілих відповідей, видаляючи дрібну
                  частину числа, якщо таке є. <strong>Якщо ви бажаєте повернути
                    число з плаваючою крапкою з Lua, ви повинні повертати його
                    як рядок</strong>, саме так, як робить сам Redis (дивіться
                  наприклад команду <a href="/commands/zscore">ZSCORE</a>).</li>
                <li>Немає <a href="http://www.lua.org/pil/19.1.html">ростого
                    шляху мати nil в масивах Lua</a>, це результат семантики
                  таблиць Lua, так що коли Redis перетворює масив Lua в протокол
                  Redis, перетворення завершується на першому nil, що трапиться.</li>
              </ul>
              <p>Ось декілька прикладів перетворення:</p>
              <pre><code>&gt; eval "return 10" 0
(integer) 10

&gt; eval "return {1,2,{3,'Hello World!'}}" 0
1) (integer) 1
2) (integer) 2
3) 1) (integer) 3
   2) "Hello World!"

&gt; eval "return redis.call('get','foo')" 0
"bar"
</code></pre>
              <p>Останній приклад показує, як можливо отримати той же саме
                значення від <code>redis.call()</code> або <code>redis.pcall()</code>
                від Lua, що буде повернено, якщо команда була викликана непрямо.</p>
              <p>В наступному прикладі можна бачити, як обробляються плаваюча
                крапка та масиви з nil:</p>
              <pre><code>&gt; eval "return {1,2,3.3333,'foo',nil,'bar'}" 0
1) (integer) 1
2) (integer) 2
3) (integer) 3
4) "foo"
</code></pre>
              <p>Як ви можете бачити, 3.333 перетворилось на 3, та рядок <em>bar</em>
                ніколи не повернеться після nil.</p>
              <span id="helper-functions-to-return-redis-types" class="anchor"></span>
              <h2>Допоміжні функції для повернення типів Redis</h2>
              <p>Є дві допоміжні функції для повернення типів Redis з Lua.</p>
              <ul>
                <li><code>redis.error_reply(error_string)</code> повертає
                  відповідь-помилку. Це функція просто повертає таблицю з одним
                  полем <code>err</code>, щоб надати вам рядок повідомлення.</li>
                <li><code>redis.status_reply(status_string)</code> повертає
                  відповідь-статус. Ця функція просто повертає таблицю з один
                  полем&nbsp;<code>ok</code>, щоб надати вам рядок повідомлення.</li>
              </ul>
              <p>Немає різниці між використаннями допоміжних функцій або
                повернення таблиці напряму, так що наступні дів форми
                еквівалентні:</p>
              <pre><code>return {err="My Error"}
return redis.error_reply("My Error")
</code></pre> <span id="atomicity-of-scripts" class="anchor"></span>
              <h2>Атомарність скриптів</h2>
              <p>Redis виконує той самий інтерпретатор Lua для виконання всіх
                команд. Також Redis гарантує, що цей скрипт виконується в
                атомарний шлях: жоден інший скрипт або команда Redis не будуть
                виконуватись, доки виконується скрипт. Ця семантика подібна до такої
                в&nbsp;<a href="/commands/multi">MULTI</a> / <a href="/commands/exec">EXEC</a>.
                З точки зору всіх інших клієнтів ефекти скрипта або ще не
                видимі, або вже завершились.</p>
              <p>Однак це також означає, що виконання повільних скриптів не є
                гарною їдеєю. Не складно створити швидкий скрипт, бо накладні
                розходи скриптів малі, але якщо ви збираєтесь створити повільний
                скрипт, ви маєте бути попереджені, що доки скрипт виконується,
                інші клієнти не зможуть виконувати команди.&nbsp;</p>
              <span id="error-handling" class="anchor"></span>
              <h2>Обробка помилок</h2>
              Як вже сказано, виклики до <code>redis.call()</code>, що
              призводять до помилок Redis, будуть переривати виконання скрипта
              та повернуть помилку, таким чином, що буде зрозуміло, яка помилка
              була згенерована скриптом:
              <pre><code>&gt; del foo
(integer) 1
&gt; lpush foo a
(integer) 1
&gt; eval "return redis.call('get','foo')" 0
(error) ERR Error running script (call to f_6b1bf486c81ceb7edf3c093f4c48582e38c0e791): ERR Operation against a key holding the wrong kind of value
</code></pre>
              <p>Використання <code>redis.pcall()</code> не викликає помилок,
                але об'єкт помилки повертається в форматі, вказаному вище (як
                таблиця Luaз полем&nbsp; <code>err</code>). Скрипт може
                передати точну помилку користувачеві, повертаючи об'єкт помилки,
                що повертає <code>redis.pcall()</code>.</p>
              <span id="bandwidth-and-evalsha" class="anchor"></span>
              <h2>Полоса пропускання та EVALSHA</h2>
              <p>Команда <a href="/commands/eval">EVAL</a> змушує вас надситати
                тіло скрипта знову та знову. Redis не потребує рекомпіляції
                скрипту кожного разу, оскільки він використовує внутрішній
                механізм кешування, однак вартість додаткової полоси пропускання
                може бути не оптимальною в багатьох контекстах.</p>
              <p>З іншого боку, визначаючи команди з використанням спеціальної
                команди або через&nbsp;<code>redis.conf</code> може бути
                проблемою з декількох причин:</p>
              <ul>
                <li>
                  <p>Різні екземпляри можуть мати різні реалізації
                    команди.&nbsp;</p>
                </li>
                <li>
                  <p>Розгортання є складним, якщо ми маємо бути впевненими, що
                    всі екземпляри містять окрему комманду, особливо в
                    розподіленому середовищі. </p>
                </li>
                <li>
                  <p>Читаючи код застосування, повна семантика може бути неясною,
                    оскільки команди викликів застосування визначені на
                    сервері.&nbsp;</p>
                </li>
              </ul>
              <p>Щоб уникнути ціх проблем, при тому униаючи пенальті полоси
                пропускання, Redis реалізує команду <a href="/commands/evalsha">EVALSHA</a>.</p>
              <p><a href="/commands/evalsha">EVALSHA</a> робить саме так, як <a
                  href="/commands/eval">EVAL</a>, але замість маючи скрипт в
                якості першого аргументу, він має дайджест SHA1 скрипта.
                Поведінка наступна:</p>
              <ul>
                <li>
                  <p>Якщо сервер все ще пам'ятає скрипт з таким дайджестом SHA1,
                    цей скрипт виконується.</p>
                </li>
                <li>
                  <p>Якщо сервер не пам'ятає скрипт з таким дайджестом SHA1,
                    повертається спеціальна помилка, що каже клієнту
                    використовувати&nbsp;<a href="/commands/eval">EVAL</a>
                    замість цього.</p>
                </li>
              </ul>
              <p>Приклад:</p>
              <pre><code>&gt; set foo bar
OK
&gt; eval "return redis.call('get','foo')" 0
"bar"
&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0
"bar"
&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0
(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval).
</code></pre>
              <p>Реалізація клієнтської бібліотеки завжди може оптимістично
                надсилати&nbsp; <a href="/commands/evalsha">EVALSHA</a> під
                покровом, навіть коли клієнт насправді викликає&nbsp;<a href="/commands/eval">EVAL</a>,
                в надії, що скрипт був уже відомий серверу. Якщо повертається
                помилка <code>NOSCRIPT</code>, замість цього буде
                викликана&nbsp;<a href="/commands/eval">EVAL</a>.</p>
              <p>Передавати ключі та аргументи як&nbsp; додаткові аргументи&nbsp;<a
                  href="/commands/eval">EVAL</a> також дуже корисно в цьому
                контексті, як рядок скрипту залишається постійним, та може бути
                ефективно кешований Redis.</p>
              <span id="script-cache-semantics" class="anchor"></span>
              <h2>Семантика скриптового кешу</h2>
              <p>Виконані скрипти гарантовано будуть в скриптовому кеші окремого
                екземпляру Redis назавжди. Це означає, що якщо&nbsp;<a href="/commands/eval">EVAL</a>
                виконаний для екземпляру Redis, всі подальші виклики&nbsp;<a href="/commands/evalsha">EVALSHA</a>
                будуть успішними .</p>
              <p>Причина, з якої скрипти можуть бути кешовані на протязі довгого
                часу, в тому, що мало вірогідно для гарно написаного
                застосування мати доволі скриптів, щоб викликати проблеми з
                пам'яттю. Кожний скрипт концептуально подібний до реалізації
                нової команди, та навіть велике застосування буде, вирогідно,
                мати тільки декілька сотен. Навіть якщо застосування буде
                модифікований багато разів, та скрипти будуть змінені,
                використання пам'яті буде незначним.&nbsp;</p>
              <p>Один з шляхів зкинути скриптовий кеш - явно викликати команду <a
                  href="/commands/script-flush">SCRIPT FLUSH</a>, що <em>повністю
                  скине</em> кеш шкриптів, видаляючи всі скрипти, що були
                виконані до цього часу.&nbsp;</p>
              <p>Це звичано потрібно тільки коли екземпляр інстанцинюється для
                нового користувача, або застосування в хмарному оточенні. </p>
              <p>Також, як вже зазначалось, рестартування екземпляру Redis
                скидає весь скриптовий кеш, що не є постійними. Однак, з боку
                зору клієнта, є тільки два шляхи переконатись, що екземпляр
                Redis не був рестартований між двома різними командами.</p>
              <ul>
                <li>Наше з'єднання з сервером постійне, та не переривалось весь
                  час.&nbsp;</li>
                <li>Клієнт явно перевіряє поле&nbsp;<code>runid</code> команди <a
                    href="/commands/info">INFO</a>, щоб переконатись, що сервер
                  не рестартував, та є все тим же процессом.&nbsp;</li>
              </ul>
              <p>Кажучи практично, для клієнта значно краще просто вважати, що в
                контексті окремого з'єднання, кешовані скрипти гарантовано
                будуть там, якщо адміністратор явно не викличе команду&nbsp;<a href="/commands/script-flush">SCRIPT
                  FLUSH</a>.</p>
              <p>Факт, що користувач може розраховувати, що Redis не видаляє
                скрипти, є семантично корисним в контексті конвеєрної обробки (pipelining).</p>
              <p>Наприклад, застосування з постійним з'єднанням до Redis може
                бути впевненим, що якщо скрипт був надісланий одного разу, від
                буде в пам'яті, так що EVALSHA може бути використаний відносно
                ціх скриптів в конвеєрній обробці, без ризику того, що будуть
                згенерована помилка через невідомий скрипт (ми побачимо цю
                проблему пізніше).</p>
              <p>Загальний шаблон є викликати&nbsp;<a href="/commands/script-load">SCRIPT
                  LOAD</a> для завантаження всіх скриптів, що будуть з'являтись
                в конвеєрі, та потім викликати&nbsp;<a href="/commands/evalsha">EVALSHA</a>
                напряму в конвеєрі, без необхідності перевіряти помилки, що
                походять від того, що скриптовий хеш не розпізнаний.</p>
              <span id="the-script-command" class="anchor"></span>
              <h2>Команда SCRIPT</h2>
              <p>Redis пропонує команду SCRIPT, що може бути використана для
                контролю скриптової підсистеми. SCRIPT наразі сприймає три різні
                команди:</p>
              <ul>
                <li>
                  <p>SCRIPT FLUSH. Ця команда є єдиним шляхом змусити Redis
                    скинути скриптовий кеш. Це найбільш корисно в хмарному
                    середовищі, коли той самий екземпляр може бут
                    перепризначений іншому користувачеві. Це також корисне для
                    тестування реалізації користувацьких бібліотек для
                    скриптових можливостей.&nbsp;</p>
                </li>
                <li>
                  <p>SCRIPT EXISTS <em>sha1</em> <em>sha2</em>... <em>shaN</em>.
                    Беручи дайджести SHA1 в якості аргументів, ця команда
                    повертає масив з 1 та 0, де 1 означає, що відповідний SHA1
                    розпізнаний як скрипт, що вже присутній в скриптовому кеші,
                    тоді як 0 ожначає, що скрипт з цім SHA1 ніколи не був
                    помічений до цього часу (або, щонайменьше, не був
                    використаний після останньої команди SCRIPT FLUSH).</p>
                </li>
                <li>
                  <p>SCRIPT LOAD <em>script</em>. Ця команди реєструє специфічний
                    скрипт в скриптовому кеші Redis. Команда корисна в усіх
                    контекстах, де ми бажаємо бути впевненими, що&nbsp;<a href="/commands/evalsha">EVALSHA</a>
                    не схибить (наприклад, в конвеєрі або в операцях
                    MULTI/EXEC), без потреби насправді виконувати скрипт.</p>
                </li>
                <li>
                  <p>SCRIPT KILL. Ця команда є єдиним шляхом для переривання довго
                    виконуваного скрипта, що досягає сконфігурованого
                    максимального часу виконання для скриптів. Команда SCRIPT
                    KILL може бути використана тільки зі скриптами, що не
                    модифікують набір даних на протязі виконання (хоча
                    припинення скрипту тільки-для-читання не порушує
                    гарантованої атомарності скриптового механізму). Дивіться
                    наступні розділи для додаткової інформації щодо довго виконуваних
                    скриптів.</p>
                </li>
              </ul>
              <span id="scripts-as-pure-functions" class="anchor"></span>
              <h2>Скрипти як чисті функції</h2>
              <p>Дуже важлива частина скриптингу є написання скриптів, що є
                чистими функціями. Скрипти, що виконуються в екземплярі Redis,
                реплікуються на піlлеглі екземпляри, надсилаючи скрипт -- не
                результуючи команди. Те ж трапляється для Файлу тільки для
                запису (Append Only File). Причиною є те, що надсилання скрипта
                на інший екземпляр Redis значно швидше, ніж надсилання декількох
                команд, що генерую скрипт, так що якщо клієнт надсилає багато
                скриптів на головний екземпляр, конвертація скриптів в
                індивідуальні команди для підлеглих / AOF може призвести до дуже
                великої полоси (та також дуже велике навантаження на CPU,
                оскільки диспечування команди, отриманої по мережі значно більше
                роботи для Redis, в порівнянні до диспачування команди,
                викликаної скриптом Lua).</p>
              <p>Одним недоліком цього підходу, в тому, що ці скрипти потребують
                мати наступні властивості:</p>
              <ul>
                <li>Скрипт завжди обчислюється до тих самих Redis команд <em>write</em>
                  з тими ж аргументами, наданими для того ж набору даних.
                  Операції, виконані скриптом, не можуть залежати від прихованої
                  (неявної) інформації, або стану, що може змінитись на протязі
                  ходу виконання скрипта, або між старими різними виконаннями
                  скрипта, а також він не може залежати від зовнішнього надходження
                  від пристроїв вводу-виводу.&nbsp;</li>
              </ul>
              <p>Такі речі, як використання системного часу, виклик випадкових
                команд&nbsp; Redis, як <a href="/commands/randomkey">RANDOMKEY</a>,
                або використання генератора випадковості Lua, можуть при до
                того, що скрипти не завжди обчислюватимуться однаковим
                часом.&nbsp;</p>
              <p>Щоб примусити цю поведінку в скриптах, Redis робить наступне:</p>
              <ul>
                <li>
                  <p>Lua не експортує команд для доступу до системного часу, або
                    іншого зовнішнього стану.&nbsp;</p>
                </li>
                <li>
                  <p>Redis буде блокувати скрипт з помилкою, якщо скрипт
                    викликає команди Redis, здатні змінити набір даних <strong>після</strong>
                    виклику <em>випадкових</em> команд Redis, як <a href="/commands/randomkey">RANDOMKEY</a>,
                    <a href="/commands/srandmember">SRANDMEMBER</a>, <a href="/commands/time">TIME</a>.
                    Це означає, що якщо скрипт тільки-для-читання, та не
                    модифікує набір даних, він вільний викликати ці команди.
                    Зауважте, що&nbsp;<em>випадкова команда</em> не обов'язково
                    означає команду, що використовує випадкові числа: люба
                    не-детермінована команда вважається випадковою командою
                    (кращим прикладом в цьому сенсі буде команда&nbsp;<a href="/commands/time">TIME</a>).</p>
                </li>
                <li>
                  <p>Команди Redis, що можуть повертати елементи випадковим
                    чином, як <a href="/commands/smembers">SMEMBERS</a>
                    (оскільки множини&nbsp; Redis <em>не впорядковані</em>)
                    мають іншу поведінку, коли викликаються з Lua, та тихо
                    проходять фільтр лексографічного сортування повернутих до
                    Lua даних. Так що <code>redis.call("smembers",KEYS[1])</code>
                    буде завжди повертати елементи Set в тому ж порядку, тоді як
                    та ж команда, надіслана від звичайних клієнтів, може
                    повертати різні результати, навіть якщо ключ містить ті і
                    самі елементи.</p>
                </li>
                <li>
                  <p>Функції генератора псевдо випадкових чисел Lua <code>math.random</code>
                    та&nbsp; <code>math.randomseed</code> модифіковані, щоб
                    завжди мати те ж зерно кожного разу, коли викликається
                    скрипт. Це означає, що виклик&nbsp;<code>math.random</code>
                    буде завжди генерувати ту ж послідовність чисел, коли
                    викликається скрипт, якщо не викликається <code>math.randomseed</code>.</p>
                </li>
              </ul>
              <p>Однак користувач все ще може записати команди з випадковою
                поведінкою з використанням наступного трюка. Уявіть, я можу
                написати скрипт Redis, що буде заповнювати список N випадковими
                цілими.</p>
              <p>Я можу почати з цієї невеликої програми на Ruby:</p>
              <pre><code>require 'rubygems'
require 'redis'

r = Redis.new

RandomPushScript = &lt;&lt;EOF
    local i = tonumber(ARGV[1])
    local res
    while (i &gt; 0) do
        res = redis.call('lpush',KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])
</code></pre>
              <p>Кожного разу, коли цей скрипт виконується, отриманий список
                буде мати в точності наступні елементи:</p>
              <pre><code>&gt; lrange mylist 0 -1
 1) "0.74509509873814"
 2) "0.87390407681181"
 3) "0.36876626981831"
 4) "0.6921941534114"
 5) "0.7857992587545"
 6) "0.57730350670279"
 7) "0.87046522734243"
 8) "0.09637165539729"
 9) "0.74990198051087"
10) "0.17082803611217"
</code></pre>
              <p>Щоб зробити це чистою функцією, але будьте впевнені, що кожний
                виклик скрипта буде завершуватись різними випадковими елементами,
                ми можемо просто додати додатковий аргумент до скрипта, що буде
                використаний як зерно псевдо-випадкового генератора Lua. Новий
                скрипт буде виглядати так:</p>
              <pre><code>RandomPushScript = &lt;&lt;EOF
    local i = tonumber(ARGV[1])
    local res
    math.randomseed(tonumber(ARGV[2]))
    while (i &gt; 0) do
        res = redis.call('lpush',KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))
</code></pre>
              <p>Що ми тут робимо, надсилаючи зерно PRNG як один з аргументів.
                Таким чином вихід скрипта буде таким же, беручи ті ж аргументи,
                але ми змінюємо один з аргументів на кожному виклику, генеруючи
                випадкове зерно на стороні клієнта. Зерно буде надане як один з
                аргументів, обоє, при реплікації, та в Append Only File,
                гарантуючи, що ті ж зміни будуть згенеровані при релокації AOF,
                або коли підлеглий обробляє скрипт.</p>
              <p>Зауваження: важливою частиною цієї поведінки в тому, що PRNG,
                який Redis реалізує як <code>math.random</code> та <code>math.randomseed</code>,
                гарантовано матиме той же віхід, безвідносно від архітектури
                системи, на якій робить Redis. 32-біт, 64-біт, big-endian та
                little-endian системи будуть продукувати той же вихід.</p>
              <span id="global-variables-protection" class="anchor"></span>
              <h2>Захист глобальних змінних</h2>
              <p>Скриптам Redis не дозволяється створювати глобальні змінні, щоб
                уникнути виток даних в стан Lua. Якщо скрипт потребує оперувати
                станом між викликами (доволі незвична потреба) він повинен
                використовувати ключі Redis замість цього.</p>
              <p>Коли виникає спроба доступу до глобальної змінної, скрипт
                завершується та EVAL повертає помилку:</p>
              <pre><code>redis 127.0.0.1:6379&gt; eval 'a=10' 0
(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable 'a'
</code></pre>
              <p>Доступ до <em>неіснуючої </em>глобальної змінної генерує
                подібну помилку.</p>
              <p>Використання функціональності налагодження Lua або інших підходів,
                як зміна мета таблиці, яка використовується для реалізації глобального
                захисту, може обійти глабальний захист не дуже складно. Однак,
                зробити це випадково складно. Якщо користувач бавиться з
                глобальним станом Lua, узгодженість AOF та реплікації не
                гарантується: не робіть цього.</p>
              <p>Зауваження для початківців Lua: щоб уникнути використання
                глобальних змінних в ваших скриптах, просто декларуйте кожну
                змінну, що ви плануєте викорстовувати, з використанням ключового
                слова <em>local</em>.</p>
              <span id="using-select-inside-scripts" class="anchor"></span>
              <h2>Використання SELECT в скриптах</h2>
              <p>Можливо викликати <a href="/commands/select">SELECT</a>
                в скриптах Lua, як в заичайному клієнті. Однак невеликий аспект
                в поведінці змінений між Redis 2.8.11 та Redis 2.8.12. До релізу
                2.8.12 обрана база даних, обрана скриптом Lua була&nbsp; <em>перенесена
                  </em>до викликаного скрипта як поточна база даних. Починаючи з
                Redis 2.8.12 база даних, обрана в скрипті Lua впливає тільки на
                виконання самого скрипта, але не модифікує базі даних, обрану
                клієнтом, що викликає скрипт.</p>
              <p>Семантична зміна між релізами рівня патчів була необхідна,
                оскільки стара поведінка була по сути несумісною з рівнем
                реплікації Redis, та призводило до помилок.</p>
              <span id="available-libraries" class="anchor"></span>
              <h2>Доступні бібліотеки</h2>
              <p>Інтерпретатор Redis Lua завантажує наступні бібліотеки Lua:</p>
              <ul>
                <li>base</li>
                <li>table</li>
                <li>string</li>
                <li>math</li>
                <li>debug</li>
                <li>struct</li>
                <li>cjson</li>
                <li>cmsgpack</li>
                <li>bitop</li>
                <li>фукнцію redis.sha1hex</li>
              </ul>
              <p>Кожний екземпляр Redis <em>гарантовано </em>має всі ці
                бібліотеки, так що ви можете бути впевнені, що оточення для
                ваших Redis скриптів завжди однакове.</p>
              <p>struct, CJSON та cmsgpack є зовнішніми бібліотеками, всі інші
                бібліотеки є стандартними бібліотеками Lua.</p>
              <span id="struct" class="anchor"></span>
              <h3>struct</h3>
              <p>struct є бібліотекою для пакування/розпакування структур в Lua.</p>
              <pre><code>Valid formats:
&gt; - big endian
&lt; - little endian
![num] - alignment
x - pading
b/B - signed/unsigned byte
h/H - signed/unsigned short
l/L - signed/unsigned long
T   - size_t
i/In - signed/unsigned integer with size `n' (default is size of int)
cn - sequence of `n' chars (from/to a string); when packing, n==0 means
     the whole string; when unpacking, n==0 means use the previous
     read number as the string length
s - zero-terminated string
f - float
d - double
' ' - ignored
</code></pre>
              <p>Приклад:</p>
              <pre><code>127.0.0.1:6379&gt; eval 'return struct.pack("HH", 1, 2)' 0
"\x01\x00\x02\x00"
127.0.0.1:6379&gt; eval 'return {struct.unpack("HH", ARGV[1])}' 0 "\x01\x00\x02\x00"
1) (integer) 1
2) (integer) 2
3) (integer) 5
127.0.0.1:6379&gt; eval 'return struct.size("HH")' 0
(integer) 4
</code></pre> <span id="cjson" class="anchor"></span>
              <h3>CJSON</h3>
              <p>Бібліотека CJSON провадить виключно швидкі маніпуляції JSON в
                Lua.</p>
              <p>Приклад:</p>
              <pre><code>redis 127.0.0.1:6379&gt; eval 'return cjson.encode({["foo"]= "bar"})' 0
"{\"foo\":\"bar\"}"
redis 127.0.0.1:6379&gt; eval 'return cjson.decode(ARGV[1])["foo"]' 0 "{\"foo\":\"bar\"}"
"bar"
</code></pre> <span id="cmsgpack" class="anchor"></span>
              <h3>cmsgpack</h3>
              <p>Бібліотека cmsgpack провадить прості та швидкі маніпуляції
                MessagePack за допомогою Lua.</p>
              <p>Приклад:</p>
              <pre><code>127.0.0.1:6379&gt; eval 'return cmsgpack.pack({"foo", "bar", "baz"})' 0
"\x93\xa3foo\xa3bar\xa3baz"
127.0.0.1:6379&gt; eval 'return cmsgpack.unpack(ARGV[1])' 0 "\x93\xa3foo\xa3bar\xa3baz"
1) "foo"
2) "bar"
3) "baz"
</code></pre> <span id="bitop" class="anchor"></span>
              <h3>bitop</h3>
              <p>Бібліотека Lua Bit Operations Module додає бітові операції з
                числами. Вона доступна для скриптів в Redis з версії 2.8.18.</p>
              <p>Приклад:</p>
              <pre><code>127.0.0.1:6379&gt; eval 'return bit.tobit(1)' 0
(integer) 1
127.0.0.1:6379&gt; eval 'return bit.bor(1,2,4,8,16,32,64,128)' 0
(integer) 255
127.0.0.1:6379&gt; eval 'return bit.tohex(422342)' 0
"000671c6"
</code></pre>
              <p>Вона підтримує декілька інших функцій: <code>bit.tobit</code>,
                <code>bit.tohex</code>, <code>bit.bnot</code>, <code>bit.band</code>,
                <code>bit.bor</code>, <code>bit.bxor</code>, <code>bit.lshift</code>,
                <code>bit.rshift</code>, <code>bit.arshift</code>, <code>bit.rol</code>,
                <code>bit.ror</code>, <code>bit.bswap</code>. Всі доступні
                функції документовані в документації&nbsp;<a href="http://bitop.luajit.org/api.html">Lua
                  BitOp<br>
                </a></p>
              <span id="redissha1hex" class="anchor"></span>
              <h3>redis.sha1hex</h3>
              <p>Виконує SHA1 для вхідного рядка.</p>
              <p>Приклад:</p>
              <pre><code>127.0.0.1:6379&gt; eval 'return redis.sha1hex(ARGV[1])' 0 "foo"
"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
</code></pre> <span id="emitting-redis-logs-from-scripts" class="anchor"></span>
              <h2>Видача журналів Redis з скриптів</h2>
              <p>Також можливо писати в файл журнала Redis з скриптов Luaз
                використанням функції <code>redis.log</code>.</p>
              <pre><code>redis.log(loglevel,message)
</code></pre>
              <p><code>loglevel</code> один з наступних:</p>
              <ul>
                <li><code>redis.LOG_DEBUG</code></li>
                <li><code>redis.LOG_VERBOSE</code></li>
                <li><code>redis.LOG_NOTICE</code></li>
                <li><code>redis.LOG_WARNING</code></li>
              </ul>
              <p>Вони відповідають напряму до звичайних рівнів журналювання
                Redis. Тільки журнали з скриптів, що використовують рівень
                журналу, що дорівнює або більше, ніж поточний сконфігурований в
                екземплярі Redis, досягнуть файлу журналу.</p>
              <p>Аргумент <code>message</code> є простим рядков. Приклад:</p>
              <pre><code>redis.log(redis.LOG_WARNING,"Something is wrong with this script.")
</code></pre>
              <p>Це згенерує наступне:</p>
              <pre><code>[32343] 22 Mar 15:21:39 # Something is wrong with this script.
</code></pre> <span id="sandbox-and-maximum-execution-time" class="anchor"></span>
              <h2>Пісочниця та максимальний час виконання</h2>
              <p>Скрипти не повинні намагатись отримати достуа до зовнішньої
                системи, як до файлової системи або робити інші системні
                виклики. Скрипт повинен тільки оперувати з даними Redis та
                переданими аргументами.</p>
              <p>Скрипти також є предметом максимального часу виконання (по замовчанню
                п'ять секунд). Цей таймаут по замовчанню є величезним, оскільки
                скрипт звичайно виконується мілісекунди. Обмеження здебільшого
                обробляє безкінечні цикли, створені під час розробки.</p>
              <p>Можливо модифікувати максимальний час, який може виконуватись
                скрипт, з точністю до мілісекунд, або через&nbsp;<code>redis.conf</code>
                або з використанням команди CONFIG GET / CONFIG SET. Параметр
                конфігурації, на який впливає максимальний час виконання,
                називається&nbsp;<code>lua-time-limit</code>.</p>
              <p>Коли скрипт досягає таймауту, він не завершується автоматично
                Redis, оскільки це порушує контракт, що Redis має з скриптовим
                механізмом, щоб задовільнити атомарність скриптів. Переривання
                скрипту означатиме потенційно залишити набір даних з напів-записаними
                даними. З ціх причин, коли скрипт виконується більше ніж вказаний
                час, відбувається наступне:</p>
              <ul>
                <li>Redis записує в журнал, що скрипт виконується дуже довго.</li>
                <li>Він починає сприймати команди зову від інших клієнтів, але
                  буде відповідати з помилкою BUSY всім клієнтам, що надсилають
                  звичайні команди. В цьому стані єдиною допустимою командоє є <a
                    href="/commands/script-kill">SCRIPT KILL</a> та <code>SHUTDOWN
                    NOSAVE</code>.</li>
                <li>Можливо завершити скрипт, що виконує команди
                  тільки-для-запису, з використання команди <a href="/commands/script-kill">SCRIPT
                    KILL</a>. Це не порушує скриптову семантику, тому що дані ще
                  не були записані в базу даних цім скриптом.&nbsp;</li>
                <li>Якщо скрипт вже визивав каманди запису, єдиною допустимою
                  командою стає <code>SHUTDOWN NOSAVE</code>, що зупиняє сервер
                  без збереження поточних набору даних на диск (тобто сервер
                  перериває роботу).</li>
              </ul>
              <span id="evalsha-in-the-context-of-pipelining" class="anchor"></span>
              <h2>EVALSHA
                в контексті конвеєрів</h2>
              <p>Треба бути уважними при використанні&nbsp;<a href="/commands/evalsha">EVALSHA</a>
                в контексті конвеєрного запиту, оскільки навіть в конвеєрі
                послідовність команд має бути гарантована. Якщо&nbsp;<a href="/commands/evalsha">EVALSHA</a>
                повертатиме помилку <code>NOSCRIPT</code>, команда не може бути
                віддана повторно підніше, не порушуючи при цьому послідовність
                виконання.&nbsp;</p>
              <p>Реалізація бібліотеки клієнта повинна прийняти один з наступних
                підходів:</p>
              <ul>
                <li>
                  <p>Завжди викорисовуйте простий&nbsp;<a href="/commands/eval">EVAL</a>
                    в контексті конвеєра.</p>
                </li>
                <li>
                  <p>Акумулюйте всі команди, що надсилаються в конвеєр, потім
                    перевірте команди <a href="/commands/eval">EVAL</a> та
                    використовуйте команду <a href="/commands/script-exists">SCRIPT
                      EXISTS</a>, щоб перевірити, що всі скрипти вже визначені.
                    If not, add <a href="/commands/script-load">SCRIPT LOAD</a>
                    commands on top of the pipeline as required, and use <a href="/commands/evalsha">EVALSHA</a>
                    for all the <a href="/commands/eval">EVAL</a> calls.</p>
                </li>
              </ul>
            </div>
          </article>
        </div>
      </div>
    </div>
  </body>
</html>
